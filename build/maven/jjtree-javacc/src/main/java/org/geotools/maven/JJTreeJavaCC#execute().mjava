    /**
     * Generates the source code from all {@code .jjt} and {@code .jj} files found in the source
     * directory. First, all {@code .jjt} files are processed using {@code jjtree}. Then, all
     * generated {@code .jj} files are processed.
     *
     * @throws MojoExecutionException if the plugin execution failed.
     */
    @SuppressWarnings("PMD.SystemPrintln")
    public void execute() throws MojoExecutionException, MojoFailureException {
        // if not windows, don't rewrite file
        final boolean windowsOs = System.getProperty("os.name").indexOf("Windows") != -1;

        outputPackageDirectory = createPackageDirectory(outputDirectory);
        if (!FileUtils.fileExists(timestampDirectory)) {
            FileUtils.mkdir(timestampDirectory);
        }
        /*
         * Copies the user-supplied Node.java files (if any) from the source directory  (by default
         * "src/main/jjtree") to the output directory (by default "target/generated-sources"). Only
         * java files found in the node package are processed.  NOTE: current version do not handle
         * properly subpackages.
         */
        final Set userNodes = searchNodeFiles();
        for (final Iterator it = userNodes.iterator(); it.hasNext(); ) {
            final File nodeFile = (File) it.next();
            try {
                FileUtils.copyFileToDirectory(nodeFile, outputPackageDirectory);
            } catch (IOException e) {
                throw new MojoExecutionException("Failed to copy Node.java files for JJTree.", e);
            }
        }
        /*
         * Reprocess the .jjt files found in the source directory (by default "src/main/jjtree").
         * The default output directory is "generated-sources/jjtree-javacc" (it doesn't contains
         * javacc output yet, but it will).
         */
        final Set staleTrees = searchStaleGrammars(new File(sourceDirectory), ".jjt");
        for (final Iterator it = staleTrees.iterator(); it.hasNext(); ) {
            final File sourceFile = (File) it.next();
            final JJTree parser = new JJTree();
            final String[] args = generateJJTreeArgumentList(sourceFile.getPath());
            final int status = parser.main(args);
            if (status != 0) {
                throw new MojoFailureException("JJTree failed with error code " + status + '.');
            }
            try {
                FileUtils.copyFileToDirectory(sourceFile, new File(timestampDirectory));
            } catch (IOException e) {
                throw new MojoExecutionException("Failed to copy processed .jjt file.", e);
            }
        }
        /*
         * Reprocess the .jj files found in the generated-sources directory.
         */
        final Set staleGrammars = searchStaleGrammars(new File(outputDirectory), ".jj");
        for (final Iterator it = staleGrammars.iterator(); it.hasNext(); ) {
            final File sourceFile = (File) it.next();
            try {
                if (windowsOs) {
                    fixHeader(sourceFile);
                }
            } catch (IOException e) {
                throw new MojoExecutionException("Failed to fix header for .jj file.", e);
            }
            final String[] args = generateJavaCCArgumentList(sourceFile.getPath());
            final int status;
            try {
                status = Main.mainProgram(args);
            } catch (Exception e) {
                throw new MojoExecutionException("Failed to run javacc.", e);
            }
            if (status != 0) {
                throw new MojoFailureException("JavaCC failed with error code " + status + '.');
            }
            try {
                FileUtils.copyFileToDirectory(sourceFile, new File(timestampDirectory));
            } catch (IOException e) {
                throw new MojoExecutionException("Failed to copy processed .jj file.", e);
            }
        }
        /*
         * Reprocess generated java files so that they won't contain invalid escape characters
         */
        if (windowsOs) {
            try {
                String[] files =
                        FileUtils.getFilesFromExtension(outputDirectory, new String[] {"java"});
                for (int i = 0; i < files.length; i++) {
                    System.out.println("Fixing " + files[i]);
                    fixHeader(new File(files[i]));
                }
            } catch (IOException e) {
                throw new MojoExecutionException("Failed to fix header for java file.", e);
            }
        }
        /*
         * Add the generated-sources directory to the compilation root for the remaining
         * maven build.
         */
        if (project != null) {
            project.addCompileSourceRoot(outputDirectory);
        }
    }

