    /**
     * This method performs the task of searching the file for a public class or interface and its
     * associated javadoc comment block. If found, the comment block is searched for a source tag
     * which, if absent, will be generated and inserted into the file.
     *
     * @param file file to process
     * @return true if the source tag was inserted into the file; false otherwise
     * @throws FileNotFoundException
     * @throws IOException
     */
    private boolean processFile(File file) throws FileNotFoundException, IOException {
        Matcher matcher = null;
        String sourceTagText;

        /*
         * Find the svn repo path: trunk, tags or branches
         */
        matcher = findSVNLine.matcher(file.getAbsolutePath());
        if (matcher.matches()) {
            int pos = matcher.start(1);

            String repoURL = Source.SVN_REPO_URL;
            StringBuilder sb = new StringBuilder(" * @source ");
            if (optionSVNDelims) {
                sb.append("$URL: ");
            }
            sb.append(Source.SVN_REPO_URL);
            sb.append(file.getAbsolutePath().substring(pos));
            if (optionSVNDelims) {
                sb.append(" $");
            }
            sourceTagText = sb.toString();

        } else {
            // don't process this file
            System.out.println("   --- skipped this file");
            System.out.println();
            return false;
        }

        BufferedReader reader = new BufferedReader(new FileReader(file));
        List<String> buffer = new ArrayList<String>();
        String line;

        while ((line = reader.readLine()) != null) {
            buffer.add(line);
        }
        reader.close();

        /*
         * Search the buffer for class header docs and, within that,
         * the @source tag
         */
        boolean inJavadocBlock = false;
        boolean inCommentBlock = false;
        boolean unknownPrecedingContent = false;
        boolean classFound = false;

        int javadocStartLine = -1;
        int javadocEndLine = -1;
        int sourceTagLine = -1;

        for (int lineNo = 0; sourceTagLine < 0 && lineNo < buffer.size(); lineNo++) {
            String text = buffer.get(lineNo);

            if (inJavadocBlock || inCommentBlock) {
                matcher = findCommentEnd.matcher(text);
                if (matcher.find()) {
                    if (inJavadocBlock) {
                        inJavadocBlock = false;
                        javadocEndLine = lineNo;
                    } else if (inCommentBlock) {
                        inCommentBlock = false;
                    } else {
                        System.out.println(
                                "   *** Mis-placed end marker for comment block "
                                        + "- skipping this file ***");
                        System.out.println();
                        return false;
                    }
                }

            } else if (findJavadocStart.matcher(text).find()) {
                inJavadocBlock = true;
                unknownPrecedingContent = false;
                javadocStartLine = lineNo;

            } else if (findCommentStart.matcher(text).find()) {
                inCommentBlock = true;

                // Guard against nested or following classes and mention of classes in
                // comment blocks
            } else if (!inJavadocBlock && !inCommentBlock && !classFound) {
                if (optionAnyClass) {
                    matcher = findClass.matcher(text);
                } else {
                    matcher = findPublicClass.matcher(text);
                }
                if (matcher.find()) {
                    classFound = true;
                    /*
                     * If no javadoc comment block preceded the class header,
                     * either add one (if optionAddHeader is true) or skip the class.
                     */
                    if (javadocStartLine < 0) {
                        if (optionAddHeader) {
                            // It is easieset to insert the elements in reverse order.
                            buffer.add(lineNo, " */");
                            buffer.add(lineNo, " * ");
                            buffer.add(lineNo, "/**");

                            javadocStartLine = lineNo;
                            javadocEndLine = lineNo + 2;

                            // clear the preceding content flag since it will no longer apply
                            unknownPrecedingContent = false;

                        } else {
                            System.out.println("   *** No class javadocs - skipping file ***");
                            System.out.println();
                            return false;
                        }
                    }

                    /* If there were any non-blank lines between the comment and
                     * the class header we will act safely and not modify the file
                     */
                    if (unknownPrecedingContent) {
                        System.out.println(
                                "   *** Javadocs do not directly precede class"
                                        + " - skipping file ***");
                        System.out.println();
                        return false;
                    }

                    /*
                     * Check if the source tag already exists. If it does, and
                     * the replace tag option is false, skip this file.
                     */
                    for (int blockLineNo = javadocStartLine;
                            blockLineNo <= javadocEndLine;
                            blockLineNo++) {
                        String commentText = buffer.get(blockLineNo);
                        matcher = findSourceTag.matcher(commentText);
                        if (matcher.find()) {
                            /*
                             * Check that those pesky Eclipse users haven't
                             * split the source tag across multiple lines with
                             * their auto-format thing.
                             */
                            matcher = findCompleteSourceTag.matcher(commentText);
                            if (!matcher.find()) {
                                if (optionFixBreaks) {
                                    matcher = findCompletePath.matcher(buffer.get(blockLineNo + 1));
                                    if (matcher.find()) {
                                        buffer.remove(blockLineNo + 1);
                                        buffer.remove(blockLineNo);
                                        sourceTagLine = blockLineNo;
                                        if (!optionReplace) {
                                            // Make the new tag text the old lines joined together.
                                            //
                                            String http = matcher.group();
                                            int start = http.indexOf("$URL");
                                            if (start < 0) {
                                                start = http.indexOf("http");
                                            }
                                            http = http.substring(start, http.length());
                                            sourceTagText = commentText + http;
                                        }
                                        System.out.println("   *** Fixing broken source tag ***");
                                        break;
                                    }
                                } else {
                                    // Just report the broken tag and skip this file
                                    System.out.println(
                                            "   *** Incomplete source tag detected"
                                                    + "- skipping this file ***");
                                    System.out.println();
                                    return false;
                                }
                            }

                            if (optionReplace) {
                                sourceTagLine = blockLineNo;
                                // delete the original tag from the buffer
                                buffer.remove(blockLineNo);
                                break;
                            } else {
                                return false;
                            }
                        }
                    }

                    if (sourceTagLine < 0) {
                        /*
                         * Check if the version tag exists. If it does we
                         * will place the source tag on the line before it
                         */
                        for (int i = javadocStartLine; i <= javadocEndLine; i++) {
                            matcher = findVersionTag.matcher(buffer.get(i));
                            if (matcher.find()) {
                                sourceTagLine = i;
                                break;
                            }
                        }
                    }

                    if (sourceTagLine < 0) {
                        sourceTagLine = javadocEndLine;
                    }

                } else {
                    /*
                     * Not a comment line or the class header. Check if it is
                     * a non-emptyLine
                     */
                    if (text.trim().length() > 0) {
                        // Annotations are OK
                        matcher = findAnnotation.matcher(text);
                        if (!matcher.find()) {
                            unknownPrecedingContent = true;
                        }
                    }
                }
            }
        }

        /*
         * If the search was successful write the results to file
         */
        if (sourceTagLine > 0) {
            return writeFile(file, buffer, sourceTagLine, sourceTagText);
        }

        return false;
    }

