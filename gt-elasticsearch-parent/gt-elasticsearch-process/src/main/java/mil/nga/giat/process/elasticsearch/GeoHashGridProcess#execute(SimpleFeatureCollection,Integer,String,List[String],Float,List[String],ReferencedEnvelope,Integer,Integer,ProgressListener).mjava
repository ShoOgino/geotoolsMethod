    @DescribeResult(name = "result", description = "Output raster")
    public GridCoverage2D execute(

            // process data
            @DescribeParameter(name = "data", description = "Input features") SimpleFeatureCollection obsFeatures,

            // process parameters
            @DescribeParameter(name = "pixelsPerCell", description = "Resolution used for upsampling (in pixels). Default = 1", defaultValue="1", min = 1) Integer argPixelsPerCell,
            @DescribeParameter(name = "gridStrategy", description = "GeoHash grid strategy", defaultValue="Basic", min = 1) String gridStrategy,
            @DescribeParameter(name = "gridStrategyArgs", description = "grid strategy arguments", min = 0) List<String> gridStrategyArgs,
            @DescribeParameter(name = "gridStrategyEmptyCellValue", description = "grid strategy empty cell value", min = 0) Float gridStrategyEmptyCellValue,
            @DescribeParameter(name = "gridStrategyScale", description = "grid strategy scale", min = 0) List<String> gridStrategyScale,

            // output image parameters
            @DescribeParameter(name = "outputBBOX", description = "Bounding box of the output") ReferencedEnvelope argOutputEnv,
            @DescribeParameter(name = "outputWidth", description = "Width of output raster in pixels") Integer argOutputWidth,
            @DescribeParameter(name = "outputHeight", description = "Height of output raster in pixels") Integer argOutputHeight,

            ProgressListener monitor) throws ProcessException {

        try {
            // construct and populate grid
            final GeoHashGrid geoHashGrid = Strategy.valueOf(gridStrategy.toUpperCase()).createNewInstance();
            geoHashGrid.setParams(gridStrategyArgs);
            geoHashGrid.setEmptyCellValue(gridStrategyEmptyCellValue);
            if (null != gridStrategyScale) {
                //Geoserver cannot handle List<Float>. Must use List<String> and manually convert to List<Float>
                List<Float> scaleRange = new ArrayList<Float>();
                gridStrategyScale.forEach(rangeValue -> {
                    try {
                        Float f = new Float(rangeValue);
                        scaleRange.add(f);
                    } catch (NumberFormatException e) {
                        LOGGER.warning("Unable to convert gridStrategyScale value: " + rangeValue + " to number");
                        throw e;
                    }
                    Float f = new Float(rangeValue);
                    scaleRange.add(f);
                });
                geoHashGrid.setScale(new RasterScale(scaleRange));
            }
            geoHashGrid.initalize(argOutputEnv, obsFeatures);
            // convert to grid coverage
            final GridCoverage2D nativeCoverage = geoHashGrid.toGridCoverage2D();

            // reproject
            final GridCoverage2D transformedCoverage = (GridCoverage2D) Operations.DEFAULT.resample(nativeCoverage, argOutputEnv.getCoordinateReferenceSystem()); 
            // upscale to approximate output resolution
            final GridCoverage2D scaledCoverage = GridCoverageUtil.scale(transformedCoverage, argOutputWidth*argPixelsPerCell, argOutputHeight*argPixelsPerCell);
            // crop (geohash grid envelope will always contain output bbox)
            final GridCoverage2D croppedCoverage = GridCoverageUtil.crop(scaledCoverage, argOutputEnv);
            return GridCoverageUtil.scale(croppedCoverage, argOutputWidth, argOutputHeight);
        } catch (IllegalArgumentException iae) {
            return null;
        } catch (Exception e) {
            throw new ProcessException(e);
        }
    }

