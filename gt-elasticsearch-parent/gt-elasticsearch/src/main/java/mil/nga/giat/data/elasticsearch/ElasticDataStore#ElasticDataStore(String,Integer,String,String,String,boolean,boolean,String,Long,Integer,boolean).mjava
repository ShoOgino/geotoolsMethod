    public ElasticDataStore(String searchHost, Integer hostPort, 
            String indexName, String searchIndices, String clusterName,
            boolean localNode, boolean storeData, String dataPath, 
            Long scrollSize, Integer scrollTime, boolean scrollEnabled) {

        LOGGER.fine("initializing data store " + searchHost + ":" + hostPort + "/" + indexName);

        this.indexName = indexName;
        
        if (searchIndices != null) {
            this.searchIndices = searchIndices;
        } else {
            this.searchIndices = indexName;
        }
        
        this.scrollEnabled = scrollEnabled;
        this.scrollSize = scrollSize;
        this.scrollTime = scrollTime;

        final ElasticCompat compat = ElasticCompatLoader.getCompat(null);
        
        if (dataPath != null) {
            Settings settings = compat.createSettings("path.home", dataPath, "http.enabled", false);
            node = nodeBuilder()
                    .settings(settings)
                    .local(true)
                    .clusterName(clusterName)
                    .node();
            client = node.client();
            isLocal = true;
        } else if (localNode) {
            Path path = null;
            try {
                path = Files.createTempDirectory("gt_es");
            } catch (IOException e) {
                throw new RuntimeException("unable to create temp director for path.home", e);
            }
            Settings settings = compat.createSettings("path.home", path);
            node = nodeBuilder()
                    .settings(settings)
                    .data(storeData)
                    .clusterName(clusterName)
                    .node();
            client = node.client();
            isLocal = false;
        } else {
            final TransportAddress address;
            address = new InetSocketTransportAddress(getInetAddress(searchHost), hostPort);
            Settings settings = compat.createSettings("cluster.name", clusterName);
            client = compat.createClient(settings, address);
            node = null;
            isLocal = false;
        }
        LOGGER.fine("client connection established");

        final ClusterStateRequest clusterStateRequest;
        clusterStateRequest = Requests.clusterStateRequest()
                .local(isLocal)
                .indices(indexName);

        LOGGER.fine("querying cluster state");
        final ClusterState state;
        state = client.admin()
                .cluster()
                .state(clusterStateRequest)
                .actionGet().getState();

        IndexMetaData metadata = state.metaData().index(indexName);
        if (metadata != null) {
            final ImmutableOpenMap<String, MappingMetaData> mappings;
            mappings = state.metaData().index(indexName).getMappings();
            final Iterator<String> elasticTypes = mappings.keysIt();
            final Vector<Name> names = new Vector<Name>();
            while (elasticTypes.hasNext()) {
                names.add(new NameImpl(elasticTypes.next()));
            }
            baseTypeNames = names;
        } else {
            baseTypeNames = new ArrayList<>();
        }
        
        layerConfigurations = new ConcurrentHashMap<>();
        docTypes = new HashMap<>();
    }

