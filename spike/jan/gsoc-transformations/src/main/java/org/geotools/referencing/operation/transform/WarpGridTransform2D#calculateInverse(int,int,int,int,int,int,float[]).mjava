    /**
     * TODO - make static as soon as we get rid of worldToGrid transform
     * Calculation inverse values. Calculation is not exact, but should provide good results
     * when shifts are smaller than grid cells.
     * @param xStart
     * @param xStep
     * @param xNumCells
     * @param yStart
     * @param yStep
     * @param yNumCells
     * @param warpPositions
     * @return
     */
    private WarpGridTransform2D calculateInverse(int xStart, int xStep, int xNumCells, int yStart,
        int yStep, int yNumCells, float[] warpPositions) {
    	
    	if ( inversePos == null){
        inversePos = new float[warpPositions.length];

        for (int i = 0; i <= yNumCells; i++) {
            for (int j = 0; j <= xNumCells; j++) {
                inversePos[(i * ((1 + xNumCells) * 2)) + (2 * j)] = (2 * ((j * xStep) + xStart))
                    - warpPositions[(i * ((1 + xNumCells) * 2)) + (2 * j)];

                inversePos[(i * ((1 + xNumCells) * 2)) + (2 * j) + 1] = (2 * ((i * yStep) + yStart))
                    - warpPositions[(i * ((1 + xNumCells) * 2)) + (2 * j) + 1];
            }
        }

    	}
        WarpGridTransform2D wgt = new WarpGridTransform2D(xStart, xStep, xNumCells, yStart, yStep,
                yNumCells, inversePos);

        wgt.setWorldtoGridTransform(this.worldToGrid);

        return wgt;
    }

