    private void initializeVertex( final int x, final int y )
    {
        final int index = calculateMeshIndex( x, y );

        // Calculate position
        final float xPos = (float) MathUtils.interpolateClamp( x, 1, mySizeX_vertices - 2, myX1, myX2 );
        final float yPos = (float) MathUtils.interpolateClamp( y, 1, mySizeY_vertices - 2, myY1, myY2 );
        float zPos = (float) myZ;

        // Fold the edges down to form a skirt, to avoid one pixel cracks between terrain blocks caused by rounding errors.
        if ( isEdge( x, y ) )
        {
            zPos -= mySkirtSize;
        }

        // Stretch the texture across the terrain mesh, and have downturned edges have the same color as the edge
        final float textureXPos = (float) MathUtils.interpolateClamp( x, 1, mySizeX_vertices - 2, 0, 1 );
        final float textureYPos = (float) MathUtils.interpolateClamp( y, 1, mySizeY_vertices - 2, 1, 0 );

        final Vector3f position = new Vector3f( xPos, yPos, zPos );
        final Vector3f normal = new Vector3f( 0, 0, 1 );
        final ColorRGBA color = new ColorRGBA( 1.0f, 1.0f, 1.0f, 1.0f );
        final Vector2f textureCoordinate = new Vector2f( textureXPos, textureYPos );

        BufferUtils.setInBuffer( position, myVertexes, index );
        BufferUtils.setInBuffer( normal, myNormals, index );
        BufferUtils.setInBuffer( color, myColors, index );
        BufferUtils.setInBuffer( textureCoordinate, myTextureCoordinates, index );
    }

