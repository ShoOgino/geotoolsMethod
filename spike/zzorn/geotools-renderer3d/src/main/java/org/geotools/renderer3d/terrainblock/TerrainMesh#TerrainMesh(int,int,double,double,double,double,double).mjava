    /**
     * @param sizeXCells Number of grid cells along the X side.
     * @param sizeYCells Number of grid cells along the Y side.
     * @param x1         first world coordinate.
     * @param y1         first world coordinate.
     * @param x2         second world coordinate.  Should be larger than the first.
     * @param y2         second world coordinate.  Should be larger than the first.
     * @param z          the default height level.
     */
    public TerrainMesh( final int sizeXCells,
                        final int sizeYCells,
                        final double x1,
                        final double y1,
                        final double x2,
                        final double y2,
                        final double z )
    {
        // JME seems to need an unique identifier for each node.  NOTE: Not thread safe.
        super( "TerrainMesh_" + theTerrainMeshCounter++ );

        // Check parameters
        ParameterChecker.checkPositiveNonZeroInteger( sizeXCells, "sizeXCells" );
        ParameterChecker.checkPositiveNonZeroInteger( sizeYCells, "sizeYCells" );
        ParameterChecker.checkNormalNumber( z, "z" );

        // Assign fields from parameters
        // Cells are the rectangular areas between four normal surface vertices.  Does not include the rectangles in the downturned skirt.
        // Vertices are the vertex points making up the grid corners of the mesh.  Also includes the vertices used to make the downturned skirt.
        mySizeX_cells = sizeXCells;
        mySizeY_cells = sizeYCells;
        mySizeX_vertices = mySizeX_cells + 1 + 2;
        mySizeY_vertices = mySizeY_cells + 1 + 2;
        myZ = z;

        mySkirtSize = calculateSkirtSize();

        // Calculate sizes
        myNumberOfVertices = mySizeX_vertices * mySizeY_vertices;
        myNumberOfCells = mySizeX_cells * mySizeY_cells;
        myNumberOfIndices = ( mySizeX_vertices - 1 ) * ( mySizeY_vertices - 1 ) * 6;

        // Create databuffers
        myVertexes = BufferUtils.createVector3Buffer( myNumberOfVertices );
        myColors = BufferUtils.createColorBuffer( myNumberOfVertices );
        myTextureCoordinates = BufferUtils.createVector2Buffer( myNumberOfVertices );
        myNormals = BufferUtils.createVector3Buffer( myNumberOfVertices );
        myIndices = BufferUtils.createIntBuffer( myNumberOfIndices );

        // Stich together the vertices into triangles
        initializeIndices();

        updateBounds( x1, y1, x2, y2 );


    }

