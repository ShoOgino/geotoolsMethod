    /**
     * Creates a <code>Polygon</code> using the next token in the stream.
     *
     * @param tokenizer tokenizer over a stream of text in Well-known Text format. The next tokens
     *     must form a &lt;Polygon Text&gt;.
     * @return a <code>Polygon</code> specified by the next token in the stream
     * @throws ParseException if the coordinates used to create the <code>Polygon</code> shell and
     *     holes do not form closed linestrings, or if an unexpected token was encountered.
     * @throws IOException if an I/O error occurs
     */
    private Surface readPolygonText() throws IOException, ParseException {

        String nextToken = getNextEmptyOrOpener();

        if (nextToken.equals(EMPTY)) {
            return new SurfaceImpl(
                    (SurfaceBoundary)
                            null); // this.primitiveFactory.createSurface((SurfaceBoundary) null);
        }

        ArrayList<Ring> holes = new ArrayList<Ring>();
        Ring shell = this.readLinearRingText();
        nextToken = getNextCloserOrComma();
        while (nextToken.equals(COMMA)) {
            Ring hole = readLinearRingText();
            holes.add(hole);
            nextToken = getNextCloserOrComma();
        }
        SurfaceBoundary sfb =
                new SurfaceBoundaryImpl(
                        crs, shell,
                        holes); // this.primitiveFactory.createSurfaceBoundary(shell, holes);
        return new SurfaceImpl(sfb); // this.primitiveFactory.createSurface(sfb);
    }

