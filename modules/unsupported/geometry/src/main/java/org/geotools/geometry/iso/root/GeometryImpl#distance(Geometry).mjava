    /**
     * Computes the distance between this and another geometry. We have to implement the logic of
     * dealing with multiprimtive geometries separately.
     *
     * <p>gdavis - This method should really be broken out into 1 of 2 things: 1. an operator class
     * that figures out the geometry type and does the operation based on that, or 2. a double
     * dispatch command pattern system that returns a command to perform based on the geometry type
     * and the command of "distance". Currently this implementation works for our needs, but we
     * should consider re-designing it with one of the above approaches for better scalability.
     *
     * @see
     *     org.opengis.geometry.coordinate.root.Geometry#distance(org.opengis.geometry.coordinate.root.Geometry)
     */
    public final double distance(Geometry geometry) {
        // first determine if this or the given geom is a multiprimitive, if so, break it
        // down and loop through each of its geoms and determine the mindistance from
        // those.
        if (geometry instanceof MultiPrimitive) {
            double minDistance = Double.POSITIVE_INFINITY;
            MultiPrimitive gc1 = (MultiPrimitive) geometry;
            Iterator<? extends Geometry> iter = gc1.getElements().iterator();
            while (iter.hasNext()) {
                GeometryImpl prim = (GeometryImpl) iter.next();
                double d = prim.distance(this);
                if (d < minDistance) {
                    minDistance = d;
                    // can't get smaller than 0, so exit now if that is the case
                    if (minDistance == 0) return 0;
                }
            }
            return minDistance;
        } else if (this instanceof MultiPrimitive) {
            double minDistance = Double.POSITIVE_INFINITY;
            MultiPrimitive gc1 = (MultiPrimitive) this;
            Iterator<? extends Geometry> iter = gc1.getElements().iterator();
            while (iter.hasNext()) {
                GeometryImpl prim = (GeometryImpl) iter.next();
                double d = prim.distance(geometry);
                if (d < minDistance) {
                    minDistance = d;
                    // can't get smaller than 0, so exit now if that is the case
                    if (minDistance == 0) return 0;
                }
            }
            return minDistance;
        } else {
            // first check if the geometries intersect (if so the min distance is 0)
            if (this.intersects(geometry)) {
                return 0;
            }

            // ensure both this and the given geometry are either points or
            // linesegments so we can use the CGAlrogrithm calculations.
            List<LineSegment> lines1 = null;
            List<LineSegment> lines2 = null;
            PointImpl point1 = null;
            PointImpl point2 = null;

            // convert this geom
            if (this instanceof PointImpl) {
                point1 = (PointImpl) this;
            } else if (this instanceof CurveImpl) {
                lines1 = ((CurveImpl) this).asLineSegments();
            } else if (this instanceof RingImplUnsafe) {
                lines1 = ((RingImplUnsafe) this).asLineString().asLineSegments();
            } else if (this instanceof RingImpl) {
                lines1 = ((RingImpl) this).asLineString().asLineSegments();
            } else if (this instanceof SurfaceImpl) {
                lines1 =
                        ((RingImplUnsafe) ((SurfaceImpl) this).getBoundary().getExterior())
                                .asLineString()
                                .asLineSegments();
            }

            // convert given geom
            if (geometry instanceof PointImpl) {
                point2 = (PointImpl) geometry;
            } else if (geometry instanceof CurveImpl) {
                lines2 = ((CurveImpl) geometry).asLineSegments();
            } else if (geometry instanceof RingImplUnsafe) {
                lines2 = ((RingImplUnsafe) geometry).asLineString().asLineSegments();
            } else if (geometry instanceof RingImpl) {
                lines2 = ((RingImpl) geometry).asLineString().asLineSegments();
            } else if (geometry instanceof SurfaceImpl) {
                lines2 =
                        ((RingImplUnsafe) ((SurfaceImpl) geometry).getBoundary().getExterior())
                                .asLineString()
                                .asLineSegments();
            }

            // now determine which algorithm to use for finding the shortest
            // distance between the two geometries
            if (point1 != null && point2 != null) {
                // use directposition.distance()
                return point1.getPosition().distance(point2.getPosition());
            } else if (lines1 != null) {
                if (point2 != null) {
                    // loop through each linesegment and check for the min distance
                    double minDistance = Double.POSITIVE_INFINITY;
                    for (int i = 0; i < lines1.size(); i++) {
                        Coordinate c1 =
                                new Coordinate(point2.getRepresentativePoint().getCoordinate());
                        Coordinate cA =
                                new Coordinate(lines1.get(i).getStartPoint().getCoordinate());
                        Coordinate cB = new Coordinate(lines1.get(i).getEndPoint().getCoordinate());
                        double d = CGAlgorithms.distancePointLine(c1, cA, cB);
                        if (d < minDistance) {
                            minDistance = d;
                            if (minDistance == 0) return 0;
                        }
                    }
                    return minDistance;
                } else if (lines2 != null) {
                    // loop through each set of linesegments and check for the
                    // min distance
                    double minDistance = Double.POSITIVE_INFINITY;
                    for (int i = 0; i < lines1.size(); i++) {
                        for (int y = 0; y < lines2.size(); y++) {
                            Coordinate A =
                                    new Coordinate(lines1.get(i).getStartPoint().getCoordinate());
                            Coordinate B =
                                    new Coordinate(lines1.get(i).getEndPoint().getCoordinate());
                            Coordinate C =
                                    new Coordinate(lines2.get(y).getStartPoint().getCoordinate());
                            Coordinate D =
                                    new Coordinate(lines2.get(y).getEndPoint().getCoordinate());
                            double d = CGAlgorithms.distanceLineLine(A, B, C, D);
                            if (d < minDistance) {
                                minDistance = d;
                                if (minDistance == 0) return 0;
                            }
                        }
                    }
                    return minDistance;
                }

            } else if (lines2 != null) {
                if (point1 != null) {
                    // loop through each linesegment and check for the min distance
                    double minDistance = Double.POSITIVE_INFINITY;
                    for (int i = 0; i < lines2.size(); i++) {
                        Coordinate c1 =
                                new Coordinate(point1.getRepresentativePoint().getCoordinate());
                        Coordinate cA =
                                new Coordinate(lines2.get(i).getStartPoint().getCoordinate());
                        Coordinate cB = new Coordinate(lines2.get(i).getEndPoint().getCoordinate());
                        double d = CGAlgorithms.distancePointLine(c1, cA, cB);
                        if (d < minDistance) {
                            minDistance = d;
                            if (minDistance == 0) return 0;
                        }
                    }
                    return minDistance;
                }
            }
        }

        // if it is some other type, show an error
        // TODO: implement code for any missing types
        Assert.isTrue(false);
        return Double.NaN;
    }

