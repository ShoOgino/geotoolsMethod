    /**
     * Adds a Ring to the graph. The direction of the ring, i.e. whether itÂ´s clockwise or counter
     * clockwise oriented, will be calculated and considered. Thus, the direction of the ring does
     * not matter. The left and right topological location arguments assume that the ring is
     * oriented CW. If the ring is in the opposite orientation, the left and right locations must be
     * interchanged.
     *
     * @param aRing A Ring. The direction of the ring (cw or ccw) does not matter
     * @param cwLeft Label for the left side of the ring
     * @param cwRight Label for the right side of the ring
     */
    private void addRing(Ring aRing, int cwLeft, int cwRight) {

        List<DirectPosition> tDPList = ((RingImplUnsafe) aRing).asDirectPositions();
        Coordinate[] coord = CoordinateArrays.toCoordinateArray(tDPList);

        // Remove neighboured identical points
        coord = CoordinateArrays.removeRepeatedPoints(coord);

        if (coord.length < 3) {
            hasTooFewPoints = true;
            invalidPoint = coord[0];
            return;
        }

        int left = cwLeft;
        int right = cwRight;

        // If Ring is counter clockwise oriented interchange the left and right
        // side for labelling
        if (cga.isCCW(coord)) {
            left = cwRight;
            right = cwLeft;
        }
        Edge e = new Edge(coord, new Label(argIndex, Location.BOUNDARY, left, right));
        lineEdgeMap.put(aRing, e);

        insertEdge(e);
        // insert the endpoint as a node, to mark that it is on the boundary
        insertPoint(argIndex, coord[0], Location.BOUNDARY);
    }

