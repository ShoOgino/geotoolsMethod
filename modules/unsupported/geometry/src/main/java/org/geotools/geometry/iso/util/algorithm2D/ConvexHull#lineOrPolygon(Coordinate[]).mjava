    /**
     * @param coordinates the vertices of a linear ring, which may or may not be flattened (i.e.
     *     vertices collinear)
     * @return a 2-vertex <code>LineString</code> if the vertices are collinear; otherwise, a <code>
     *     Polygon</code> with unnecessary (collinear) vertices removed
     */
    private Geometry lineOrPolygon(Coordinate[] coordinates) {

        coordinates = cleanRing(coordinates);
        List<Position> positions = CoordinateArrays.toPositionList(this.crs, coordinates);
        if (coordinates.length == 3) {
            positions.remove(2);
            LineStringImpl lineString = new LineStringImpl(new PointArrayImpl(positions), 0.0);
            List<CurveSegment> segments = new ArrayList<CurveSegment>();
            segments.add(lineString);
            return new CurveImpl(this.crs, segments);
            // return
            // this.geomFactory.getPrimitiveFactory().createCurveByDirectPositions((List<Position>)
            // positions);
        }

        LineStringImpl lineString = new LineStringImpl(new PointArrayImpl(positions), 0.0);
        List<CurveSegment> segments = new ArrayList<CurveSegment>();
        segments.add(lineString);
        OrientableCurve curve = new CurveImpl(crs, segments);
        List<OrientableCurve> orientableCurves = new ArrayList<OrientableCurve>();
        orientableCurves.add(curve);

        Ring exterior = new RingImpl(orientableCurves);
        List<Ring> interiorList = new ArrayList<Ring>();

        SurfaceBoundaryImpl sb = new SurfaceBoundaryImpl(crs, exterior, interiorList);
        return new SurfaceImpl(sb);

        // return
        // this.geomFactory.getPrimitiveFactory().createSurfaceByDirectPositions((List<DirectPosition>) positions);
    }

