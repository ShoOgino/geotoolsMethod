    /**
     * Constructor The second version, which is guaranteed to work always in 2D coordinate spaces,
     * constructs a Surface by indicating its boundary as a collection of Curves organized into a
     * SurfaceBoundary. In 3D coordinate spaces, this second version of the constructor shall
     * require all of the defining boundary Curve instances to be coplanar (lie in a single plane)
     * which will define the surface interior.
     *
     * <p>Surface::Surface(bdy : SurfaceBoundary) : Surface
     *
     * @param boundary The SurfaceBoundary which defines the Surface
     */
    public SurfaceImpl(SurfaceBoundary boundary) {

        super(boundary.getCoordinateReferenceSystem(), null, null, null);

        // Set Boundary
        this.boundary = boundary;

        // Set Envelope
        this.envelope = boundary.getEnvelope();

        // TODO Is it really necessary to create the surface patches?
        // Create Surface Patch on basis of the Boundary
        ArrayList<SurfacePatch> newPatchList = new ArrayList<SurfacePatch>();
        newPatchList.add(new PolygonImpl((SurfaceBoundaryImpl) boundary, (SurfaceImpl) this));
        this.patch = newPatchList;
    }

