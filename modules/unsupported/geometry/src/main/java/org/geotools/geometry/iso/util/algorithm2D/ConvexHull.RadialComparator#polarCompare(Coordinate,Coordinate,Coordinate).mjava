		/**
		 * Given two points p and q compare them with respect to their radial
		 * ordering about point o. First checks radial ordering. If points are
		 * collinear, the comparison is based on their distance to the origin.
		 * <p>
		 * p < q iff
		 * <ul>
		 * <li>ang(o-p) < ang(o-q) (e.g. o-p-q is CCW)
		 * <li>or ang(o-p) == ang(o-q) && dist(o,p) < dist(o,q)
		 * </ul>
		 * 
		 * @param o
		 *            the origin
		 * @param p
		 *            a point
		 * @param q
		 *            another point
		 * @return -1, 0 or 1 depending on whether p is less than, equal to or
		 *         greater than q
		 */
		private static int polarCompare(Coordinate o, Coordinate p, Coordinate q) {
			double dxp = p.x - o.x;
			double dyp = p.y - o.y;
			double dxq = q.x - o.x;
			double dyq = q.y - o.y;

			/*
			 * // MD - non-robust int result = 0; double alph = Math.atan2(dxp,
			 * dyp); double beta = Math.atan2(dxq, dyq); if (alph < beta) {
			 * result = -1; } if (alph > beta) { result = 1; } if (result != 0)
			 * return result; //
			 */

			int orient = CGAlgorithms.computeOrientation(o, p, q);

			if (orient == CGAlgorithms.COUNTERCLOCKWISE)
				return 1;
			if (orient == CGAlgorithms.CLOCKWISE)
				return -1;

			// points are collinear - check distance
			double op = dxp * dxp + dyp * dyp;
			double oq = dxq * dxq + dyq * dyq;
			if (op < oq) {
				return -1;
			}
			if (op > oq) {
				return 1;
			}
			return 0;
		}

