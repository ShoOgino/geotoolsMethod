        /**
         * Given two points p and q compare them with respect to their radial ordering about point
         * o. First checks radial ordering. If points are collinear, the comparison is based on
         * their distance to the origin.
         *
         * <p>p < q iff
         *
         * <ul>
         *   <li>ang(o-p) < ang(o-q) (e.g. o-p-q is CCW)
         *   <li>or ang(o-p) == ang(o-q) && dist(o,p) < dist(o,q)
         * </ul>
         *
         * @param o the origin
         * @param p a point
         * @param q another point
         * @return -1, 0 or 1 depending on whether p is less than, equal to or greater than q
         */
        private static int polarCompare(Coordinate o, Coordinate p, Coordinate q) {
            double dxp = p.x - o.x;
            double dyp = p.y - o.y;
            double dxq = q.x - o.x;
            double dyq = q.y - o.y;

            /*
             * // MD - non-robust int result = 0; double alph = Math.atan2(dxp,
             * dyp); double beta = Math.atan2(dxq, dyq); if (alph < beta) {
             * result = -1; } if (alph > beta) { result = 1; } if (result != 0)
             * return result; //
             */

            int orient = CGAlgorithms.computeOrientation(o, p, q);

            if (orient == CGAlgorithms.COUNTERCLOCKWISE) return 1;
            if (orient == CGAlgorithms.CLOCKWISE) return -1;

            // points are collinear - check distance
            double op = dxp * dxp + dyp * dyp;
            double oq = dxq * dxq + dyq * dyq;
            if (op < oq) {
                return -1;
            }
            if (op > oq) {
                return 1;
            }
            return 0;
        }

