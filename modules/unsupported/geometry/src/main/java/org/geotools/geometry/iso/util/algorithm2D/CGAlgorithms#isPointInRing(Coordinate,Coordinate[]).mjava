	/**
	 * Test whether a point lies inside a ring. The ring may be oriented in
	 * either direction. If the point lies on the ring boundary the result of
	 * this method is unspecified.
	 * <p>
	 * This algorithm does not attempt to first check the point against the
	 * envelope of the ring.
	 * 
	 * @param p
	 *            point to check for ring inclusion
	 * @param ring
	 *            assumed to have first point identical to last point
	 * @return <code>true</code> if p is inside ring
	 */
	public static boolean isPointInRing(Coordinate p, Coordinate[] ring) {
		/*
		 * For each segment l = (i-1, i), see if it crosses ray from test point
		 * in positive x direction.
		 */
		int crossings = 0; // number of segment/ray crossings
		for (int i = 1; i < ring.length; i++) {
			int i1 = i - 1;
			Coordinate p1 = ring[i];
			Coordinate p2 = ring[i1];

			if (((p1.y > p.y) && (p2.y <= p.y))
					|| ((p2.y > p.y) && (p1.y <= p.y))) {
				double x1 = p1.x - p.x;
				double y1 = p1.y - p.y;
				double x2 = p2.x - p.x;
				double y2 = p2.y - p.y;
				/*
				 * segment straddles x axis, so compute intersection with
				 * x-axis.
				 */
				double xInt = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2)
						/ (y2 - y1);
				// xsave = xInt;
				/*
				 * crosses ray if strictly positive intersection.
				 */
				if (xInt > 0.0) {
					crossings++;
				}
			}
		}
		/*
		 * p is inside if number of crossings is odd.
		 */
		if ((crossings % 2) == 1) {
			return true;
		} else {
			return false;
		}
	}

