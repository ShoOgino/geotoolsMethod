    /**
     * Test whether a point lies inside a ring. The ring may be oriented in either direction. If the
     * point lies on the ring boundary the result of this method is unspecified.
     *
     * <p>This algorithm does not attempt to first check the point against the envelope of the ring.
     *
     * @param p point to check for ring inclusion
     * @param ring assumed to have first point identical to last point
     * @return <code>true</code> if p is inside ring
     */
    public static boolean isPointInRing(Coordinate p, Coordinate[] ring) {
        /*
         * For each segment l = (i-1, i), see if it crosses ray from test point
         * in positive x direction.
         */
        int crossings = 0; // number of segment/ray crossings
        for (int i = 1; i < ring.length; i++) {
            int i1 = i - 1;
            Coordinate p1 = ring[i];
            Coordinate p2 = ring[i1];

            if (((p1.y > p.y) && (p2.y <= p.y)) || ((p2.y > p.y) && (p1.y <= p.y))) {
                double x1 = p1.x - p.x;
                double y1 = p1.y - p.y;
                double x2 = p2.x - p.x;
                double y2 = p2.y - p.y;
                /*
                 * segment straddles x axis, so compute intersection with
                 * x-axis.
                 */
                double xInt = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2) / (y2 - y1);
                // xsave = xInt;
                /*
                 * crosses ray if strictly positive intersection.
                 */
                if (xInt > 0.0) {
                    crossings++;
                }
            }
        }
        /*
         * p is inside if number of crossings is odd.
         */
        if ((crossings % 2) == 1) {
            return true;
        } else {
            return false;
        }
    }

