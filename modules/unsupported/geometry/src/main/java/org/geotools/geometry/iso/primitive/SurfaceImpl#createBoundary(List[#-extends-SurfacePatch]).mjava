    /**
     * Creates a SurfaceBoundary by a list of neigboured patches
     *
     * @param patches List of surface patches that represent the surface
     * @return the SurfaceBoundary of the surface represented by the set of surface patches
     * @throws IllegalArgument Exception if the union of the surface patches is not a surface. That
     *     means that the patches are not continuous.
     */
    private SurfaceBoundaryImpl createBoundary(List<? extends SurfacePatch> patches) {

        if (patches.isEmpty()) return null;

        SurfacePatch firstPatch = patches.get(0);
        if (patches.size() == 1) return (SurfaceBoundaryImpl) firstPatch.getBoundary();

        Surface firstPatchSurface = new SurfaceImpl(firstPatch.getBoundary());
        Set<OrientableSurface> surfaceList = new HashSet<OrientableSurface>();

        for (int i = 1; i < patches.size(); i++) {
            SurfacePatch nextPatch = patches.get(i);
            surfaceList.add(new SurfaceImpl(nextPatch.getBoundary()));
        }

        MultiSurface ms = new MultiSurfaceImpl(getCoordinateReferenceSystem(), surfaceList);
        TransfiniteSet unionResultSurface = firstPatchSurface.union(ms);
        if (!(unionResultSurface instanceof SurfaceImpl))
            throw new IllegalArgumentException("Surface patches are not continuous");

        return (SurfaceBoundaryImpl) ((SurfaceImpl) unionResultSurface).getBoundary();
    }

