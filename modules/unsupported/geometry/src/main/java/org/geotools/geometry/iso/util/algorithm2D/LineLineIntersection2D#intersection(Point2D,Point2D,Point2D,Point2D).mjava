    //  This method returns:
    // 1) four parameters if the segments are overlaped, the first two parameters
    //  corresponding to the intersection points on this segment and the last
    //  two on the other segment. If both first parameters are Double.NaN,
    //  this segment contains the other segment. If both last parameters are
    //  Double.NaN, this segment is within the other one.
    // 2) two parameters if the interior or the boundary of this segment intersects
    //  the interior or the boundary of the other segment. If the boundaries
    //  intersect, the parameters are rounded to exactly startParam or endParam
    public static double[] intersection(Point2D p0, Point2D p1, Point2D q0, Point2D q1) {
        // the range of the returned values is from 0.0 to 1.0
        // Overlaping:
        // (p0,p1) *------------->*   *------------->*        *------->*        *------------->*
        //      *------------->*
        // (q0,q1) *------------->*      *------>*         *------------->*        *------------->*
        //   *------------->*
        //   result: (0.0,1.0,0.0,1.0)  (0.2,0.8,NaN,NaN)   (NaN,NaN,0.2,0.8)    (0.2,NaN,NaN,0.8)
        //     (NaN,0,8,0.2,NaN)
        //
        // (p0,p1) *----->*                     *------->*    *----->*
        // *------->*
        // (q0,q1)        *------>*      *----->*                    *------>*      *----->*
        // result: (1.0,NaN,NaN,0.0)     (NaN,0.0,1.0,NaN)    (1.0,NaN,NaN,0.0)
        // (NaN,0.0,1.0,NaN)
        // Seg 0: \ /
        // \/ result: (0.5,0.5)
        // /\
        // Seg1 / \
        //
        // |p1
        // | q0_________q1 result: (0.5,NaN)
        // |
        // |p0
        //
        // q0 _________q1
        // |p1
        // | result: (NaN,0.5)
        // |
        // |p0
        //

        if (AlgoLine2D.isParallel(p0, p1, q0, q1)) { // the segments are
            // parallel
            double[] result = new double[4];
            result[0] = java.lang.Double.NaN;
            result[1] = java.lang.Double.NaN;
            result[2] = java.lang.Double.NaN;
            result[3] = java.lang.Double.NaN;
            // return nothing if they are not on the same line or outside the line
            result[0] = AlgoLine2D.constrParamForPoint(p0, p1, q0);
            result[1] = AlgoLine2D.constrParamForPoint(p0, p1, q1);
            result[2] = AlgoLine2D.constrParamForPoint(q0, q1, p0);
            result[3] = AlgoLine2D.constrParamForPoint(q0, q1, p1);
            for (int i = 0; i <= 3; ++i) {
                if (result[i] < 0.0 || result[i] > 1.0) result[i] = java.lang.Double.NaN;
            }
            return result;
        } else {
            // Dim result[1] As double
            // result = intersectionConstrParam(p0, p1, q0, q1)
            // return nothing if the the four points are on the same line (det <= eps)
            double[] result = new double[2];
            result[0] = java.lang.Double.NaN;
            result[1] = java.lang.Double.NaN;
            Point2D ep = AlgoPoint2D.subtract(p1, p0);
            Point2D eq = AlgoPoint2D.subtract(q1, q0);
            Point2D pq = AlgoPoint2D.subtract(q0, p0);
            double det = AlgoPoint2D.cross(ep, eq); // not 0, because AlgoLine.isParallel() = false
            double rp = AlgoPoint2D.cross(pq, eq) / det;
            double rq = AlgoPoint2D.cross(pq, ep) / det;
            double eps = AlgoPoint2D.EPSILONSQ;
            if (Math.abs(rp) < eps) rp = 0.0;
            if (Math.abs(rp - 1.0) < eps) rp = 1.0;
            if (Math.abs(rq) < eps) rq = 0.0;
            if (Math.abs(rq - 1.0) < eps) rq = 1.0;
            if (rp < 0.0 || rp > 1.0) rp = java.lang.Double.NaN;
            if (rq < 0.0 || rq > 1.0) rq = java.lang.Double.NaN;
            result[0] = rp;
            result[1] = rq;
            return result;
        }
    }

