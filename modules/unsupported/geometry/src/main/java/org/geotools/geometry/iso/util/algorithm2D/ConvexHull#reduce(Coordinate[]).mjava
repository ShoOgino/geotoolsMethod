    /**
     * Uses a heuristic to reduce the number of points scanned to compute the hull. The heuristic is
     * to find a polygon guaranteed to be in (or on) the hull, and eliminate all points inside it. A
     * quadrilateral defined by the extremal points in the four orthogonal directions can be used,
     * but even more inclusive is to use an octilateral defined by the points in the 8 cardinal
     * directions.
     *
     * <p>Note that even if the method used to determine the polygon vertices is not 100% robust,
     * this does not affect the robustness of the convex hull.
     *
     * @param pts
     * @return
     */
    private Coordinate[] reduce(Coordinate[] inputPts) {
        // Coordinate[] polyPts = computeQuad(inputPts);
        Coordinate[] polyPts = computeOctRing(inputPts);
        // Coordinate[] polyPts = null;

        // unable to compute interior polygon for some reason
        if (polyPts == null) return inputPts;

        // LinearRing ring = geomFactory.createLinearRing(polyPts);
        // System.out.println(ring);

        // add points defining polygon
        HashSet reducedSet = new HashSet();
        for (int i = 0; i < polyPts.length; i++) {
            reducedSet.add(polyPts[i]);
        }
        /**
         * Add all unique points not in the interior poly. CGAlgorithms.isPointInRing is not defined
         * for points actually on the ring, but this doesn't matter since the points of the interior
         * polygon are forced to be in the reduced set.
         */
        for (int i = 0; i < inputPts.length; i++) {
            if (!CGAlgorithms.isPointInRing(inputPts[i], polyPts)) {
                reducedSet.add(inputPts[i]);
            }
        }
        Coordinate[] reducedPts = CoordinateArrays.toCoordinateArray(reducedSet);
        return reducedPts;
    }

