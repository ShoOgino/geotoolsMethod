	/**
	 * Uses a heuristic to reduce the number of points scanned to compute the
	 * hull. The heuristic is to find a polygon guaranteed to be in (or on) the
	 * hull, and eliminate all points inside it. A quadrilateral defined by the
	 * extremal points in the four orthogonal directions can be used, but even
	 * more inclusive is to use an octilateral defined by the points in the 8
	 * cardinal directions.
	 * <p>
	 * Note that even if the method used to determine the polygon vertices is
	 * not 100% robust, this does not affect the robustness of the convex hull.
	 * 
	 * @param pts
	 * @return
	 */
	private Coordinate[] reduce(Coordinate[] inputPts) {
		// Coordinate[] polyPts = computeQuad(inputPts);
		Coordinate[] polyPts = computeOctRing(inputPts);
		// Coordinate[] polyPts = null;

		// unable to compute interior polygon for some reason
		if (polyPts == null)
			return inputPts;

		// LinearRing ring = geomFactory.createLinearRing(polyPts);
		// System.out.println(ring);

		// add points defining polygon
		HashSet reducedSet = new HashSet();
		for (int i = 0; i < polyPts.length; i++) {
			reducedSet.add(polyPts[i]);
		}
		/**
		 * Add all unique points not in the interior poly.
		 * CGAlgorithms.isPointInRing is not defined for points actually on the
		 * ring, but this doesn't matter since the points of the interior
		 * polygon are forced to be in the reduced set.
		 */
		for (int i = 0; i < inputPts.length; i++) {
			if (!CGAlgorithms.isPointInRing(inputPts[i], polyPts)) {
				reducedSet.add(inputPts[i]);
			}
		}
		Coordinate[] reducedPts = CoordinateArrays
				.toCoordinateArray(reducedSet);
		return reducedPts;
	}

