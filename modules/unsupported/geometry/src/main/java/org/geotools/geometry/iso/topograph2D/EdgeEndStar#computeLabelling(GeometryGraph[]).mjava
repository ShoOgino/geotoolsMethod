	/**
	 * Computes the labelling for the ???
	 * 
	 * @param geom
	 */
	public void computeLabelling(GeometryGraph[] geom) {
		computeEdgeEndLabels();
		// Propagate side labels around the edges in the star
		// for each parent Geometry
		// Debug.print(this);
		propagateSideLabels(0);
		// Debug.print(this);
		// Debug.printIfWatch(this);
		propagateSideLabels(1);
		// Debug.print(this);
		// Debug.printIfWatch(this);

		/**
		 * If there are edges that still have null labels for a geometry this
		 * must be because there are no area edges for that geometry incident on
		 * this node. In this case, to label the edge for that geometry we must
		 * test whether the edge is in the interior of the geometry. To do this
		 * it suffices to determine whether the node for the edge is in the
		 * interior of an area. If so, the edge has location INTERIOR for the
		 * geometry. In all other cases (e.g. the node is on a line, on a point,
		 * or not on the geometry at all) the edge has the location EXTERIOR for
		 * the geometry.
		 * <p>
		 * Note that the edge cannot be on the BOUNDARY of the geometry, since
		 * then there would have been a parallel edge from the Geometry at this
		 * node also labelled BOUNDARY and this edge would have been labelled in
		 * the previous step.
		 * <p>
		 * This code causes a problem when dimensional collapses are present,
		 * since it may try and determine the location of a node where a
		 * dimensional collapse has occurred. The point should be considered to
		 * be on the EXTERIOR of the polygon, but locate() will return INTERIOR,
		 * since it is passed the original Geometry, not the collapsed version.
		 * 
		 * If there are incident edges which are Line edges labelled BOUNDARY,
		 * then they must be edges resulting from dimensional collapses. In this
		 * case the other edges can be labelled EXTERIOR for this Geometry.
		 * 
		 * MD 8/11/01 - NOT TRUE! The collapsed edges may in fact be in the
		 * interior of the Geometry, which means the other edges should be
		 * labelled INTERIOR for this Geometry. Not sure how solve this...
		 * Possibly labelling needs to be split into several phases: area label
		 * propagation, symLabel merging, then finally null label resolution.
		 */
		boolean[] hasDimensionalCollapseEdge = { false, false };
		for (Iterator it = iterator(); it.hasNext();) {
			EdgeEnd e = (EdgeEnd) it.next();
			Label label = e.getLabel();
			for (int geomi = 0; geomi < 2; geomi++) {
				if (label.isLine(geomi)
						&& label.getLocation(geomi) == Location.BOUNDARY)
					hasDimensionalCollapseEdge[geomi] = true;
			}
		}
		// Debug.print(this);
		for (Iterator it = iterator(); it.hasNext();) {
			EdgeEnd e = (EdgeEnd) it.next();
			Label label = e.getLabel();
			// Debug.println(e);
			for (int geomi = 0; geomi < 2; geomi++) {
				if (label.isAnyNull(geomi)) {
					int loc = Location.NONE;
					if (hasDimensionalCollapseEdge[geomi]) {
						loc = Location.EXTERIOR;
					} else {
						Coordinate p = e.getCoordinate();
						loc = getLocation(geomi, p, geom);
					}
					label.setAllLocationsIfNull(geomi, loc);
				}
			}
			// Debug.println(e);
		}
		// Debug.print(this);
		// Debug.printIfWatch(this);
	}

