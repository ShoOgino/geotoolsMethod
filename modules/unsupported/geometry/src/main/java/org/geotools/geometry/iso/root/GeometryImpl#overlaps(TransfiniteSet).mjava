	/**
	 * This operator tests, whether an object overlaps with this object.
	 * That is that a part of the object lies within this object and another part lies without this object,
	 * e.g. the other object intersects with the interior, boundary and exterior of this object
	 * 
	 * @param pointSet The other object
	 * 
	 * @return TRUE, if the other object overlaps with this object
	 */
	public boolean overlaps(TransfiniteSet pointSet) {
		GeometryImpl geom = GeometryImpl.castToGeometryImpl(pointSet);
		
		int d1 = geom.getDimension(null);
		int d2 = this.getDimension(null);

		// Overlaps only for Point/Point, Curve/Curve, Surface/Surface
		if (d1 != d2) {
			return false;
		}
		// Return false, if the envelopes doesnÂ´t intersect
		if (!((EnvelopeImpl)this.getEnvelope()).intersects(geom.getEnvelope()))
			return false;
		
		IntersectionMatrix tIM = null;
		try {
			tIM = RelateOp.relate(this, geom);
		} catch (UnsupportedDimensionException e) {
			e.printStackTrace();
			return false;
		}
		
		boolean rValue = false;
		if (d1 == 1)
			rValue = tIM.matches("1*T***T**");
		else
			rValue = tIM.matches("T*T***T**");

		
//		if (this instanceof PrimitiveImpl) {
//			if (geom instanceof PrimitiveImpl) {
//				// Primitive / Primitive
//				if (geom.getDimension(null) == 1)
//					rValue = tIM.matches("1*T***T**");
//				else
//					rValue = tIM.matches("T*T***T**");
//			} else
//			if (geom instanceof ComplexImpl) {
//				// Primitive / Complex
//				if (geom.getDimension(null) == 1)
//					rValue = tIM.matches("1*T***T**");
//				else
//					rValue = tIM.matches("T*T***T**");
//			} else {
//				Assert.isTrue(false);
//			}
//		} else
//		if (this instanceof ComplexImpl) {
//			if (geom instanceof PrimitiveImpl) {
//				// Complex / Primitive
//				if (geom.getDimension(null) == 1)
//					rValue = tIM.matches("1*T***T**");
//				else
//					rValue = tIM.matches("T*T***T**");
//			} else
//			if (geom instanceof ComplexImpl) {
//				// Complex / Complex
//				if (geom.getDimension(null) == 1)
//					rValue = tIM.matches("1*T***T**");
//				else
//					rValue = tIM.matches("T*T***T**");
//			} else {
//				Assert.isTrue(false);
//			}
//		}
		
		return rValue;	
	}

