	/**
	 * Find the innermost enclosing shell EdgeRing containing the argument
	 * EdgeRing, if any. The innermost enclosing ring is the <i>smallest</i>
	 * enclosing ring. The algorithm used depends on the fact that: <br>
	 * ring A contains ring B if envelope(ring A) contains envelope(ring B)
	 * <br>
	 * This routine is only safe to use if the chosen point of the hole is known
	 * to be properly contained in a shell (which is guaranteed to be the case
	 * if the hole does not touch its shell)
	 * 
	 * @return containing EdgeRing, if there is one
	 * @return null if no containing EdgeRing is found
	 */
	private EdgeRing findEdgeRingContaining(EdgeRing testEr, List shellList) {

		Ring testRing = testEr.getRing();
		org.geotools.geometry.iso.coordinate.EnvelopeImpl env = (EnvelopeImpl) testRing
				.getEnvelope();
		Envelope testEnv = new Envelope(env.getLowerCorner().getOrdinate(X), env
				.getUpperCorner().getOrdinate(X), env.getLowerCorner().getOrdinate(Y), env
				.getUpperCorner().getOrdinate(Y));
		// Take a point on the ring to do the point in ring test
		DirectPosition dp = testRing.getRepresentativePoint();
		Coordinate testPt = new Coordinate(dp.getCoordinate());

		EdgeRing minShell = null;
		Envelope minEnv = null;
		for (Iterator it = shellList.iterator(); it.hasNext();) {
			EdgeRing tryShell = (EdgeRing) it.next();
			Ring tryRing = tryShell.getRing();

			env = (EnvelopeImpl) tryRing.getEnvelope();
			Envelope tryEnv = new Envelope(env.getLowerCorner().getOrdinate(X), env
					.getUpperCorner().getOrdinate(X), env.getLowerCorner().getOrdinate(Y), env
					.getUpperCorner().getOrdinate(Y));

			if (minShell != null) {
				env = (EnvelopeImpl) minShell.getRing().getEnvelope();
				minEnv = new Envelope(env.getLowerCorner().getOrdinate(X), env
						.getUpperCorner().getOrdinate(X), env.getLowerCorner().getOrdinate(Y),
						env.getUpperCorner().getOrdinate(Y));
			}

			boolean isContained = false;
			if (tryEnv.contains(testEnv)
					&& CGAlgorithms.isPointInRing(testPt, CoordinateArrays
							.toCoordinateArray( (((RingImplUnsafe) tryRing).asDirectPositions()) ))) {
				isContained = true;
			}
			// check if this new containing ring is smaller than the current
			// minimum ring
			if (isContained) {
				if (minShell == null || minEnv.contains(tryEnv)) {
					minShell = tryShell;
				}
			}
		}
		return minShell;
	}

