	/**
	 * Computes the "edge distance" of an intersection point p along a segment.
	 * The edge distance is a metric of the point along the edge. The metric
	 * used is a robust and easy to compute metric function. It is <b>not</b>
	 * equivalent to the usual Euclidean metric. It relies on the fact that
	 * either the x or the y ordinates of the points in the edge are unique,
	 * depending on whether the edge is longer in the horizontal or vertical
	 * direction.
	 * <p>
	 * NOTE: This function may produce incorrect distances for inputs where p is
	 * not precisely on p1-p2 (E.g. p = (139,9) p1 = (139,10), p2 = (280,1)
	 * produces distanct 0.0, which is incorrect.
	 * <p>
	 * My hypothesis is that the function is safe to use for points which are
	 * the result of <b>rounding</b> points which lie on the line, but not safe
	 * to use for <b>truncated</b> points.
	 */
	public static double computeEdgeDistance(Coordinate p, Coordinate p0,
			Coordinate p1) {
		double dx = Math.abs(p1.x - p0.x);
		double dy = Math.abs(p1.y - p0.y);

		double dist = -1.0; // sentinel value
		if (p.equals(p0)) {
			dist = 0.0;
		} else if (p.equals(p1)) {
			if (dx > dy)
				dist = dx;
			else
				dist = dy;
		} else {
			double pdx = Math.abs(p.x - p0.x);
			double pdy = Math.abs(p.y - p0.y);
			if (dx > dy)
				dist = pdx;
			else
				dist = pdy;
			// <FIX>
			// hack to ensure that non-endpoints always have a non-zero distance
			if (dist == 0.0 && !p.equals(p0)) {
				dist = Math.max(pdx, pdy);
			}
		}
		Assert.isTrue(!(dist == 0.0 && !p.equals(p0)),
				"Bad distance calculation");
		return dist;
	}

