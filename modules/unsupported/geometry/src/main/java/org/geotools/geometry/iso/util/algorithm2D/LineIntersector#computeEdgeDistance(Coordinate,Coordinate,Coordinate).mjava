    /**
     * Computes the "edge distance" of an intersection point p along a segment. The edge distance is
     * a metric of the point along the edge. The metric used is a robust and easy to compute metric
     * function. It is <b>not</b> equivalent to the usual Euclidean metric. It relies on the fact
     * that either the x or the y ordinates of the points in the edge are unique, depending on
     * whether the edge is longer in the horizontal or vertical direction.
     *
     * <p>NOTE: This function may produce incorrect distances for inputs where p is not precisely on
     * p1-p2 (E.g. p = (139,9) p1 = (139,10), p2 = (280,1) produces distanct 0.0, which is
     * incorrect.
     *
     * <p>My hypothesis is that the function is safe to use for points which are the result of
     * <b>rounding</b> points which lie on the line, but not safe to use for <b>truncated</b>
     * points.
     */
    public static double computeEdgeDistance(Coordinate p, Coordinate p0, Coordinate p1) {
        double dx = Math.abs(p1.x - p0.x);
        double dy = Math.abs(p1.y - p0.y);

        double dist = -1.0; // sentinel value
        if (p.equals(p0)) {
            dist = 0.0;
        } else if (p.equals(p1)) {
            if (dx > dy) dist = dx;
            else dist = dy;
        } else {
            double pdx = Math.abs(p.x - p0.x);
            double pdy = Math.abs(p.y - p0.y);
            if (dx > dy) dist = pdx;
            else dist = pdy;
            // <FIX>
            // hack to ensure that non-endpoints always have a non-zero distance
            if (dist == 0.0 && !p.equals(p0)) {
                dist = Math.max(pdx, pdy);
            }
        }
        Assert.isTrue(!(dist == 0.0 && !p.equals(p0)), "Bad distance calculation");
        return dist;
    }

