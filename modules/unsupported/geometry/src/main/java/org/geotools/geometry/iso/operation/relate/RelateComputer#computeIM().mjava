    /**
     * Computes the Intersection Matrix for the two given geometry objects
     *
     * @return Intersection Matrix
     */
    public IntersectionMatrix computeIM() {

        IntersectionMatrix tIM = new IntersectionMatrix();

        // since Geometries are finite and embedded in a 2-D space, the EE
        // element must always be 2
        tIM.set(Location.EXTERIOR, Location.EXTERIOR, 2);

        // if the Geometries don't overlap there is nothing to do
        //		if (!arg[0].getGeometry().getEnvelopeInternal().intersects(
        //				arg[1].getGeometry().getEnvelopeInternal())) {
        EnvelopeImpl env1 = (EnvelopeImpl) arg[0].getGeometry().getEnvelope();
        EnvelopeImpl env2 = (EnvelopeImpl) arg[1].getGeometry().getEnvelope();
        if (!env1.intersects(env2)) {
            computeDisjointIM(tIM);
            return tIM;
        }
        this.arg[0].computeSelfNodes(this.li, false);
        this.arg[1].computeSelfNodes(this.li, false);

        // compute intersections between edges of the two input geometries
        SegmentIntersector tIntersector =
                this.arg[0].computeEdgeIntersections(this.arg[1], this.li, false);

        this.computeIntersectionNodes(0);
        this.computeIntersectionNodes(1);

        // Copy the labelling for the nodes in the parent Geometries. These
        // override any labels determined by intersections between the
        // geometries.
        this.copyNodesAndLabels(0);
        this.copyNodesAndLabels(1);

        // complete the labelling for any nodes which only have a label for a
        // single geometry
        this.labelIsolatedNodes();

        // If a proper intersection was found,
        // we can set a lower bound on the IM.
        this.computeProperIntersectionIM(tIntersector, tIM);

        // Now process improper intersections (e.g. where one or other of the
        // geometries has a vertex at the intersection point) We need to compute
        // the edge graph at all nodes to determine the IM.

        // build EdgeEnds for all intersections
        EdgeEndBuilder eeBuilder = new EdgeEndBuilder();
        List ee0 = eeBuilder.computeEdgeEnds(arg[0].getEdgeIterator());
        this.insertEdgeEnds(ee0);
        List ee1 = eeBuilder.computeEdgeEnds(arg[1].getEdgeIterator());
        this.insertEdgeEnds(ee1);

        this.labelNodeEdges();

        // Compute the labeling for isolated components <br>
        // Isolated components are components that do not touch any other
        // components in the graph. They can be identified by the fact that they
        // will contain labels containing ONLY a single element, the one for
        // their parent geometry. We only need to check components contained in
        // the input graphs, since isolated components will not have been
        // replaced by new components formed by intersections.

        this.labelIsolatedEdges(0, 1);
        this.labelIsolatedEdges(1, 0);

        // update the IM from all components
        this.updateIM(tIM);

        return tIM;
    }

