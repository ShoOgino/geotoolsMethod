    /**
     * Compute a Ring from the point list previously collected. Test if the ring is a hole (i.e. if
     * it is CCW) and set the hole flag accordingly.
     */
    private void computeRing() {
        if (this.ring != null) return; // don't compute more than once

        // OLD CODE:
        // Coordinate[] coord = new Coordinate[pts.size()];
        // for (int i = 0; i < pts.size(); i++) {
        // coord[i] = (Coordinate) pts.get(i);
        // }

        // Coordinate[] coord = new Coordinate[this.pts.size()];
        List<Position> dpList = new LinkedList<Position>();

        for (int i = 0; i < this.pts.size(); i++) {
            double[] doubleCoords = ((Coordinate) this.pts.get(i)).getCoordinates();
            Position dp = new PositionImpl(new DirectPositionImpl(crs, doubleCoords));
            dpList.add(dp);
        }

        // Create List of CurveSegment´s (LineString´s)
        LineStringImpl lineString = new LineStringImpl(new PointArrayImpl(dpList), 0.0);
        List<CurveSegment> segments = new ArrayList<CurveSegment>();
        segments.add(lineString);

        // Create List of OrientableCurve´s (Curve´s)
        OrientableCurve curve = new CurveImpl(crs, segments);
        List<OrientableCurve> orientableCurves = new ArrayList<OrientableCurve>();
        orientableCurves.add(curve);

        this.ring = new RingImpl(orientableCurves);
        // this.ring = (RingImpl)
        // this.mFeatGeomFactory.getPrimitiveFactory().createRingByDirectPositions(dpList);

        // isHole is now calculated in the constructor.
        /*
        // See if the Ring is counterclockwise oriented
        this.isHole = this.cga.isCCW(CoordinateArrays
        		.toCoordinateArray(this.ring.asDirectPositions()));
        */

        // Debug.println( (isHole ? "hole - " : "shell - ") +
        // WKTWriter.toLineString(new
        // CoordinateArraySequence(ring.getCoordinates())));
    }

