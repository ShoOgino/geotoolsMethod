	/**
	 * Compute a Ring from the point list previously collected. Test if the ring
	 * is a hole (i.e. if it is CCW) and set the hole flag accordingly.
	 */
	private void computeRing() {
		if (this.ring != null)
			return; // don't compute more than once

		// OLD CODE:
		// Coordinate[] coord = new Coordinate[pts.size()];
		// for (int i = 0; i < pts.size(); i++) {
		// coord[i] = (Coordinate) pts.get(i);
		// }

		//Coordinate[] coord = new Coordinate[this.pts.size()];
		List<Position> dpList = new LinkedList<Position>();

		for (int i = 0; i < this.pts.size(); i++) {
			double[] doubleCoords = ((Coordinate) this.pts.get(i))
					.getCoordinates();
			Position dp = new PositionImpl( new DirectPositionImpl(crs, doubleCoords) );
			dpList.add(dp);
		}
		
		// Create List of CurveSegment´s (LineString´s)
		LineStringImpl lineString = new LineStringImpl(new PointArrayImpl(
				dpList), 0.0);
		List<CurveSegment> segments = new ArrayList<CurveSegment>();
		segments.add(lineString);
		
		// Create List of OrientableCurve´s (Curve´s)
		OrientableCurve curve = new CurveImpl(crs, segments);
		List<OrientableCurve> orientableCurves = new ArrayList<OrientableCurve>();
		orientableCurves.add(curve);

		this.ring = new RingImpl(orientableCurves);		
		// this.ring = (RingImpl) this.mFeatGeomFactory.getPrimitiveFactory().createRingByDirectPositions(dpList);
		
		// isHole is now calculated in the constructor.
		/*
		// See if the Ring is counterclockwise oriented
		this.isHole = this.cga.isCCW(CoordinateArrays
				.toCoordinateArray(this.ring.asDirectPositions()));
		*/

		// Debug.println( (isHole ? "hole - " : "shell - ") +
		// WKTWriter.toLineString(new
		// CoordinateArraySequence(ring.getCoordinates())));
	}

