	protected int computeIntersect(Coordinate p1, Coordinate p2, Coordinate q1,
			Coordinate q2) {
		isProper = false;

		// first try a fast test to see if the envelopes of the lines intersect
		if (!Envelope.intersects(p1, p2, q1, q2))
			return DONT_INTERSECT;

		// for each endpoint, compute which side of the other segment it lies
		// if both endpoints lie on the same side of the other segment,
		// the segments do not intersect
		int Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);
		int Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);

		if ((Pq1 > 0 && Pq2 > 0) || (Pq1 < 0 && Pq2 < 0)) {
			return DONT_INTERSECT;
		}

		int Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);
		int Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);

		if ((Qp1 > 0 && Qp2 > 0) || (Qp1 < 0 && Qp2 < 0)) {
			return DONT_INTERSECT;
		}

		boolean collinear = Pq1 == 0 && Pq2 == 0 && Qp1 == 0 && Qp2 == 0;
		if (collinear) {
			return computeCollinearIntersection(p1, p2, q1, q2);
		}
		/**
		 * Check if the intersection is an endpoint. If it is, copy the endpoint
		 * as the intersection point. Copying the point rather than computing it
		 * ensures the point has the exact value, which is important for
		 * robustness. It is sufficient to simply check for an endpoint which is
		 * on the other line, since at this point we know that the inputLines
		 * must intersect.
		 */
		if (Pq1 == 0 || Pq2 == 0 || Qp1 == 0 || Qp2 == 0) {
			isProper = false;
			if (Pq1 == 0) {
				intPt[0] = new Coordinate(q1);
			}
			if (Pq2 == 0) {
				intPt[0] = new Coordinate(q2);
			}
			if (Qp1 == 0) {
				intPt[0] = new Coordinate(p1);
			}
			if (Qp2 == 0) {
				intPt[0] = new Coordinate(p2);
			}
		} else {
			isProper = true;
			intPt[0] = intersection(p1, p2, q1, q2);
		}
		return DO_INTERSECT;
	}

