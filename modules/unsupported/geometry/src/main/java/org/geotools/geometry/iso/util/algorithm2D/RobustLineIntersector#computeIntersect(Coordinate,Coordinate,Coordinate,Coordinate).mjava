    protected int computeIntersect(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2) {
        isProper = false;

        // first try a fast test to see if the envelopes of the lines intersect
        if (!Envelope.intersects(p1, p2, q1, q2)) return DONT_INTERSECT;

        // for each endpoint, compute which side of the other segment it lies
        // if both endpoints lie on the same side of the other segment,
        // the segments do not intersect
        int Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);
        int Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);

        if ((Pq1 > 0 && Pq2 > 0) || (Pq1 < 0 && Pq2 < 0)) {
            return DONT_INTERSECT;
        }

        int Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);
        int Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);

        if ((Qp1 > 0 && Qp2 > 0) || (Qp1 < 0 && Qp2 < 0)) {
            return DONT_INTERSECT;
        }

        boolean collinear = Pq1 == 0 && Pq2 == 0 && Qp1 == 0 && Qp2 == 0;
        if (collinear) {
            return computeCollinearIntersection(p1, p2, q1, q2);
        }
        /**
         * Check if the intersection is an endpoint. If it is, copy the endpoint as the intersection
         * point. Copying the point rather than computing it ensures the point has the exact value,
         * which is important for robustness. It is sufficient to simply check for an endpoint which
         * is on the other line, since at this point we know that the inputLines must intersect.
         */
        if (Pq1 == 0 || Pq2 == 0 || Qp1 == 0 || Qp2 == 0) {
            isProper = false;
            if (Pq1 == 0) {
                intPt[0] = new Coordinate(q1);
            }
            if (Pq2 == 0) {
                intPt[0] = new Coordinate(q2);
            }
            if (Qp1 == 0) {
                intPt[0] = new Coordinate(p1);
            }
            if (Qp2 == 0) {
                intPt[0] = new Coordinate(p2);
            }
        } else {
            isProper = true;
            intPt[0] = intersection(p1, p2, q1, q2);
        }
        return DO_INTERSECT;
    }

