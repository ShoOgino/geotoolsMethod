    /**
     * Returns a {@link Geometry} that represents the convex hull of the input geometry. The
     * returned geometry contains the minimal number of points needed to represent the convex hull.
     * In particular, no more than two consecutive points will be collinear.
     *
     * @return if the convex hull contains 3 or more points, a {@link Polygon}; 2 points, a {@link
     *     LineString}; 1 point, a {@link Point}; 0 points, an empty {@link GeometryCollection}.
     */
    public Geometry getConvexHull() {

        if (inputPts.length == 0) {
            // return geomFactory.createGeometryCollection(null);
            // if no points, return null
            return null;
        }
        if (inputPts.length == 1) {
            // 1 point: return Point
            return new PointImpl(
                    new DirectPositionImpl(
                            crs,
                            inputPts[0]
                                    .getCoordinates())); // this.geomFactory.getPrimitiveFactory().createPoint(inputPts[0].getCoordinate());
        }
        if (inputPts.length == 2) {
            List<Position> positions = CoordinateArrays.toPositionList(this.crs, this.inputPts);
            LineStringImpl lineString = new LineStringImpl(new PointArrayImpl(positions), 0.0);
            List<CurveSegment> segments = new ArrayList<CurveSegment>();
            segments.add(lineString);
            return new CurveImpl(this.crs, segments);
            // return this.geomFactory.getPrimitiveFactory().createCurveByPositions((List<Position>)
            // positions);
        }

        Coordinate[] reducedPts = inputPts;
        // use heuristic to reduce points, if large
        if (inputPts.length > 50) {
            reducedPts = reduce(inputPts);
        }
        // sort points for Graham scan.
        Coordinate[] sortedPts = preSort(reducedPts);

        // Use Graham scan to find convex hull.
        Stack cHS = grahamScan(sortedPts);

        // Convert stack to an array.
        Coordinate[] cH = toCoordinateArray(cHS);

        // Convert array to appropriate output geometry.
        return lineOrPolygon(cH);
    }

