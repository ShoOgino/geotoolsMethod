	/**
	 * Returns a {@link Geometry} that represents the convex hull of the input
	 * geometry. The returned geometry contains the minimal number of points
	 * needed to represent the convex hull. In particular, no more than two
	 * consecutive points will be collinear.
	 * 
	 * @return if the convex hull contains 3 or more points, a {@link Polygon};
	 *         2 points, a {@link LineString}; 1 point, a {@link Point}; 0
	 *         points, an empty {@link GeometryCollection}.
	 */
	public Geometry getConvexHull() {

		if (inputPts.length == 0) {
			// return geomFactory.createGeometryCollection(null);
			// if no points, return null
			return null;
		}
		if (inputPts.length == 1) {
			// 1 point: return Point
			return new PointImpl( new DirectPositionImpl(crs, inputPts[0].getCoordinates()) ); //this.geomFactory.getPrimitiveFactory().createPoint(inputPts[0].getCoordinates());
		}
		if (inputPts.length == 2) {
			List<Position> positions = CoordinateArrays.toPositionList(this.crs, this.inputPts);
			LineStringImpl lineString = new LineStringImpl(new PointArrayImpl(positions), 0.0);
			List<CurveSegment> segments = new ArrayList<CurveSegment>();
			segments.add(lineString);
			return new CurveImpl(this.crs, segments);
			//return this.geomFactory.getPrimitiveFactory().createCurveByPositions((List<Position>) positions);
		}

		Coordinate[] reducedPts = inputPts;
		// use heuristic to reduce points, if large
		if (inputPts.length > 50) {
			reducedPts = reduce(inputPts);
		}
		// sort points for Graham scan.
		Coordinate[] sortedPts = preSort(reducedPts);

		// Use Graham scan to find convex hull.
		Stack cHS = grahamScan(sortedPts);

		// Convert stack to an array.
		Coordinate[] cH = toCoordinateArray(cHS);

		// Convert array to appropriate output geometry.
		return lineOrPolygon(cH);
	}

