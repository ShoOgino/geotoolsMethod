    /**
     * This method computes the actual value of the intersection point. To obtain the maximum
     * precision from the intersection calculation, the coordinates are normalized by subtracting
     * the minimum ordinate values (in absolute value). This has the effect of removing common
     * significant digits from the calculation to maintain more bits of precision.
     */
    private Coordinate intersection(Coordinate p1, Coordinate p2, Coordinate q1, Coordinate q2) {
        Coordinate n1 = new Coordinate(p1);
        Coordinate n2 = new Coordinate(p2);
        Coordinate n3 = new Coordinate(q1);
        Coordinate n4 = new Coordinate(q2);
        Coordinate normPt = new Coordinate();
        normalizeToEnvCentre(n1, n2, n3, n4, normPt);

        Coordinate intPt = null;
        try {
            intPt = HCoordinate.intersection(n1, n2, n3, n4);
        } catch (NotRepresentableException e) {
            Assert.shouldNeverReachHere("Coordinate for intersection is not calculable");
            // EnvelopeMidpointIntersector emInt = new
            // EnvelopeMidpointIntersector(n1, n2, n3, n4);
            // intPt = emInt.getIntersection();
        }

        intPt.x += normPt.x;
        intPt.y += normPt.y;

        /**
         * MD - May 4 2005 - This is still a problem. Here is a failure case:
         *
         * <p>LINESTRING (2089426.5233462777 1180182.3877339689, 2085646.6891757075
         * 1195618.7333999649) LINESTRING (1889281.8148903656 1997547.0560044837, 2259977.3672235999
         * 483675.17050843034) int point = (2097408.2633752143,1144595.8008114607)
         */
        // if (!isInSegmentEnvelopes(intPt)) {
        // System.out.println("Intersection outside segment envelopes: " + intPt);
        // }
        /*
         * // disabled until a better solution is found if (!
         * isInSegmentEnvelopes(intPt)) { // System.out.println("first value
         * outside segment envelopes: " + intPt);
         *
         * IteratedBisectionIntersector ibi = new
         * IteratedBisectionIntersector(p1, p2, q1, q2); intPt =
         * ibi.getIntersection(); } if (! isInSegmentEnvelopes(intPt)) {
         * // System.out.println("ERROR - outside segment envelopes: " + intPt);
         *
         * IteratedBisectionIntersector ibi = new
         * IteratedBisectionIntersector(p1, p2, q1, q2); Coordinate testPt =
         * ibi.getIntersection(); }
         */

        if (precisionModel != null) {
            precisionModel.makePrecise(intPt);
        }

        return intPt;
    }

