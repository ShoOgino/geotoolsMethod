    /**
     * Compute self-nodes, taking advantage of the Geometry type to minimize the number of
     * intersection tests. (E.g. rings are not tested for self-intersection, since they are assumed
     * to be valid).
     *
     * @param li the LineIntersector to use
     * @param computeRingSelfNodes if <false>, intersection checks are optimized to not test rings
     *     for self-intersection
     * @return the SegmentIntersector used, containing information about the intersections found
     */
    public SegmentIntersector computeSelfNodes(LineIntersector li, boolean computeRingSelfNodes) {

        SegmentIntersector si = new SegmentIntersector(li, true, false);

        // get an instance for an edgeSetIntersector (here: MC Sweepline
        // Intersector)
        EdgeSetIntersector esi = this.createEdgeSetIntersector();

        // optimized test for Polygons and Rings
        if (!computeRingSelfNodes
                && (parentGeom instanceof Ring
                        || parentGeom instanceof Surface
                        || parentGeom instanceof MultiPrimitive)) {
            // TODO auskommentiert; checken!
            // && (parentGeom instanceof LinearRing
            // || parentGeom instanceof Polygon
            // || parentGeom instanceof MultiPolygon)
            // Compute Intersections without self-intersections
            esi.computeIntersections(edges, si, false);
        } else {
            // Compute Intersections with self-intersections
            esi.computeIntersections(edges, si, true);
        }

        // System.out.println("SegmentIntersector # tests = " + si.numTests);
        addSelfIntersectionNodes(argIndex);
        return si;
    }

