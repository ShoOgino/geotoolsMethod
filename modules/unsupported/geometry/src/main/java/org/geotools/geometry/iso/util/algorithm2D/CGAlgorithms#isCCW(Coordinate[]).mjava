	/**
	 * Computes whether a ring defined by an array of {@link Coordinate} is
	 * oriented counter-clockwise.
	 * <ul>
	 * <li>The list of points is assumed to have the first and last points
	 * equal.
	 * <li>This will handle coordinate lists which contain repeated points.
	 * </ul>
	 * This algorithm is <b>only</b> guaranteed to work with valid rings. If
	 * the ring is invalid (e.g. self-crosses or touches), the computed result
	 * <b>may</b> not be correct.
	 * 
	 * @param ring
	 *            an array of coordinates forming a ring
	 * @return <code>true</code> if the ring is oriented counter-clockwise.
	 */
	public static boolean isCCW(Coordinate[] ring) {
		// # of points without closing endpoint
		int nPts = ring.length - 1;

		// find highest point
		Coordinate hiPt = ring[0];
		int hiIndex = 0;
		for (int i = 1; i <= nPts; i++) {
			Coordinate p = ring[i];
			if (p.y > hiPt.y) {
				hiPt = p;
				hiIndex = i;
			}
		}

		// find distinct point before highest point
		int iPrev = hiIndex;
		do {
			iPrev = iPrev - 1;
			if (iPrev < 0)
				iPrev = nPts;
		} while (ring[iPrev].equals2D(hiPt) && iPrev != hiIndex);

		// find distinct point after highest point
		int iNext = hiIndex;
		do {
			iNext = (iNext + 1) % nPts;
		} while (ring[iNext].equals2D(hiPt) && iNext != hiIndex);

		Coordinate prev = ring[iPrev];
		Coordinate next = ring[iNext];

		/**
		 * This check catches cases where the ring contains an A-B-A
		 * configuration of points. This can happen if the ring does not contain
		 * 3 distinct points (including the case where the input array has fewer
		 * than 4 elements), or it contains coincident line segments.
		 */
		if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next))
			return false;

		int disc = computeOrientation(prev, hiPt, next);

		/**
		 * If disc is exactly 0, lines are collinear. There are two possible
		 * cases: (1) the lines lie along the x axis in opposite directions (2)
		 * the lines lie on top of one another
		 * 
		 * (1) is handled by checking if next is left of prev ==> CCW (2) will
		 * never happen if the ring is valid, so don't check for it (Might want
		 * to assert this)
		 */
		boolean isCCW = false;
		if (disc == 0) {
			// poly is CCW if prev x is right of next x
			isCCW = (prev.x > next.x);
		} else {
			// if area is positive, points are ordered CCW
			isCCW = (disc > 0);
		}
		return isCCW;
	}

