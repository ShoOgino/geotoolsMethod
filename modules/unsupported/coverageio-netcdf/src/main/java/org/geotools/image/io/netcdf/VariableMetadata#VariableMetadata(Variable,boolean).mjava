    /**
     * Extracts metadata from the specified variable using our own method.
     *
     * @param variable The variable to extract metadata from.
     * @param forceRangePacking {@code true} if the valid range is encoded in geophysics units
     *        (which is a violation of CF convention), or {@code false} in order to autodetect
     *        using the UCAR heuristic rule.
     */
    public VariableMetadata(final Variable variable, boolean forceRangePacking) {
        final DataType dataType, scaleType, rangeType;
        /*
         * Gets the scale factors, if present. Also remember its type
         * for the heuristic rule to be applied later on the valid range.
         */
        imageType  = getRawDataType(variable);
        dataType   = widestType = variable.getDataType();
        scale      = attribute(variable, "scale_factor");
        offset     = attribute(variable, "add_offset");
        scaleType  = widestType;
        widestType = dataType; // Reset before we scan the other attributes.
        /*
         * Gets minimum and maximum. If a "valid_range" attribute is presents, it as precedence
         * over "valid_min" and "valid_max" as specified in UCAR documentation.
         */
        double minimum = Double.NaN;
        double maximum = Double.NaN;
        Attribute attribute = variable.findAttribute("valid_range");
        if (attribute != null) {
            widestType = widest(attribute.getDataType(), widestType);
            Number value = attribute.getNumericValue(0);
            if (value != null) {
                minimum = value.doubleValue();
            }
            value = attribute.getNumericValue(1);
            if (value != null) {
                maximum = value.doubleValue();
            }
        }
        if (Double.isNaN(minimum)) {
            minimum = attribute(variable, "valid_min");
        }
        if (Double.isNaN(maximum)) {
            maximum = attribute(variable, "valid_max");
        }
        rangeType  = widestType;
        widestType = dataType; // Reset before we scan the other attributes.
        if (!forceRangePacking) {
            // Heuristic rule defined in UCAR documentation (see EnhanceScaleMissing interface)
            forceRangePacking = rangeType.equals(scaleType) &&
                                rangeType.equals(widest(rangeType, dataType));
        }
        if (forceRangePacking) {
            final double offset = Double.isNaN(this.offset) ? 0 : this.offset;
            final double scale  = Double.isNaN(this.scale ) ? 1 : this.scale;
            minimum = (minimum - offset) / scale;
            maximum = (maximum - offset) / scale;
            if (!isFloatingPoint(rangeType)) {
                if (!Double.isNaN(minimum) && !Double.isInfinite(minimum)) {
                    minimum = Math.round(minimum);
                }
                if (!Double.isNaN(maximum) && !Double.isInfinite(maximum)) {
                    maximum = Math.round(maximum);
                }
            }
        }
        if (Double.isNaN(minimum)) minimum = Double.NEGATIVE_INFINITY;
        if (Double.isNaN(maximum)) maximum = Double.POSITIVE_INFINITY;
        this.minimum = minimum;
        this.maximum = maximum;
        /*
         * Gets fill and missing values. According UCAR documentation, they are
         * always in packed units. We keep them "as-is" (as opposed to UCAR who
         * converts them to geophysics units), in order to avoid rounding errors.
         * Note that we merge missing and fill values in a single array, without
         * duplicated values.
         */
        widestType = dataType;
        attribute = variable.findAttribute("missing_value");
        final double fillValue    = attribute(variable, "_FillValue");
        final int    fillCount    = Double.isNaN(fillValue) ? 0 : 1;
        final int    missingCount = (attribute != null) ? attribute.getLength() : 0;
        final double[] missings   = new double[fillCount + missingCount];
        if (fillCount != 0) {
            missings[0] = fillValue;
        }
        int count = fillCount;
scan:   for (int i=0; i<missingCount; i++) {
            final Number number = attribute.getNumericValue(i);
            if (number != null) {
                final double value = number.doubleValue();
                if (!Double.isNaN(value)) {
                    for (int j=0; j<count; j++) {
                        if (value == missings[j]) {
                            // Current value duplicates a previous one.
                            continue scan;
                        }
                    }
                    missings[count++] = value;
                }
            }
        }
        missingValues = (count != 0) ? XArray.resize(missings, count) : null;
    }

