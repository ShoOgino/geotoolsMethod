    /**
     * @precondition {@code typeName != null && versioningFilter != null}
     * @precondition {@code versioningFilter.getIdentifiers().size() > 0}
     * @postcondition {@code $return != null}
     * @param typeName
     * @param versioningFilter
     * @param extraQuery
     * @return
     * @throws IOException
     */
    public FeatureCollection getFeatures(final Name typeName,
            final Id versioningFilter, final Query extraQuery)
            throws IOException {
        Assert.notNull(typeName);
        Assert.notNull(versioningFilter);
        Assert.isTrue(versioningFilter.getIdentifiers().size() > 0);

        final Set<Identifier> identifiers = versioningFilter.getIdentifiers();
        final Set<ResourceId> resourceIds = new HashSet<ResourceId>();
        for (Identifier id : identifiers) {
            if (id instanceof ResourceId) {
                resourceIds.add((ResourceId) id);
            }
        }
        if (resourceIds.size() == 0) {
            throw new IllegalArgumentException("At least one "
                    + ResourceId.class.getName() + " should be provided: "
                    + identifiers);
        }

        final FeatureType featureType = this.getSchema(typeName);
        ResourceIdFeatureCollector versionQuery;
        versionQuery = new ResourceIdFeatureCollector(repository, featureType,
                resourceIds);

        DefaultFeatureCollection features = new DefaultFeatureCollection(null,
                (SimpleFeatureType) featureType);
        for (Feature f : versionQuery) {
            features.add((SimpleFeature) f);
        }
        return features;
    }

