    /**
     * Assemble a feature collection by polygonizing the boundary segments that
     * have been collected by the vectorizing algorithm.
     * 
     * @param grid the input grid coverage
     * @param band the band containing the data to vectorize
     * @param insideEdges whether to vectorize inside edges (those separating grid regions
     *        with non-outside values)
     * @param type feature type
     * @param monitor a progress listener (may be {@code null})
     * @return a new FeatureCollection containing the boundary polygons
     */
    private SimpleFeatureCollection assembleFeatures(GridCoverage2D grid, int band,
            boolean insideEdges, SimpleFeatureType type, ProgressListener monitor) {
        if (monitor == null) {
            monitor = new NullProgressListener();
        }

        SimpleFeatureCollection features = FeatureCollections.newCollection();
        SimpleFeatureBuilder builder = new SimpleFeatureBuilder(type);

        Point2D p = new Point2D.Double();
        double[] bandData = new double[grid.getNumSampleDimensions()];

        polygonizer.add(lines);
        Collection polygons = polygonizer.getPolygons();
        final int size = polygons.size();
        try {
            float progressScale = 100.0f / size;
            monitor.started();

            int index = 0;
            for (Iterator i = polygons.iterator(); i.hasNext(); index++) {

                if (monitor.isCanceled()) {
                    throw new CancellationException();
                }
                monitor.progress(progressScale * index);

                Polygon poly = (Polygon) i.next();
                InteriorPointArea ipa = new InteriorPointArea(poly);
                Coordinate c = ipa.getInteriorPoint();
                Point insidePt = geomFactory.createPoint(c);

                if (!poly.contains(insidePt)) {
                    // try another method to generate an interior point
                    boolean found = false;
                    for (Coordinate ringC : poly.getExteriorRing().getCoordinates()) {
                        c.x = ringC.x + cellWidthX / 2;
                        c.y = ringC.y;
                        insidePt = geomFactory.createPoint(c);
                        if (poly.contains(insidePt)) {
                            found = true;
                            break;
                        }
                    }

                    if (!found) {
                        throw new IllegalStateException("Can't locate interior point for polygon");
                    }
                }

                p.setLocation(c.x, c.y);
                bandData = grid.evaluate(p, bandData);

                if (!isOutside(bandData[band])) {
                    builder.add(poly);

                    if (insideEdges) {
                        builder.add(bandData[band]);
                    } else {
                        builder.add(INSIDE_FLAG_VALUE);
                    }
                    features.add(builder.buildFeature(null));
                }
            }
            return features;
        } finally {
            monitor.complete();
        }
    }

