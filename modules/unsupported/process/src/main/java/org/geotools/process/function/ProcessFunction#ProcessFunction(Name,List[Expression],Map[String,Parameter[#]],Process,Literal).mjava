    public ProcessFunction(Name processName, List<Expression> inputExpressions,
            Map<String, Parameter<?>> parameters, Process process, Literal fallbackValue) {
        super();
        String nsuri = processName.getNamespaceURI();
        this.name = nsuri == null ? processName.getLocalPart() : nsuri + ":" + processName.getLocalPart();
        this.processName = processName;
        this.inputExpressions = inputExpressions;
        this.parameters = parameters;
        this.process = process;
        this.fallbackValue = fallbackValue;
        
        // build the function name
        List<org.opengis.parameter.Parameter<?>> inputParams = new ArrayList<org.opengis.parameter.Parameter<?>>();
        Map<String, Parameter<?>> parameterInfo = Processors.getParameterInfo(processName);
        if( parameterInfo instanceof LinkedHashMap){
            // predictable order so we can assume parameter order
            for (Parameter<?> param : parameterInfo.values() ){
                // we do not specify the parameter type to avoid validation issues with the
                // different positional/named conventions 
                inputParams.add(param);
            }
        }
        else {
            Set<String> paramNames = parameterInfo.keySet();
            for (String pn: paramNames) {
                // we do not specify the parameter type to avoid validation issues with the
                // different positional/named conventions 
                org.opengis.parameter.Parameter param = FunctionNameImpl.parameter(pn, Object.class, 0, 1);
                inputParams.add(param);
            }
        }
        Map<String, Parameter<?>> resultParams = Processors.getResultInfo(processName, null);
        org.opengis.parameter.Parameter result = resultParams.values().iterator().next();
        functionName = new FunctionNameImpl(name, result, inputParams);
    }

