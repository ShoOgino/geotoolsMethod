    public ProcessFunction(
            Name processName,
            List<Expression> inputExpressions,
            Map<String, Parameter<?>> parameters,
            Process process,
            Literal fallbackValue) {
        super();
        String nsuri = processName.getNamespaceURI();
        this.name =
                nsuri == null
                        ? processName.getLocalPart()
                        : nsuri + ":" + processName.getLocalPart();
        this.processName = processName;
        this.inputExpressions = inputExpressions;
        this.parameters = parameters;
        this.process = process;
        this.fallbackValue = fallbackValue;

        // build the function name
        List<org.opengis.parameter.Parameter<?>> inputParams =
                new ArrayList<org.opengis.parameter.Parameter<?>>();
        Map<String, Parameter<?>> parameterInfo = Processors.getParameterInfo(processName);
        if (parameterInfo instanceof LinkedHashMap) {
            // predictable order so we can assume parameter order
            for (Parameter<?> param : parameterInfo.values()) {
                // we do not specify the parameter type to avoid validation issues with the
                // different positional/named conventions
                inputParams.add(param);
            }
        } else {
            Set<String> paramNames = parameterInfo.keySet();
            for (String pn : paramNames) {
                // we do not specify the parameter type to avoid validation issues with the
                // different positional/named conventions
                org.opengis.parameter.Parameter param =
                        FunctionNameImpl.parameter(pn, Object.class, 0, 1);
                inputParams.add(param);
            }
        }
        Map<String, Parameter<?>> resultParams = Processors.getResultInfo(processName, null);
        org.opengis.parameter.Parameter result = resultParams.values().iterator().next();
        functionName = new FunctionNameImpl(name, result, inputParams);
    }

