    /**
     * This method controls the construction of line segments that border regions of uniform data
     * in the raster. See the {@linkplain #nbrConfig} method for more details.
     *
     * @param row index of the image row in the top left cell of the 2x2 data window
     * @param col index of the image col in the top left cell of the 2x2 data window
     * @param curData values in the current data window
     */
    private void updateCoordList(int row, int col, double[] curData) {
        LineSegment seg;

        switch (nbrConfig(curData)) {
        case 0:
            // vertical line continuing
            // nothing to do
            break;

        case 1:
            // bottom right corner
            // new horizontal and vertical lines
            horizLine = new LineSegment();
            horizLine.p0.x = col;

            seg = new LineSegment();
            seg.p0.y = row;
            vertLines.put(col, seg);
            break;

        case 2:
            // horizontal line continuing
            // nothing to do
            break;

        case 3:
            // bottom left corner
            // end of horizontal line; start of new vertical line
            horizLine.p1.x = col;
            addHorizLine(row);
            horizLine = null;

            seg = new LineSegment();
            seg.p0.y = row;
            vertLines.put(col, seg);
            break;

        case 4:
            // top left corner
            // end of horizontal line; end of vertical line
            horizLine.p1.x = col;
            addHorizLine(row);
            horizLine = null;

            seg = vertLines.get(col);
            seg.p1.y = row;
            addVertLine(col);
            vertLines.remove(col);
            break;

        case 5:
            // top right corner
            // start horiztonal line; end vertical line
            horizLine = new LineSegment();
            horizLine.p0.x = col;

            seg = vertLines.get(col);
            seg.p1.y = row;
            addVertLine(col);
            vertLines.remove(col);
            break;

        case 6:
            // inverted T in upper half
            // end horiztonal line; start new horizontal line; end vertical line
            horizLine.p1.x = col;
            addHorizLine(row);

            horizLine.p0.x = col;

            seg = vertLines.get(col);
            seg.p1.y = row;
            addVertLine(col);
            vertLines.remove(col);
            break;

        case 7:
            // T in lower half
            // end horizontal line; start new horizontal line; start new vertical line
            horizLine.p1.x = col;
            addHorizLine(row);

            horizLine.p0.x = col;

            seg = new LineSegment();
            seg.p0.y = row;
            vertLines.put(col, seg);
            break;

        case 8:
            // T pointing left
            // end horizontal line; end vertical line; start new vertical line
            horizLine.p1.x = col;
            addHorizLine(row);
            horizLine = null;

            seg = vertLines.get(col);
            seg.p1.y = row;
            addVertLine(col);

            seg = new LineSegment();
            seg.p0.y = row;
            vertLines.put(col, seg);
            break;

        case 9:
            // T pointing right
            // start new horizontal line; end vertical line; start new vertical line
            horizLine = new LineSegment();
            horizLine.p0.x = col;

            seg = vertLines.get(col);
            seg.p1.y = row;
            addVertLine(col);

            seg = new LineSegment();
            seg.p0.y = row;
            vertLines.put(col, seg);
            break;

        case 10:
            // cross
            // end horizontal line; start new horizontal line
            // end vertical line; start new vertical line
            horizLine.p1.x = col;
            addHorizLine(row);

            horizLine.p0.x = col;

            seg = vertLines.get(col);
            seg.p1.y = row;
            addVertLine(col);

            seg = new LineSegment();
            seg.p0.y = row;
            vertLines.put(col, seg);

            int z = -1;
            if (isDifferent(curData[TL], curData[BR])) {
                if (!isDifferent(curData[TR], curData[BL])) {
                    z = CROSS;
                }
            } else {
                if (isDifferent(curData[TR], curData[BL])) {
                    z = TL_BR;
                } else {
                    z = TR_BL;
                }
            }
            if (z != -1) {
                cornerTouches.add(new Coordinate(col, row, z));
            }
            break;

        case 11:
            // uniform
            // nothing to do
            break;
        }
    }

