    /**
     * Evaluates the process input expressions.
     * The object provides the context for evaluating the input expressions,
     * and may be null if no context is available
     * (for instance, when being called to evaluation the inputs
     * for the {@link RenderingProcessFunction} inversion methods).
     * 
     * @param object the object to evaluate the input expressions against.
     * @return the map of inputs
     */
	protected Map<String, Object> evaluateInputs(Object object) {
		// collect the entries
        Map<String, Object> processInputs = new HashMap<String, Object>();
        for (Expression input : inputExpressions) {
            Object result = input.evaluate(object, Map.class);
            if (result != null) {
                Map map = (Map) result;
                if (map.size() > 1) {
                    throw new InvalidParameterException("The parameters to a ProcessFunction "
                            + "must all be maps with a single entry, "
                            + "the key is the process argument name, "
                            + "the value is the argument value");
                } else {
                    // handle the key/value
                    Iterator it = map.entrySet().iterator();
                    Map.Entry<String, Object> entry = (Entry<String, Object>) it.next();
                    final String paramName = entry.getKey();
                    final Object paramValue = entry.getValue();

                    // see if we have a parameter with that name
                    Parameter param = parameters.get(paramName);
                    if (param == null) {
                        throw new InvalidParameterException("Parameter " + paramName
                                + " is not among the process parameters: " + parameters.keySet());
                    } else {
                        // if the value is not null, convert to the param target type and add
                        // to the process invocation params
                        if (paramValue != null) {
                            Object converted;
                            if(param.maxOccurs > 1) {
                                // converter will work if the have to convert the array type, but not if
                                // they have to deal with two conversions, from single to multi, from type to type
                                if(!(paramValue instanceof Collection) && !(paramValue.getClass().isArray())) {
                                    List<Object> collection = Collections.singletonList(paramValue);
                                    converted = Converters.convert(collection, Array.newInstance(param.type, 0).getClass());
                                } else {
                                    converted = Converters.convert(paramValue, Array.newInstance(param.type, 0).getClass()); 
                                }
                            } else {
                                converted = Converters.convert(paramValue, param.type);
                            }
                            if (converted == null) {
                                if(param.maxOccurs > 1 && Collection.class.isAssignableFrom(paramValue.getClass())) {
                                    final Collection collection = (Collection) paramValue;
                                    Collection convertedCollection = new ArrayList(collection.size());
                                    for (Object original : collection) {
                                        Object convertedItem = Converters.convert(original, param.type);
                                        if(original != null && convertedItem == null) {
                                            throw new InvalidParameterException("Could not convert the value "
                                                    + original + " into the expected type " + param.type
                                                    + " for parameter " + paramName);
                                        }
                                        convertedCollection.add(convertedItem);
                                    }
                                    Object array = Array.newInstance(param.type, convertedCollection.size());
                                    int i = 0;
                                    for (Object item : convertedCollection) {
                                        Array.set(array, i, item);
                                        i++;
                                    }
                                    converted = array;
                                } else {
                                    throw new InvalidParameterException("Could not convert the value "
                                            + paramValue + " into the expected type " + param.type
                                            + " for parameter " + paramName);
                                }
                            }
                            processInputs.put(paramName, converted);
                        }
                    }
                }
            }
        }
		return processInputs;
	}

