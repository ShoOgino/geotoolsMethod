	/**
	 * This method checks the {@link ColorModel} of the current image with the
	 * one of the first image in order to check if they are compatible or not in
	 * order to perform a mosaic operation.
	 * 
	 * <p>
	 * It is worth to point out that we also check if, in case we have two index
	 * color model image, we also try to suggest whether or not we should do a
	 * color expansion.
	 * 
	 * @param defaultCM
	 * @param defaultPalette
	 * @param actualCM
	 * @return a boolean asking to skip this feature.
	 */
	private boolean checkColorModels(ColorModel defaultCM,
			byte[][] defaultPalette, ColorModel actualCM) {

		// /////////////////////////////////////////////////////////////////////
		//
		//
		// ComponentColorModel
		//
		//
		// /////////////////////////////////////////////////////////////////////
		if (defaultCM instanceof ComponentColorModel
				&& actualCM instanceof ComponentColorModel) {
			final ComponentColorModel defCCM = (ComponentColorModel) defaultCM, actualCCM = (ComponentColorModel) actualCM;
			return !(defCCM.getNumColorComponents() == actualCCM
					.getNumColorComponents()
					&& defCCM.hasAlpha() == actualCCM.hasAlpha()
					&& defCCM.getColorSpace().equals(actualCCM.getColorSpace())
					&& defCCM.getTransparency() == actualCCM.getTransparency() && defCCM
					.getTransferType() == actualCCM.getTransferType());
		}
		// /////////////////////////////////////////////////////////////////////
		//
		//
		// IndexColorModel
		//
		//
		// /////////////////////////////////////////////////////////////////////
		if (defaultCM instanceof IndexColorModel
				&& actualCM instanceof IndexColorModel) {
			final IndexColorModel defICM = (IndexColorModel) defaultCM, actualICM = (IndexColorModel) actualCM;
			if (defICM.getNumColorComponents() != actualICM
					.getNumColorComponents()
					|| defICM.hasAlpha() != actualICM.hasAlpha()
					|| !defICM.getColorSpace()
							.equals(actualICM.getColorSpace())
					|| defICM.getTransferType() != actualICM.getTransferType())
				return true;
			// ///
			//
			// Suggesting expansion in the simplest case
			//
			// ///
			if (defICM.getMapSize() != actualICM.getMapSize()
					|| defICM.getTransparency() != actualICM.getTransparency()
					|| defICM.getTransferType() != actualICM.getTransferType()
					|| defICM.getTransparentPixel() != actualICM
							.getTransparentPixel()) {
				mustConvertToRGB = true;
				return false;
			}
			// //
			//
			// Now checking palettes to see if we need to do a color convert
			//
			// //
			// get the palette for this color model
			int numBands = actualICM.getNumColorComponents();
			byte[][] actualPalette = new byte[3][actualICM.getMapSize()];
			actualICM.getReds(actualPalette[0]);
			actualICM.getGreens(actualPalette[0]);
			actualICM.getBlues(actualPalette[0]);
			if (numBands == 4)
				actualICM.getAlphas(defaultPalette[0]);
			// compare them
			for (int i = 0; i < defICM.getMapSize(); i++)
				for (int j = 0; j < numBands; j++)
					if (actualPalette[j][i] != defaultPalette[j][i]) {
						mustConvertToRGB = true;
						break;
					}
			return false;

		}
		// //
		//
		// if we get here this means that the two color models where completely
		// different, hence skip this feature.
		//
		// //
		return true;
	}

