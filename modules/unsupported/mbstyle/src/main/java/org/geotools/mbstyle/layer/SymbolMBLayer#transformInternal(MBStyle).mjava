    /**
     * Transform {@link SymbolMBLayer} to GeoTools FeatureTypeStyle.
     * <p>
     * Notes:
     * </p>
     * <ul>
     * </ul>
     *
     * @param styleContext The MBStyle to which this layer belongs, used as a context for things like resolving sprite and glyph names to full urls.
     * @return FeatureTypeStyle
     */
    public List<FeatureTypeStyle> transformInternal(MBStyle styleContext) {

        MBStyleTransformer transformer = new MBStyleTransformer(parse);
        StyleBuilder sb = new StyleBuilder();
        List<Symbolizer> symbolizers = new ArrayList<Symbolizer>();

        LabelPlacement labelPlacement;

        // Create point or line placement

        // Functions not yet supported for symbolPlacement, so try to evaluate or use default.
        String symbolPlacementVal = transformer.requireLiteral(symbolPlacement(), String.class, "point", "symbol-placement", getId());

        if ("point".equalsIgnoreCase(symbolPlacementVal.trim())) {
            // Point Placement (default)
            PointPlacement pointP = sb.createPointPlacement();
            // Set anchor point (translated by text-translate)
            // GeoTools AnchorPoint doesn't seem to have an effect on PointPlacement
            pointP.setAnchorPoint(anchorPoint());

            // MapBox text-offset: +y means down
            Displacement textTranslate = textTranslateDisplacement();
            textTranslate.setDisplacementY(ff.multiply(ff.literal(-1), textTranslate.getDisplacementY()));
            pointP.setDisplacement(textTranslate);

            pointP.setRotation(textRotate());

            labelPlacement = pointP;
        } else {
            // Line Placement

            LinePlacement lineP = sb.createLinePlacement(null);
            lineP.setRepeated(true);

            // pixels (geotools) vs ems (mapbox) for text-offset
            lineP.setPerpendicularOffset(
                    ff.multiply(ff.literal(-1), textOffsetDisplacement().getDisplacementY()));

            labelPlacement = lineP;
        }

        Halo halo = sf.halo(sf.fill(null, textHaloColor(), null), textHaloWidth());
        Fill fill = sf.fill(null, textColor(), textOpacity());


        Font font = sb.createFont(ff.literal(""), ff.literal("normal"), ff.literal("normal"), textSize());
        if (getTextFont() != null) {
            font.getFamily().clear();
            for (String textFont : getTextFont()) {
                font.getFamily().add(ff.literal(textFont));
            }
        }


        // If the textField is a literal string (not a function), then
        // we need to support Mapbox token replacement.
        Expression textExpression = textField();
        if (textExpression instanceof Literal) {
            String text = textExpression.evaluate(null, String.class);
            if (text.trim().isEmpty()) {
                textExpression = ff.literal(" ");
            } else {
                textExpression = transformer.cqlExpressionFromTokens(text);
            }
        }
        
        textExpression = ff.function("StringTransform", textExpression, textTransform());

        TextSymbolizer2 symbolizer = (TextSymbolizer2) sf.textSymbolizer(getId(),
                ff.property((String) null), sf.description(Text.text("text"), null), NonSI.PIXEL,
                textExpression, font, labelPlacement, halo, fill);

        Number symbolSpacing = transformer.requireLiteral(symbolSpacing(), Number.class, 250,
                "symbol-spacing", getId());
        symbolizer.getOptions().put("repeat", String.valueOf(symbolSpacing));

        // text max angle
        // layer.getTextMaxAngle();
        // symbolizer.getOptions().put("maxAngleDelta", "40");

        // conflictResolution
        // Mapbox allows text overlap and icon overlap separately. GeoTools only has conflictResolution.
        Boolean textAllowOverlap = transformer.requireLiteral(textAllowOverlap(), Boolean.class, false,
                "text-allow-overlap", getId());
        Boolean iconAllowOverlap = transformer.requireLiteral(iconAllowOverlap(), Boolean.class, false,
                "icon-allow-overlap", getId());

        symbolizer.getOptions().put("conflictResolution",
                String.valueOf(!(textAllowOverlap || iconAllowOverlap)));

        String textFitVal = transformer.requireLiteral(iconTextFit(), String.class, "none", "icon-text-fit", getId()).trim();
        if ("height".equalsIgnoreCase(textFitVal) || "width".equalsIgnoreCase(textFitVal)) {
            symbolizer.getOptions().put("graphic-resize",
                    "stretch");
        } else if ("both".equalsIgnoreCase(textFitVal)) {
            symbolizer.getOptions().put("graphic-resize",
                    "proportional");
        } else {
            // Default
            symbolizer.getOptions().put("graphic-resize",
                    "none");
        }

        //Mapbox allows you to sapecify an array of values, one for each side
        if (getIconTextFitPadding() != null && !getIconTextFitPadding().isEmpty()) {
            symbolizer.getOptions().put("graphic-margin",
                    String.valueOf(getIconTextFitPadding().get(0)));
        } else {
            symbolizer.getOptions().put("graphic-margin", "0");
        }

        // halo blur
        // layer.textHaloBlur();

        // auto wrap
        // getTextSize defaults to 16, and getTextMaxWidth defaults to 10 
        // converts text-max-width(mbstyle) from ems to pixels for autoWrap(sld)
        symbolizer.getOptions().put("autoWrap", String.valueOf(getTextMaxWidth().intValue() * getTextSize().intValue())); 

        // If the layer has an icon image, add it to our symbolizer
        if (hasIconImage()) {

            // If the iconImage is a literal string (not a function), then
            // we need to support Mapbox token replacement.
            // Note: the URL is expected to be a CQL STRING ...
            Expression iconExpression = iconImage();
            if (iconExpression instanceof Literal) {
                iconExpression = transformer.cqlExpressionFromTokens(iconExpression.evaluate(null, String.class));
            }
            
            ExternalGraphic eg = transformer.createExternalGraphicForSprite(iconExpression, iconSize(), styleContext);            
            // layer.iconSize() - MapBox uses multiplier, GeoTools uses pixels
            Graphic g = sf.graphic(Arrays.asList(eg), iconOpacity(), null,
                    iconRotate(), null, null);
            Displacement d = iconOffsetDisplacement();
            d.setDisplacementY(d.getDisplacementY());
            g.setDisplacement(d);
            symbolizer.setGraphic(g);
        }

        symbolizers.add(symbolizer);
        MBFilter filter = getFilter();

        // List of opengis rules here (needed for constructor)
        List<org.opengis.style.Rule> rules = new ArrayList<>();
        Rule rule = sf.rule(getId(), null, null, 0.0, Double.POSITIVE_INFINITY, symbolizers,
                filter.filter());
        rule.setLegendGraphic(new Graphic[0]);

        rules.add(rule);

        return Collections.singletonList(sf.featureTypeStyle(getId(),
                sf.description(Text.text("MBStyle " + getId()),
                        Text.text("Generated for " + getSourceLayer())),
                null, // (unused)
                Collections.emptySet(), filter.semanticTypeIdentifiers(), // we only expect this to be applied to polygons
                rules));
    }

