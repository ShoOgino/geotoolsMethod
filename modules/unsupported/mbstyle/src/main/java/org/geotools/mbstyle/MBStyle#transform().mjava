    /**
     * Transform MBStyle to a GeoTools StyledLayerDescriptor.
     *
     * @return StyledLayerDescriptor
     */
    public StyledLayerDescriptor transform() {
        StyleFactory sf = parse.getStyleFactory();
        StyledLayerDescriptor sld = sf.createStyledLayerDescriptor();


        List<MBLayer> layers = layers();
        if (layers.isEmpty()) {
            throw new MBFormatException("layers empty");
        }

        Map<String, NamedLayer> sourceLayers = new HashMap<>();
        for (MBLayer layer : layers) {
            Style style = sf.createStyle();
            MBObjectStops mbObjectStops = new MBObjectStops(layer);

            int layerMaxZoom = layer.getMaxZoom();
            int layerMinZoom = layer.getMinZoom();
            Double layerMinScaleDenominator = layerMaxZoom == Integer.MAX_VALUE ? null
                    : MBObjectStops.zoomLevelToScaleDenominator((long) Math.min(25, layerMaxZoom));
            Double layerMaxScaleDenominator = layerMinZoom == Integer.MIN_VALUE ? null
                    : MBObjectStops.zoomLevelToScaleDenominator((long) Math.max(-25, layerMinZoom));

            if (layer.visibility()) {
                List<FeatureTypeStyle> featureTypeStyle = null;
                // check for property and zoom functions, if true we will have a layer for each one that
                // becomes a feature type style.
                if (mbObjectStops.ls.zoomStops || mbObjectStops.ls.zoomPropertyStops) {
                    List<Long> stopLevels = mbObjectStops.stops;
                    int i = 0;
                    for (MBLayer l : mbObjectStops.layersForStop) {
                        long s = stopLevels.get(i);
                        long[] rangeForStopLevel = mbObjectStops.getRangeForStop(s, mbObjectStops.ranges);
                        Double maxScaleDenominator = MBObjectStops.zoomLevelToScaleDenominator(rangeForStopLevel[0]);
                        Double minScaleDenominator = null;
                        if (rangeForStopLevel[1] != -1) {
                            minScaleDenominator = MBObjectStops.zoomLevelToScaleDenominator(rangeForStopLevel[1]);
                        }

                        featureTypeStyle = l.transform(this, minScaleDenominator, maxScaleDenominator);
                        style.featureTypeStyles().addAll(featureTypeStyle);
                        i++;
                    }
                } else {
                    featureTypeStyle = layer.transform(this, layerMinScaleDenominator, layerMaxScaleDenominator);
                    style.featureTypeStyles().addAll(featureTypeStyle);
                }
            }

            if( !style.featureTypeStyles().isEmpty() ) {

                if (layer instanceof BackgroundMBLayer) {
                    //Background does not use a source; construct a user later with a world extent inline feature
                    //so that we still have a valid SLD.
                    UserLayer userLayer = sf.createUserLayer();

                    final SimpleFeatureTypeBuilder ftb = new SimpleFeatureTypeBuilder();
                    final PrecisionModel pm = new PrecisionModel(PrecisionModel.FLOATING);
                    final GeometryFactory jtsFactory = new GeometryFactory(pm, 4326);

                    //must include a geometry so that the layer is rendered
                    try {
                        CoordinateReferenceSystem crs = CRS.decode("EPSG:4326");

                        ftb.add("geometry", com.vividsolutions.jts.geom.Polygon.class, crs);
                        ftb.setCRS(crs);
                        ftb.setDefaultGeometry("geometry");
                        ftb.setName("background");
                        SimpleFeatureType featureType = ftb.buildFeatureType();

                        final DefaultFeatureCollection fc = new DefaultFeatureCollection();
                        fc.add(SimpleFeatureBuilder.build(
                                featureType,
                                new Object[] {jtsFactory.toGeometry(new ReferencedEnvelope(CRS.getEnvelope(crs)))},
                                "background"));

                        userLayer.setInlineFeatureType(featureType);
                        userLayer.setInlineFeatureDatastore(DataUtilities.dataStore(fc));
                        userLayer.setName("background");

                        userLayer.userStyles().add(style);
                        sld.layers().add(userLayer);
                    } catch (FactoryException e) {
                        throw new MBFormatException("Error constructing background layer", e);
                    }
                } else {
                    String sourceLayer = layer.getSourceLayer();
                    if (sourceLayer == null) {
                        //If source-layer is not set, assume the source just has one layer which shares its name
                        sourceLayer = layer.getSource();
                    }
                    //Add all styles with the same source-layer to the same NamedLayer
                    NamedLayer namedLayer = sourceLayers.get(sourceLayer);
                    if (namedLayer == null) {
                        namedLayer = sf.createNamedLayer();
                        namedLayer.setName(sourceLayer);
                        //TODO: When NamedLayer supports description, use layer.getId() for description

                        sourceLayers.put(sourceLayer, namedLayer);
                        sld.layers().add(namedLayer);
                    }
                    namedLayer.styles().add(style);
                }
            }
        }

        if (sld.layers().isEmpty()) {
            throw new MBFormatException("No visibile layers");
        }


        sld.setName(getName());
        return sld;
    }

