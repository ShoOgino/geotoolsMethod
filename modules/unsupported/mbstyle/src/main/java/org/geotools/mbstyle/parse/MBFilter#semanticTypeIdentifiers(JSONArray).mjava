    /**
     * Utility method to convert json to set of {@link SemanticType}.
     *
     * <p>This method recursively calls itself to handle all and any operators.
     *
     * @param array JSON array defining filter
     * @return SemanticTypes from provided json, may be nested
     */
    Set<SemanticType> semanticTypeIdentifiers(JSONArray array) {
        if (array == null || array.isEmpty()) {
            throw new MBFormatException("MBFilter expected");
        }
        String operator = parse.get(array, 0);
        if (("==".equals(operator)
                        || "!=".equals(operator)
                        || "in".equals(operator)
                        || "!in".equals(operator))
                && "$type".equals(parse.get(array, 1))) {

            if ("in".equals(operator) || "==".equals(operator)) {
                Set<SemanticType> semanticTypes = new HashSet<>();
                List<?> types = array.subList(2, array.size());
                for (Object type : types) {
                    if (type instanceof String) {
                        String jsonText = (String) type;
                        SemanticType semanticType = translateSemanticType(jsonText);
                        semanticTypes.add(semanticType);
                    } else {
                        throw new MBFormatException(
                                "[\"in\",\"$type\", ...] limited to Point, LineString, Polygon: "
                                        + type);
                    }
                }
                if ("==".equals(operator) && types.size() != 1) {
                    throw new MBFormatException(
                            "[\"==\",\"$type\", ...] limited one geometry type, to test more than one use \"in\" operator.");
                }
                return semanticTypes;
            } else if ("!in".equals(operator) || "!=".equals(operator)) {
                Set<SemanticType> semanticTypes =
                        new HashSet<>(Arrays.asList(SemanticType.values()));
                List<?> types = array.subList(2, array.size());
                for (Object type : types) {
                    if (type instanceof String) {
                        String jsonText = (String) type;
                        SemanticType semanticType = translateSemanticType(jsonText);
                        semanticTypes.remove(semanticType);
                    } else {
                        throw new MBFormatException(
                                "[\"!in\",\"$type\", ...] limited to Point, LineString, Polygon: "
                                        + type);
                    }
                }
                if ("!=".equals(operator) && types.size() != 1) {
                    throw new MBFormatException(
                            "[\"!=\",\"$type\", ...] limited one geometry type, to test more than one use \"!in\" operator.");
                }
                return semanticTypes;
            }
        }

        if ("all".equals(operator)) {
            Set<SemanticType> semanticTypes = new HashSet<>();
            for (int i = 1; i < json.size(); i++) {
                JSONArray alternative = (JSONArray) json.get(i);
                Set<SemanticType> types = semanticTypeIdentifiers(alternative);
                if (types.isEmpty()) {
                    continue;
                } else {
                    if (semanticTypes.isEmpty()) {
                        // exactly one alternative is okay
                        semanticTypes.addAll(types);
                    } else {
                        throw new MBFormatException(
                                "Only one \"all\" alternative may be a $type filter");
                    }
                }
            }
            return semanticTypes;
        } else if ("any".equals(operator)) {
            Set<SemanticType> semanticTypes = new HashSet<>();
            for (int i = 1; i < json.size(); i++) {
                Set<SemanticType> types = semanticTypeIdentifiers((JSONArray) json.get(i));
                semanticTypes.addAll(types);
            }
            return semanticTypes;
        } else if ("none".equals(operator)) {
            Set<SemanticType> semanticTypes = new HashSet<>(Arrays.asList(SemanticType.values()));
            for (int i = 1; i < json.size(); i++) {
                Set<SemanticType> types = semanticTypeIdentifiers((JSONArray) json.get(i));
                semanticTypes.removeAll(types);
            }
            return semanticTypes;
        }
        return Collections.emptySet();
    }

