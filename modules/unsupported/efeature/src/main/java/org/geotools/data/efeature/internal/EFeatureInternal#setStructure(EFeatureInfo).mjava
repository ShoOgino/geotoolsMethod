    public boolean setStructure(EFeatureInfo eNewStructure) {
        //
        // Do sanity checks
        //
        if (eNewStructure == null) {
            throw new NullPointerException("EFeatureInfo structure can not be null");
        }
        //
        // Calculate change
        //
        boolean bFlag = this.eStructure != eNewStructure;
        //
        // Is changed
        //
        if (bFlag) {
            //
            // Cache reference to old structure
            //
            EFeatureInfo eOldStructure = this.eStructure;
            //
            // ------------------------------------------------------
            //  Validate implementation against structure?
            // ------------------------------------------------------
            //  This is an optimization exploiting the fact that
            //  structures are immutable once created, and that
            //  each structure can thus be uniquely identified
            //  by a unique ID. It is therefore only required to
            //  validate this implementation against each unique
            //  structure once.
            //
            if (!eNewStructure.eEqualTo(eOldStructure)) {
                validate(eNewStructure, eImpl());
            }
            //
            // Is valid, initialize this instance
            //
            this.eStructure = eNewStructure;
            //
            // Reset id information, forcing ID holder checks
            //
            eInitID();
            //
            // Reset property collections
            //
            this.eProperties = null;
            this.ePropertyMap = null;
            //
            // Tell listeners in old structure about the change?
            //
            if (eOldStructure != null) {
                eOldStructure.eNotify(
                        this, EFeaturePackage.EFEATURE__STRUCTURE, eOldStructure, eNewStructure);
            }
        }
        //
        // Finished
        //
        return bFlag;
    }

