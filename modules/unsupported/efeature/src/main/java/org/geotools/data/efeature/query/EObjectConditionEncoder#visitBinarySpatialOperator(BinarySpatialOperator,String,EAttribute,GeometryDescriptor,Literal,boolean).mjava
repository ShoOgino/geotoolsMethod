    /**
     * Common implementation for {@link BinarySpatialOperator binary spatial operator} filters. This
     * way they're all handled centrally.
     *
     * <p>This method extracts property name, geometry literal and descriptor and evaluates if
     * property name and geometry literal arguments are swapped.
     *
     * @param filter - the binary spatial operator statement
     * @param name - operator name
     * @param property - property name expression
     * @param geometry - geometry literal expression
     * @param swapped - true if geometry literal is left expression (first)
     * @param eAttribute - EAttribute instance
     * @param descriptor - geometry descriptor
     * @return a {@link Condition} instance
     * @throws RuntimeException - if one or more expressions are not supported
     */
    protected Condition visitBinarySpatialOperator(
            BinarySpatialOperator filter,
            String name,
            EAttribute eAttribute,
            GeometryDescriptor descriptor,
            Literal geometry,
            boolean swapped) {
        try {
            if (BBOX.NAME.equals(name)) {
                return new EGeometryValueBBox(eAttribute, geometry, swapped);
            } else if (Beyond.NAME.equals(name)) {
                double distance = convert((Beyond) filter, descriptor);
                return new EGeometryValueBeyond(eAttribute, geometry, distance);
            } else if (DWithin.NAME.equals(name)) {
                double distance = convert((DWithin) filter, descriptor);
                return new EGeometryValueDWithin(eAttribute, geometry, distance);
            } else if (Contains.NAME.equals(name)) {
                return new EGeometryValueContains(eAttribute, geometry, swapped);
            } else if (Crosses.NAME.equals(name)) {
                return new EGeometryValueCrosses(eAttribute, geometry, swapped);
            } else if (Disjoint.NAME.equals(name)) {
                return new EGeometryValueDisjoint(eAttribute, geometry, swapped);
            } else if (Equals.NAME.equals(name)) {
                return new EGeometryValueEquals(eAttribute, geometry, swapped);
            } else if (Intersects.NAME.equals(name)) {
                return new EGeometryValueIntersects(eAttribute, geometry, swapped);
            } else if (Overlaps.NAME.equals(name)) {
                return new EGeometryValueOverlaps(eAttribute, geometry, swapped);
            } else if (Touches.NAME.equals(name)) {
                return new EGeometryValueTouches(eAttribute, geometry, swapped);
            } else if (Within.NAME.equals(name)) {
                return new EGeometryValueWithin(eAttribute, geometry, swapped);
            }
        } catch (Exception e) {
            throw new RuntimeException("Spatial operation " + name + " is not supported", e);
        }

        // Not supported, throw exception
        //
        throw new IllegalArgumentException("Spatial operation " + name + " is not supported");
    }

