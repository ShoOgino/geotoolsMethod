    /**
     * Ensure that ID is unique. If not, return one that is.
     *
     * <p>This method used the {@link #eInverseIDMap} to ensure that the next ID is is unique
     *
     * @param eImpl - {@link EObject} instance
     * @param eImpl - the object with ID
     * @param uID - proposed ID
     * @return actual unique ID
     */
    protected Long eUniqueID(URI eURI, EObject eImpl, Long uID) {
        //
        // Get Map of cached ID for given URI
        //
        Map<EObject, Long> eCachedIDs = eInverseIDMap.get(eURI);
        //
        // Found cached IDs?
        //
        if (eCachedIDs != null) {
            //
            // Check if an equal ID value is already cached for given object
            //
            if (uID.equals(eCachedIDs.get(eImpl))) return uID;
            //
            // Initialize upper bounds for safe exit
            //
            int size = eCachedIDs.size();
            int count = 0;
            //
            // Continue until unique is found or end of map reached
            //
            while (eCachedIDs.containsValue(uID) && count < size) {
                uID++;
                count++;
            }
        }
        //
        // Finished
        //
        return uID;
    }

