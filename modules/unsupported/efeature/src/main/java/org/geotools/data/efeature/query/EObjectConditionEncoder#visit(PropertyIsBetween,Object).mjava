    /**
     * Create EMF query compatible {@link EAttributeValueIsBetween BETWEEN condition} from given
     * {@link PropertyIsBetween BETWEEN filter} and push it to {@link EObjectCondition} stack.
     *
     * <p>Literal values {@link Number}, {@link java.util.Date} and {@link String} are supported.
     * Any other {@link Literal} value will throw an {@link RuntimeException}.
     *
     * @param filter - the {@link Filter} instance to be visited
     * @param extraData - not in use
     * @return a {@link EAttributeValueIsBetween} instance
     * @throws RuntimeException If one or more expressions are not supported
     */
    @Override
    public EAttributeValueIsBetween visit(PropertyIsBetween filter, Object extraData)
            throws RuntimeException {
        //
        // Get all expressions
        //
        Expression expr = filter.getExpression();
        Expression lowerbounds = filter.getLowerBoundary();
        Expression upperbounds = filter.getUpperBoundary();
        //
        // Get expression data type
        //
        Class<?> type;
        AttributeDescriptor attType = (AttributeDescriptor) expr.evaluate(featureType);
        if (attType != null) {
            type = attType.getType().getBinding();
        } else {
            //
            // Assume it's a string
            //
            type = String.class;
        }
        //
        // Check if type is not supported
        //
        if (!DataTypes.supports(type)) {
            throw new RuntimeException("Type " + type + " not supported.");
        }
        //
        // For each expression in filter:
        // 1) Build expression recursively and put onto expression stack
        // 2) Cast expression result to expected type
        //
        expr.accept(this, false);
        PropertyName name =
                toType(
                        eExpressionStack.pop(),
                        PropertyName.class,
                        "PropertyIsBetween expression is not a PropertyName");
        lowerbounds.accept(this, type);
        Literal lower =
                toLiteral(
                        eExpressionStack.pop(),
                        "PropertyIsBetween lower bound expression is not a Literal");
        upperbounds.accept(this, type);
        Literal upper =
                toLiteral(
                        eExpressionStack.pop(),
                        "PropertyIsBetween upper bound expression is not a Literal");
        //
        // Get EAttribute instance from definition
        //
        EAttribute eAttribute = eFeatureInfo.eGetAttribute(name.getPropertyName());
        //
        // Found attribute?
        //
        if (eAttribute == null) {
            throw new IllegalArgumentException(
                    "EAttribute " + name.getPropertyName() + " not found");
        }

        try {
            //
            // Create EObjectCondition instance and push it to condition stack
            //
            EAttributeValueIsBetween eCondition =
                    new EAttributeValueIsBetween(eAttribute, lower, upper);
            //
            // Push to stack
            //
            eConditionStack.push(eCondition);
            //
            // Finished
            //
            return eCondition;

        } catch (EFeatureEncoderException e) {
            throw new RuntimeException("Failed to create BETWEEN condition", e);
        }
    }

