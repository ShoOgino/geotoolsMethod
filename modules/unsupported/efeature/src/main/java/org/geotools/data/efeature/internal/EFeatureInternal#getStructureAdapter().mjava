    /**
     * Cached {@link Adapter} which monitors changes made to the {@link EObject} instance this
     * delegates to.
     * <p>
     * On each change, this adapter determines if any data cached by this instance should be
     * invalidated. The following conditions invoke invalidation of data:
     * <ol>
     * <li>{@link #bounds} is invalidated after a {@link #getValue() geometry} change</li>
     * </ol>
     * 
     * @return a lazily cached {@link EStructuralFeature} instance.
     */
    protected EFeatureListener<EStructureInfo<?>> getStructureAdapter() {
        if (eStructurelistener == null || eStructurelistener.get() == null) {
            eStructurelistener = new WeakReference<EFeatureListener<EStructureInfo<?>>>(
                    new EFeatureListener<EStructureInfo<?>>() {

                        public boolean onChange(EStructureInfo<?> eInfo, int property, Object oldValue,
                                Object newValue) {
                            if (property == EFeatureInfo.SRID) {
                                // Current bounds have wrong CRS.
                                // This forces current bounds
                                // to be recalculated on next call
                                // to getData().getBounds()
                                //
                                bounds = null;

                                // Notify
                                //
                                if (eImpl().eNotificationRequired()) {
                                    eImpl().eNotify(
                                            new ENotificationImpl(eImpl(), Notification.SET,
                                                    EFeaturePackage.EFEATURE__SRID, oldValue,
                                                    newValue));
                                }
                            }
                            return true;
                        }

                    });
        }
        return eStructurelistener.get();
    }

