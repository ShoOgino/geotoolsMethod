    /**
     * Common implementation for {@link BinaryLogicOperator binary logic operator} filters. This way
     * they're all handled centrally.
     * <p>
     * This method iterate over all filter children, concatenating them into a single EMF Query
     * {@link Condition logical operator condition} and push it to {@link EObjectCondition} stack.
     * <p>
     * Only {@link Not NOT}, {@link Condition#OR(Condition) OR} and {@link Condition#OR(Condition)
     * AND} operator filters are supported. Any other {@link BinaryLogicOperator binary logic
     * operator} filter instance will throw a {@link RuntimeException}.
     * </p>
     * 
     * @param filter - the logic statement.
     * @param extraData - extra filter data. Not modified directly by this method.
     * 
     * @return a {@link Condition} instance
     * 
     * @throws RuntimeException If one or more expressions are not supported
     * 
     */
    protected Condition visit(BinaryLogicOperator filter, Object extraData) {

        // Initialize
        //
        Condition eCondition = null;

        // Get name logic operator
        //
        String operator = ((String) extraData).toUpperCase();

        // Get filter iterator
        //
        Iterator<Filter> list = filter.getChildren().iterator();

        // Is inverse operator?
        //
        if (filter instanceof org.opengis.filter.Not) {

            // Build filter recursively and put onto condition stack
            //
            list.next().accept(this, extraData);

            // Invert condition
            //
            eCondition = new Not(eConditionStack.pop());

        } else if ("OR".equals(operator)) {
            while (list.hasNext()) {

                // Build filter recursively and put onto condition stack
                //
                list.next().accept(this, extraData);

                // Initialize?
                //
                if (eCondition == null) {
                    eCondition = eConditionStack.pop();
                } else {
                    eCondition = eCondition.OR(eConditionStack.pop());
                }

            }
        } else if ("AND".equals(operator)) {
            while (list.hasNext()) {

                // Build filter recursively and put onto condition stack
                //
                list.next().accept(this, extraData);

                // Initialize?
                //
                if (eCondition == null) {
                    eCondition = eConditionStack.pop();
                } else {
                    eCondition = eCondition.AND(eConditionStack.pop());
                }

            }
        } else {
            throw new RuntimeException("Binary logical " + "operator " + operator
                    + " filter not supported");
        }

        // No condition created?
        //
        if (eCondition == null) {
            throw new NullPointerException("Binary logical " + "operator " + operator
                    + " filter not supported");
        }

        // Push concatenated condition to stack
        //
        eConditionStack.push(eCondition);

        // Finished
        //
        return eCondition;
    }

