    /**
     * Common implementation for {@link BinaryLogicOperator binary logic operator} filters. This way
     * they're all handled centrally.
     *
     * <p>This method iterate over all filter children, concatenating them into a single EMF Query
     * {@link Condition logical operator condition} and push it to {@link EObjectCondition} stack.
     *
     * <p>Only {@link Not NOT}, {@link Condition#OR(Condition) OR} and {@link
     * Condition#OR(Condition) AND} operator filters are supported. Any other {@link
     * BinaryLogicOperator binary logic operator} filter instance will throw a {@link
     * RuntimeException}.
     *
     * @param filter - the logic statement.
     * @param extraData - extra filter data. Not modified directly by this method.
     * @return a {@link Condition} instance
     * @throws RuntimeException If one or more expressions are not supported
     */
    protected Condition visit(BinaryLogicOperator filter, Object extraData) {

        // Initialize
        //
        Condition eCondition = null;

        // Get name logic operator
        //
        String operator = ((String) extraData).toUpperCase();

        // Get filter iterator
        //
        Iterator<Filter> list = filter.getChildren().iterator();

        // Is inverse operator?
        //
        if ("OR".equals(operator)) {
            while (list.hasNext()) {

                // Build filter recursively and put onto condition stack
                //
                list.next().accept(this, extraData);

                // Initialize?
                //
                if (eCondition == null) {
                    eCondition = eConditionStack.pop();
                } else {
                    eCondition = eCondition.OR(eConditionStack.pop());
                }
            }
        } else if ("AND".equals(operator)) {
            while (list.hasNext()) {

                // Build filter recursively and put onto condition stack
                //
                list.next().accept(this, extraData);

                // Initialize?
                //
                if (eCondition == null) {
                    eCondition = eConditionStack.pop();
                } else {
                    eCondition = eCondition.AND(eConditionStack.pop());
                }
            }
        } else {
            throw new RuntimeException(
                    "Binary logical " + "operator " + operator + " filter not supported");
        }

        // No condition created?
        //
        if (eCondition == null) {
            throw new NullPointerException(
                    "Binary logical " + "operator " + operator + " filter not supported");
        }

        // Push concatenated condition to stack
        //
        eConditionStack.push(eCondition);

        // Finished
        //
        return eCondition;
    }

