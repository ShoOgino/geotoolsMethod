    /**
     * Ensure that ID is unique. If not, return one that is.
     * <p>
     * This method used the {@link #eCachedIDMap} to ensure that 
     * the next ID is is unique
     * @param eObject - {@link EObject} instance
     * @param uID - proposed ID
     * @param eObject - the object with ID 
     * @return actual unique ID
     */
    protected Long uniqueID(URI eURI, EObject eObject, Long uID) {
        //
        // Get Map of cached ID for given URI
        //
        Map<EObject,Long> eCachedIDs = eCachedIDMap.get(eURI);        
        //
        // Found cached IDs?
        //
        if(eCachedIDs!=null) {            
            //
            // Check if an equal ID value is already cached for given object
            //
            if(uID.equals(eCachedIDs.get(eObject))) 
                return uID;
            //
            // Initialize upper bounds for safe exit
            //
            int size = eCachedIDs.size();
            int count = 0;
            // 
            // Continue until unique is found or end of map reached
            //
            while(eCachedIDs.containsValue(uID) && count<size) {
                uID++;
                count++;
            }
        }
        //
        // Finished
        //
        return uID;
    }

