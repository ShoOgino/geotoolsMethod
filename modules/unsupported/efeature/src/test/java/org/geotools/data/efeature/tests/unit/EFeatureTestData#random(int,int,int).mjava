    /**
     * Initialize resource by adding given amount of data into it.
     *
     * <p>If already initialized, this does nothing.
     *
     * <p>
     *
     * @param ncount - number of {@link NonGeoEObject} instances
     * @param fcount - number of {@link EFeatureData} instances
     * @param ccount - number of {@link EFeatureCompatibleData} instances
     * @throws Exception If initialization fails for some reason
     */
    public void random(int ncount, int fcount, int ccount) throws Exception {
        //
        // Only initialize once
        //
        if (!isInit) {
            //
            // Add given amount of NonGeoEObject instances
            //
            addNonGeoEObjects(ncount);
            //
            // Calculate number object with geometry data
            //
            int gcount = fcount + ccount;
            //
            // Add objects with geometry data?
            //
            if (gcount > 0) {
                //
                // Get numeric attribute data types
                //
                List<Class<Number>> aTypes = DataTypes.getSubTypes(Number.class);
                //
                // Get number of numeric attribute data types
                //
                int acount = aTypes.size();
                //
                // Calculate number of attribute values per numeric type
                //
                int tcount = (int) Math.ceil((double) gcount / (double) acount);
                //
                // Prepare attribute generating data
                //
                int i = 0;
                int n = Math.min(tcount, gcount);
                int count = n;
                //
                // Generate random numeric data
                //
                Number[] attributes = new Number[0];
                while (i < acount && count <= gcount) {
                    Class<Number> type = aTypes.get(i);
                    Number nmin = DataTypes.getMinValue(type);
                    Number nmax = DataTypes.getMaxValue(type);
                    attributes = attributes(Number.class, type, attributes, n, nmin, nmax);
                    count += (n = Math.min(tcount, gcount - count));
                    i++;
                }
                //
                // Calculate geometry values per unique type
                //
                tcount = (int) Math.ceil(gcount / 3.0);
                //
                // Prepare geometry data for EFeatureData instances
                //
                i = 0;
                count = (n = Math.min(tcount, gcount));
                //
                // Generate random geometry data
                //
                Geometry[] geometries =
                        geometries(null, Geometry.class, generatePointWKTs(n, 0, 20));
                count += (n = Math.min(tcount, gcount - count));
                if (count <= gcount) {
                    geometries =
                            geometries(
                                    geometries,
                                    Geometry.class,
                                    generateLineStringWKTs(n, 0, 20, 1, 5));
                    count += (n = Math.min(tcount, gcount - count));
                }
                if (count <= gcount) {
                    geometries =
                            geometries(
                                    geometries,
                                    Geometry.class,
                                    generatePolygonWKTs(n, 0, 20, 1, 5, 1, 10));
                }
                //
                // Add objects
                //
                addFeatureData(0, fcount, attributes, geometries);
                addFeatureCompatibleData(fcount, gcount, attributes, geometries);
            }
            //
            // Save counts
            //
            nonGeoEObjectCount = ncount;
            eFeatureDataCount = fcount;
            eFeatureCompatibleDataCount = ccount;
            //
            // Prevent future initializations
            //
            isInit = true;
        }
    }

