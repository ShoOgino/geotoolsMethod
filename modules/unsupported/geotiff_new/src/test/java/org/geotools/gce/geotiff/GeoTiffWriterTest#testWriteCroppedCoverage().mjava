    /**
     * Testing {@link GeoTiffWriter} capabilities to write a cropped coverage.
     *
     * @throws IllegalArgumentException
     * @throws IOException
     * @throws UnsupportedOperationException
     * @throws ParseException
     * @throws FactoryException
     * @throws TransformException
     */
    @Test
    @Ignore
    public void testWriteCroppedCoverage()
            throws IllegalArgumentException, IOException, UnsupportedOperationException,
                    ParseException, FactoryException, TransformException {

        // /////////////////////////////////////////////////////////////////////
        //
        //
        // READ
        //
        //
        // /////////////////////////////////////////////////////////////////////
        // /////////////////////////////////////////////////////////////////////
        //
        // Look for the original coverage that wew want to crop.
        //
        // /////////////////////////////////////////////////////////////////////
        final File readdir = TestData.file(GeoTiffWriterTest.class, "");
        final File writedir =
                new File(
                        new StringBuilder(readdir.getAbsolutePath())
                                .append("/testWriter/")
                                .toString());
        writedir.mkdir();
        final File tiff = new File(readdir, "latlon.tiff");
        assert tiff.exists() && tiff.canRead() && tiff.isFile();
        if (TestData.isInteractiveTest()) logger.info(tiff.getAbsolutePath());

        // /////////////////////////////////////////////////////////////////////
        //
        // Create format and reader
        //
        // /////////////////////////////////////////////////////////////////////
        final GeoTiffFormat format = new GeoTiffFormat();
        // getting a reader
        GridCoverageReader reader = format.getReader(tiff);
        assertNotNull(reader);

        // /////////////////////////////////////////////////////////////////////
        //
        // Read the original coverage.
        //
        // /////////////////////////////////////////////////////////////////////
        GridCoverage2D gc = (GridCoverage2D) reader.read(null);
        if (TestData.isInteractiveTest()) {
            logger.info(
                    new StringBuilder("Coverage before: ")
                            .append("\n")
                            .append(gc.getCoordinateReferenceSystem().toWKT())
                            .append(gc.getEnvelope().toString())
                            .toString());
        }
        final CoordinateReferenceSystem sourceCRS = gc.getCoordinateReferenceSystem2D();
        final GeneralEnvelope sourceEnvelope = (GeneralEnvelope) gc.getEnvelope();
        final GridGeometry2D sourcedGG = (GridGeometry2D) gc.getGridGeometry();
        final MathTransform sourceG2W = sourcedGG.getGridToCRS(PixelInCell.CELL_CENTER);

        // /////////////////////////////////////////////////////////////////////
        //
        //
        // CROP
        //
        //
        // /////////////////////////////////////////////////////////////////////

        // /////////////////////////////////////////////////////////////////////
        //
        // Crop the original coverage.
        //
        // /////////////////////////////////////////////////////////////////////
        double xc = sourceEnvelope.getMedian(0);
        double yc = sourceEnvelope.getMedian(1);
        double xl = sourceEnvelope.getSpan(0);
        double yl = sourceEnvelope.getSpan(1);
        final GeneralEnvelope cropEnvelope =
                new GeneralEnvelope(
                        new double[] {xc - xl / 4.0, yc - yl / 4.0},
                        new double[] {xc + xl / 4.0, yc + yl / 4.0});
        final CoverageProcessor processor = new CoverageProcessor();
        final ParameterValueGroup param = processor.getOperation("CoverageCrop").getParameters();
        param.parameter("Source").setValue(gc);
        param.parameter("Envelope").setValue(cropEnvelope);
        final GridCoverage2D cropped = (GridCoverage2D) processor.doOperation(param);

        // /////////////////////////////////////////////////////////////////////
        //
        // Check that we got everything correctly after the crop.
        //
        // /////////////////////////////////////////////////////////////////////
        // checking the ranges of the output image.
        final GridGeometry2D croppedGG = (GridGeometry2D) cropped.getGridGeometry();
        final GridEnvelope2D croppedGR = (GridEnvelope2D) croppedGG.getGridRange();
        final MathTransform croppedG2W = croppedGG.getGridToCRS(PixelInCell.CELL_CENTER);
        final GeneralEnvelope croppedEnvelope = (GeneralEnvelope) cropped.getEnvelope();
        assertTrue("min x do not match after crop", 29 == croppedGR.x);
        assertTrue("min y do not match after crop", 30 == croppedGR.y);
        assertTrue("max x do not match after crop", 90 == croppedGR.getMaxX());
        assertTrue("max y do not match after crop", 91 == croppedGR.getMaxY());
        // check that the affine transform are the same thing
        assertTrue(
                "The Grdi2World tranformations of the original and the cropped covearage do not match",
                sourceG2W.equals(croppedG2W));
        // check that the envelope is correct
        final GeneralEnvelope expectedEnvelope =
                new GeneralEnvelope(
                        croppedGR,
                        PixelInCell.CELL_CENTER,
                        croppedG2W,
                        cropped.getCoordinateReferenceSystem2D());
        assertTrue(
                "Expected envelope is different from the computed one",
                expectedEnvelope.equals(
                        croppedEnvelope,
                        XAffineTransform.getScale((AffineTransform) croppedG2W) / 2.0,
                        false));

        // /////////////////////////////////////////////////////////////////////
        //
        //
        // WRITING AND TESTING
        //
        //
        // /////////////////////////////////////////////////////////////////////
        final File writeFile =
                new File(
                        writedir.getAbsolutePath()
                                + File.separatorChar
                                + cropped.getName().toString()
                                + ".tiff");
        final GridCoverageWriter writer = format.getWriter(writeFile);
        // /////////////////////////////////////////////////////////////////////
        //
        // Create the writing params
        //
        // /////////////////////////////////////////////////////////////////////
        try {
            writer.write(cropped, null);
        } catch (IOException e) {
        } finally {
            try {
                writer.dispose();
            } catch (Throwable e) {
            }
        }

        // release things
        cropped.dispose(true);
        gc.dispose(true);
        if (reader != null) {
            try {

                reader.dispose();
            } catch (Throwable e) {
            }
        }

        try {
            reader = new GeoTiffReader(writeFile, null);
            assertNotNull(reader);
            gc = (GridCoverage2D) reader.read(null);
            assertNotNull(gc);
            final CoordinateReferenceSystem targetCRS = gc.getCoordinateReferenceSystem2D();
            assertTrue(
                    "Source and Target coordinate reference systems do not match",
                    CRS.equalsIgnoreMetadata(sourceCRS, targetCRS));
            assertEquals(
                    "Read-back and Cropped envelopes do not match",
                    cropped.getEnvelope(),
                    croppedEnvelope);

            if (TestData.isInteractiveTest()) {
                logger.info(
                        new StringBuilder("Coverage after: ")
                                .append("\n")
                                .append(gc.getCoordinateReferenceSystem().toWKT())
                                .append(gc.getEnvelope().toString())
                                .toString());
                gc.show();
            } else {
                gc.getRenderedImage().getData();
            }

        } finally {
            if (reader != null) {
                try {

                    reader.dispose();
                } catch (Throwable e) {
                }
            }
            if (!TestData.isInteractiveTest()) {
                gc.dispose(true);
            }
        }
    }

