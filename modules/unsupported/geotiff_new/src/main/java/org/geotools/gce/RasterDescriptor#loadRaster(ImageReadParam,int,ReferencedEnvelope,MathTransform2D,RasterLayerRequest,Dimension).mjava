    public RasterLoadingResult loadRaster(
            final ImageReadParam readParameters,
            final int overviewIndex,
            final ReferencedEnvelope cropBBox,
            final MathTransform2D requestedWorldToGrid,
            final RasterLayerRequest request,
            final Dimension tileDimension)
            throws IOException {

        if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
            LOGGER.fine("Loading raster data for RasterDescriptor " + this.toString());
        }
        ImageInputStream inStream = null;

        final ReferencedEnvelope bbox = new ReferencedEnvelope(rasterBBOX);
        // intersection of this tile bound with the current crop bbox
        final ReferencedEnvelope intersection =
                new ReferencedEnvelope(
                        bbox.intersection(cropBBox), cropBBox.getCoordinateReferenceSystem());

        ImageReader reader = null;
        try {
            //
            // get info about the raster we have to read
            //
            // get selected level and base level dimensions
            final RasterLevelDescriptor selectedlevel = levels.get(Integer.valueOf(overviewIndex));
            final Object input = selectedlevel.source.getSource();
            inStream =
                    selectedlevel
                            .source
                            .getInputStreamSPI()
                            .createInputStreamInstance(
                                    input, ImageIO.getUseCache(), ImageIO.getCacheDirectory());
            int imageChoice = selectedlevel.source.getImageIndex();

            if (inStream == null) {
                return null;
            }

            // get a reader
            reader = GeoTiffUtils.TIFFREADERFACTORY.createReaderInstance();
            reader.setInput(inStream);

            // now create the crop grid to world which can be used to decide
            // which sourceFile area we need to crop in the selected level taking
            // into account the scale factors imposed by the selection of this
            // level together with the base level grid to world transformation
            final MathTransform2D cropGridToWorldCorner =
                    (MathTransform2D)
                            ProjectiveTransform.create(selectedlevel.gridToWorldTransformCorner);
            final MathTransform2D cropWorldToGrid = cropGridToWorldCorner.inverse();

            // computing the crop sourceFile area which leaves straight into the
            // selected level raster space, NOTICE that at the end we need to
            // take into account the fact that we might also decimate therefore
            // we cannot just use the crop grid to world but we need to correct
            // it.
            final Rectangle sourceArea =
                    CRS.transform(cropWorldToGrid, new GeneralEnvelope(intersection))
                            .toRectangle2D()
                            .getBounds();
            XRectangle2D.intersect(
                    sourceArea, selectedlevel.rasterDimensions.getBounds(), sourceArea);
            // make sure roundings don't bother us

            // is it empty??
            if (sourceArea.isEmpty()) {
                if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                    LOGGER.warning(
                            "Got empty area for rasterGranuleLoader "
                                    + this.toString()
                                    + " with request "
                                    + request.toString());
                }
                return null;

            } else if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
                LOGGER.fine(
                        "Loading level " + overviewIndex + " with sourceFile region " + sourceArea);
            }
            // set the sourceFile region
            // readParameters.setSourceRegion(sourceAreaWithCollar);
            readParameters.setSourceRegion(sourceArea);

            // read
            // TODO make this generic
            RenderedImage raster =
                    request.getReadType()
                            .read(
                                    readParameters,
                                    imageChoice,
                                    (File) input,
                                    selectedlevel.rasterDimensions.getBounds(),
                                    tileDimension);
            if (raster == null) {
                return null;
            }
            try {
                raster.getWidth();
            } catch (Throwable e) {
                if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
                    LOGGER.log(
                            java.util.logging.Level.FINE,
                            "Unable to load raster for rasterGranuleLoader "
                                    + this.toString()
                                    + " with request "
                                    + request.toString(),
                            e);
                }
                return null;
            }

            // use fixed sourceFile area
            sourceArea.setRect(readParameters.getSourceRegion());

            //
            // setting new coefficients to define a new affineTransformation
            // to be applied to the grid to world transformation
            // -----------------------------------------------------------------------------------
            //
            // With respect to the original envelope, the obtained planarImage
            // needs to be rescaled. The scaling factors are computed as the
            // ratio between the cropped sourceFile region sizes and the read
            // image sizes.
            //
            // place it in the mosaic using the coords created above;
            double decimationScaleX = ((1.0 * sourceArea.width) / raster.getWidth());
            double decimationScaleY = ((1.0 * sourceArea.height) / raster.getHeight());
            final AffineTransform decimationScaleTranform =
                    XAffineTransform.getScaleInstance(decimationScaleX, decimationScaleY);

            // keep into account translation to work into the selected level
            // raster space
            final AffineTransform afterDecimationTranslateTranform =
                    XAffineTransform.getTranslateInstance(sourceArea.x, sourceArea.y);

            // now we need to go back to the base level raster space
            final AffineTransform backToBaseLevelScaleTransform =
                    selectedlevel.getBaseToLevelTransform();

            // now create the overall transform
            final AffineTransform finalRaster2Model = new AffineTransform(baseGridToWorld);
            finalRaster2Model.concatenate(CoverageUtilities.CENTER_TO_CORNER);

            if (!XAffineTransform.isIdentity(
                    backToBaseLevelScaleTransform, GeoTiffUtils.AFFINE_IDENTITY_EPS))
                finalRaster2Model.concatenate(backToBaseLevelScaleTransform);
            if (!XAffineTransform.isIdentity(
                    afterDecimationTranslateTranform, GeoTiffUtils.AFFINE_IDENTITY_EPS))
                finalRaster2Model.concatenate(afterDecimationTranslateTranform);
            if (!XAffineTransform.isIdentity(
                    decimationScaleTranform, GeoTiffUtils.AFFINE_IDENTITY_EPS))
                finalRaster2Model.concatenate(decimationScaleTranform);

            // return raster + its own transformation
            return new RasterLoadingResult(raster, finalRaster2Model);

        } catch (IllegalStateException e) {
            if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                LOGGER.log(
                        java.util.logging.Level.WARNING,
                        "Unable to load raster for rasterGranuleLoader "
                                + this.toString()
                                + " with request "
                                + request.toString(),
                        e);
            }
            return null;
        } catch (org.opengis.referencing.operation.NoninvertibleTransformException e) {
            if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                LOGGER.log(
                        java.util.logging.Level.WARNING,
                        "Unable to load raster for rasterGranuleLoader "
                                + this.toString()
                                + " with request "
                                + request.toString(),
                        e);
            }
            return null;
        } catch (TransformException e) {
            if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                LOGGER.log(
                        java.util.logging.Level.WARNING,
                        "Unable to load raster for rasterGranuleLoader "
                                + this.toString()
                                + " with request "
                                + request.toString(),
                        e);
            }
            return null;
        } finally {

            if (inStream != null) {
                try {
                    inStream.close();
                } catch (Throwable t) {

                }
            }
            if (reader != null) {
                try {
                    reader.dispose();
                } catch (Throwable t) {

                }
            }
        }
    }

