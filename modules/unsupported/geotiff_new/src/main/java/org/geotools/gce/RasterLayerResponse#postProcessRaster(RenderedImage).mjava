    private RenderedImage postProcessRaster(RenderedImage image) {
        // alpha on the final mosaic
        if (transparentColor != null) {

            //
            // TRANSPARENT COLOR MANAGEMENT
            //
            //
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Support for alpha on input image ");
            }
            return ImageUtilities.maskColor(transparentColor, image);
        }
        //        if (!needsReprojection){
        //            try {
        //
        //                // creating sourceFile grid to world corrected to the pixel corner
        //                final AffineTransform sourceGridToWorld = new
        // AffineTransform((AffineTransform) finalGridToWorldCorner);
        //
        //                // target world to grid at the corner
        //                final AffineTransform targetGridToWorld = new
        // AffineTransform(request.getRequestedGridToWorld());
        //                targetGridToWorld.concatenate(CoverageUtilities.CENTER_TO_CORNER);
        //
        //                // target world to grid at the corner
        //                final AffineTransform targetWorldToGrid=targetGridToWorld.createInverse();
        //                // final complete transformation
        //                targetWorldToGrid.concatenate(sourceGridToWorld);
        //
        //                //update final grid to world
        //                finalGridToWorldCorner=new AffineTransform2D(targetGridToWorld);
        //                //
        //                // Check and see if the affine transform is doing a copy.
        //                // If so call the copy operation.
        //                //
        //                // we are in raster space here, so 1E-3 is safe
        //                if(XAffineTransform.isIdentity(targetWorldToGrid,
        // GeoTiffUtils.AFFINE_IDENTITY_EPS))
        //                    return image;
        //
        //                // create final image
        //                // TODO this one could be optimized further depending on how the affine is
        // created
        //                //
        //                // In case we are asked to use certain tile dimensions we tile
        //                // also at this stage in case the read type is Direct since
        //                // buffered images comes up untiled and this can affect the
        //                // performances of the subsequent affine operation.
        //                //
        //                final Hints localHints= new Hints(hints);
        //                if (hints != null && !hints.containsKey(JAI.KEY_BORDER_EXTENDER)) {
        //                    final Object extender = hints.get(JAI.KEY_BORDER_EXTENDER);
        //                    if (!(extender != null && extender instanceof BorderExtender)) {
        //                        localHints.add(ImageUtilities.EXTEND_BORDER_BY_COPYING);
        //                    }
        //                }
        //                ImageWorker iw = new ImageWorker(image);
        //                iw.setRenderingHints(localHints);
        //                iw.affine(targetWorldToGrid, new InterpolationNearest(),
        // backgroundValues);
        //                image = iw.getRenderedImage();
        //            } catch (NoninvertibleTransformException e) {
        //                if (LOGGER.isLoggable(Level.SEVERE)){
        //                    LOGGER.log(Level.SEVERE, "Unable to create the requested mosaic ", e
        // );
        //                }
        //            }
        //        }
        return image;
    }

