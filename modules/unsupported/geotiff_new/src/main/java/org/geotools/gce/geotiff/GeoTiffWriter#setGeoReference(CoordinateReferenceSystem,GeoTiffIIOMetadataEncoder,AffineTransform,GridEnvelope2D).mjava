    /**
     * This method is used to set the tie point and the scale parameters for the
     * GeoTiff file we are writing or the ModelTransformation in case a more
     * general {@link AffineTransform} is needed to represent the raster space
     * to model space transform.
     * 
     * <p>
     * This method works regardles of the nature fo the crs without making any
     * assumptions on the order or the direction of the axes, but checking them
     * from the supplied CRS.
     * 
     * @see {@link http
     *      ://lists.maptools.org/pipermail/geotiff/2006-January/000213.html}
     * @see      {@http://lists.maptools.org/pipermail/geotiff/2006-January/000212.html
     * }
     * @param crs
     *            The {@link CoordinateReferenceSystem} of the
     *            {@link GridCoverage2D} to encode.
     * @param metadata
     *            where to set the georeferencing information.
     * @param range
     *            that describes the raster space for this geotiff.
     * @param rasterToModel
     *            describes the {@link AffineTransform} between raster space and
     *            model space.
     * 
     * @throws IndexOutOfBoundsException
     * @throws IOException
     * @throws TransformException
     */
    private static void setGeoReference(final CoordinateReferenceSystem crs,
            final GeoTiffIIOMetadataEncoder metadata, final AffineTransform rasterToModel,
            GridEnvelope2D range) throws IndexOutOfBoundsException, IOException {

        // /////////////////////////////////////////////////////////////////////
        //
        // We have to set an affine transformation which is going to be 2D
        // since we support baseline GeoTiff.
        //
        // /////////////////////////////////////////////////////////////////////
        final AffineTransform modifiedRasterToModel = new AffineTransform(rasterToModel);
        // move the internal grid to world to corner from center
        modifiedRasterToModel.concatenate(CoverageUtilities.CENTER_TO_CORNER);
        ;
        int minx = range.getLow(0), miny = range.getLow(1);
        if (minx != 0 || miny != 0) {
            // //
            //
            // Preconcatenate a transform to have raster space beginning at (0,0)
            //
            // //
            modifiedRasterToModel.concatenate(AffineTransform.getTranslateInstance(minx, miny));
        }

        // //////////////////////////////////////////////////////////////////////////
        //
        // Setting raster type to pixel corner since that is the default for geotiff
        // and makes most software happy
        //
        // /////////////////////////////////////////////////////////////////////////
        metadata.addGeoShortParam(GeoTiffConstants.GTRasterTypeGeoKey,
                GeoTiffConstants.RasterPixelIsArea);

        // /////////////////////////////////////////////////////////////////////
        //
        // AXES DIRECTION
        //
        // we need to understand how the axes of this gridcoverage are
        // specified, trying to understand the direction of the first axis in
        // order to correctly use transformations.
        //
        // Note that here wew assume that in case of a Flip the flip is on the Y axis.
        //
        // /////////////////////////////////////////////////////////////////////
        boolean lonFirst = XAffineTransform.getSwapXY(modifiedRasterToModel) != -1;

        // /////////////////////////////////////////////////////////////////////
        //
        // ROTATION
        //
        // If fthere is not rotation or shearing or flipping we have a simple
        // scale and translate hence we can simply set the tie points.
        //
        // /////////////////////////////////////////////////////////////////////
        double rotation = XAffineTransform.getRotation(modifiedRasterToModel);

        // /////////////////////////////////////////////////////////////////////
        //
        // Deciding how to save the georef with respect to the CRS.
        //
        // /////////////////////////////////////////////////////////////////////
        // tie points
        if (!(Double.isInfinite(rotation) || Double.isNaN(rotation) || Math.abs(rotation) > 1E-6)) {
            final double tiePointLongitude = (lonFirst) ? modifiedRasterToModel.getTranslateX()
                    : modifiedRasterToModel.getTranslateY();
            final double tiePointLatitude = (lonFirst) ? modifiedRasterToModel.getTranslateY()
                    : modifiedRasterToModel.getTranslateX();
            metadata.setModelTiePoint(0, 0, 0, tiePointLongitude, tiePointLatitude, 0);

            // scale
            final double scaleModelToRasterLongitude = (lonFirst) ? Math.abs(modifiedRasterToModel
                    .getScaleX()) : Math.abs(modifiedRasterToModel.getShearY());
            final double scaleModelToRasterLatitude = (lonFirst) ? Math.abs(modifiedRasterToModel
                    .getScaleY()) : Math.abs(modifiedRasterToModel.getShearX());
            metadata.setModelPixelScale(scaleModelToRasterLongitude, scaleModelToRasterLatitude, 0);
            // Alternative code, not yet enabled in order to avoid breaking code.
            // The following code is insensitive to axis order and rotations in the 'coord' space 
            // (not in the 'grid' space, otherwise we would not take the inverse of the matrix).
            /*
             * final AffineTransform coordToGrid = gridToCoord.createInverse();
             * final double scaleModelToRasterLongitude = 1 /
             * XAffineTransform.getScaleX0(coordToGrid); final double
             * scaleModelToRasterLatitude = 1 /
             * XAffineTransform.getScaleY0(coordToGrid);
             */
        } else {
            metadata.setModelTransformation(modifiedRasterToModel);
        }
    }

