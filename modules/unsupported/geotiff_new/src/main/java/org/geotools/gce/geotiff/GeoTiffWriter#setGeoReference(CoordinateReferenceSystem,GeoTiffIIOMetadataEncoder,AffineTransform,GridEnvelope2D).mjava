    /**
     * This method is used to set the tie point and the scale parameters for the GeoTiff file we are
     * writing or the ModelTransformation in case a more general {@link AffineTransform} is needed
     * to represent the raster space to model space transform.
     *
     * <p>This method works regardles of the nature fo the crs without making any assumptions on the
     * order or the direction of the axes, but checking them from the supplied CRS.
     *
     * @see {@link http ://lists.maptools.org/pipermail/geotiff/2006-January/000213.html}
     * @see {@http://lists.maptools.org/pipermail/geotiff/2006-January/000212.html }
     * @param crs The {@link CoordinateReferenceSystem} of the {@link GridCoverage2D} to encode.
     * @param metadata where to set the georeferencing information.
     * @param range that describes the raster space for this geotiff.
     * @param rasterToModel describes the {@link AffineTransform} between raster space and model
     *     space.
     * @throws IndexOutOfBoundsException
     * @throws IOException
     * @throws TransformException
     */
    private static void setGeoReference(
            final CoordinateReferenceSystem crs,
            final GeoTiffIIOMetadataEncoder metadata,
            final AffineTransform rasterToModel,
            GridEnvelope2D range)
            throws IndexOutOfBoundsException, IOException {

        // /////////////////////////////////////////////////////////////////////
        //
        // We have to set an affine transformation which is going to be 2D
        // since we support baseline GeoTiff.
        //
        // /////////////////////////////////////////////////////////////////////
        final AffineTransform modifiedRasterToModel = new AffineTransform(rasterToModel);
        // move the internal grid to world to corner from center
        modifiedRasterToModel.concatenate(CoverageUtilities.CENTER_TO_CORNER);
        ;
        int minx = range.getLow(0), miny = range.getLow(1);
        if (minx != 0 || miny != 0) {
            // //
            //
            // Preconcatenate a transform to have raster space beginning at (0,0)
            //
            // //
            modifiedRasterToModel.concatenate(AffineTransform.getTranslateInstance(minx, miny));
        }

        // //////////////////////////////////////////////////////////////////////////
        //
        // Setting raster type to pixel corner since that is the default for geotiff
        // and makes most software happy
        //
        // /////////////////////////////////////////////////////////////////////////
        metadata.addGeoShortParam(
                GeoTiffConstants.GTRasterTypeGeoKey, GeoTiffConstants.RasterPixelIsArea);

        // /////////////////////////////////////////////////////////////////////
        //
        // AXES DIRECTION
        //
        // we need to understand how the axes of this gridcoverage are
        // specified, trying to understand the direction of the first axis in
        // order to correctly use transformations.
        //
        // Note that here wew assume that in case of a Flip the flip is on the Y axis.
        //
        // /////////////////////////////////////////////////////////////////////
        boolean lonFirst = XAffineTransform.getSwapXY(modifiedRasterToModel) != -1;

        // /////////////////////////////////////////////////////////////////////
        //
        // ROTATION
        //
        // If fthere is not rotation or shearing or flipping we have a simple
        // scale and translate hence we can simply set the tie points.
        //
        // /////////////////////////////////////////////////////////////////////
        double rotation = XAffineTransform.getRotation(modifiedRasterToModel);

        // /////////////////////////////////////////////////////////////////////
        //
        // Deciding how to save the georef with respect to the CRS.
        //
        // /////////////////////////////////////////////////////////////////////
        // tie points
        if (!(Double.isInfinite(rotation) || Double.isNaN(rotation) || Math.abs(rotation) > 1E-6)) {
            final double tiePointLongitude =
                    (lonFirst)
                            ? modifiedRasterToModel.getTranslateX()
                            : modifiedRasterToModel.getTranslateY();
            final double tiePointLatitude =
                    (lonFirst)
                            ? modifiedRasterToModel.getTranslateY()
                            : modifiedRasterToModel.getTranslateX();
            metadata.setModelTiePoint(0, 0, 0, tiePointLongitude, tiePointLatitude, 0);

            // scale
            final double scaleModelToRasterLongitude =
                    (lonFirst)
                            ? Math.abs(modifiedRasterToModel.getScaleX())
                            : Math.abs(modifiedRasterToModel.getShearY());
            final double scaleModelToRasterLatitude =
                    (lonFirst)
                            ? Math.abs(modifiedRasterToModel.getScaleY())
                            : Math.abs(modifiedRasterToModel.getShearX());
            metadata.setModelPixelScale(scaleModelToRasterLongitude, scaleModelToRasterLatitude, 0);
            // Alternative code, not yet enabled in order to avoid breaking code.
            // The following code is insensitive to axis order and rotations in the 'coord' space
            // (not in the 'grid' space, otherwise we would not take the inverse of the matrix).
            /*
             * final AffineTransform coordToGrid = gridToCoord.createInverse();
             * final double scaleModelToRasterLongitude = 1 /
             * XAffineTransform.getScaleX0(coordToGrid); final double
             * scaleModelToRasterLatitude = 1 /
             * XAffineTransform.getScaleY0(coordToGrid);
             */
        } else {
            metadata.setModelTransformation(modifiedRasterToModel);
        }
    }

