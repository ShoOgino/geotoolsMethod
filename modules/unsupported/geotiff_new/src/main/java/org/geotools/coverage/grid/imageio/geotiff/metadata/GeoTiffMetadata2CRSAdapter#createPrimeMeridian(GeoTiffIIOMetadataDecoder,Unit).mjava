	/**
	 * Creating a prime meridian for the gcs we are creating at an higher level.
	 * As usual this method tries to follow the geotiff specification.
	 * 
	 * @param linearUnit
	 *            to use for building this {@link PrimeMeridian}.
	 * 
	 * @return a {@link PrimeMeridian} built using the provided {@link Unit} and
	 *         the provided metadata.
	 * @throws IOException
	 */
	private PrimeMeridian createPrimeMeridian(
			final GeoTiffIIOMetadataDecoder metadata, Unit linearUnit)
			throws IOException {
		// look up the prime meridian:
		// + could be an EPSG code
		// + could be user defined
		// + not defined = greenwich
		final String pmCode = metadata
				.getGeoKey(GeoTiffGCSCodes.GeogPrimeMeridianGeoKey);
		PrimeMeridian pm = null;

		try {
			if (pmCode != null) {
				if (pmCode.equals(GeoTiffConstants.GTUserDefinedGeoKey_String)) {
					try {
						final String name = metadata
								.getGeoKey(GeoTiffGCSCodes.GeogCitationGeoKey);
						final String pmValue = metadata
								.getGeoKey(GeoTiffGCSCodes.GeogPrimeMeridianLongGeoKey);
						final double pmNumeric = Double.parseDouble(pmValue);
						// is it Greenwich?
						if (pmNumeric == 0)
							return DefaultPrimeMeridian.GREENWICH;
						final Map props = new HashMap();
						props.put("name", (name != null) ? name
								: "User Defined GEOTIFF Prime Meridian");
						pm = datumObjFactory.createPrimeMeridian(props,
								pmNumeric, linearUnit);
					} catch (NumberFormatException nfe) {
						final IOException io = new GeoTiffException(metadata,
								"Invalid user-defined prime meridian spec.",
								nfe);

						throw io;
					}
				} else {
					pm = this.allAuthoritiesFactory.createPrimeMeridian("EPSG:"
							+ pmCode);
				}
			} else {
				pm = DefaultPrimeMeridian.GREENWICH;
			}
		} catch (FactoryException fe) {
			final IOException io = new GeoTiffException(metadata, fe
					.getLocalizedMessage(), fe);
			throw io;
		}

		return pm;
	}

