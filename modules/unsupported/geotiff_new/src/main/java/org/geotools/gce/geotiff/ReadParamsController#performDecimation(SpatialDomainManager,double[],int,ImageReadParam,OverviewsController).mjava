    /**
     * This method is responsible for evaluating possible subsampling factors
     * once the best resolution level has been found, in case we have support
     * for overviews, or starting from the original coverage in case there are
     * no overviews available.
     * 
     * Anyhow this method should not be called directly but subclasses should
     * make use of the setReadParams method instead in order to transparently
     * look for overviews.
     * 
     * @param levelIndex
     * @param readParameters
     * @param requestedRes
     */
     private static void performDecimation(
            final SpatialDomainManager spatialDomainManager,
            final double[] requestedResolution,
            final int levelIndex,
            final ImageReadParam readParameters, 
            final OverviewsController overviewsController
            ) {

        // the read parameters cannot be null
        Utilities.ensureNonNull("readParameters", readParameters);
        Utilities.ensureNonNull("spatialDomainManager", spatialDomainManager);
        Utilities.ensureNonNull("overviewsController", overviewsController);
        
        // get the requested resolution
        if (requestedResolution == null) {
            // if there is no requested resolution we don't do any
            // subsampling
            readParameters.setSourceSubsampling(1, 1, 0, 0);
            return;
        }

        double selectedRes[] = new double[2];
        final OverviewLevel level = overviewsController.resolutionsLevels.get(levelIndex);
        selectedRes[0] = level.resolutionX;
        selectedRes[1] = level.resolutionY;

        final int rasterWidth, rasterHeight;
        if (levelIndex == 0) {
            // highest resolution
            rasterWidth = spatialDomainManager.coverageRasterArea.width;
            rasterHeight = spatialDomainManager.coverageRasterArea.height;
        } else {
            // work on overviews
            // TODO this is bad side effect of how the Overviews are managed
            // right now. There are two problems here,
            // first we are assuming that we are working with LON/LAT,
            // second is that we are getting just an approximation of
            // raster dimensions. The solution is to have the rater
            // dimensions on each level and to confront raster dimensions,
            // which means working
            rasterWidth = (int) Math.round(spatialDomainManager.coverageBBox.getSpan(0)/ selectedRes[0]);
            rasterHeight = (int) Math.round(spatialDomainManager.coverageBBox.getSpan(1)/ selectedRes[1]);

        }
        // /////////////////////////////////////////////////////////////////////
        // DECIMATION ON READING
        // Setting subsampling factors with some checks
        // 1) the subsampling factors cannot be zero
        // 2) the subsampling factors cannot be such that the w or h are
        // zero
        // /////////////////////////////////////////////////////////////////////
        int subSamplingFactorX = (int) Math.floor(requestedResolution[0] / selectedRes[0]);
        subSamplingFactorX = subSamplingFactorX == 0 ? 1 : subSamplingFactorX;

        while (rasterWidth / subSamplingFactorX <= 0 && subSamplingFactorX >= 0)
            subSamplingFactorX--;
        subSamplingFactorX = subSamplingFactorX <= 0 ? 1 : subSamplingFactorX;

        int subSamplingFactorY = (int) Math.floor(requestedResolution[1] / selectedRes[1]);
        subSamplingFactorY = subSamplingFactorY == 0 ? 1 : subSamplingFactorY;

        while (rasterHeight / subSamplingFactorY <= 0 && subSamplingFactorY >= 0)
            subSamplingFactorY--;
        subSamplingFactorY = subSamplingFactorY <= 0 ? 1 : subSamplingFactorY;

        readParameters.setSourceSubsampling(subSamplingFactorX, subSamplingFactorY, 0, 0);
    }

