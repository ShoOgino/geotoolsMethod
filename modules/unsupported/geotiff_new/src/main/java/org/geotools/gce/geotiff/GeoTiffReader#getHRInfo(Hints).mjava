	/**
	 * 
	 * @param hints
	 * @throws IOException
	 * @throws FactoryException
	 * @throws TransformException
	 * @throws MismatchedDimensionException
	 * @throws DataSourceException
	 */
	private void getHRInfo(Hints hints) throws IOException, FactoryException,
			TransformException, MismatchedDimensionException,
			DataSourceException {
		// //
		//
		// Get a reader for this format
		//
		// //
		final ImageReader reader = Utils.TIFFREADERFACTORY.createReaderInstance();

		// //
		//
		// get the METADATA
		//
		// //
		reader.setInput(inStream);
		
		
		final IIOMetadata iioMetadata = reader.getImageMetadata(0);
		CoordinateReferenceSystem foundCrs = null;
		boolean useWorldFile = false;
		
		try{
		    metadata = new GeoTiffIIOMetadataDecoder(iioMetadata);
		    gtcs = new GeoTiffMetadata2CRSAdapter(hints);
		    if (gtcs != null)
		    	foundCrs = gtcs.createCoordinateSystem(metadata);
		    else 
		        useWorldFile = true;
		    
		    if (metadata.hasNoData())
	                    noData = metadata.getNoData();
		}catch (IllegalArgumentException iae){
		    useWorldFile = true;
		}catch (UnsupportedOperationException uoe){
		    useWorldFile = true;
		}
		
		
		// //
		//
		// get the CRS INFO
		//
		// //
		final Object tempCRS = this.hints
				.get(Hints.DEFAULT_COORDINATE_REFERENCE_SYSTEM);
		if (tempCRS != null) {
			this.crs = (CoordinateReferenceSystem) tempCRS;
			LOGGER.log(Level.WARNING, new StringBuilder(
					"Using forced coordinate reference system ").append(
					crs.toWKT()).toString());
		} else{
		    if (useWorldFile)
		        foundCrs = Utils.getCRS(source);
		    crs = foundCrs;
		}
		
		if (crs == null){
                    throw new DataSourceException ("Coordinate Reference System is not available");
                }
			

		// //
		//
		// get the dimension of the hr image and build the model as well as
		// computing the resolution
		// //
		numOverviews = reader.getNumImages(true) - 1;
		final int hrWidth = reader.getWidth(0);
		final int hrHeight = reader.getHeight(0);
		final int hrTileW= reader.getTileWidth(0);
		final int hrTileH= reader.getTileHeight(0);
		hrLayout= new RasterLayout(0,0,hrWidth,hrHeight,0,0,hrTileW,hrTileH);
		final Rectangle actualDim = new Rectangle(0, 0, hrWidth, hrHeight);
		originalGridRange = new GridEnvelope2D(actualDim);

		if (!useWorldFile && gtcs != null) {
		    this.raster2Model = GeoTiffMetadata2CRSAdapter.getRasterToModel(metadata);
        		    
        		 
                }
                else {
                    this.raster2Model = Utils.parseWorldFile(source);
                }
        		
		if (this.raster2Model == null){
                    throw new DataSourceException ("Raster to Model Transformation is not available");
                }
		
		final AffineTransform tempTransform = new AffineTransform((AffineTransform) raster2Model);
		tempTransform.translate(-0.5, -0.5);
		originalEnvelope = CRS.transform(ProjectiveTransform.create(tempTransform), new GeneralEnvelope(actualDim));
		originalEnvelope.setCoordinateReferenceSystem(crs);

		// ///
		// 
		// setting the higher resolution available for this coverage
		//
		// ///
		highestRes = new double[2];
		highestRes[0]=XAffineTransform.getScaleX0(tempTransform);
		highestRes[1]=XAffineTransform.getScaleY0(tempTransform);

		// //
		//
		// get information for the successive images
		//
		// //
		
		if (numOverviews >= 1) {
			overViewResolutions = new double[numOverviews][2];
			overViewLayouts= new RasterLayout[numOverviews];
			for (int i = 0; i < numOverviews; i++) {
				//getting raster layout
				final int width=reader.getWidth(i+1);
				final int height=reader.getHeight(i+1);
				final int tileW=reader.getTileWidth(i+1);
				final int tileH=reader.getTileHeight(i+1);
				
				overViewLayouts[i]= new RasterLayout(0,0,width,height,0,0,tileW,tileH);
				
				//computing resolutions
				overViewResolutions[i][0] = (highestRes[0]*hrWidth)/width;
				overViewResolutions[i][1] = (highestRes[1]*hrHeight)/height;
			}
		} else
			overViewResolutions = null;
		
		// get sample image
		final ImageReadParam readParam= reader.getDefaultReadParam();
		readParam.setSourceRegion(new Rectangle(0,0,4,4));
		final BufferedImage sampleImage = reader.read(0,readParam);
		baseImageType = new ImageTypeSpecifier(sampleImage);
		reader.dispose();
                
	}

