    /**
     * Currently, we only accept files, and we open the file to verify that it
     * has a GeoKeyDirectory tag. If anything more subtle is wrong with the
     * file, we deal with that when we try and read it.
     * 
     * @param o
     *            the source object to test for compatibility with this format.
     * 
     * 
     * @return true if "o" is a File or a URL that points to a GeoTiff with a
     *         GeoTiff file as a resource.
     */
    @Override
    public boolean accepts(Object o, Hints hints) {

        if (o == null) {
            return false;
        }
        ImageReader reader = null;
        ImageInputStream inputStream = null;
        boolean closeMe = false;
        try {
            if (o instanceof URL) {
                // /////////////////////////////////////////////////////////////
                //
                // URL management
                // In case the URL points to a file we need to get to the fie
                // directly and avoid caching. In case it points to http or ftp
                // or it is an opnen stream we have very small to do and we need
                // to enable caching.
                //
                // /////////////////////////////////////////////////////////////
                final URL url = (URL) o;
                o = DataUtilities.urlToFile(url);

            } else if (o instanceof ImageInputStream) {
                closeMe = false;
            }
            // get a stream
            inputStream = (ImageInputStream) ((o instanceof ImageInputStream) ? o
                    : ImageIOExt.createImageInputStream(o));
            if (inputStream == null) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Unable to get an ImageInputStream");
                }
                return false;
            }

            // get a reader
            if (!spi.canDecodeInput(inputStream)) {
                return false;
            }
            reader = spi.createReaderInstance();

            inputStream.mark();
            reader.setInput(inputStream);
            final IIOMetadata metadata = reader.getImageMetadata(0);
            if (metadata == null) {
                return false;
            }
            //
            // parse metadata and be resilient with CRS
            //
            final GeoTiffIIOMetadataDecoder metadataAdapter = new GeoTiffIIOMetadataDecoder(
                    metadata);
            if (!metadataAdapter.hasGeoKey() && LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Unable to find geokey directory for this tif file");
            }

            //
            // analyze georeferencing
            //
            // do we have verything as geotiff?
            if (metadataAdapter.hasModelTrasformation() || 
                    (metadataAdapter.hasPixelScales() && metadataAdapter.hasTiePoints())){
                return true;
            }

            // now look for info into a WLD file
            MathTransform raster2Model = Utils.parseWorldFile(o);
            if (raster2Model != null) {
                return true;
            } else {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Unable to find georeferencing for this tif file");
                }
                return false;
            }
        } catch (Throwable e) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log(Level.FINE, e.getLocalizedMessage(), e);
            }
            return false;
        } finally {
            if (reader != null) {
                try {
                    reader.dispose();
                } catch (Exception e) {

                }
            }
            if (closeMe && inputStream != null) {
                try {
                    inputStream.close();
                } catch (Throwable t) {

                }
            }
        }
    }

