    /**
     * Set proper fields from the specified input parameter.
     * 
     * @param param
     *            the input {@code ParamaterValue} object
     * @param name
     *            the name of the parameter
     */
    private void extractParameter(ParameterValue<?> param, Identifier name) {

        // //
        //
        // Requested GridGeometry2D parameter
        //
        // //
        if (name.equals(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            final GridGeometry2D gg = (GridGeometry2D) param.getValue();
            if (gg == null) {
                return;
            }

            requestedBBox = new ReferencedEnvelope((Envelope) gg.getEnvelope2D());
            requestedRasterArea = gg.getGridRange2D().getBounds();
            requestedGridToWorld = (AffineTransform) gg.getGridToCRS2D();
            return;
        }

        // //
        //
        // Use JAI ImageRead parameter
        //
        // //
        if (name.equals(AbstractGridFormat.USE_JAI_IMAGEREAD.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            readType = param.booleanValue() ? ReadType.JAI_IMAGEREAD : ReadType.DIRECT_READ;
            return;
        }

        // //
        //
        // Overview Policy parameter
        //
        // //
        if (name.equals(AbstractGridFormat.OVERVIEW_POLICY.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            overviewPolicy = (OverviewPolicy) param.getValue();
            return;
        }

        if (name.equals(GeoTiffFormat.INPUT_TRANSPARENT_COLOR.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            inputTransparentColor = (Color) param.getValue();
            // paranoiac check on the provided transparent color
            inputTransparentColor = new Color(inputTransparentColor.getRed(),
                    inputTransparentColor.getGreen(), inputTransparentColor.getBlue());
            return;

        }
        //
        // if (name.equals(ImageMosaicFormat.FADING.getName())) {
        // final Object value = param.getValue();
        // if(value==null)
        // return;
        // blend = ((Boolean) param.getValue()).booleanValue();
        // return;
        //
        // }
        // if (name.equals(
        // GeoTiffFormat.OUTPUT_TRANSPARENT_COLOR.getName())) {
        // final Object value = param.getValue();
        // if(value==null)
        // return;
        // outputTransparentColor = (Color) param.getValue();
        // // paranoiac check on the provided transparent color
        // outputTransparentColor = new Color(
        // outputTransparentColor.getRed(),
        // outputTransparentColor.getGreen(),
        // outputTransparentColor.getBlue());
        // return;
        //
        // }
        //
         if (name.equals(
         GeoTiffFormat.BACKGROUND_VALUES.getName())) {
         final Object value = param.getValue();
         if(value==null)
         return;
         backgroundValues = (double[]) param.getValue();
         return;
        
         }
        //
        // if (name.equals(ImageMosaicFormat.MAX_ALLOWED_TILES.getName())) {
        // final Object value = param.getValue();
        // if(value==null)
        // return;
        // maximumNumberOfGranules=param.intValue();
        // return;
        // }
        //
        //
        // if (name.equals(GeoTiffFormat.ALLOW_MULTITHREADING.getName())) {
        // final Object value = param.getValue();
        // if(value==null)
        // return;
        // multithreadingAllowed = ((Boolean) param.getValue()).booleanValue();
        // return;
        // }

        // //
        //
        // Suggested tile size parameter. It must be specified with
        // the syntax: "TileWidth,TileHeight" (without quotes where TileWidth
        // and TileHeight are integer values)
        //
        // //
        if (name.equals(GeoTiffFormat.SUGGESTED_TILE_SIZE.getName())) {
            final String suggestedTileSize = (String) param.getValue();

            // Preliminary checks on parameter value
            if ((suggestedTileSize != null) && (suggestedTileSize.trim().length() > 0)) {

                if (suggestedTileSize.contains(GeoTiffFormat.TILE_SIZE_SEPARATOR)) {
                    final String[] tilesSize = suggestedTileSize
                            .split(GeoTiffFormat.TILE_SIZE_SEPARATOR);
                    if (tilesSize.length == 2) {
                        try {
                            // Getting suggested tile size
                            final int tileWidth = Integer.valueOf(tilesSize[0].trim());
                            final int tileHeight = Integer.valueOf(tilesSize[1].trim());
                            tileDimensions = new Dimension(tileWidth, tileHeight);
                        } catch (NumberFormatException nfe) {
                            if (LOGGER.isLoggable(Level.WARNING)) {
                                LOGGER.log(Level.WARNING, "Unable to parse "
                                        + "suggested tile size parameter");
                            }
                        }
                    }
                }
            }
        }
    }

