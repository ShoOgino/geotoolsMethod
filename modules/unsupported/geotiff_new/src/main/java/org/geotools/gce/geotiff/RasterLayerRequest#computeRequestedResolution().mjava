	/**
	 * Computes the requested resolution which is going to be used for selecting
	 * overviews and or deciding decimation factors on the target coverage.
	 * 
	 * <p>
	 * In case the requested envelope is in the same
	 * {@link CoordinateReferenceSystem} of the coverage we compute the
	 * resolution using the requested {@link MathTransform}. Notice that it must
	 * be a {@link LinearTransform} or else we fail.
	 * 
	 * <p>
	 * In case the requested envelope is not in the same {@link CoordinateReferenceSystem} of the coverage we 
	 * 
	 * @throws DataSourceException
	 *             in case something bad happens during reprojections and/or
	 *             intersections.
	 */
	private void computeRequestedResolution() throws DataSourceException
	{
			
		try{
	
			// let's try to get the resolution from the requested gridToWorld
			if(requestedGridToWorld instanceof LinearTransform)
			{

				//
				// the crs of the request and the one of the coverage are NOT the
				// same and the conversion is not , we can get the resolution from envelope + raster directly
				//
				if(destinationToSourceTransform!=null&&!destinationToSourceTransform.isIdentity())
				{

					
			        //
			        // compute the approximated resolution in the request crs, notice that we are
					// assuming a reprojection that keeps the raster area unchanged hence
					// the effect is a degradation of quality, but we take that into account emprically
			        //
					requestedResolution=null;
					
					// compute the raster that correspond to the crop bbox at the highest resolution
					final Rectangle sourceRasterArea = new GeneralGridEnvelope(
							 CRS.transform(
									 PixelTranslation.translate(rasterManager.getRaster2Model(),PixelInCell.CELL_CENTER,PixelInCell.CELL_CORNER).inverse(),
									 cropBBox),PixelInCell.CELL_CORNER,false).toRectangle();
					XRectangle2D.intersect(sourceRasterArea, rasterManager.domainManager.coverageRasterArea, sourceRasterArea);
					if(sourceRasterArea.isEmpty())
						throw new DataSourceException("aaa");
					

					// transform the crop bbox to the request model space
					final GeneralEnvelope envelope=CRS.transform(destinationToSourceTransform.inverse(), cropBBox);
			        final GridToEnvelopeMapper geMapper= new GridToEnvelopeMapper(new GridEnvelope2D(sourceRasterArea),envelope);
			        final AffineTransform tempTransform = geMapper.createAffineTransform();
			        final double scaleX=XAffineTransform.getScaleX0((AffineTransform) requestedGridToWorld)/XAffineTransform.getScaleX0(tempTransform);
			        final double scaleY=XAffineTransform.getScaleY0((AffineTransform) requestedGridToWorld)/XAffineTransform.getScaleY0(tempTransform);
					//
					// empiric adjustment to get a finer resolution to have better quality when reprojecting
			        // TODO make it parametric
					//
			        requestedRasterScaleFactors= new double[2];
			        requestedRasterScaleFactors[0]=scaleX*1.0;
			        requestedRasterScaleFactors[1]=scaleY*1.0;
			        
			        
			        // adjust the final grid to world
			        final GridToEnvelopeMapper geMapper1= new GridToEnvelopeMapper(new GridEnvelope2D(destinationRasterArea),cropBBox);
			        requestedGridToWorld= geMapper1.createAffineTransform();

					
				}
				else
				{

					//
					// the crs of the request and the one of the coverage are the
					// same, we can get the resolution from the grid to world
					//					
//					if(requestedGridToWorld instanceof AffineTransform){
						requestedResolution= new double[]
						                                {
															XAffineTransform.getScaleX0(requestedGridToWorld),
															XAffineTransform.getScaleY0(requestedGridToWorld)
														};
//					}
//					else{
//						// get the matrix
//						final Matrix matrix= ((LinearTransform)requestedGridToWorld).getMatrix();
//						final XAffineTransform transform=new XAffineTransform(
//								matrix.getElement(0, 0),
//								matrix.getElement(1, 0),
//								matrix.getElement(0, 1),
//								matrix.getElement(1, 1),
//								matrix.getElement(0, 2),
//								matrix.getElement(1, 2));
//						requestedResolution= new double[]
//						                                {
//															XAffineTransform.getScaleX0(transform),
//															XAffineTransform.getScaleY0(transform)
//														};
//					}
//		
				}
			}
				
				
			//leave
			return;
		}catch (Throwable e) {
			if(LOGGER.isLoggable(Level.INFO))
				LOGGER.log(Level.INFO,"Unable to compute requested resolution",e);
		}
		
		//
		//use the coverage resolution since we cannot compute the requested one
		//
		LOGGER.log(Level.WARNING,"Unable to compute requested resolution, using highest available");
		requestedResolution=rasterManager.domainManager.coverageFullResolution;
					
	}

