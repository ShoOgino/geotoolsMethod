    /**
     * Creating an ellipsoid following the GeoTiff spec.
     *
     * @param unit to build this {@link Ellipsoid}..
     * @return an {@link Ellipsoid}.
     * @throws GeoTiffException
     */
    private Ellipsoid createEllipsoid(final Unit unit, final GeoTiffIIOMetadataDecoder metadata)
            throws GeoTiffException {
        // /////////////////////////////////////////////////////////////////////
        //
        // Getting the ellipsoid key in order to understand if we are working
        // against a common ellipsoid or a user defined one.
        //
        // /////////////////////////////////////////////////////////////////////
        // ellipsoid key
        final String ellipsoidKey = metadata.getGeoKey(GeoTiffGCSCodes.GeogEllipsoidGeoKey);
        String temp = null;
        // is the ellipsoid user defined?
        if (ellipsoidKey.equalsIgnoreCase(GeoTiffConstants.GTUserDefinedGeoKey_String)) {
            // /////////////////////////////////////////////////////////////////////
            //
            // USER DEFINED ELLIPSOID
            //
            // /////////////////////////////////////////////////////////////////////
            String nameEllipsoid = metadata.getGeoKey(GeoTiffGCSCodes.GeogCitationGeoKey);
            if (nameEllipsoid == null) nameEllipsoid = "unnamed";
            // is it the default for WGS84?
            if (nameEllipsoid.trim().equalsIgnoreCase("WGS84")) return DefaultEllipsoid.WGS84;

            // //
            //
            // It is worth to point out that I ALWAYS use the inverse flattening
            // along with the semi-major axis to builde the Flattened Sphere.
            // This
            // has to be done in order to comply with the opposite process of
            // going from CRS to metadata where this coupls is always used.
            //
            // //
            // getting temporary parameters
            temp = metadata.getGeoKey(GeoTiffGCSCodes.GeogSemiMajorAxisGeoKey);
            final double semiMajorAxis = (temp != null ? Double.parseDouble(temp) : Double.NaN);
            temp = metadata.getGeoKey(GeoTiffGCSCodes.GeogInvFlatteningGeoKey);
            final double inverseFlattening;
            if (temp != null) {
                inverseFlattening = (temp != null ? Double.parseDouble(temp) : Double.NaN);
            } else {
                temp = metadata.getGeoKey(GeoTiffGCSCodes.GeogSemiMinorAxisGeoKey);
                final double semiMinorAxis = (temp != null ? Double.parseDouble(temp) : Double.NaN);
                inverseFlattening = semiMajorAxis / (semiMajorAxis - semiMinorAxis);
            }
            // look for the Ellipsoid first then build the datum
            return DefaultEllipsoid.createFlattenedSphere(
                    nameEllipsoid, semiMajorAxis, inverseFlattening, unit);
        }

        try {
            // /////////////////////////////////////////////////////////////////////
            //
            // EPSG STANDARD ELLIPSOID
            //
            // /////////////////////////////////////////////////////////////////////
            return this.allAuthoritiesFactory.createEllipsoid(
                    new StringBuffer("EPSG:").append(ellipsoidKey).toString());
        } catch (FactoryException fe) {
            final GeoTiffException ex =
                    new GeoTiffException(metadata, fe.getLocalizedMessage(), fe);

            throw ex;
        }
    }

