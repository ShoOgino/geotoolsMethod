    private RenderedImage postProcessRaster(RenderedImage image) {
//     // alpha on the final mosaic
//        if (transparentColor != null) {
//                if (LOGGER.isLoggable(Level.FINE))
//                        LOGGER.fine("Support for alpha on final mosaic");
//                return ImageUtilities.maskColor(transparentColor,image);
//
//        }
//        if (!needsReprojection){
//            try {
//                
//                // creating source grid to world corrected to the pixel corner
//                final AffineTransform sourceGridToWorld = new AffineTransform((AffineTransform) finalGridToWorldCorner);
//                
//                // target world to grid at the corner
//                final AffineTransform targetGridToWorld = new AffineTransform(request.getRequestedGridToWorld());
//                targetGridToWorld.concatenate(CoverageUtilities.CENTER_TO_CORNER);
//                
//                // target world to grid at the corner
//                final AffineTransform targetWorldToGrid=targetGridToWorld.createInverse();
//                // final complete transformation
//                targetWorldToGrid.concatenate(sourceGridToWorld);
//                
//                //update final grid to world
//                finalGridToWorldCorner=new AffineTransform2D(targetGridToWorld);
//                //
//                // Check and see if the affine transform is doing a copy.
//                // If so call the copy operation.
//                //
//                // we are in raster space here, so 1E-3 is safe
//                if(XAffineTransform.isIdentity(targetWorldToGrid, Utils.AFFINE_IDENTITY_EPS))
//                    return image;
//                
//                // create final image
//                // TODO this one could be optimized further depending on how the affine is created
//                //
//                // In case we are asked to use certain tile dimensions we tile
//                // also at this stage in case the read type is Direct since
//                // buffered images comes up untiled and this can affect the
//                // performances of the subsequent affine operation.
//                //
//                final Hints localHints= new Hints(hints);
//                if (hints != null && !hints.containsKey(JAI.KEY_BORDER_EXTENDER)) {
//                    final Object extender = hints.get(JAI.KEY_BORDER_EXTENDER);
//                    if (!(extender != null && extender instanceof BorderExtender)) {
//                        localHints.add(ImageUtilities.EXTEND_BORDER_BY_COPYING);
//                    }
//                }
//                ImageWorker iw = new ImageWorker(image);
//                iw.setRenderingHints(localHints);
//                iw.affine(targetWorldToGrid, new InterpolationNearest(), backgroundValues);
//                image = iw.getRenderedImage();
//            } catch (NoninvertibleTransformException e) {
//                if (LOGGER.isLoggable(Level.SEVERE)){
//                    LOGGER.log(Level.SEVERE, "Unable to create the requested mosaic ", e );
//                }
//            }
//        }
        return image;
    }

