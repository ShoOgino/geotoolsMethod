    public RenderedImage loadRaster(final ImageReadParam readParameters, final int imageIndex,
            final ReferencedEnvelope cropBBox, final MathTransform2D mosaicWorldToGrid,
            final RasterLayerRequest request, final Dimension tileDimension) throws IOException {

        if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
            LOGGER.fine("Loading raster data for rasterGranuleLoader " + this.toString());
        }
        ImageInputStream inStream = null;
        int imageChoice = imageIndex;
        File file = granuleFile;

        final ReferencedEnvelope bbox = new ReferencedEnvelope(granuleBBOX);
        // intersection of this tile bound with the current crop bbox
        final ReferencedEnvelope intersection = new ReferencedEnvelope(bbox.intersection(cropBBox),
                cropBBox.getCoordinateReferenceSystem());

        ImageReader reader = null;
        try {
            //
            // get info about the raster we have to read
            //
            if (request.rasterManager.parent.extOvrImgChoice >= 0 && 
                    imageIndex >= request.rasterManager.parent.extOvrImgChoice) {
                file = request.rasterManager.parent.ovrSource;
                inStream = request.rasterManager.parent.ovrInStreamSPI.createInputStreamInstance(
                        file, ImageIO.getUseCache(), ImageIO.getCacheDirectory());
                imageChoice = imageIndex - request.rasterManager.parent.extOvrImgChoice;
            } else {
                inStream = ImageIOExt.createImageInputStream(file);    
            }
            
            if (inStream == null) {
                return null;
            }

            // get a reader
            reader = Utils.TIFFREADERFACTORY.createReaderInstance();
            reader.setInput(inStream);

            // get selected level and base level dimensions
            final Level selectedlevel = getLevel(request, imageIndex);

            // now create the crop grid to world which can be used to decide
            // which source area we need to crop in the selected level taking
            // into account the scale factors imposed by the selection of this
            // level together with the base level grid to world transformation
            final MathTransform2D cropGridToWorldCorner = (MathTransform2D) ProjectiveTransform
                    .create(selectedlevel.gridToWorldTransform);
            final MathTransform2D cropWorldToGrid = cropGridToWorldCorner.inverse();

            // computing the crop source area which leaves straight into the
            // selected level raster space, NOTICE that at the end we need to
            // take into account the fact that we might also decimate therefore
            // we cannot just use the crop grid to world but we need to correct
            // it.
            final Rectangle sourceArea = CRS
                    .transform(cropWorldToGrid, new GeneralEnvelope(intersection)).toRectangle2D()
                    .getBounds();
            XRectangle2D.intersect(sourceArea, selectedlevel.rasterDimensions, sourceArea);
            // make sure roundings don't bother us

            // final Rectangle sourceAreaWithCollar= (Rectangle)
            // sourceArea.clone();
            // sourceAreaWithCollar.grow((int)(sourceArea.width*0.05),(int)(
            // sourceArea.height*0.05));

            // is it empty??
            if (sourceArea.isEmpty()) {
                if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                    LOGGER.warning("Got empty area for rasterGranuleLoader " + this.toString()
                            + " with request " + request.toString());
                }
                return null;

            } else if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
                LOGGER.fine("Loading level " + imageIndex + " with source region " + sourceArea);
            }
            // set the source region
            // readParameters.setSourceRegion(sourceAreaWithCollar);
            readParameters.setSourceRegion(sourceArea);

            // read
            RenderedImage raster = request.getReadType().read(readParameters, imageChoice,
                    file, selectedlevel.rasterDimensions, tileDimension);
            if (raster == null) {
                return null;
            }
            try {
                raster.getWidth();
            } catch (Throwable e) {
                if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
                    LOGGER.log(java.util.logging.Level.FINE,
                            "Unable to load raster for rasterGranuleLoader " + this.toString()
                                    + " with request " + request.toString(), e);
                }
                return null;
            }

            // use fixed source area
            sourceArea.setRect(readParameters.getSourceRegion());

            //
            // setting new coefficients to define a new affineTransformation
            // to be applied to the grid to world transformation
            // -----------------------------------------------------------------------------------
            //
            // With respect to the original envelope, the obtained planarImage
            // needs to be rescaled. The scaling factors are computed as the
            // ratio between the cropped source region sizes and the read
            // image sizes.
            //
            // place it in the mosaic using the coords created above;
            double decimationScaleX = ((1.0 * sourceArea.width) / raster.getWidth());
            double decimationScaleY = ((1.0 * sourceArea.height) / raster.getHeight());
            final AffineTransform decimationScaleTranform = XAffineTransform.getScaleInstance(
                    decimationScaleX, decimationScaleY);

            // keep into account translation to work into the selected level
            // raster space
            final AffineTransform afterDecimationTranslateTranform = XAffineTransform
                    .getTranslateInstance(sourceArea.x, sourceArea.y);

            // now we need to go back to the base level raster space
            final AffineTransform backToBaseLevelScaleTransform = selectedlevel.levelToBaseTransform;

            // now create the overall transform
            final AffineTransform tempRaster2Model = new AffineTransform(baseGridToWorld);
            tempRaster2Model.concatenate(CoverageUtilities.CENTER_TO_CORNER);
            if (!XAffineTransform.isIdentity(backToBaseLevelScaleTransform, Utils.EPSILON)) {
                tempRaster2Model.concatenate(backToBaseLevelScaleTransform);
            }
            if (!XAffineTransform.isIdentity(afterDecimationTranslateTranform, Utils.EPSILON)) {
                tempRaster2Model.concatenate(afterDecimationTranslateTranform);
            }
            if (!XAffineTransform.isIdentity(decimationScaleTranform, Utils.EPSILON)) {
                tempRaster2Model.concatenate(decimationScaleTranform);
            }

            // keep into account translation factors to place this tile
            final AffineTransform translationTransform = tempRaster2Model;
            translationTransform.preConcatenate((AffineTransform) mosaicWorldToGrid);

            final InterpolationNearest nearest = new InterpolationNearest();
            // paranoiac check to avoid that JAI freaks out when computing its
            // internal layouT on images that are too small
            Rectangle2D finalLayout = ImageUtilities.layoutHelper(raster,
                    (float) translationTransform.getScaleX(),
                    (float) translationTransform.getScaleY(),
                    (float) translationTransform.getTranslateX(),
                    (float) translationTransform.getTranslateY(), nearest);
            if (finalLayout.isEmpty()) {
                if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
                    LOGGER.fine("Unable to create a rasterGranuleLoader " + this.toString()
                            + " due to jai scale bug");
                }
                return null;
            }

            // apply the affine transform conserving indexed color model
            final RenderingHints localHints = new RenderingHints(JAI.KEY_REPLACE_INDEX_COLOR_MODEL,
                    Boolean.FALSE);
            if (XAffineTransform.isIdentity(translationTransform, Utils.EPSILON)) {
                return raster;
            } else {
                //
                // In case we are asked to use certain tile dimensions we tile
                // also at this stage in case the read type is Direct since
                // buffered images comes up untiled and this can affect the
                // performances of the subsequent affine operation.
                //
                final Dimension tileDimensions = request.getTileDimensions();
                if (tileDimensions != null && request.getReadType().equals(ReadType.DIRECT_READ)) {
                    final ImageLayout layout = new ImageLayout();
                    layout.setTileHeight(tileDimensions.width).setTileWidth(tileDimensions.height);
                    localHints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT, layout));
                }
                // border extender
                // return WarpDescriptor.create(raster, new
                // WarpAffine(translationTransform.createInverse()),new
                // InterpolationNearest(),
                // request.getBackgroundValues(),localHints);
                return AffineDescriptor.create(raster, translationTransform, nearest, null,
                        localHints);
            }

        } catch (IllegalStateException e) {
            if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                LOGGER.log(java.util.logging.Level.WARNING,
                        "Unable to load raster for rasterGranuleLoader " + this.toString()
                                + " with request " + request.toString(), e);
            }
            return null;
        } catch (org.opengis.referencing.operation.NoninvertibleTransformException e) {
            if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                LOGGER.log(java.util.logging.Level.WARNING,
                        "Unable to load raster for rasterGranuleLoader " + this.toString()
                                + " with request " + request.toString(), e);
            }
            return null;
        } catch (TransformException e) {
            if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                LOGGER.log(java.util.logging.Level.WARNING,
                        "Unable to load raster for rasterGranuleLoader " + this.toString()
                                + " with request " + request.toString(), e);
            }
            return null;
        } finally {

            if (inStream != null) {
                try {
                    inStream.close();
                } catch (Throwable t) {

                }
            }
            if (reader != null) {
                try {
                    reader.dispose();
                } catch (Throwable t) {

                }
            }
        }

    }

