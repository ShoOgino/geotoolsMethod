    /**
     * Create the grid to world (or raster to model) transformation for this sourceFile which is
     * placed at the centre of the pixel rather at the corner.
     *
     * @param metadata containing the information to build the {@link MathTransform} for going from
     *     grid to world.
     * @param forceToCellCenter if <code>true</code>, force to create the raster to model
     *     transformation respecting the OGC {@link PixelInCell#CELL_CENTER} convention for the
     *     {@link ImageDatum} of the underlying {@link ImageCRS}.
     * @throws GeoTiffException
     */
    public static MathTransform getRasterToModel(
            final GeoTiffIIOMetadataDecoder metadata, final boolean forceToCellCenter)
            throws GeoTiffException {
        //
        // Load initials
        //
        final boolean hasTiePoints = metadata.hasTiePoints();
        final boolean hasPixelScales = metadata.hasPixelScales();
        final boolean hasModelTransformation = metadata.hasModelTrasformation();
        int rasterType = getGeoKeyAsInt(GeoTiffConstants.GTRasterTypeGeoKey, metadata);
        // geotiff spec says that PixelIsArea is the default
        if (rasterType == GeoTiffConstants.UNDEFINED)
            rasterType = GeoTiffConstants.RasterPixelIsArea;
        MathTransform xform = null;
        if (hasTiePoints && hasPixelScales) {

            //
            // we use tie points and pixel scales to build the grid to world
            //
            // model space
            final TiePoint[] tiePoints = metadata.getModelTiePoints();
            final PixelScale pixScales = metadata.getModelPixelScales();

            // here is the matrix we need to build
            final GeneralMatrix gm = new GeneralMatrix(3);
            final double scaleRaster2ModelLongitude = pixScales.getScaleX();
            final double scaleRaster2ModelLatitude = -pixScales.getScaleY();
            // "raster" space
            final double tiePointColumn =
                    tiePoints[0].getValueAt(0)
                            + ((forceToCellCenter
                                            || rasterType == GeoTiffConstants.RasterPixelIsArea)
                                    ? -0.5
                                    : 0);

            // coordinates
            // (indicies)
            final double tiePointRow =
                    tiePoints[0].getValueAt(1)
                            + ((forceToCellCenter
                                            || rasterType == GeoTiffConstants.RasterPixelIsArea)
                                    ? -0.5
                                    : 0);

            // compute an "offset and scale" matrix
            gm.setElement(0, 0, scaleRaster2ModelLongitude);
            gm.setElement(1, 1, scaleRaster2ModelLatitude);
            gm.setElement(0, 1, 0);
            gm.setElement(1, 0, 0);

            gm.setElement(
                    0,
                    2,
                    tiePoints[0].getValueAt(3) - (scaleRaster2ModelLongitude * tiePointColumn));
            gm.setElement(
                    1, 2, tiePoints[0].getValueAt(4) - (scaleRaster2ModelLatitude * tiePointRow));

            // make it a LinearTransform
            xform = ProjectiveTransform.create(gm);

        } else if (hasModelTransformation) {
            if (rasterType == GeoTiffConstants.RasterPixelIsArea) {
                final AffineTransform tempTransform =
                        new AffineTransform(metadata.getModelTransformation());
                if (forceToCellCenter) tempTransform.concatenate(PixelIsArea2PixelIsPoint);
                xform = ProjectiveTransform.create(tempTransform);

            } else {
                assert rasterType == GeoTiffConstants.RasterPixelIsPoint;
                xform = ProjectiveTransform.create(metadata.getModelTransformation());
            }
        } else throw new GeoTiffException(metadata, "Unknown Raster to Model configuration.", null);

        return xform;
    }

