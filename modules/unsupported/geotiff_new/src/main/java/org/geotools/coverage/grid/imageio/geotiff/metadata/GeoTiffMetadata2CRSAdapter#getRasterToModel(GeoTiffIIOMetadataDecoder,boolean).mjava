	/**
	 * Create the grid to world (or raster to model) transformation for this
	 * sourceFile which is placed at the centre of the pixel rather at the corner.
	 * 
	 * @param metadata
	 *            containing the information to build the {@link MathTransform}
	 *            for going from grid to world.
	 * @param forceToCellCenter if <code>true</code>, force to create the raster to model
	 * transformation respecting the OGC {@link PixelInCell#CELL_CENTER}
         * convention for the {@link ImageDatum} of the underlying {@link ImageCRS}.
	 * 
	 * @throws GeoTiffException
	 */
	public static MathTransform getRasterToModel(
			final GeoTiffIIOMetadataDecoder metadata, 
			final boolean forceToCellCenter) throws GeoTiffException {
		//
		// Load initials
		//
		final boolean hasTiePoints = metadata.hasTiePoints();
		final boolean hasPixelScales = metadata.hasPixelScales();
		final boolean hasModelTransformation = metadata.hasModelTrasformation();
		int rasterType = getGeoKeyAsInt(GeoTiffConstants.GTRasterTypeGeoKey,metadata);
		// geotiff spec says that PixelIsArea is the default
		if (rasterType == GeoTiffConstants.UNDEFINED)
			rasterType = GeoTiffConstants.RasterPixelIsArea;
		MathTransform xform = null;
		if (hasTiePoints && hasPixelScales) {
			
			//
			// we use tie points and pixel scales to build the grid to world
			//
			// model space
			final TiePoint[] tiePoints = metadata.getModelTiePoints();
			final PixelScale pixScales = metadata.getModelPixelScales();



			// here is the matrix we need to build
			final GeneralMatrix gm = new GeneralMatrix(3);
			final double scaleRaster2ModelLongitude = pixScales.getScaleX();
			final double scaleRaster2ModelLatitude = -pixScales.getScaleY();
			// "raster" space 
			final double tiePointColumn = tiePoints[0].getValueAt(0)
					+ ((forceToCellCenter || rasterType == GeoTiffConstants.RasterPixelIsArea) ? - 0.5: 0); 
			
			// coordinates
			// (indicies)
			final double tiePointRow = tiePoints[0].getValueAt(1)
					+ ((forceToCellCenter || rasterType == GeoTiffConstants.RasterPixelIsArea) ? - 0.5: 0);

			// compute an "offset and scale" matrix
			gm.setElement(0, 0, scaleRaster2ModelLongitude);
			gm.setElement(1, 1, scaleRaster2ModelLatitude);
			gm.setElement(0, 1, 0);
			gm.setElement(1, 0, 0);

			gm.setElement(0, 2, tiePoints[0].getValueAt(3)
					- (scaleRaster2ModelLongitude * tiePointColumn));
			gm.setElement(1, 2, tiePoints[0].getValueAt(4)
					- (scaleRaster2ModelLatitude * tiePointRow));

			// make it a LinearTransform
			xform = ProjectiveTransform.create(gm);

		} else if (hasModelTransformation) {
                    if (rasterType == GeoTiffConstants.RasterPixelIsArea){
                        final AffineTransform tempTransform = new AffineTransform(
                                metadata.getModelTransformation());
                        if (forceToCellCenter)
                            tempTransform.concatenate(PixelIsArea2PixelIsPoint);
                        xform = ProjectiveTransform.create(tempTransform);
                            
                    }
                    else {
                        assert rasterType == GeoTiffConstants.RasterPixelIsPoint;
                        xform = ProjectiveTransform.create(metadata
                                    .getModelTransformation());

                    }
                } else
                    throw new GeoTiffException(metadata,
                                    "Unknown Raster to Model configuration.", null);

                return xform;
	}

