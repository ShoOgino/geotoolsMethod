    /**
     * This method loads the granules which overlap the requested {@link GeneralEnvelope} using 
     * the provided values for alpha and input ROI.
     */
    private RenderedImage prepareResponse() throws DataSourceException {

        try {

            // select the relevant overview, notice that at this time we have relaxed a bit the 
            // requirement to have the same exact resolution for all the overviews, but still we 
            // do not allow for reading the various grid to world transform directly from the 
            // input files, therefore we are assuming that each granuleDescriptor has a scale 
            // and translate only grid to world that can be deduced from its base level dimension 
            // and envelope. The grid to world transforms for the other levels can be computed 
            // accordingly knowning the scale factors.
            if (request.getRequestedBBox() != null && request.getRequestedRasterArea() != null) {
                imageChoice = setReadParams(request.getOverviewPolicy(), baseReadParameters, request);
            } else {
                imageChoice = 0;
            }
            assert imageChoice >= 0;
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Loading level " + imageChoice + " with subsampling factors "
                        + baseReadParameters.getSourceXSubsampling() + " "
                        + baseReadParameters.getSourceYSubsampling());
            }

            final BoundingBox cropBBOX = request.getCropBBox();
            if (cropBBOX != null) {
                finalBBox = ReferencedEnvelope.reference(cropBBOX);
            } else {
                finalBBox = new ReferencedEnvelope(coverageEnvelope);
            }

            
            // compute final world to grid
            
//            // base grid to world for the center of pixels
//            final AffineTransform g2w;
//            final OverviewLevel baseLevel = rasterManager.overviewsController.resolutionsLevels.get(0);
//            final OverviewLevel selectedLevel = rasterManager.overviewsController.resolutionsLevels.get(imageChoice);
//            final double resX = baseLevel.resolutionX;
//            final double resY = baseLevel.resolutionY;
//            final double[] requestRes = request.getRequestedResolution();
//
//            g2w = new AffineTransform((AffineTransform) baseGridToWorld);
//            g2w.concatenate(CoverageUtilities.CENTER_TO_CORNER);
//            
//            if ((requestRes[0] < resX || requestRes[1] < resY) ) {
//                // Using the best available resolution
//                oversampledRequest = true;
//            } else {
//                    
//                // SG going back to working on a per level basis to do the composition
//                // g2w = new AffineTransform(request.getRequestedGridToWorld());
//                g2w.concatenate(AffineTransform.getScaleInstance(selectedLevel.scaleFactor,selectedLevel.scaleFactor));
//                g2w.concatenate(AffineTransform.getScaleInstance(baseReadParameters.getSourceXSubsampling(), baseReadParameters.getSourceYSubsampling()));
//            }
            
            // compute final world to grid base grid to world for the center of pixels
            final AffineTransform g2w = new AffineTransform((AffineTransform) baseGridToWorld);
            // move it to the corner
            g2w.concatenate(CoverageUtilities.CENTER_TO_CORNER);

            // keep into account overviews and subsampling
            final OverviewLevel level = rasterManager.overviewsController.resolutionsLevels.get(imageChoice);
            final OverviewLevel baseLevel = rasterManager.overviewsController.resolutionsLevels.get(0);
            final AffineTransform2D adjustments = new AffineTransform2D(
                    (level.resolutionX / baseLevel.resolutionX)
                            * baseReadParameters.getSourceXSubsampling(), 0, 0,
                    (level.resolutionY / baseLevel.resolutionY)
                            * baseReadParameters.getSourceYSubsampling(), 0, 0);
            g2w.concatenate(adjustments);
            
            // move it to the corner
            finalGridToWorldCorner = new AffineTransform2D(g2w);
            finalWorldToGridCorner = finalGridToWorldCorner.inverse();            
            final GeneralEnvelope tempRasterBounds = CRS.transform(finalWorldToGridCorner, finalBBox);
            rasterBounds=tempRasterBounds.toRectangle2D().getBounds();
            if (rasterBounds.width == 0)
                rasterBounds.width++;
            if (rasterBounds.height == 0)
                rasterBounds.height++;
            
            final double[] requestRes = request.getRequestedResolution();
            final double resX = baseLevel.resolutionX;
            final double resY = baseLevel.resolutionY;            
            if ((requestRes[0] < resX || requestRes[1] < resY) ) {
                // Using the best available resolution
                oversampledRequest = true;
            }             
            if(oversampledRequest)
                rasterBounds.grow(2, 2);            


            RasterProducer rasterProducer = new RasterProducer();
            rasterProducer.produce();

            //
            // Did we actually load anything?? Notice that it might happen that either we have 
            // wholes inside the definition area for the image or we had some problem with 
            // missing tiles, therefore it might happen that for some bboxes we don't have 
            // anything to load.
            //
            if (theImage != null) {

                //
                // Create the mosaic image by doing a crop if necessary and also managing the 
                // transparent color if applicable. Be aware that management of the transparent 
                // color involves removing transparency information from the input images.
                //
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Loaded finalBBox " + finalBBox.toString()
                            + " while crop finalBBox " + request.getCropBBox());
                }

                return theImage;

            } else {
                // if we get here that means that we do not have anything to load
                // but still we are inside the definition area for the mosaic,
                // therefore we create a fake coverage using the background values,
                // if provided (defaulting to 0), as well as the compute raster
                // bounds, envelope and grid to world.

                final Number[] values = ImageUtilities.getBackgroundValues(rasterManager.defaultSM, backgroundValues);
                // create a constant image with a proper layout
                final RenderedImage finalImage = ConstantDescriptor.create(
                        Float.valueOf(rasterBounds.width),
                        Float.valueOf(rasterBounds.height),
                        values,
                        null);
                if(rasterManager.defaultCM!=null){
                    final ImageLayout2 il= new ImageLayout2();
                    il.setColorModel(rasterManager.defaultCM);
                    Dimension tileSize= request.getTileDimensions();
                    if(tileSize==null){
                        tileSize=JAI.getDefaultTileSize();
                    } 
                    il.setSampleModel(rasterManager.defaultCM.createCompatibleSampleModel(tileSize.width, tileSize.height));
                    il.setTileGridXOffset(0).setTileGridYOffset(0).setTileWidth((int)tileSize.getWidth()).setTileHeight((int)tileSize.getHeight());
                    return FormatDescriptor.create(
                            finalImage,
                            Integer.valueOf(il.getSampleModel(null).getDataType()),
                            new RenderingHints(JAI.KEY_IMAGE_LAYOUT,il));
                }
                return finalImage;
            }

        } catch (IOException e) {
            throw new DataSourceException("Unable to create this mosaic", e);
        } catch (TransformException e) {
            throw new DataSourceException("Unable to create this mosaic", e);
        }
    }

