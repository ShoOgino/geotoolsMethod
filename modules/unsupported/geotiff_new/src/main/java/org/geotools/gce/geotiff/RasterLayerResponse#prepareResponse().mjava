	/**
	 * This method loads the granules which overlap the requested
	 * {@link GeneralEnvelope} using the provided values for alpha and input
	 * ROI.
	 */
	private RenderedImage prepareResponse() throws DataSourceException {

		try {

			
			//
			// prepare the params for executing a mosaic operation.
			//
			final double[] backgroundValues = request.getBackgroundValues();

			// select the relevant overview, notice that at this time we have
			// relaxed a bit the requirement to have the same exact resolution
			// for all the overviews, but still we do not allow for reading the
			// various grid to world transform directly from the input files,
			// therefore we are assuming that each rasterGranuleLoader has a scale and
			// translate only grid to world that can be deduced from its base
			// level dimension and envelope. The grid to world transforms for
			// the other levels can be computed accordingly knowning the scale
			// factors.
			if (request.getRequestedBBox() != null&& request.getRequestedRasterArea() != null)
				imageChoice = setReadParams(request.getOverviewPolicy(), baseReadParameters,request);
			else
				imageChoice = 0;
			assert imageChoice>=0;
			if (LOGGER.isLoggable(Level.FINE))
				LOGGER.fine("Loading level "+imageChoice+" with subsampling factors "+baseReadParameters.getSourceXSubsampling()
				        +" "+baseReadParameters.getSourceYSubsampling());			
			
			
			final BoundingBox cropBBOX = request.getCropBBox();
			if (cropBBOX != null)
				bbox = ReferencedEnvelope.reference(cropBBOX);
			else
				bbox = new ReferencedEnvelope(coverageEnvelope);
			
			XAffineTransform.getFlip((AffineTransform) baseGridToWorld);
			//compute final world to grid
			// base grid to world for the center of pixels
			final AffineTransform g2w = new AffineTransform((AffineTransform) baseGridToWorld);
			// move it to the corner
			g2w.concatenate(CoverageUtilities.CENTER_TO_CORNER);
			
			//keep into account overviews and subsampling
			final OverviewLevel level = rasterManager.overviewsController.resolutionsLevels.get(imageChoice);
			final OverviewLevel baseLevel = rasterManager.overviewsController.resolutionsLevels.get(0);
			final AffineTransform2D adjustments = new AffineTransform2D(
					(level.resolutionX/baseLevel.resolutionX)*baseReadParameters.getSourceXSubsampling(),
					0,
					0,
					(level.resolutionY/baseLevel.resolutionY)*baseReadParameters.getSourceYSubsampling(),
					0,
					0);
			g2w.concatenate(adjustments);
			finalGridToWorldCorner=new AffineTransform2D(g2w);
			finalWorldToGridCorner = finalGridToWorldCorner.inverse();// compute raster bounds
			rasterBounds=new GeneralGridEnvelope(CRS.transform(finalWorldToGridCorner, bbox),PixelInCell.CELL_CORNER,false).toRectangle();
			
			
			final GranuleWorker worker = new GranuleWorker(new ReferencedEnvelope(coverageEnvelope),baseGridToWorld);
			worker.produce();
			
			//
			// Did we actually load anything?? Notice that it might happen that
			// either we have wholes inside the definition area for the image
			// or we had some problem with missing tiles, therefore it might
			// happen that for some bboxes we don't have anything to load.
			//
			if (theImage!=null) {

				//
				// Create the mosaic image by doing a crop if necessary and also
				// managing the transparent color if applicable. Be aware that
				// management of the transparent color involves removing
				// transparency information from the input images.
				// 
				if (LOGGER.isLoggable(Level.FINE))
					LOGGER.fine("Loaded bbox "+
							bbox.toString()+" while crop bbox "+request.getCropBBox());
				
				
				return theImage;				
			
			}
			else{
				// if we get here that means that we do not have anything to load
				// but still we are inside the definition area for the mosaic,
				// therefore we create a fake coverage using the background values,
				// if provided (defaulting to 0), as well as the compute raster
				// bounds, envelope and grid to world.
				
			    // create proper layout hint
			    final ImageLayout2 il= new ImageLayout2();
			    il.setSampleModel(rasterManager.baseImageType.getSampleModel()).setColorModel(rasterManager.baseImageType.getColorModel());
			    
			    final Hints hints = new Hints(rasterManager.getHints());
			    hints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT, il));
			    
	
				if (backgroundValues == null)
					
					//we don't have background values available
				    // TODO use code to suggest NO Data Value
					return ConstantDescriptor.create(
									Float.valueOf(rasterBounds.width), 
									Float.valueOf(rasterBounds.height),
									new Number[]{CoverageUtilities.suggestNoDataValue(rasterManager.baseImageType.getSampleModel().getDataType())},
									hints);
				else {
					
					//we have background values available
					final Double[] values = new Double[backgroundValues.length];
					for (int i = 0; i < values.length; i++)
						values[i] = backgroundValues[i];
					return ConstantDescriptor.create(
									Float.valueOf(rasterBounds.width), 
									Float.valueOf(rasterBounds.height),
									values, 
									hints);
				}
			}

		} catch (IOException e) {
			throw new DataSourceException("Unable to create this mosaic", e);
		} catch (TransformException e) {
			throw new DataSourceException("Unable to create this mosaic", e);
		} 
	}

