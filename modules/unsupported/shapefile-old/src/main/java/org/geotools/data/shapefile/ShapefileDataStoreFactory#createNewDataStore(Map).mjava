    /**
     * Creates a new DataStore - for a file that does not exist yet.
     * <p>
     * This method has different logic than createDataStore. It is willing to be
     * memory mapped, and generate an index for a local file that does not exist
     * yet.
     * 
     */
    public DataStore createNewDataStore(Map params) throws IOException {
        // basic param lookup
        URL url = (URL) URLP.lookUp(params);
        Boolean isMemoryMapped = (Boolean) MEMORY_MAPPED.lookUp(params);
        Boolean cacheMemoryMaps = (Boolean) CACHE_MEMORY_MAPS.lookUp(params);
        URI namespace = (URI) NAMESPACEP.lookUp(params);
        Charset dbfCharset = (Charset) DBFCHARSET.lookUp(params);
        TimeZone dbfTimeZone = (TimeZone) DBFTIMEZONE.lookUp(params);
        Boolean isCreateSpatialIndex = (Boolean) CREATE_SPATIAL_INDEX.lookUp(params);
        Boolean isEnableSpatialIndex = (Boolean) ENABLE_SPATIAL_INDEX.lookUp(params);
        if (isEnableSpatialIndex == null) {
            // should not be needed as default is TRUE
            isEnableSpatialIndex = Boolean.TRUE;
        }
        if (isCreateSpatialIndex == null) {
            // should not be needed as default is TRUE
            assert (true);
            isCreateSpatialIndex = Boolean.TRUE;
        }
        if (dbfCharset == null) {
            assert (true);
            // this should not happen as Charset.forName("ISO-8859-1") was used
            // as the param default?
            dbfCharset = Charset.forName("ISO-8859-1");
        }
        if(dbfTimeZone == null) {
        	dbfTimeZone = TimeZone.getDefault();
        }
        if (isMemoryMapped == null) {
            assert (true);
            // this should not happen as false was the default
            isMemoryMapped = Boolean.FALSE;
        }
        if (cacheMemoryMaps == null) {
        	cacheMemoryMaps = Boolean.FALSE;
        }
        
        // are we creating a directory of shapefiles store, or a single one?
        File dir = DataUtilities.urlToFile(url);
        if(dir != null && dir.isDirectory()) {
            return new DirectoryDataStore(DataUtilities.urlToFile(url), new ShpFileStoreFactory(this, params));
        } else {
            ShpFiles shpFiles = new ShpFiles(url);
    
            boolean isLocal = shpFiles.isLocal();
            boolean useMemoryMappedBuffer = isLocal
                    && isMemoryMapped.booleanValue();
            boolean enableIndex = isEnableSpatialIndex.booleanValue() && isLocal;
            boolean createIndex = isCreateSpatialIndex.booleanValue() && isLocal;
    
            try {
            	ShapefileDataStore store;
                if (enableIndex) {
                    store = new IndexedShapefileDataStore(url, namespace,
                            useMemoryMappedBuffer, cacheMemoryMaps, createIndex, IndexType.QIX, dbfCharset);
                } else {
                    store = new ShapefileDataStore(url, namespace,
                            useMemoryMappedBuffer, cacheMemoryMaps, dbfCharset);
                }
                store.setDbftimeZone(dbfTimeZone);
                return store;
            } catch (MalformedURLException mue) {
                throw new DataSourceException(
                        "Url for shapefile malformed: " + url, mue);
            }
        }
    }

