    @Test
    public void rasterizePolygons() throws Exception {
        SimpleFeatureCollection features = createPolys();
        ReferencedEnvelope bounds = features.getBounds();

        Dimension gridDim = new Dimension((int) bounds.getWidth(), (int) bounds.getHeight());

        String covName = "Test";
        ProgressListener monitor = null;

        GridCoverage2D cov =
                VectorToRasterProcess.process(features, "value", gridDim, bounds, covName, monitor);

        // textPrint(cov);

        /*
         * Compare the coverage to the input features. We are expecting
         * to see the two small rectangles (values 1 and 3) 'on top' of
         * the larger rectangle (value 2)
         */
        Map<Integer, Envelope> rects = new HashMap<>();
        SimpleFeatureIterator iter = features.features();
        while (iter.hasNext()) {
            SimpleFeature sf = iter.next();
            rects.put(
                    (Integer) sf.getAttribute("value"),
                    ((Geometry) sf.getDefaultGeometry()).getEnvelopeInternal());
        }

        try {
            MathTransform2D mt = cov.getGridGeometry().getGridToCRS2D(PixelOrientation.CENTER);
            Point gridP = new Point();
            Point2D.Double geoP = new Point2D.Double();
            int[] covValue = new int[1];
            for (gridP.y = 0; gridP.y < gridDim.height; gridP.y++) {
                for (gridP.x = 0; gridP.x < gridDim.width; gridP.x++) {
                    mt.transform(gridP, geoP);
                }

                cov.evaluate(geoP, covValue);
                if (covValue[0] != 0) {
                    assertTrue(rects.get(covValue[0]).contains(geoP.x, geoP.y));
                }
            }

        } catch (TransformException tex) {
            throw new RuntimeException(tex);
        }
    }

