    /**
     * Computes the grid index for a point for the grid determined by the cellsize.
     * 
     * @param griddedPt the point to grid, and also holds the output value
     * @param cellSize the grid cell size
     */
    private void gridIndex(Coordinate griddedPt, double cellSize) {
        
        // TODO: is there any situation where this could result in too much loss of precision?  
        /**
         * The grid is based at the origin of the entire data space, 
         * not just the query window.
         * This makes gridding stable during panning.
         * 
         * This should not lose too much precision for any reasonable coordinate system and map size.
         * The worst case is a CRS with small ordinate values, and a large cell size.
         * The worst case tested is a map in degrees, zoomed out to show about twice the globe - works fine.
         */
        // Use longs to avoid possible overflow issues (e.g. for a very small cell size)
        long ix = (long) ((griddedPt.x) / cellSize);
        long iy = (long) ((griddedPt.y) / cellSize);
        
        griddedPt.x = ix;
        griddedPt.y = iy;
    }

