    /**
     * Computes the grid index for a point for the grid determined by the cellsize.
     *
     * @param griddedPt the point to grid, and also holds the output value
     * @param cellSize the grid cell size
     */
    private void gridIndex(Coordinate griddedPt, double cellSize) {

        // TODO: is there any situation where this could result in too much loss
        // of precision?
        /**
         * The grid is based at the origin of the entire data space, not just the query window. This
         * makes gridding stable during panning.
         *
         * <p>This should not lose too much precision for any reasonable coordinate system and map
         * size. The worst case is a CRS with small ordinate values, and a large cell size. The
         * worst case tested is a map in degrees, zoomed out to show about twice the globe - works
         * fine.
         */
        // Use longs to avoid possible overflow issues (e.g. for a very small
        // cell size)
        long ix = (long) ((griddedPt.x) / cellSize);
        long iy = (long) ((griddedPt.y) / cellSize);

        griddedPt.x = ix;
        griddedPt.y = iy;
    }

