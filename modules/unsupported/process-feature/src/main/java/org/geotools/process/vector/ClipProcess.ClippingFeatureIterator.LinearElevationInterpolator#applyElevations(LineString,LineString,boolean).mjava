            private void applyElevations(LineString ls, LineString original, boolean tolerant) {
                // do we have any elevation to bring on the new line?
                if (!hasElevations(original.getCoordinateSequence())) {
                    return;
                }

                // let's do a synched scan of the two lines
                CoordinateSequence cs = ls.getCoordinateSequence();
                CoordinateSequence csOrig = original.getCoordinateSequence();
                Coordinate c1 = cs.getCoordinate(0);
                Coordinate c2 = cs.getCoordinate(1);
                int localIdx = 0;
                Coordinate o1 = csOrig.getCoordinate(0);
                Coordinate o2 = csOrig.getCoordinate(1);
                int origIdx = 0;
                RobustLineIntersector intersector = new RobustLineIntersector();
                int matched = 0;
                boolean flipped = false;
                // search the fist segment of the origin that contains the first segment of the
                // local
                for (; ; ) {
                    intersector.computeIntersection(c1, c2, o1, o2);
                    int intersectionNum = intersector.getIntersectionNum();
                    // doing these checks for any non collinear point is expensive, do it only if
                    // there is at least one intersection
                    // or if we're in tolerant mode
                    if (intersectionNum == LineIntersector.POINT_INTERSECTION
                            || (tolerant && intersectionNum != LineIntersector.COLLINEAR)) {
                        // this one might be due to a numerical issue, where the two lines to do
                        // intersect
                        // exactly, but almost. Let's compute the distance and see
                        LineSegment segment = new LineSegment(o1, o2);
                        double d1 = segment.distance(c1);
                        double d2 = segment.distance(c2);
                        if (d1 <= PointDistance.EPS_METERS && d2 <= PointDistance.EPS_METERS) {
                            intersectionNum = LineIntersector.COLLINEAR;
                        }
                    }
                    if (intersectionNum == LineIntersector.COLLINEAR) {
                        matched++;
                        applyZValues(cs, localIdx, csOrig, origIdx);
                        localIdx++;
                        if (localIdx == cs.size() - 1) {
                            // we reached the end, apply the Z also on the second ordinate
                            // of the segment and exit
                            applyZValues(cs, localIdx, csOrig, origIdx);
                            break;
                        } else {
                            c1 = c2;
                            c2 = cs.getCoordinate(localIdx + 1);
                        }
                    } else {
                        origIdx++;
                        if (origIdx >= csOrig.size() - 1) {
                            if (!flipped) {
                                // it may be that the two lines have different orientations, we'll
                                // flip ls and
                                // start back
                                ls = ls.reverse();
                                cs = ls.getCoordinateSequence();
                                flipped = true;
                                c1 = cs.getCoordinate(0);
                                c2 = cs.getCoordinate(1);
                                localIdx = 0;
                                o1 = csOrig.getCoordinate(0);
                                o2 = csOrig.getCoordinate(1);
                                origIdx = 0;
                            } else {
                                throw new ClippingException(
                                        "Could not find collinear segments between "
                                                + ls.toText()
                                                + "\n and \n"
                                                + original.toText()
                                                + "\n after matching "
                                                + matched
                                                + " points");
                            }
                        } else {
                            o1 = o2;
                            o2 = csOrig.getCoordinate(origIdx + 1);
                        }
                    }
                }
            }

