            @Override
            public void filter(CoordinateSequence seq, int i) {
                if (elevations == null) {
                    return;
                }

                if (seq.getDimension() < 3) {
                    throw new IllegalArgumentException(
                            "Expecting a 3 dimensional coordinate sequence to re-apply the Z values");
                }
                double x = seq.getX(i);
                double y = seq.getY(i);

                for (PointDistance pd : elevations) {
                    double distance = pd.updateDistance(x, y, crs);
                    // did we match an existing point?
                    if (distance < PointDistance.EPS_METERS) {
                        // copy over the z and bail out
                        seq.setOrdinate(i, 2, pd.c.getZ());
                        return;
                    }
                }

                // ok, we need to apply the IDW interpolation for this point
                Collections.sort(elevations);
                double sum = 0;
                double weights = 0;
                final int usedPoints = Math.min(MAX_POINTS, elevations.size());
                for (int j = 0; j < usedPoints; j++) {
                    PointDistance pd = elevations.get(j);
                    sum += pd.c.getZ() / pd.squareDistance;
                    weights += 1 / pd.squareDistance;
                }
                double z = sum / weights;
                // apply safe rounding to avoid numerical issues with the above calculation due
                // to the weights being, often, very small numbers
                BigDecimal bd = BigDecimal.valueOf(z);
                double rz = bd.setScale(scale, BigDecimal.ROUND_HALF_EVEN).doubleValue();
                seq.setOrdinate(i, 2, rz);
            }

