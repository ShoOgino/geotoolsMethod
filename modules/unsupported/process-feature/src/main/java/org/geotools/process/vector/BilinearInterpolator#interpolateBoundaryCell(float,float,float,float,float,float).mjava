    /**
     * Interpolates across an edge grid cell, which has 1 or more NO_DATA values. Grid cells with 2
     * or or NO_DATA values still receive the value NO_DATA. Otherwise, the cell is interpolated
     * across the triangle defined by the 3 valid corner values. This produces a much smoother edge
     * appearance, containing 45-degree lines instead of a jagged stairstep boundary.
     *
     * @param xfrac the fractional x location of the interpolation point within the cell
     * @param yfrac the fractional y location of the interpolation point within the cell
     * @param v00 the lower left value
     * @param v10 the lower right value
     * @param v01 the upper left value
     * @param v11 the upper right value
     * @return the interpolated value
     */
    private float interpolateBoundaryCell(
            float xfrac, float yfrac, float v00, float v10, float v01, float v11) {
        // count noData values
        int count = 0;
        if (v00 == noDataValue) count++;
        if (v10 == noDataValue) count++;
        if (v01 == noDataValue) count++;
        if (v11 == noDataValue) count++;

        /** Cells with >= 2 noData ==> noData */
        if (count > 1) return noDataValue;

        /**
         * Now only one cell has noData value. Compute interpolation over cell, with vertex layout
         * normalized to put noData in NE. This is done by flipping the cell across the X or Y axis,
         * or both (and transforming the point offsets likewise)
         */
        if (v00 == noDataValue)
            return interpolateBoundaryCellNorm(1.0f - yfrac, 1.0f - xfrac, v11, v10, v01);
        if (v11 == noDataValue) return interpolateBoundaryCellNorm(xfrac, yfrac, v00, v10, v01);
        if (v10 == noDataValue)
            return interpolateBoundaryCellNorm(xfrac, 1.0f - yfrac, v01, v11, v00);
        if (v01 == noDataValue)
            return interpolateBoundaryCellNorm(1.0f - xfrac, yfrac, v10, v00, v11);

        // should never reach here
        return noDataValue;
    }

