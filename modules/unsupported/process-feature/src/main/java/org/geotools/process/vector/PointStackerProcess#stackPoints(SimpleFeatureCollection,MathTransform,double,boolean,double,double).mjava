    /**
     * Computes the stacked points for the given data collection. All geometry types are handled -
     * for non-point geometries, the centroid is used.
     */
    private Collection<StackedPoint> stackPoints(
            SimpleFeatureCollection data,
            MathTransform crsTransform,
            double cellSize,
            boolean weightClusterPosition,
            double minX,
            double minY)
            throws TransformException {

        Map<Coordinate, StackedPoint> stackedPts = new HashMap<>();

        double[] srcPt = new double[2];
        double[] dstPt = new double[2];

        Coordinate indexPt = new Coordinate();
        try (SimpleFeatureIterator featureIt = data.features()) {
            while (featureIt.hasNext()) {
                SimpleFeature feature = featureIt.next();
                // get the point location from the geometry
                Geometry geom = (Geometry) feature.getDefaultGeometry();
                Coordinate p = getRepresentativePoint(geom);

                // reproject data point to output CRS, if required
                srcPt[0] = p.x;
                srcPt[1] = p.y;
                crsTransform.transform(srcPt, 0, dstPt, 0, 1);
                Coordinate pout = new Coordinate(dstPt[0], dstPt[1]);

                indexPt.x = pout.x;
                indexPt.y = pout.y;
                gridIndex(indexPt, cellSize);

                StackedPoint stkPt = stackedPts.get(indexPt);
                if (stkPt == null) {

                    /** Note that we compute the cluster position in the middle of the grid */
                    double centreX = indexPt.x * cellSize + cellSize / 2;
                    double centreY = indexPt.y * cellSize + cellSize / 2;

                    stkPt = new StackedPoint(indexPt, new Coordinate(centreX, centreY));
                    stackedPts.put(stkPt.getKey(), stkPt);
                }
                stkPt.add(pout, weightClusterPosition);
            }
        }
        return stackedPts.values();
    }

