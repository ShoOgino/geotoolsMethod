        /**
         * Returns a list of scale dependent filters that represent the difference (the uncovered
         * area) between this {@link SLDSelector} and then specified rule
         *
         * @param rule
         * @return
         */
        public List<SLDSelector> difference(SLDSelector other) {
            List<SLDSelector> result = new ArrayList<>();

            // fast interaction tests
            if (!this.scaleRange.intersects(other.scaleRange)) {
                return Collections.singletonList(this);
            }

            // first case, portions of scale range not overlapping
            NumberRange<?>[] scaleRangeDifferences = this.scaleRange.subtract(other.scaleRange);
            for (NumberRange<?> scaleRangeDifference : scaleRangeDifferences) {
                result.add(new SLDSelector(scaleRangeDifference, this.filter));
            }

            // second case, scale ranges overlapping, but filter/pseudoclass not
            NumberRange<?> scaleRangeIntersection = this.scaleRange.intersect(other.scaleRange);
            if (scaleRangeIntersection != null && !scaleRangeIntersection.isEmpty()) {
                And difference = FF.and(this.filter, FF.not(other.filter));
                Filter simplifiedDifference = simplify(difference);
                if (simplifiedDifference != Filter.EXCLUDE) {
                    result.add(new SLDSelector(scaleRangeIntersection, simplifiedDifference));
                }
            }

            return result;
        }

