        /**
         * Returns a list of scale dependent filters that represent the difference (the uncovered
         * area) between this {@link SLDSelector} and then specified rule
         * 
         * @param rule
         * @return
         */
        public List<SLDSelector> difference(SLDSelector other) {
            List<SLDSelector> result = new ArrayList<>();

            // first case, portions of scale range not overlapping
            NumberRange<?>[] scaleRangeDifferences = this.scaleRange.subtract(other.scaleRange);
            for (NumberRange<?> scaleRangeDifference : scaleRangeDifferences) {
                result.add(new SLDSelector(scaleRangeDifference, this.filter));
            }

            // second case, scale ranges overlapping, but filter/pseudoclass not
            NumberRange<?> scaleRangeIntersection = this.scaleRange.intersect(other.scaleRange);
            if (scaleRangeIntersection != null && !scaleRangeIntersection.isEmpty()) {
                Filter filterDifference = simplify(FF.and(this.filter, FF.not(other.filter)));
                if (filterDifference != Filter.EXCLUDE) {
                    result.add(new SLDSelector(scaleRangeIntersection, filterDifference));
                }
            }

            return result;
        }

