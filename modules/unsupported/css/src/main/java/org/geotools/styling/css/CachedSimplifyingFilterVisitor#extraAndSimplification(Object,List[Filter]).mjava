    protected List<Filter> extraAndSimplification(Object extraData, List<Filter> filters) {
        if (filters.size() > 1) {
            // if there are nested ors and top level filters, try factoring out common expression,
            // e.g., (A | B) & A -> A
            Set<Filter> topLevel = new HashSet<>();
            for (Filter filter : filters) {
                if (!(filter instanceof Or)) {
                    topLevel.add(filter);
                }
            }
            for (int i = 0; i < filters.size(); ) {
                Filter f = filters.get(i);
                boolean skip = false;
                if (f instanceof Or) {
                    Or or = ((Or) f);
                    for (Filter child : or.getChildren()) {
                        if (topLevel.contains(child)) {
                            skip = true;
                            break;
                        }
                    }
                }
                if (skip) {
                    filters.remove(i);
                } else {
                    i++;
                }
            }
        }
        // if there are nested Ors, try distribution, see if this helps reduce the
        // overall expression
        if (filters.size() > 1) {
            for (int i = 0; i < filters.size(); i++) {
                Filter f = filters.get(i);
                if (f instanceof Or) {
                    Or or = ((Or) f);
                    Filter reduced = null;
                    boolean twoOrMore = false;
                    for (Filter child : or.getChildren()) {
                        List<Filter> newList = new ArrayList<>(filters);
                        newList.remove(or);
                        newList.add(child);
                        And and = getFactory(extraData).and(newList);
                        Filter simplified = (Filter) and.accept(this, extraData);
                        if (simplified == Filter.EXCLUDE) {
                            continue;
                        } else if (simplified == Filter.INCLUDE) {
                            return Collections.singletonList(Filter.INCLUDE);
                        } else if (reduced == null) {
                            reduced = simplified;
                        } else if (!simplified.equals(reduced)) {
                            twoOrMore = true;
                            break;
                        }
                    }

                    if (reduced == null) {
                        return Collections.singletonList(Filter.EXCLUDE);
                    } else if (!twoOrMore) {
                        filters.clear();
                        if (!(reduced instanceof And)) {
                            return Collections.singletonList(reduced);
                        } else {
                            filters.addAll(((And) reduced).getChildren());
                            filters = basicAndSimplification(filters);
                            // this assumes we'll never stumble into a single children "or",
                            // because those are simplified out at the beginning of this procedure
                            i = 0;
                        }
                    }
                }
            }
        }
        return filters;
    }

