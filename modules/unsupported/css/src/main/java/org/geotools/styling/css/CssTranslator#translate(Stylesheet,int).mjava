    /**
     * Translates a CSS stylesheet into an equivalent GeoTools {@link Style} object
     * 
     * @param stylesheet
     * @return
     */
    public Style translate(Stylesheet stylesheet, int maxCombinations) {
        List<CssRule> allRules = stylesheet.getRules();

        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Starting with " + allRules.size() + "  rules in the stylesheet");
        }

        // prepare the full SLD builder
        StyleBuilder styleBuilder = new StyleBuilder();
        styleBuilder.name("Default Styler");

        // split rules by index and typename, then build the power set for each group and
        // generate the rules and symbolizers
        List<List<CssRule>> zIndexRules = organizeByZIndex(allRules);

        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Split the rules into " + zIndexRules + "  sets after z-index separation");
        }

        for (List<CssRule> rules : zIndexRules) {
            Collections.sort(rules, Collections.reverseOrder(new CssRuleComparator()));
            Map<String, List<CssRule>> typenameRules = organizeByTypeName(rules);

            // build the SLD
            for (Map.Entry<String, List<CssRule>> entry : typenameRules.entrySet()) {
                // create the feature type style for this typename
                FeatureTypeStyleBuilder ftsBuilder = styleBuilder.featureTypeStyle();
                String featureTypeName = entry.getKey();
                List<CssRule> localRules = entry.getValue();
                if (featureTypeName != null) {
                    ftsBuilder.setFeatureTypeNames(Arrays.asList((Name) new NameImpl(
                            featureTypeName)));
                }
                final FeatureType targetFeatureType = getTargetFeatureType(featureTypeName,
                        localRules);
                if (targetFeatureType != null) {
                    // attach the target feature type to all Data selectors to allow range based
                    // simplification
                    for (CssRule rule : localRules) {
                        rule.getSelector().accept(new AbstractSelectorVisitor() {
                            @Override
                            public Object visit(Data data) {
                                data.featureType = targetFeatureType;
                                return super.visit(data);
                            }
                        });
                    }
                }

                // at this point we can have rules with selectors having two scale ranges
                // in or, we should split them, as we cannot represent them in SLD
                // (and yes, this changes their selectivity a bit, could not find a reasonable
                // solution out of this so far, past the power set we might end up with
                // and and of two selectors, that internally have ORs of scales, which could
                // be quite complicated to un-tangle)
                List<CssRule> flattenedRules = flattenScaleRanges(localRules);

                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Preparing power set expansion with " + flattenedRules.size()
                            + "  rules for feature type: " + featureTypeName);
                }

                // expand the css rules power set
                RulePowerSetBuilder builder = new RulePowerSetBuilder(flattenedRules,
                        maxCombinations);
                List<CssRule> combinedRules = builder.buildPowerSet();

                Collections.sort(combinedRules, Collections.reverseOrder(new CssRuleComparator()));

                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Generated " + combinedRules.size()
                            + " combined rules after filtered power set expansion");
                }

                // create a SLD rule for each css one, making them exclusive, that is,
                // remove from each rule the union of the zoom/data domain matched by previous rules
                DomainCoverage coverage = new DomainCoverage(targetFeatureType);
                for (int i = 0; i < combinedRules.size(); i++) {
                    // skip eventual combinations that are not sporting any
                    // root pseudo class
                    CssRule cssRule = combinedRules.get(i);
                    if (!cssRule.hasSymbolizerProperty()) {
                        continue;
                    }
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine("Current domain coverage: " + coverage);
                        LOGGER.fine("Adding rule to domain coverage: " + cssRule);
                        LOGGER.fine("Rules left to process: " + (combinedRules.size() - i));
                    }
                    List<CssRule> derivedRules = coverage.addRule(cssRule);
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine("Derived rules not yet covered in domain coverage: "
                                + derivedRules.size() + "\n" + derivedRules);
                    }
                    for (CssRule derived : derivedRules) {
                        buildSldRule(derived, ftsBuilder, targetFeatureType);
                    }
                }
            }
        }

        return styleBuilder.build();
    }

