    /**
     * Recursively builds all possible signatures in the domain (will stop immediately if a
     * signature is not accepted, or builds on top of a already rejected signature)
     * 
     * @param s
     * @param k
     * @param n
     * @param result
     */
    void fill(Signature s, int k, int n, List<R> result) {
        if (k == n) {
            if (!rejected(s, k)) {
                List<T> objects = listFromSignature(s);
                if (!objects.isEmpty()) {
                    if (accept(objects)) {
                        R combined = buildResult(objects);
                        if (combined != null) {
                            result.add(combined);
                        }
                    } else {
                        rejects.add((Signature) s.clone());
                    }
                }
            }
            return;
        }
        s.set(k, true);
        if (!rejected(s, k)) {
            fill(s, k + 1, n, result);
        }
        s.set(k, false);
        if (!rejected(s, k)) {
            fill(s, k + 1, n, result);
        }
    }

