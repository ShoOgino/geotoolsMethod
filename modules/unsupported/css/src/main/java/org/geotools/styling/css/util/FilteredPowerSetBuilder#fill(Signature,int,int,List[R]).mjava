    /**
     * Recursively builds all possible signatures in the domain (will stop immediately if a
     * signature is not accepted, or builds on top of a already rejected signature)
     * 
     * @param s
     * @param k
     * @param n
     * @param result
     */
    void fill(Signature s, int k, int n, List<R> result) {
        List<T> objects = listFromSignature(s);
        if (!objects.isEmpty()) {
            if (!accept(objects)) {
                rejects.add((Signature) s.clone());
                return;
            }
        }

        if (k == n) {
            R combined = buildResult(objects);
            if (combined != null) {
                result.add(combined);
            }
        } else {
            s.set(k, true);
            if (!rejected(s, k)) {
                fill(s, k + 1, n, result);
            }
            s.set(k, false);
            if (!rejected(s, k)) {
                fill(s, k + 1, n, result);
            }
        }
    }

