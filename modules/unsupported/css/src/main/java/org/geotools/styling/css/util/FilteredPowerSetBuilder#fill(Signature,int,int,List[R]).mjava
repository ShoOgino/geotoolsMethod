    /**
     * Recursively builds all possible signatures in the domain (will stop immediately if a
     * signature is not accepted, or builds on top of a already rejected signature)
     * 
     * @param s
     * @param k
     * @param n
     * @param result
     */
    void fill(Signature s, int k, int n, List<R> result) {
        List<T> objects = listFromSignature(s);
        if (!objects.isEmpty()) {
            if (!accept(objects)) {
                final Signature cloned = (Signature) s.clone();
                int cardinality = cloned.cardinality();
                this.minPopulated = Math.min(minPopulated, cardinality);
                while(rejects.size() <= cardinality) {
                    rejects.add(null);
                }
                List<Signature> signatures = rejects.get(cardinality);
                if(signatures == null) {
                    signatures = new ArrayList<>();
                    rejects.set(cardinality, signatures);
                }
                signatures.add(cloned);
                return;
            }
        }

        if (k == n) {
            List<R> combined = buildResult(objects);
            if (combined != null) {
                result.addAll(combined);
            }
        } else {
            s.set(k, true);
            if (!rejected(s, k)) {
                fill(s, k + 1, n, result);
            }
            s.set(k, false);
            if (!rejected(s, k)) {
                fill(s, k + 1, n, result);
            }
        }
    }

