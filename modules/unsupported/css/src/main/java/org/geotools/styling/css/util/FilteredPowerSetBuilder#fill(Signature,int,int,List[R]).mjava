    /**
     * Recursively builds all possible signatures in the domain (will stop immediately if a signature is not accepted, or builds on top of a already
     * rejected signature)
     * 
     * @param s
     * @param k
     * @param n
     * @param result
     */
    void fill(Signature s, int k, int n, List<R> result) {
        List<T> objects = listFromSignature(s);
        if (!objects.isEmpty()) {
            if (!accept(objects)) {
                final Signature cloned = (Signature) s.clone();
                int cardinality = cloned.cardinality();
                while (rejects.size() <= cardinality) {
                    rejects.add(null);
                }
                List<Signature> signatures = rejects.get(cardinality);
                if (signatures == null) {
                    signatures = new ArrayList<>();
                    rejects.set(cardinality, signatures);
                }
                signatures.add(cloned);
                return;
            }
        }

        if (k == n) {
            List<R> combined = buildResult(objects);
            if (combined != null) {
                result.addAll(combined);
            }
        } else {
            s.set(k, true);
            List<List<Signature>> storedRejects = cloneRejects();
            if (!rejected(s, k)) {
                fill(s, k + 1, n, result);
            }
            // none of these new signatures can contain one above because
            // bit K is now set to zero, so reset rejects to the parent value
            this.rejects = storedRejects;
            // avoid generating outputs for bits that are catch all, and being negated
            if (!isInclude(domain.get(k))) {
                s.set(k, false);
                if (!rejected(s, k)) {
                    fill(s, k + 1, n, result);
                }
            }

        }
    }

