    /**
     * Splits the rules into different sets by feature type name
     * 
     * @param rules
     * @return
     */
    private Map<String, List<CssRule>> organizeByTypeName(List<CssRule> rules) {
        TypeNameExtractor extractor = new TypeNameExtractor();
        for (CssRule rule : rules) {
            rule.getSelector().accept(extractor);
        }

        // extract all typename specific rules
        Map<String, List<CssRule>> result = new LinkedHashMap<>();
        Set<TypeName> typeNames = extractor.getTypeNames();
        if (typeNames.size() == 1 && typeNames.contains(TypeName.DEFAULT)) {
            // no layer specific stuff
            result.put(TypeName.DEFAULT.name, rules);
        } else {
            // remove the default from the type names, otherwise we
            // are going to generate rules/symbolizers that are contained both in the
            // layer specific feature type styles, and in a generic one at the
            // end, which will make them draw multiple times and affecting z order perception
            typeNames.remove(TypeName.DEFAULT);
        }

        for (TypeName tn : typeNames) {
            List<CssRule> typeNameRules = new ArrayList<>();
            for (CssRule rule : rules) {
                Selector combined = Selector.and(tn, rule.getSelector());
                if (combined != Selector.REJECT) {
                    typeNameRules
                            .add(new CssRule(combined, rule.getProperties(), rule.getComment()));
                }
            }
            result.put(tn.name, typeNameRules);
        }

        return result;
    }

