    private int translateCss(
            TranslationMode mode,
            List<CssRule> allRules,
            StyleBuilder styleBuilder,
            int maxCombinations,
            int autoThreshold) {
        // split rules by index and typename, then build the power set for each group and
        // generate the rules and symbolizers
        Map<Integer, List<CssRule>> zIndexRules =
                organizeByZIndex(allRules, CssRule.ZIndexMode.NoZIndexAll);
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Split the rules into " + zIndexRules + "  sets after z-index separation");
        }
        int translatedRuleCount = 0;
        for (Map.Entry<Integer, List<CssRule>> zEntry : zIndexRules.entrySet()) {
            final Integer zIndex = zEntry.getKey();
            List<CssRule> rules = zEntry.getValue();
            Collections.sort(rules, CssRuleComparator.DESCENDING);
            Map<String, List<CssRule>> typenameRules = organizeByTypeName(rules);
            // build the SLD
            for (Map.Entry<String, List<CssRule>> entry : typenameRules.entrySet()) {
                String featureTypeName = entry.getKey();
                List<CssRule> localRules = entry.getValue();
                final FeatureType targetFeatureType =
                        getTargetFeatureType(featureTypeName, localRules);
                if (targetFeatureType != null) {
                    // attach the target feature type to all Data selectors to allow range based
                    // simplification
                    for (CssRule rule : localRules) {
                        rule.getSelector()
                                .accept(
                                        new AbstractSelectorVisitor() {
                                            @Override
                                            public Object visit(Data data) {
                                                data.featureType = targetFeatureType;
                                                return super.visit(data);
                                            }
                                        });
                    }
                }
                // at this point we can have rules with selectors having two scale ranges
                // in or, we should split them, as we cannot represent them in SLD
                // (and yes, this changes their selectivity a bit, could not find a reasonable
                // solution out of this so far, past the power set we might end up with
                // and and of two selectors, that internally have ORs of scales, which could
                // be quite complicated to un-tangle)
                List<CssRule> flattenedRules = flattenScaleRanges(localRules);
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine(
                            "Preparing power set expansion with "
                                    + flattenedRules.size()
                                    + "  rules for feature type: "
                                    + featureTypeName);
                }
                // The simplifying visitor that will cache the results to avoid re-computing
                // over and over the same simplifications
                CachedSimplifyingFilterVisitor cachedSimplifier =
                        new CachedSimplifyingFilterVisitor(targetFeatureType);
                RulePowerSetBuilder builder =
                        new RulePowerSetBuilder(flattenedRules, cachedSimplifier, maxCombinations) {
                            @Override
                            protected java.util.List<CssRule> buildResult(
                                    java.util.List<CssRule> rules) {
                                if (zIndex != null && zIndex > 0) {
                                    TreeSet<Integer> zIndexes = getZIndexesForRules(rules);
                                    if (!zIndexes.contains(zIndex)) {
                                        return null;
                                    }
                                }
                                return super.buildResult(rules);
                            }
                        };
                List<CssRule> combinedRules = builder.buildPowerSet();
                if (combinedRules.isEmpty()) {
                    continue;
                }
                // create the feature type style for this typename
                FeatureTypeStyleBuilder ftsBuilder = styleBuilder.featureTypeStyle();
                // regardless of the translation mode, the first rule matching is
                // the only one that we want to be applied (in exclusive mode it will be
                // the only one matching, the simple mode we want the evaluation to stop there)
                ftsBuilder.option(
                        FeatureTypeStyle.KEY_EVALUATION_MODE,
                        FeatureTypeStyle.VALUE_EVALUATION_MODE_FIRST);

                if (featureTypeName != null) {
                    ftsBuilder.setFeatureTypeNames(
                            Arrays.asList((Name) new NameImpl(featureTypeName)));
                }
                Collections.sort(combinedRules, CssRuleComparator.DESCENDING);
                int rulesCount = combinedRules.size();
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine(
                            "Generated "
                                    + rulesCount
                                    + " combined rules after filtered power set expansion");
                }
                String composite = null;
                Boolean compositeBase = null;
                String sortBy = null;
                String sortByGroup = null;
                Expression transform = null;
                // setup the tool that will eliminate redundant rules (if necessary)
                DomainCoverage coverage = new DomainCoverage(targetFeatureType, cachedSimplifier);
                if (mode == TranslationMode.Exclusive) {
                    // create a SLD rule for each css one, making them exclusive, that is,
                    // remove from each rule the union of the zoom/data domain matched by previous
                    // rules
                    coverage.exclusiveRulesEnabled = true;
                } else if (mode == TranslationMode.Auto) {
                    if (rulesCount < autoThreshold) {
                        LOGGER.fine(
                                "Sticking to Exclusive translation mode, rules number is "
                                        + rulesCount
                                        + " with a threshold of "
                                        + autoThreshold);
                        coverage.exclusiveRulesEnabled = true;
                        coverage.complexityThreshold = autoThreshold;
                    } else {
                        LOGGER.info(
                                "Switching to Simple translation mode, rules number is "
                                        + rulesCount
                                        + " with a threshold of "
                                        + autoThreshold);
                        coverage.exclusiveRulesEnabled = false;
                        // switch the translation mode permanently from this point on
                        mode = TranslationMode.Simple;
                    }

                } else {
                    // just skip rules with the same selector
                    coverage.exclusiveRulesEnabled = false;
                }
                // generate the SLD rules
                for (int i = 0; i < rulesCount; i++) {
                    // skip eventual combinations that are not sporting any
                    // root pseudo class
                    CssRule cssRule = combinedRules.get(i);
                    if (!cssRule.hasSymbolizerProperty()) {
                        continue;
                    }
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine("Current domain coverage: " + coverage);
                        LOGGER.fine("Adding rule to domain coverage: " + cssRule);
                        LOGGER.fine("Rules left to process: " + (rulesCount - i));
                    }
                    List<CssRule> derivedRules = coverage.addRule(cssRule);
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine(
                                "Derived rules not yet covered in domain coverage: "
                                        + derivedRules.size()
                                        + "\n"
                                        + derivedRules);
                    }
                    for (CssRule derived : derivedRules) {
                        if (!derived.hasNonNullSymbolizerProperty()) {
                            continue;
                        }
                        buildSldRule(derived, ftsBuilder, targetFeatureType, null);

                        translatedRuleCount++;

                        // Reminder about why this is done the way it's done. These are all rule
                        // properties
                        // in CSS and are subject to override. In SLD they contribute to containing
                        // FeatureTypeStyle, so the first one found wins and controls this z-level

                        // check if we have global composition going, and use the value of
                        // the first rule providing the information (the one with the highest
                        // priority)
                        if (composite == null) {
                            List<Value> values =
                                    derived.getPropertyValues(PseudoClass.ROOT, COMPOSITE)
                                            .get(COMPOSITE);
                            if (values != null && !values.isEmpty()) {
                                composite = values.get(0).toLiteral();
                            }
                        }
                        if (compositeBase == null) {
                            List<Value> values =
                                    derived.getPropertyValues(PseudoClass.ROOT, COMPOSITE_BASE)
                                            .get(COMPOSITE_BASE);
                            if (values != null && !values.isEmpty()) {
                                compositeBase = Boolean.valueOf(values.get(0).toLiteral());
                            }
                        }

                        // check if we have any sort-by
                        if (sortBy == null) {
                            List<Value> values =
                                    derived.getPropertyValues(PseudoClass.ROOT, SORT_BY)
                                            .get(SORT_BY);
                            if (values != null && !values.isEmpty()) {
                                sortBy = values.get(0).toLiteral();
                            }
                        }

                        // check if we have any sort-by-group
                        if (sortByGroup == null) {
                            List<Value> values =
                                    derived.getPropertyValues(PseudoClass.ROOT, SORT_BY_GROUP)
                                            .get(SORT_BY_GROUP);
                            if (values != null && !values.isEmpty()) {
                                sortByGroup = values.get(0).toLiteral();
                            }
                        }

                        // check if we have a transform, apply it
                        if (transform == null) {
                            List<Value> values =
                                    derived.getPropertyValues(PseudoClass.ROOT, TRANSFORM)
                                            .get(TRANSFORM);
                            if (values != null && !values.isEmpty()) {
                                transform = values.get(0).toExpression();
                            }
                        }
                    }

                    if (composite != null) {
                        ftsBuilder.option(COMPOSITE, composite);
                    }
                    if (Boolean.TRUE.equals(compositeBase)) {
                        ftsBuilder.option(COMPOSITE_BASE, "true");
                    }
                    if (sortBy != null) {
                        ftsBuilder.option(FeatureTypeStyle.SORT_BY, sortBy);
                    }
                    if (sortByGroup != null) {
                        ftsBuilder.option(FeatureTypeStyle.SORT_BY_GROUP, sortByGroup);
                    }
                    if (transform != null) {
                        ftsBuilder.transformation(transform);
                    }
                }
            }
        }
        return translatedRuleCount;
    }

