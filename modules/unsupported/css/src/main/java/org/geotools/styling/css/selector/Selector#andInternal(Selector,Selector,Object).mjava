    private static Selector andInternal(Selector s1, Selector s2, Object context) {
        // merge with Accept
        if (s1 instanceof Accept) {
            return s2;
        } else if (s2 instanceof Accept) {
            return s1;
        }
        
        // merge with Negate
        if (s1 instanceof Reject || s2 instanceof Reject) {
            return REJECT;
        }
        
        // if one of the two is an or, we can fold the other into it to preserve
        // a structure with a top-most or
        if(s1 instanceof Or) {
            return foldInOr((Or) s1, s2, context);
        } else if(s2 instanceof Or) {
            return foldInOr((Or) s2, s1, context);
        }

        // ok, we can flatten all the concatenated and nested ands in a single list
        List<Selector> selectors = new ArrayList<>();
        flatten(selectors, s1, And.class);
        flatten(selectors, s2, And.class);

        // map by class, same class selectors can be merged
        Map<Class, List<Selector>> classifieds = mapByClass(selectors);
        
        // simplest scenario, there is a Reject
        if(classifieds.get(Reject.class) != null) {
            return REJECT;
        }

        // get rid of Accept, they are irrelevant
        classifieds.remove(Accept.class);

        // perform combinations for selected types
        for (AndCombiner combiner : AND_COMBINERS) {
            List<Selector> classSelectors = classifieds.get(combiner.clazz);
            if (classSelectors == null) {
                continue;
            }
            if(classSelectors.size() > 1) {
                try {
                    
                    Selector result = (Selector) combiner.andMethod.invoke(null, classSelectors, context);
                    if (result == REJECT) {
                        return REJECT;
                    } else if (result == ACCEPT) {
                        classifieds.remove(combiner.clazz);
                    } else if (result instanceof And) {
                        classifieds.put(combiner.clazz, new ArrayList<>(((Composite) result).getChildren()));
                    } else {
                        classifieds.put(combiner.clazz, Collections.singletonList(result));
                    }
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
        }

        // build the result
        List<Selector> finalList = new ArrayList<>();
        for (Class c : classifieds.keySet()) {
            List<Selector> list = classifieds.get(c);
            if (list != null) {
                finalList.addAll(list);
            }
        }
        if (finalList.size() == 0) {
            return ACCEPT;
        } else if (finalList.size() == 1) {
            return finalList.get(0);
        } else {
            return new And(finalList);
        }
    }

