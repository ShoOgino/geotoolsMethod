    @Override
    protected List<CssRule> buildResult(List<CssRule> rules) {
        boolean foundSymbolizerProperty = false;
        for (CssRule rule : rules) {
            if (rule.hasSymbolizerProperty()) {
                foundSymbolizerProperty = true;
                break;
            }
        }
        // if none of the source rules has a symbolizer property, there is nothing to combine,
        // the cascade still won't generate any output
        if (!foundSymbolizerProperty) {
            return null;
        }

        CssRule combined;
        if (rules.size() == 1) {
            combined = rules.get(0);
        } else {
            combined = combineRules(rules);
        }

        // do we have mixins to consider now?
        List<CssRule> results = new ArrayList<>();
        if (mixins == null || mixins.size() == 0) {
            results.add(combined);
        } else {
            List<CssRule> applicableMixins = getApplicableMixins(combined);

            if (applicableMixins.size() > 0) {
                int idx = 0;

                // let's see if all mixins are applying without conditinos
                for (; idx < applicableMixins.size(); idx++) {
                    CssRule mixin = applicableMixins.get(idx);
                    Selector mixedSelector = Selector.and(mixin.selector, combined.selector,
                            simplifier);
                    if (mixedSelector == Selector.REJECT) {
                        // this mixin is no good
                        continue;
                    } else if (mixedSelector.equals(combined.selector)) {
                        // this mixin always applies
                        combined = combineRules(Arrays.asList(combined, mixin));
                    } else {
                        break;
                    }
                }

                // in this case we stumbled into a mixin that adds a condition to the selector,
                // from here on we have to perform another power set expansion with the remaining
                // mixins
                if (idx < applicableMixins.size()) {
                    List<CssRule> list = new ArrayList<>();
                    list.add(combined);
                    list.addAll(applicableMixins.subList(idx, applicableMixins.size()));
                    RulePowerSetBuilder builder = new RulePowerSetBuilder(new List[] { list,
                            Collections.emptyList() }, simplifier, maxCombinations - count);
                    List<CssRule> conditionalPowerSet = builder.buildPowerSet();
                    results.addAll(conditionalPowerSet);
                } else {
                    results.add(combined);
                }

            } else {
                results.add(combined);
            }
        }

        // make sure we're not going beyond the max generated rules
        count += results.size();
        if (maxCombinations > 0 && count > maxCombinations) {
            LOGGER.severe("Bailing out, the CSS rule combinations have already generated more than "
                    + "maxCombinations SLD rules, giving up. Please simplify your CSS style");
        } else if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("New rule: " + combined);
        }

        return results;
    }

