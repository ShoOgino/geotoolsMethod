    /**
     * Adds a rule to the domain, and returns a list of rules representing bits of the domain that
     * were still not covered by the previous rules
     *
     * @param rule
     * @return
     */
    public List<CssRule> addRule(CssRule rule) {
        Selector selector = rule.getSelector();

        // turns the rule in a set of domain coverage expressions (simplified selectors)
        List<SLDSelector> ruleCoverage =
                toSLDSelectors(selector, targetFeatureType)
                        .stream()
                        .filter(s -> !generatedSelectors.contains(s))
                        .collect(Collectors.toList());
        if (ruleCoverage.isEmpty()) {
            return Collections.emptyList();
        } else {
            generatedSelectors.addAll(ruleCoverage);
        }

        if (exclusiveRulesEnabled && complexityThreshold > 0) {
            final int totalComplexity = getTotalComplexity();
            if (totalComplexity > complexityThreshold) {
                LOGGER.log(
                        Level.INFO,
                        "Switching CSS translation to non exclusive mode as total "
                                + "domain coverage complexity {0} went above threshold {1}",
                        new Object[] {totalComplexity, complexityThreshold});
                exclusiveRulesEnabled = false;
            }
        }

        // if we are just checking for straight duplicates, let it go
        if (!exclusiveRulesEnabled) {
            return coverageToRules(rule, ruleCoverage);
        }

        // for each rule we have in the domain, get the differences, if any, with this rule,
        // emit them as derived rules, and increase the coverage
        if (elements.isEmpty()) {
            elements.addAll(ruleCoverage);
            return coverageToRules(rule, ruleCoverage);
        } else {
            List<SLDSelector> reducedCoverage = new ArrayList<>(ruleCoverage);
            for (SLDSelector element : elements) {
                List<SLDSelector> difference = new ArrayList<>();
                for (SLDSelector rc : reducedCoverage) {
                    List<SLDSelector> ruleDifference = rc.difference(element);
                    difference.addAll(ruleDifference);
                }
                reducedCoverage = difference;
                if (reducedCoverage.isEmpty()) {
                    break;
                }
            }

            if (!reducedCoverage.isEmpty()) {
                List<CssRule> derivedRules = new ArrayList<>();
                reducedCoverage = combineSLDSelectors(reducedCoverage);
                for (SLDSelector rc : reducedCoverage) {
                    derivedRules.add(
                            new CssRule(
                                    rc.toSelector(simplifier),
                                    rule.getProperties(),
                                    rule.getComment()));
                }

                elements.addAll(reducedCoverage);

                // so far, this sorting done just for the sake of readability during debugging
                elements = combineSLDSelectors(elements);
                return derivedRules;
            } else {
                return Collections.emptyList();
            }
        }
    }

