    /**
     * Adds a rule to the domain, and returns a list of rules representing bits of the domain that
     * were still not covered by the previous rules
     * 
     * @param rule
     * @return
     */
    public List<CssRule> addRule(CssRule rule) {
        Selector selector = rule.getSelector();

        // turns the rule in a set of domain coverage expressions (simplified selectors)
        List<SLDSelector> ruleCoverage = toSLDSelectors(selector, targetFeatureType).stream().filter(s -> !generatedSelectors.contains(s)).collect(Collectors.toList());
        if (ruleCoverage.isEmpty()) {
            return Collections.emptyList();
        } else {
            generatedSelectors.addAll(ruleCoverage);
        }
        
        if(exclusiveRulesEnabled && complexityThreshold > 0) {
            final int totalComplexity = getTotalComplexity();
            if(totalComplexity > complexityThreshold) {
                LOGGER.log(Level.INFO, "Switching CSS translation to non exclusive mode as total "
                        + "domain coverage complexity {0} went above threshold {1}", new Object[] {totalComplexity, complexityThreshold});
                exclusiveRulesEnabled = false;
            }
        }

        // if we are just checking for straight duplicates, let it go
        if (!exclusiveRulesEnabled) {
            return coverageToRules(rule, ruleCoverage);
        }

        // for each rule we have in the domain, get the differences, if any, with this rule,
        // emit them as derived rules, and increase the coverage
        if (elements.isEmpty()) {
            elements.addAll(ruleCoverage);
            return coverageToRules(rule, ruleCoverage);
        } else {
            List<SLDSelector> reducedCoverage = new ArrayList<>(ruleCoverage);
            for (SLDSelector element : elements) {
                List<SLDSelector> difference = new ArrayList<>();
                for (SLDSelector rc : reducedCoverage) {
                    List<SLDSelector> ruleDifference = rc.difference(element);
                    difference.addAll(ruleDifference);
                }
                reducedCoverage = difference;
                if (reducedCoverage.isEmpty()) {
                    break;
                }
            }

            if (!reducedCoverage.isEmpty()) {
                List<CssRule> derivedRules = new ArrayList<>();
                for (SLDSelector rc : reducedCoverage) {
                    derivedRules.add(new CssRule(rc.toSelector(simplifier), rule.getProperties(),
                            rule.getComment()));
                }

                elements.addAll(reducedCoverage);

                // so far, this sorting done just for the sake of readability during debugging
                Collections.sort(elements, new SLDSelectorComparator());
                List<SLDSelector> combined = new ArrayList<>();
                SLDSelector prev = null;
                for (SLDSelector ss : elements) {
                    if (prev == null) {
                        prev = ss;
                    } else if (prev.scaleRange.equals(ss.scaleRange)) {
                        org.opengis.filter.Or or = FF.or(ss.filter, prev.filter);
                        Filter simplified = simplify(or);
                        prev = new SLDSelector(prev.scaleRange, simplified);
                    } else {
                        combined.add(prev);
                        prev = ss;
                    }
                }
                if (prev != null) {
                    combined.add(prev);
                }
                this.elements = combined;
                return derivedRules;
            } else {
                return Collections.emptyList();
            }
        }
    }

