    protected List<RectangleLong> getTileBoundsFor(Query query, long z) throws SQLException {
        RectangleLong levelBounds = mbtiles.getTileBounds(z, false);
        if (query == null || query.getFilter() == null || query.getFilter() == Filter.INCLUDE) {
            return Collections.singletonList(levelBounds);
        }

        // Get the bounds from the query, map them to tile space, intersect with the level bounds
        // and remove the empty results. At the end, the list might be empty.
        List<RectangleLong> rectangles =
                Optional.ofNullable(ExtractMultiBoundsFilterVisitor.getBounds(query.getFilter()))
                        .map(o -> o.stream())
                        .orElse(Stream.empty())
                        .filter(e -> !Double.isInfinite(e.getWidth()))
                        .map(
                                e -> {
                                    try {
                                        return mbtiles.toTilesRectangle(e, z);
                                    } catch (SQLException ex) {
                                        throw new RuntimeException(ex);
                                    }
                                })
                        .map(tr -> tr.intersection(levelBounds))
                        // don't filter empty intersections, or will return the whole world for them
                        .collect(Collectors.toList());
        if (rectangles.isEmpty()) {
            return Collections.singletonList(levelBounds);
        }

        // bounds expand into tile references, what might not have been overlapping now is so,
        // need to reconcile
        List<RectangleLong> result = new ArrayList<>();
        for (RectangleLong rect : rectangles) {
            if (result.isEmpty()) {
                result.add(rect);
                continue;
            }

            boolean mergedAny = false;
            do {
                // Find all rectangles found so far that overlap with the current one,
                // include them in the current one and remove the from the result
                // This expansion can cause envelopes not previously matching to overlap
                // with the current rect, so start back from the beginning until we
                // can continue to merge the results
                mergedAny = false;
                ListIterator<RectangleLong> it = result.listIterator();
                while (it.hasNext()) {
                    RectangleLong next = it.next();
                    if (next.intersects(rect)) {
                        it.remove();
                        rect.expandToInclude(next);
                        mergedAny = true;
                    }
                }
            } while (mergedAny);
            // the rect could not be merged with any of the ones in the result, add it
            result.add(rect);
        }

        return result;
    }

