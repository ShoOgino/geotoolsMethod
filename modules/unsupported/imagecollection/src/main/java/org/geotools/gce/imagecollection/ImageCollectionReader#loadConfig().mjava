    /** 
     * Setup collection configuration by checking for a properties file containing basic info such as
     * coverageName, relative path of the default image, expand RGB flag, timeBetweenChecks.
     * @throws FileNotFoundException
     */
    private void loadConfig() throws FileNotFoundException {
        final String propertiesPath = rootPath + Utils.CONFIG_FILE;
        final File propertiesFile = new File(propertiesPath);
        String coverage = null;
        final boolean hasPropertiesFile = Utils.checkFileReadable(propertiesFile);
        if (hasPropertiesFile){
            
            // //
            //
            // STEP 0:
            // Loading configuration from properties file
            //
            // //
            Properties props = new Properties();
            FileInputStream fis = null;
            try {
                fis = new FileInputStream(propertiesFile);
                props.load(fis);

                // Getting coverage name
                if (props.containsKey(Utils.ImageCollectionProperties.COVERAGE_NAME)) {
                    final String coverageName = (String) props.get(Utils.ImageCollectionProperties.COVERAGE_NAME);
                    if (coverageName != null&& coverageName.trim().length() > 0) {
                        coverage = coverageName;
                    }
                }
                // Getting default path
                if (props.containsKey(Utils.ImageCollectionProperties.DEFAULT_PATH)) {
                    final String defaultPath = (String) props.get(Utils.ImageCollectionProperties.DEFAULT_PATH);
                    if (defaultPath != null && defaultPath.trim().length() > 0) {
                        this.defaultPath = defaultPath;
                    }
                }
                // Getting expand to rgb property (used to deal with paletted images)
                if (props.containsKey(Utils.ImageCollectionProperties.EXPAND_RGB)) {
                    final String expand = (String) props.get(Utils.ImageCollectionProperties.EXPAND_RGB);
                    if (expand != null && expand.trim().length() > 0) {
                        this.expandMe = Boolean.parseBoolean(expand);
                    }
                }
                
                // Getting timeIntervalCheck. 
                if (props.containsKey(Utils.ImageCollectionProperties.TIME_BETWEEN_CHECKS)) {
                    final String timeCheck = (String) props.get(Utils.ImageCollectionProperties.TIME_BETWEEN_CHECKS);
                    if (timeCheck != null && timeCheck.trim().length() > 0) {
                        try {
                            this.timeBetweenChecks = Long.parseLong(timeCheck) * 1000;
                        } catch (NumberFormatException nfe){
                            if (LOGGER.isLoggable(Level.WARNING)){
                                LOGGER.log(Level.WARNING, "Unable to parse the specified time interval check.", nfe);
                            }
                        }
                    }
                }
                
                //TODO: Re-enable this or modify this once we get support for CRS with y as DISPLAY_DOWN
//                if (props.containsKey(Utils.ImageCollectionProperties.EPSG_CODE)) {
//                    final String epsgCode = (String) props.get(Utils.ImageCollectionProperties.EPSG_CODE);
//                    if (epsgCode != null && epsgCode.trim().length() > 0) {
//                        this.epsgCode = Integer.parseInt(epsgCode);
//                    }
//                }
                
            } catch (FileNotFoundException e) {
                if (LOGGER.isLoggable(Level.WARNING)) {
                    LOGGER.log(Level.WARNING, "Unable to parse the config file: " + propertiesPath, e);
                }

            } catch (IOException e) {
                if (LOGGER.isLoggable(Level.WARNING)) {
                    LOGGER.log(Level.WARNING, "Unable to parse the config file: " + propertiesPath, e);
                }
            } finally {
                if (fis != null) {
                    try {
                        fis.close();
                    } catch (Throwable t) {
                        // Does nothing
                    }
                }
            }
        }

        // //
        //
        // STEP 1:
        // Setting parameter which haven't been found in the property file
        //
        // //
        if (coverage == null){
            coverageName = FilenameUtils.getBaseName(FilenameUtils.getFullPathNoEndSeparator(rootPath));    
        } else {
            coverageName = coverage;
        }
        
        if (defaultPath == null){
            final File parent = new File(rootPath);
            final List<File> files;
            if (parent.exists() && parent.isDirectory() && parent.canRead()){
                files = Utils.getFileList(parent, Utils.FILE_FILTER, true);
                if (!files.isEmpty()){
                    String path = files.get(0).getAbsolutePath();
                    defaultPath = path;
                    if (path.startsWith(rootPath)){
                        defaultPath = path.substring(rootPath.length()); 
                    }
                }
            }
        }
        
        if (!hasPropertiesFile){
            updatePropertiesFile(propertiesFile);
        }
    }

