    /**
     * Init coverage properties from the provided Properties file
     * @param props
     * @return
     */
    private String initProperties(Properties props) {
        String coverage = null;
        // Getting coverage name
        if (props.containsKey(Utils.ImageCollectionProperties.COVERAGE_NAME)) {
            final String coverageName = (String) props.get(Utils.ImageCollectionProperties.COVERAGE_NAME);
            if (coverageName != null && coverageName.trim().length() > 0) {
                coverage = coverageName;
            }
        }
        // Getting default path
        if (props.containsKey(Utils.ImageCollectionProperties.DEFAULT_PATH)) {
            final String defaultPath = (String) props.get(Utils.ImageCollectionProperties.DEFAULT_PATH);
            if (defaultPath != null && defaultPath.trim().length() > 0) {
                defaultValues.path = defaultPath;
            }
        }
        // Getting expand to rgb property (used to deal with paletted images)
        if (props.containsKey(Utils.ImageCollectionProperties.EXPAND_RGB)) {
            final String expand = (String) props.get(Utils.ImageCollectionProperties.EXPAND_RGB);
            if (expand != null && expand.trim().length() > 0) {
                this.expandMe = Boolean.parseBoolean(expand);
            }
        }
        
        // Getting timeIntervalCheck. 
        if (props.containsKey(Utils.ImageCollectionProperties.TIME_BETWEEN_CHECKS)) {
            final String timeCheck = (String) props.get(Utils.ImageCollectionProperties.TIME_BETWEEN_CHECKS);
            if (timeCheck != null && timeCheck.trim().length() > 0) {
                try {
                    defaultValues.timeBetweenChecks = Long.parseLong(timeCheck) * 1000;
                } catch (NumberFormatException nfe){
                    if (LOGGER.isLoggable(Level.WARNING)){
                        LOGGER.log(Level.WARNING, "Unable to parse the specified time interval check.", nfe);
                    }
                }
            }
        }
        
        // Getting MaxWidth parameter. 
        if (props.containsKey(Utils.ImageCollectionProperties.MAX_WIDTH)) {
            final String maxW = (String) props.get(Utils.ImageCollectionProperties.MAX_WIDTH);
            if (maxW != null && maxW.trim().length() > 0) {
                try {
                    defaultValues.maxWidth = Integer.parseInt(maxW);
                } catch (NumberFormatException nfe){
                    if (LOGGER.isLoggable(Level.WARNING)){
                        LOGGER.log(Level.WARNING, "Unable to parse the specified Max Width property.", nfe);
                    }
                }
            }
        }
        
        // Getting MaxHeight parameter. 
        if (props.containsKey(Utils.ImageCollectionProperties.MAX_HEIGHT)) {
            final String maxH = (String) props.get(Utils.ImageCollectionProperties.MAX_HEIGHT);
            if (maxH != null && maxH.trim().length() > 0) {
                try {
                    defaultValues.maxHeight = Integer.parseInt(maxH);
                } catch (NumberFormatException nfe){
                    if (LOGGER.isLoggable(Level.WARNING)){
                        LOGGER.log(Level.WARNING, "Unable to parse the specified Max Height property.", nfe);
                    }
                }
            }
        }
        
        
        //TODO: Re-enable this or modify this once we get support for CRS with y as DISPLAY_DOWN
//        if (props.containsKey(Utils.ImageCollectionProperties.EPSG_CODE)) {
//            final String epsgCode = (String) props.get(Utils.ImageCollectionProperties.EPSG_CODE);
//            if (epsgCode != null && epsgCode.trim().length() > 0) {
//                this.epsgCode = Integer.parseInt(epsgCode);
//            }
//        }
        
        return coverage;
    }

