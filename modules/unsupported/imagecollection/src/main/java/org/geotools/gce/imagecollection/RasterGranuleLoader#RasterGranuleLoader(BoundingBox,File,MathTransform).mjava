    public RasterGranuleLoader(final BoundingBox granuleBBOX,
            final File granuleFile, final MathTransform gridToWorld) {

        this.granuleBBOX = ReferencedEnvelope.reference(granuleBBOX);
        this.granuleFile = granuleFile;

        // create the base grid to world transformation
        ImageInputStream inStream = null;
        ImageReader reader = null;
        try {
            //
            // get info about the raster we have to read
            //

            // get a stream
            inStream = Utils.getInputStream(granuleFile);
            if (inStream == null)
                throw new IllegalArgumentException("Unable to get an input stream for the provided file "
                                + granuleFile.toString());

            // get a reader
            reader = Utils.getReader(inStream);
            if (reader == null) {
                throw new IllegalArgumentException("Unable to get an ImageReader for the provided file "
                                + granuleFile.toString());
            }

            // get selected level and base level dimensions
            final Rectangle originalDimension = ImageUtilities.getDimension(0, inStream, reader);

            // build the g2W for this tile, in principle we should get it
            // somehow from the tile itself or from the index, but at the moment
            // we do not have such info, hence we assume that it is a simple
            // scale and translate
            if (gridToWorld == null) {
                final GridToEnvelopeMapper geMapper = new GridToEnvelopeMapper(
                        new GridEnvelope2D(originalDimension), granuleBBOX);
                geMapper.setPixelAnchor(PixelInCell.CELL_CENTER);
                this.baseGridToWorld = geMapper.createAffineTransform();
            } else
                this.baseGridToWorld = (AffineTransform) gridToWorld;

            // add the base level
            this.granuleLevels.put(Integer.valueOf(0), new Level(1, 1,
                    originalDimension.width, originalDimension.height));

        } catch (IllegalStateException e) {
            throw new IllegalArgumentException(e);

        } catch (IOException e) {
            throw new IllegalArgumentException(e);
        } finally {
            try {
                if (inStream != null)
                    inStream.close();
            } catch (Throwable e) {
                throw new IllegalArgumentException(e);
            } finally {
                if (reader != null)
                    reader.dispose();
            }
        }
    }

