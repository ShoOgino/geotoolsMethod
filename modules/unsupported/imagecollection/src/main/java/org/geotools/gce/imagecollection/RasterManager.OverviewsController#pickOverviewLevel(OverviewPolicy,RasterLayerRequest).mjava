        int pickOverviewLevel(final OverviewPolicy policy, final RasterLayerRequest request) {

            // //
            //
            // If this file has only
            // one page we use decimation, otherwise we use the best page
            // available.
            // Future versions should use both.
            //
            // //
            if (resolutionsLevels == null || resolutionsLevels.size() <= 0) return 0;

            // Now search for the best matching resolution.
            // Check also for the "perfect match"... unlikely in practice unless
            // someone tunes the clients to request exactly the resolution embedded in
            // the overviews, something a perf sensitive person might do in fact

            // requested scale factor for least reduced axis
            final OverviewLevel max = (OverviewLevel) resolutionsLevels.get(0);

            // the requested resolutions
            final double requestedScaleFactorX;
            final double requestedScaleFactorY;
            final double[] requestedRes = request.getRequestedResolution();
            if (requestedRes != null) {
                final double reqx = requestedRes[0];
                final double reqy = requestedRes[1];

                requestedScaleFactorX = reqx / max.resolutionX;
                requestedScaleFactorY = reqy / max.resolutionY;
            } else {
                final double[] scaleFactors = request.getRequestedRasterScaleFactors();
                if (scaleFactors == null) return 0;
                requestedScaleFactorX = scaleFactors[0];
                requestedScaleFactorY = scaleFactors[1];
            }
            final int leastReduceAxis = requestedScaleFactorX <= requestedScaleFactorY ? 0 : 1;
            final double requestedScaleFactor =
                    leastReduceAxis == 0 ? requestedScaleFactorX : requestedScaleFactorY;

            // are we looking for a resolution even higher than the native one?
            if (requestedScaleFactor <= 1) return max.imageChoice;
            // are we looking for a resolution even lower than the smallest
            // overview?
            final OverviewLevel min =
                    (OverviewLevel) resolutionsLevels.get(resolutionsLevels.size() - 1);
            if (requestedScaleFactor >= min.scaleFactor) return min.imageChoice;
            // Ok, so we know the overview is between min and max, skip the first
            // and search for an overview with a resolution lower than the one requested,
            // that one and the one from the previous step will bound the searched resolution
            OverviewLevel prev = max;
            final int size = resolutionsLevels.size();
            for (int i = 1; i < size; i++) {
                final OverviewLevel curr = resolutionsLevels.get(i);
                // perfect match check
                if (curr.scaleFactor == requestedScaleFactor) {
                    return curr.imageChoice;
                }

                // middle check. The first part of the condition should be sufficient, but
                // there are cases where the x resolution is satisfied by the lowest resolution,
                // the y by the one before the lowest (so the aspect ratio of the request is
                // different than the one of the overviews), and we would end up going out of the
                // loop
                // since not even the lowest can "top" the request for one axis
                if (curr.scaleFactor > requestedScaleFactor || i == size - 1) {
                    if (policy == OverviewPolicy.QUALITY) return prev.imageChoice;
                    else if (policy == OverviewPolicy.SPEED) return curr.imageChoice;
                    else if (requestedScaleFactor - prev.scaleFactor
                            < curr.scaleFactor - requestedScaleFactor) return prev.imageChoice;
                    else return curr.imageChoice;
                }
                prev = curr;
            }
            // fallback
            return max.imageChoice;
        }

