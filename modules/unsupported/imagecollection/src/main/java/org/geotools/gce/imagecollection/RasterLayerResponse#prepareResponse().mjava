    /**
     * This method loads the granules which overlap the requested {@link GeneralEnvelope} using the
     * provided values for alpha and input ROI.
     */
    private RenderedImage prepareResponse() throws DataSourceException {

        try {

            // final double[] backgroundValues = request.getBackgroundValues();

            // select the relevant overview, notice that at this time we have
            // The grid to world transforms for the other levels can be computed
            // accordingly knowning the scale factors.
            if (request.getRequestedBBox() != null && request.getRequestedRasterArea() != null)
                imageChoice =
                        setReadParams(request.getOverviewPolicy(), baseReadParameters, request);
            else imageChoice = 0;
            assert imageChoice >= 0;
            if (LOGGER.isLoggable(Level.FINE))
                LOGGER.fine(
                        "Loading level "
                                + imageChoice
                                + "with subsampling factors "
                                + baseReadParameters.getSourceXSubsampling()
                                + " "
                                + baseReadParameters.getSourceYSubsampling());

            final BoundingBox cropBBOX = request.getCropBBox();
            if (cropBBOX != null) bbox = ReferencedEnvelope.reference(cropBBOX);
            else bbox = new ReferencedEnvelope(coverageEnvelope);

            //            XAffineTransform.getFlip((AffineTransform) baseGridToWorld);
            // compute final world to grid
            // base grid to world for the center of pixels
            final AffineTransform g2w = new AffineTransform((AffineTransform) baseGridToWorld);
            // move it to the corner
            g2w.concatenate(CoverageUtilities.CENTER_TO_CORNER);

            // keep into account overviews and subsampling
            final OverviewLevel level =
                    request.imageManager.overviewsController.resolutionsLevels.get(imageChoice);
            final OverviewLevel baseLevel =
                    request.imageManager.overviewsController.resolutionsLevels.get(0);
            final AffineTransform2D adjustments =
                    new AffineTransform2D(
                            (level.resolutionX / baseLevel.resolutionX)
                                    * baseReadParameters.getSourceXSubsampling(),
                            0,
                            0,
                            (level.resolutionY / baseLevel.resolutionY)
                                    * baseReadParameters.getSourceYSubsampling(),
                            0,
                            0);
            g2w.concatenate(adjustments);
            finalGridToWorldCorner = new AffineTransform2D(g2w);
            finalWorldToGridCorner = finalGridToWorldCorner.inverse();
            rasterBounds =
                    new GeneralGridEnvelope(
                                    CRS.transform(finalWorldToGridCorner, bbox),
                                    PixelInCell.CELL_CORNER,
                                    false)
                            .toRectangle();

            final GranuleWorker worker =
                    new GranuleWorker(new ReferencedEnvelope(coverageEnvelope), baseGridToWorld);
            worker.produce();

            //
            // Did we actually load anything?
            //
            if (theImage != null) {
                if (LOGGER.isLoggable(Level.FINE))
                    LOGGER.fine(
                            "Loaded bbox "
                                    + bbox.toString()
                                    + " while crop bbox "
                                    + request.getCropBBox());

                return theImage;

            } else {

                if (backgroundValues == null) {

                    // we don't have background values available
                    return ConstantDescriptor.create(
                            Float.valueOf(rasterBounds.width),
                            Float.valueOf(rasterBounds.height),
                            new Byte[] {0},
                            this.rasterManager.getHints());
                } else {

                    // we have background values available
                    final Double[] values = new Double[backgroundValues.length];
                    for (int i = 0; i < values.length; i++) values[i] = backgroundValues[i];
                    return ConstantDescriptor.create(
                            Float.valueOf(rasterBounds.width),
                            Float.valueOf(rasterBounds.height),
                            values,
                            this.rasterManager.getHints());
                }
            }

        } catch (IOException e) {
            throw new DataSourceException("Unable to create this response", e);
        } catch (TransformException e) {
            throw new DataSourceException("Unable to create this response", e);
        }
    }

