    synchronized void buildMetadata(HDF4APSImageReader reader) {
        try {
        	final int numAttributes = reader.getNumGlobalAttributes();

            // number of supported attributes
            final int nStdFileAttribMap = HDF4APSProperties.STD_FA_ATTRIB.length;
            final int nStdTimeAttribMap = HDF4APSProperties.STD_TA_ATTRIB.length;
            final int nStdSensorAttribMap = HDF4APSProperties.STD_SA_ATTRIB.length;
            final int nFileInputParamAttribMap = HDF4APSProperties.PFA_IPA_ATTRIB.length;
            final int nFileNavAttribMap = HDF4APSProperties.PFA_NA_ATTRIB.length;
            final int nFileInGeoCovAttribMap = HDF4APSProperties.PFA_IGCA_ATTRIB.length;

            for (int i = 0; i < numAttributes; i++) {
                // get Attributes
                final KeyValuePair keyValuePair = reader.getGlobalAttribute(i);
                final String attribName = keyValuePair.getKey();
                final String attribValue = keyValuePair.getValue();
                // get Attribute Name
                // checks if the attribute name matches one of the supported
                // attributes

                boolean found = false;
                for (int k = 0; k < nStdFileAttribMap && !found; k++) {
                    // if matched
                    if (attribName.equals(HDF4APSProperties.STD_FA_ATTRIB[k])) {
                        stdFileAttribMap.put(attribName, attribValue);
                        found = true;
                    }
                }

                for (int k = 0; k < nStdTimeAttribMap && !found; k++) {
                    // if matched
                    if (attribName.equals(HDF4APSProperties.STD_TA_ATTRIB[k])) {
                        stdTimeAttribMap.put(attribName, attribValue);
                        found = true;
                    }
                }

                for (int k = 0; k < nStdSensorAttribMap && !found; k++) {
                    // if matched
                    if (attribName.equals(HDF4APSProperties.STD_SA_ATTRIB[k])) {
                        stdSensorAttribMap.put(attribName, attribValue);
                        found = true;
                    }
                }

                for (int k = 0; k < nFileInputParamAttribMap && !found; k++) {
                    // if matched
                    if (attribName.equals(HDF4APSProperties.PFA_IPA_ATTRIB[k])) {
                        fileInputParamAttribMap.put(attribName,attribValue);
                        if (attribName.equals(HDF4APSProperties.PFA_IPA_PRODLIST)) {
                            String products[] = attribValue.split(",");
                            prodList = HDF4APSProperties.refineProductList(products);
                        }
                        found = true;
                    }
                }

                for (int k = 0; k < nFileNavAttribMap && !found; k++) {
                    // if matched
                    if (attribName.equals(HDF4APSProperties.PFA_NA_ATTRIB[k])) {
                        fileNavAttribMap.put(attribName, attribValue);
                        if (attribName .equals(HDF4APSProperties.PFA_NA_MAPPROJECTION))
                            projectionDatasetName = attribValue;
                        found = true;
                    }
                }

                for (int k = 0; k < nFileInGeoCovAttribMap && !found; k++) {
                    // if matched
                    if (attribName.equals(HDF4APSProperties.PFA_IGCA_ATTRIB[k])) {
                        fileInGeoCovAttribMap.put(attribName,attribValue);
                        found = true;
                    }
                }

                if (!found)
                    genericAttribMap.put(attribName, attribValue);
            }

            // //////////////////////////////////
            // Retrieving products metadata
            // //////////////////////////////////

//            prodListNum = prodList.length;
//            if (productsMap == null)
//                productsMap = new LinkedHashMap<String, ArrayList<Map<String,String>>>(prodListNum);

//            final int numSDS = root.size();
//            for (int i = 0; i < numSDS; i++) {
//                H4SDS sds = (H4SDS) root.get(i);
//                final String name = sds.getName();
//                boolean productFound = false;
//                for (int j = 0; j < prodListNum && !productFound; j++) {
//                    if (name.equals(prodList[j])) {
//                        productFound = true;
//
//                        final int sdsAttributes = sds.getNumAttributes();
//                        if (sdsAttributes != 0) {
//
//                            final int nPdsAttrib = HDF4APSProperties.PDSA_ATTRIB.length;
//                            final LinkedHashMap<String,String> pdsAttribMap = new LinkedHashMap<String,String>(
//                                    nPdsAttrib);
//                            final LinkedHashMap<String,String> pdsGenericAttribMap = new LinkedHashMap<String,String>(
//                                    10);
//
//                            for (int indexAttr = 0; indexAttr < sdsAttributes; indexAttr++) {
//
//                                // get Attributes
//                                final H4Attribute att = (H4Attribute) sds
//                                        .getAttribute(indexAttr);
//
//                                // get Attribute Name
//                                final String attribName = att.getName();
//
//                                // get Attribute Value
//                                final String attribValue = H4Utilities
//                                        .buildAttributeString(att);
//                                boolean attributeFound = false;
//                                for (int k = 0; k < nPdsAttrib
//                                        && !attributeFound; k++) {
//                                    // if matched
//                                    if (attribName
//                                            .equals(HDF4APSProperties.PDSA_ATTRIB[k])) {
//                                        pdsAttribMap.put(attribName,
//                                                attribValue);
//
//                                        attributeFound = true;
//                                    }
//                                }
//
//                                if (!attributeFound) {
//                                    pdsGenericAttribMap.put(attribName, attribValue);
//                                }
//                            }
//
//                            final ArrayList<Map<String,String>> productAttribs = new ArrayList<Map<String,String>>(2);
//                            // putting pdsaAttribMap and genericAttribMap
//                            // in the arrayList
//                            productAttribs.add(pdsAttribMap);
//                            productAttribs.add(pdsGenericAttribMap);
//                            productsMap.put(name, productAttribs);
//                        }
//                    }
//                }
//
//            
//                if (!productFound && name.equals(projectionDatasetName)) {
//                    Object data = sds.read();
//                    final int datatype = sds.getDatatype();
//                    if (projectionMap == null)
//                        projectionMap = buildProjectionAttributesMap(data,
//                                datatype);
//                }
            Map<String,String> originalMap = reader.projectionMap;
            projectionMap = new LinkedHashMap<String, String>(originalMap.size());
            for (String key : originalMap.keySet()){
            	String value = originalMap.get(key);
            	projectionMap.put(key, value);
            }
//            }

        } catch (IOException e) {
            throw new IllegalArgumentException("Errors while getting access" +
            		" to HDF during StreamMetadata setting",e);
        }
    }

