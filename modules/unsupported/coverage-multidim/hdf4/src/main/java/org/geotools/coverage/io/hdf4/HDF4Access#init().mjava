    private void init() {
        // get the needed info from them to set the extent
        try {
            final HDF4ImageReader reader = (HDF4ImageReader) HDF4Driver.spi.createReaderInstance(this.input);
            reader.setInput(this.input);

            int numCoverages = 0;

            // Setting the name
            final Name mainCoverageName = Utilities.buildCoverageName(input);
            Name coverageName = mainCoverageName;

            // TODO: Add more checks on Vertical/Temporal dimension availability
            final int numImages = reader.getNumImages(false);

            // //
            //
            // Setting Envelope and Extents
            //
            // //
            Map<Name, Map<String, HDF4ProductFieldType>> fieldsMap = new HashMap<Name, Map<String, HDF4ProductFieldType>>();
            for (int imageIndex = 0; imageIndex < numImages; imageIndex++) {
                final SpatioTemporalMetadata metadata = reader.getSpatioTemporalMetadata(imageIndex);
                final SliceDescriptor sd = reader.getSliceDescriptor(imageIndex);
                if (sd == null)
                    throw new IllegalStateException("unable to get the required sliceDescriptor");

                // //
                //
                // Getting slice extent
                // 
                // //
//                VerticalExtent ve = sd.getVerticalExtent();
//                CoordinateReferenceSystem crs = sd.getCoordinateReferenceSystem();
                TemporalGeometricPrimitive time = sd.getTemporalExtent();
                
                BoundingBox boundingBox = sd.getHorizontalExtent();
//                String referenceID = "";
//                if (crs instanceof CompoundCRS){
//                    List<CoordinateReferenceSystem> list = ((CompoundCRS) crs).getCoordinateReferenceSystems();
//                    if (list!=null && !list.isEmpty()){
//                        for (CoordinateReferenceSystem crsElement : list){
//                            if (crsElement instanceof VerticalCRS){
//                                referenceID = crsElement.getName().getCode();
//                                break;
//                            }
//                        }
//                    }
//                }

                Band band = metadata.getBand(0);
                Set<TemporalGeometricPrimitive> temporalExtent;
//                Set<NumberRange<Double>> verticalExtent;
                Map<String, HDF4ProductFieldType> fields;

                // //
                //
                // Firstly, group coverages having the same bounding Box.
                // Some datasources may contain data coming from acquisitions
                // on different areas. We divide them in different groups.
                //
                // //

//                if (!verticalCRSMap.containsKey(referenceID)) {
                if (!coverages2DMap.containsKey(boundingBox)) {
                    // //
                    //
                    // This is the first occurrence. Setting coverageName,
                    // as well as the extents.
                    //
                    // //
                    coverageName = new NameImpl(mainCoverageName.getLocalPart() + "_" + Integer.toString(numCoverages++));
                    coverageNames.add(coverageName);
//                    verticalCRSMap.put(referenceID, coverageName);
                    coverages2DMap.put(boundingBox, coverageName);
                    temporalExtent = new LinkedHashSet<TemporalGeometricPrimitive>();
//                    verticalExtent = new LinkedHashSet<NumberRange<Double>>();
                    fields = new LinkedHashMap<String, HDF4ProductFieldType>();
                    temporalExtentMap.put(coverageName, temporalExtent);
//                    verticalExtentMap.put(coverageName, verticalExtent);
                    fieldsMap.put(coverageName, fields);
                } else {
//                    coverageName = verticalCRSMap.get(referenceID);
                	coverageName = coverages2DMap.get(boundingBox);
                }

                if (!envelopesMap.containsKey(coverageName)) {
                    // //
                    //
                    // In case this coverage's properties haven't been
                    // initialized yet, init them.
                    //
                    // //
                    initOriginalEnvelopeAndCRS(coverageName, sd);
                    final GridGeometry2D gridGeometry2D = buildGridGeometry2D(coverageName, metadata);
                    gridGeometry2DMap.put(coverageName, gridGeometry2D);
                } else {
                    GeneralEnvelope envelope = envelopesMap.get(coverageName);
                    envelope.add(sd.getGeneralEnvelope());
                    envelopesMap.put(coverageName, envelope);
                }

                // //
                //
                // Update the temporal, vertical extent for this coverage
                //
                // //
                temporalExtent = (LinkedHashSet<TemporalGeometricPrimitive>) temporalExtentMap.get(coverageName);
//                verticalExtent = (LinkedHashSet<NumberRange<Double>>) verticalExtentMap.get(coverageName);
//                if (ve != null) {
//                	NumberRange<Double> verticalEnvelope = NumberRange.create(ve.getMinimumValue().doubleValue(), ve.getMaximumValue().doubleValue());
//                    if (!verticalExtent.contains(verticalEnvelope))
//                        verticalExtent.add(verticalEnvelope);
//                }

                if (time != null) {
                    if (!temporalExtent.contains(time))
                        temporalExtent.add(time);
                }

                // //
                //
                // Update the fields for this coverage
                //
                // //
                fields = (LinkedHashMap<String, HDF4ProductFieldType>) fieldsMap.get(coverageName);

                String elementName = band.getName();
                if (!fields.containsKey(elementName)) {

                    Product product = HDF4ProductFieldType.getProduct(elementName);
                    Unit unit = Unit.ONE;
                    if (product != null) {
                        unit = product.getUoM();
                    } else {
                        String uOm = band.getUoM();
                        if(uOm == null)
                        	 unit = Unit.ONE.alternate(uOm);
                        else
                        	try {
                        		unit = Unit.valueOf(uOm);
	                        } catch (IllegalArgumentException iae) {
	                            try {
	                                unit = Unit.ONE.alternate(uOm);
	                            } catch (IllegalArgumentException iae2) {
	                                if (LOGGER.isLoggable(Level.FINE)) {
	                                    LOGGER.log(Level.FINE, "Unable to parse the provided unit " + uOm, iae2);
	                                }
	                            } catch (UnsupportedOperationException uoe) {
	                                if (LOGGER.isLoggable(Level.FINE)) {
	                                    LOGGER.log(Level.FINE,
	                                            "Unable to parse the provided unit "
	                                                    + uOm, uoe);
	                                }
	                            }
	                        }
                    }
                    final Name nameImpl = new NameImpl(coverageName.getLocalPart(), elementName);
                    final InternationalString description = new SimpleInternationalString(product!=null?product.getDescription():elementName);

                    // setting bands names.
                    final GridSampleDimension gridBand = Utilities.buildBands(band, elementName, unit);
                    final HDF4ProductFieldType fd = new HDF4ProductFieldType(nameImpl, description, gridBand);
                    fields.put(elementName, fd);
                }

                // //
                //
                // Updating the sliceDescriptor Map
                //
                // //
                sliceDescriptorsMap.put(imageIndex, sd);
                spatioTemporalMetadataMap.put(imageIndex, metadata);
            }

            // //
            //
            // Checking sets
            //
            // //
            for (Name covName : coverageNames) {
//            for (Name covName : verticalExtentMap.keySet()) {
//                Set<NumberRange<Double>> verticalExtent = verticalExtentMap.get(covName);
//                if (verticalExtent.size() == 0) {
//                    verticalExtent = Collections.emptySet();
//                    verticalExtentMap.put(covName, verticalExtent);
//                }
                Set<TemporalGeometricPrimitive> temporalExtent = temporalExtentMap.get(covName);
                if (temporalExtent.size() == 0) {
                    temporalExtent = Collections.emptySet();
                    temporalExtentMap.put(covName, temporalExtent);
                }

                // //
                //
                // Setting a proper RangeType using the FieldTypes found
                //
                // //
                Map<String, HDF4ProductFieldType> fields = (LinkedHashMap<String, HDF4ProductFieldType>) fieldsMap.get(covName);
                if (fields != null && !fields.isEmpty()) {
                    final Set<FieldType> fieldTypes = new LinkedHashSet<FieldType>(fields.size());
                    final StringBuilder sb = new StringBuilder();
                    for (HDF4ProductFieldType fd : fields.values()) {
                        fieldTypes.add(fd);
                        final InternationalString description = fd.getDescription();
                        sb.append(description != null ? description.toString()+ "," : "");
                    }
                    String description = sb.toString();
                    int pos = -1;
                    if (description.length() > 0 && (pos = description.lastIndexOf(",")) != -1) {
                        description = description.substring(0, pos);
                    }
                    DefaultRangeType range = new DefaultRangeType(covName,new SimpleInternationalString(description),fieldTypes);
                    rangeMap.put(covName, range);
                }
            }

            numberOfCoverages = numCoverages;
            // dispose the reader
            reader.dispose();
        } catch (IOException e) {
            this.numberOfCoverages = 1;

        } catch (FactoryException fe) {
            this.numberOfCoverages = 1;

        } catch (TransformException fe) {
            this.numberOfCoverages = 1;
        }

    }

