    @Override
    protected int getCountInternal(Query query) throws IOException {
        // schedule all the counts
        AggregatingDataStore store = getStore();
        List<Future<Long>> counts = new ArrayList<Future<Long>>();
        for (SourceType st : config.getSourceTypes()) {
            // Remove maxFeatures and startIndex from the query, these should be handled after
            // aggregating
            Query q = new Query(query);
            q.setMaxFeatures(Query.DEFAULT_MAX);
            q.setStartIndex(0);
            Future<Long> f =
                    store.submit(new CountCallable(store, q, st.getStoreName(), st.getTypeName()));
            counts.add(f);
        }

        // aggregate the counts
        long total = 0;
        for (Future<Long> future : counts) {
            try {
                long count = future.get();
                if (count > 0) {
                    total += count;
                } else {
                    // one of the sources found it was too costly to count
                    return -1;
                }
            } catch (Exception e) {
                throw new IOException("Failed to count on a delegate store", e);
            }
        }
        return (int) total;
    }

