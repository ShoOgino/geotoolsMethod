    public AbstractMapPane(MapContent content, RenderingExecutor executor) {
        setBackground(DEFAULT_BACKGROUND_COLOR);
        setFocusable(true);

        drawingLock = new ReentrantLock();
        paramsLock = new ReentrantReadWriteLock();

        paneTaskExecutor = Executors.newSingleThreadScheduledExecutor();
        paintDelay = DEFAULT_PAINT_DELAY;
        acceptRepaintRequests = new AtomicBoolean(true);
        clearLabelCache = new AtomicBoolean(true);
        baseImageMoved = new AtomicBoolean();
        imageOrigin = new Point(0, 0);

        dragBox = new MouseDragBox(this);
        mouseEventDispatcher = new DefaultMapMouseEventDispatcher(this);

        addMouseListener(dragBox);
        addMouseMotionListener(dragBox);

        addMouseListener(mouseEventDispatcher);
        addMouseMotionListener(mouseEventDispatcher);
        addMouseWheelListener(mouseEventDispatcher);

        /*
         * Listen for mouse entered events to (re-)set the
         * current tool cursor, otherwise the cursor seems to
         * default to the standard cursor sometimes (at least
         * on OSX)
         */
        addMouseListener(
                new MouseInputAdapter() {
                    @Override
                    public void mouseEntered(MouseEvent e) {
                        super.mouseEntered(e);
                        if (currentCursorTool != null) {
                            setCursor(currentCursorTool.getCursor());
                        }
                    }
                });

        keyHandler = new MapPaneKeyHandler(this);
        addKeyListener(keyHandler);

        /*
         * Note: we listen for both resizing events (with HierarchyBoundsListener)
         * and showing events (with HierarchyListener). Although showing
         * is often accompanied by resizing this is not reliable in Swing.
         */
        addHierarchyListener(
                new HierarchyListener() {
                    @Override
                    public void hierarchyChanged(HierarchyEvent he) {
                        if ((he.getChangeFlags() & HierarchyEvent.SHOWING_CHANGED) != 0) {
                            if (isShowing()) {
                                onShownOrResized();
                            }
                        }
                    }
                });

        addHierarchyBoundsListener(
                new HierarchyBoundsAdapter() {
                    @Override
                    public void ancestorResized(HierarchyEvent he) {
                        if (isShowing()) {
                            onShownOrResized();
                        }
                    }
                });

        doSetMapContent(content);
        doSetRenderingExecutor(executor);
    }

