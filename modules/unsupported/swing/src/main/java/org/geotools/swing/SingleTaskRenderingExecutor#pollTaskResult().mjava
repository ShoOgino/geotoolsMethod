    private void pollTaskResult() {
        if (!taskFuture.isDone()) {
            notifyStarted(false);
            return;
        }

        // call again in case the task was so quick we missed the start
        notifyStarted(true);
        
        RenderingTask.Status result = RenderingTask.Status.PENDING;
        try {
            result = taskFuture.get();
        } catch (Exception ex) {
            throw new IllegalStateException("When getting rendering result", ex);
        }

        watcher.cancel(true);

        /*
         * We zero the cancel latch here because it's possible that the job
         * completed (or failed) before it could be cancelled. When this statement 
         * was only executed for the CANCELLED case (below) it led to 
         * apps somtimes freezing.
         */
        cancelLatch.countDown();

        RenderingExecutorEvent event = new RenderingExecutorEvent(this, task.getId());
        switch (result) {
            case CANCELLED:
                listener.onRenderingCancelled(event);
                break;

            case COMPLETED:
                listener.onRenderingCompleted(event);
                break;

            case FAILED:
                listener.onRenderingFailed(event);
                break;
        }
    }

