    private void pollTaskResult() {
        if (taskFuture == null) {
            return;
        } else if (!taskFuture.isDone()) {
            notifyStarted(false);
            return;
        }

        // call again in case the task was so quick we missed the start
        notifyStarted(true);
        
        RenderingTask.Status result = null;
        long taskId = task.getId();
        try {
            result = taskFuture.get();
        } catch (Exception ex) {
            throw new IllegalStateException("When getting rendering result", ex);
        }
        
        taskFuture = null;

        /*
         * We zero the cancel latch here because it's possible that the job
         * completed (or failed) before it could be cancelled. When this statement 
         * was only executed for the CANCELLED case (below) it caused apps
         * to freeze occasionally.
         */
        cancelLatch.countDown();
        
        RenderingExecutorEvent event = new RenderingExecutorEvent(this, taskId);
        switch (result) {
            case CANCELLED:
                listener.onRenderingCancelled(event);
                break;

            case COMPLETED:
                listener.onRenderingCompleted(event);
                break;

            case FAILED:
                listener.onRenderingFailed(event);
                break;
        }
    }

