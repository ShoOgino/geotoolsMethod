    @SuppressWarnings("deprecation")
    public void handleEvent( Event event ) {

        curPaintArea = getVisibleRect();

        // System.out.println("event: " + event.type);
        if (event.type == SWT.MouseDown) {
            startX = event.x;
            startY = event.y;
            // start mouse activity
            mouseDown = true;
        } else if (event.type == SWT.MouseUp) {
            endX = event.x;
            endY = event.y;

            boolean mouseWasMoved = startX != endX || startY != endY;
            if (toolCanMove && mouseWasMoved) {
                // if the tool is able to move draw the moved image
                afterImageMove();
            }
            // stop mouse activity
            mouseDown = false;
            isDragging = false;
        } else if (event.type == SWT.Paint) {
            // System.out.println("PAINT CALLED (DOESN'T MEAN I'M DRAWING)");

            if (acceptRepaintRequests) {
                gc = event.gc;

                // System.out.println(toolCanDraw + "/" + toolCanMove + "/" + isDragging + "/" +
                // redrawBaseImage);

                /*
                 * if the mouse is dragging and the current tool can
                 * move the map we just draw what we already have
                 * on white background. At the end of the moving 
                 * we will take care of adding the missing pieces.
                 */
                if (toolCanMove && isDragging) {
                    // System.out.println("toolCanMove && isDragging");
                    if (gc != null && !gc.isDisposed() && swtImage != null) {
                        /*
                         * double buffer necessary, since the SWT.NO_BACKGROUND
                         * needed by the canvas to properly draw background, doesn't
                         * clean the parts outside the bounds of the moving panned image,
                         * giving a spilling image effect.
                         */
                        Image tmpImage = new Image(getDisplay(), curPaintArea.width, curPaintArea.height);
                        GC tmpGc = new GC(tmpImage);
                        tmpGc.setBackground(white);
                        tmpGc.fillRectangle(0, 0, curPaintArea.width, curPaintArea.height);
                        tmpGc.drawImage(swtImage, imageOrigin.x, imageOrigin.y);
                        gc.drawImage(tmpImage, 0, 0);
                        tmpImage.dispose();
                    }
                    return;
                }

                /*
                 * if the mouse is dragging and the current tool can
                 * draw a boundingbox while dragging, we draw the box 
                 * keeping the current drawn image
                 */
                if (toolCanDraw && isDragging) {
                    // System.out.println("draw box: " + startX + "/" + startY + "/" + endX +
                    // "/" + endY);
                    if (swtImage != null) {
                        drawFinalImage(swtImage);
                    }
                    gc.setXORMode(true);

                    org.eclipse.swt.graphics.Color fC = gc.getForeground();
                    gc.setLineWidth(2);
                    gc.setForeground(yellow);
                    gc.drawRectangle(startX, startY, endX - startX, endY - startY);

                    gc.setForeground(fC);
                    gc.setXORMode(false);
                    return;
                }

                if (!toolCanDraw && !toolCanMove && isDragging) {
                    return;
                }

                if (curPaintArea == null || content == null || renderer == null) {
                    return;
                }

                if (content.layers().size() == 0) {
                    // if no layers available, return only if there are also no overlays

                    gc.setForeground(yellow);
                    gc.fillRectangle(0, 0, curPaintArea.width + 1, curPaintArea.height + 1);
                    if (overlayImage == null)
                        return;
                }

                final ReferencedEnvelope mapAOI = content.getViewport().getBounds();
                if (mapAOI == null) {
                    return;
                }

                if (redrawBaseImage) {
                    MapPaneEvent ev = new MapPaneEvent(this, MapPaneEvent.Type.RENDERING_STARTED);
                    publishEvent(ev);

                    baseImage = new BufferedImage(curPaintArea.width + 1, curPaintArea.height + 1, BufferedImage.TYPE_INT_ARGB);
                    Graphics2D g2d = baseImage.createGraphics();
                    g2d.fillRect(0, 0, curPaintArea.width + 1, curPaintArea.height + 1);
                    g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                    // renderer.setContext(context);
                    java.awt.Rectangle awtRectangle = Utils.toAwtRectangle(curPaintArea);
                    renderer.paint(g2d, awtRectangle, mapAOI, getWorldToScreenTransform());
                    // swtImage.dispose();

                    if (swtImage != null && !swtImage.isDisposed()) {
                        swtImage.dispose();
                        swtImage = null;
                    }
                    System.out.println("READRAWBASEIMAGE");
                    swtImage = new Image(getDisplay(), awtToSwt(baseImage, curPaintArea.width + 1, curPaintArea.height + 1));
                }

                if (swtImage != null) {
                    drawFinalImage(swtImage);
                }

                MapPaneEvent ev = new MapPaneEvent(this, MapPaneEvent.Type.RENDERING_STOPPED);
                publishEvent(ev);
                clearLabelCache = true;
                onRenderingCompleted();
                redrawBaseImage = false;
            }
        }
    }

