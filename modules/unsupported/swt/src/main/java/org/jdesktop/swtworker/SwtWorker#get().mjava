    /**
     * {@inheritDoc}
     *
     * <p>Note: calling {@code get} on the <i>Event Dispatch Thread</i> blocks <i>all</i> events,
     * including repaints, from being processed until this {@code SwingWorker} is complete.
     *
     * <p>When you want the {@code SwingWorker} to block on the <i>Event Dispatch Thread</i> we
     * recommend that you use a <i>modal dialog</i>.
     *
     * <p>For example:
     *
     * <pre>
     * class SwingWorkerCompletionWaiter implements PropertyChangeListener {
     *     private JDialog dialog;
     *
     *     public SwingWorkerCompletionWaiter(JDialog dialog) {
     *         this.dialog = dialog;
     *     }
     *
     *     public void propertyChange(PropertyChangeEvent event) {
     *         if (&quot;state&quot;.equals(event.getPropertyName())
     *                 &amp;&amp; SwingWorker.StateValue.DONE == event.getNewValue()) {
     *             dialog.setVisible(false);
     *             dialog.dispose();
     *         }
     *     }
     * }
     * JDialog dialog = new JDialog(owner, true);
     * swingWorker.addPropertyChangeListener(
     *     new SwingWorkerCompletionWaiter(dialog));
     * swingWorker.execute();
     * //the dialog will be visible until the SwingWorker is done
     * dialog.setVisible(true);
     * </pre>
     */
    public final T get() throws InterruptedException, ExecutionException {
        return future.get();
    }

