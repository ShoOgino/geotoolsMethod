    /**
     * returns workersExecutorService.
     *
     * <p>returns the service stored in the appContext or creates it if necessary. If the last one
     * it triggers autoShutdown thread to get started.
     *
     * @return ExecutorService for the {@code SwingWorkers}
     * @see #startAutoShutdownThread
     */
    private static synchronized ExecutorService getWorkersExecutorService() {
        if (executorService == null) {
            // this creates non-daemon threads.
            ThreadFactory threadFactory =
                    new ThreadFactory() {
                        final AtomicInteger threadNumber = new AtomicInteger(1);

                        public Thread newThread(final Runnable r) {
                            StringBuilder name = new StringBuilder("SwingWorker-pool-");
                            name.append(System.identityHashCode(this));
                            name.append("-thread-");
                            name.append(threadNumber.getAndIncrement());

                            Thread t = new Thread(r, name.toString());
                            ;
                            if (t.isDaemon()) t.setDaemon(false);
                            if (t.getPriority() != Thread.NORM_PRIORITY)
                                t.setPriority(Thread.NORM_PRIORITY);
                            return t;
                        }
                    };

            /*
             * We want a to have no more than MAX_WORKER_THREADS
             * running threads.
             *
             * We want a worker thread to wait no longer than 1 second
             * for new tasks before terminating.
             */
            executorService =
                    new ThreadPoolExecutor(
                            0,
                            MAX_WORKER_THREADS,
                            5L,
                            TimeUnit.SECONDS,
                            new LinkedBlockingQueue<>(),
                            threadFactory) {

                        private final ReentrantLock pauseLock = new ReentrantLock();
                        private final Condition unpaused = pauseLock.newCondition();
                        private boolean isPaused = false;
                        private final ReentrantLock executeLock = new ReentrantLock();

                        @Override
                        public void execute(Runnable command) {
                            /*
                             * ThreadPoolExecutor first tries to run task
                             * in a corePool. If all threads are busy it
                             * tries to add task to the waiting queue. If it
                             * fails it run task in maximumPool.
                             *
                             * We want corePool to be 0 and
                             * maximumPool to be MAX_WORKER_THREADS
                             * We need to change the order of the execution.
                             * First try corePool then try maximumPool
                             * pool and only then store to the waiting
                             * queue. We can not do that because we would
                             * need access to the private methods.
                             *
                             * Instead we enlarge corePool to
                             * MAX_WORKER_THREADS before the execution and
                             * shrink it back to 0 after.
                             * It does pretty much what we need.
                             *
                             * While we changing the corePoolSize we need
                             * to stop running worker threads from accepting new
                             * tasks.
                             */

                            // we need atomicity for the execute method.
                            executeLock.lock();
                            try {

                                pauseLock.lock();
                                try {
                                    isPaused = true;
                                } finally {
                                    pauseLock.unlock();
                                }

                                setCorePoolSize(MAX_WORKER_THREADS);
                                super.execute(command);
                                setCorePoolSize(0);

                                pauseLock.lock();
                                try {
                                    isPaused = false;
                                    unpaused.signalAll();
                                } finally {
                                    pauseLock.unlock();
                                }
                            } finally {
                                executeLock.unlock();
                            }
                        }

                        @Override
                        protected void afterExecute(Runnable r, Throwable t) {
                            super.afterExecute(r, t);
                            pauseLock.lock();
                            try {
                                while (isPaused) {
                                    unpaused.await();
                                }
                            } catch (InterruptedException ignore) {

                            } finally {
                                pauseLock.unlock();
                            }
                        }
                    };
        }
        return executorService;
    }

