	/**
     * Creates a sql insert statement.  Uses each feature's schema, which makes
     * it possible to insert out of order, as well as inserting less than all
     * features.
     *
     * @param attributes the attribute columns to be inserted
     * @param feature the feature to add.
     *
     * @return an insert sql statement.
     *
     * @throws IOException
     */
    protected String makeInsertSql(List<AttributeDescriptor> attributes, SimpleFeature feature) throws IOException {

		SQLEncoderDB2 db2Encoder = (SQLEncoderDB2) encoder;

        String attrValue = null;
        boolean firstAttr = true;
		StringBuffer colNameList = new StringBuffer("");
		StringBuffer valueList = new StringBuffer("");

        for (int i = 0; i < attributes.size(); i++) {
			String colName = escapeName(attributes.get(i).getLocalName());
			if (!firstAttr) {
				colNameList.append(", ");
				valueList.append(", ");
			}
			firstAttr = false;
            colNameList.append(colName);
            
			Object currAtt = feature.getAttribute(i);        	
			if (currAtt == null) {
				attrValue = "NULL";
			}
			else 
			if (Geometry.class.isAssignableFrom(attributes.get(i).getType().getBinding())) {
				attrValue = db2Encoder.db2Geom((Geometry) currAtt);
			} else 
			if (String.class.isAssignableFrom(attributes.get(i).getType().getBinding())) {
				attrValue = "'" + currAtt.toString() + "'";
				} else	{
					attrValue = currAtt.toString();
				}

			
            valueList.append(attrValue);
        }


        String statementSQL = "INSERT INTO " + getSchemaTableName()
			+ "( " + colNameList.toString() + ")"
			+ " VALUES(" + valueList.toString() + ")"
		;
        return (statementSQL);
    }

