	/**
	 * Creates a geometry filter with the specified filter type, left and right
	 * expressions.
	 * 
	 * @param opClass Class of the filter (Contains, Intersects, etc)
	 * @param left
	 * @param right
	 * 
	 * @return a BinarySpatialOperato
	 * 
	 * @throws IllegalFilterException
	 */
	private BinarySpatialOperator createGeometryFilter(Class opClass,
			PropertyName left, Literal right) throws IllegalFilterException {
		BinarySpatialOperator gf = null;

		if (opClass == Contains.class) {
			gf = ff.contains(left, right);
		} else if (opClass == Crosses.class) {
			gf = ff.crosses(left, right);
		} else if (opClass == Disjoint.class) {
			gf = ff.disjoint(left, right);
		} else if (opClass == Equals.class) {
			gf = ff.equal(left, right);
		} else if (opClass == Intersects.class) {
			gf = ff.intersects(left, right);
		} else if (opClass == Overlaps.class) {
			gf = ff.overlaps(left, right);
		} else if (opClass == Touches.class) {
			gf = ff.touches(left, right);
		} else if (opClass == Within.class) {
			gf = ff.within(left, right);
		} else {
			// This shouldn't happen since we will have pulled out
			// the unsupported parts before invoking this method
			String msg = "unsupported filter type" + opClass.toString();
			System.out.println(msg);
		}
		return gf;
	}

