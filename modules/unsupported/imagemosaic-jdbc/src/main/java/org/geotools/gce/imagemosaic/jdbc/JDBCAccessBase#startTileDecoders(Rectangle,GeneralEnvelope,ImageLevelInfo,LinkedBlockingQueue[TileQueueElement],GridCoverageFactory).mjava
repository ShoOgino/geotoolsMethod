    /*
     * (non-Javadoc)
     *
     * @see org.geotools.gce.imagemosaic.jdbc.JDBCAccess#startTileDecoders(java.awt.Rectangle,
     *      org.geotools.geometry.GeneralEnvelope,
     *      org.geotools.gce.imagemosaic.jdbc.ImageLevelInfo,
     *      java.util.concurrent.LinkedBlockingQueue)
     */
    public void startTileDecoders(
            Rectangle pixelDimension,
            GeneralEnvelope requestEnvelope,
            ImageLevelInfo levelInfo,
            LinkedBlockingQueue<TileQueueElement> tileQueue,
            GridCoverageFactory coverageFactory)
            throws IOException {
        Date start = new Date();
        List<ImageDecoderThread> threads = new ArrayList<ImageDecoderThread>();
        ExecutorService pool = getExecutorServivicePool();

        String statementString = getGridSelectStatement(levelInfo);
        Queue<Future<?>> runResults = new LinkedList<Future<?>>();

        try (Connection con = dataSource.getConnection();
                PreparedStatement s = con.prepareStatement(statementString)) {
            setGridSelectParams(s, requestEnvelope, levelInfo);

            try (ResultSet r = s.executeQuery()) {

                while (r.next()) {
                    byte[] tileBytes = getTileBytes(r);
                    Envelope env = getEnvelopeFromResultSet(r);
                    String location = r.getString(config.getKeyAttributeNameInSpatialTable());

                    Rectangle2D tmp =
                            new Rectangle2D.Double(
                                    env.getMinX(), env.getMinY(), env.getWidth(), env.getHeight());
                    GeneralEnvelope tileGeneralEnvelope = new GeneralEnvelope(tmp);
                    tileGeneralEnvelope.setCoordinateReferenceSystem(
                            requestEnvelope.getCoordinateReferenceSystem());

                    ImageDecoderThread thread =
                            new ImageDecoderThread(
                                    tileBytes,
                                    location,
                                    tileGeneralEnvelope,
                                    requestEnvelope,
                                    levelInfo,
                                    tileQueue);
                    //				thread.start();
                    threads.add(thread);
                    runResults.add(pool.submit(thread));
                }
            }

            // if (con.getAutoCommit() == false) {
            // con.commit();
            // }

            con.close();
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, e.getMessage(), e);
            throw new IOException(e);
        }

        if (LOGGER.isLoggable(Level.INFO))
            LOGGER.info(
                    "Getting "
                            + threads.size()
                            + " Tiles needs "
                            + ((new Date()).getTime() - start.getTime())
                            + " millisecs");

        // wait for all threads dto finish and write end marker
        pool.shutdown();
        try {
            pool.awaitTermination(3600, TimeUnit.SECONDS); // wait for one hour
        } catch (InterruptedException e) {
            throw new RuntimeException(e.getLocalizedMessage());
        }

        //		for (AbstractThread thread : threads) {
        //			try {
        //				thread.join();
        //			} catch (InterruptedException e) {
        //				throw new RuntimeException(e.getLocalizedMessage());
        //			}
        //		}

        // rethrow unhandled exceptions into main thread
        for (Future<?> jobDone : runResults) {
            try {
                jobDone.get();
            } catch (Exception ex) {
                LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);
                throw new RuntimeException(ex);
            }
        }

        tileQueue.add(TileQueueElement.ENDELEMENT);

        if (LOGGER.isLoggable(Level.INFO))
            LOGGER.info(
                    "Getting and decoding  "
                            + threads.size()
                            + " Tiles needs "
                            + ((new Date()).getTime() - start.getTime())
                            + " millisecs");
    }

