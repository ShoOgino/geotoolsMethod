    private void testBandMerge(RenderedImage[] sources, boolean noDataUsed, boolean roiUsed) {
        // Optional No Data Range used
        Range[] noData;
        // Source image data type
        int dataType = sources[0].getSampleModel().getDataType();
        // If no Data are present, the No Data Range associated is used
        if (noDataUsed) {

            switch (dataType) {
            case DataBuffer.TYPE_BYTE:
                noData = noDataByte;
                break;
            case DataBuffer.TYPE_USHORT:
                noData = noDataUShort;
                break;
            case DataBuffer.TYPE_SHORT:
                noData = noDataShort;
                break;
            case DataBuffer.TYPE_INT:
                noData = noDataInt;
                break;
            case DataBuffer.TYPE_FLOAT:
                noData = noDataFloat;
                break;
            case DataBuffer.TYPE_DOUBLE:
                noData = noDataDouble;
                break;
            default:
                throw new IllegalArgumentException("Wrong data type");
            }
        } else {
            noData = null;
        }

        // ROI to use
        ROI roi = null;
        if (roiUsed) {
            roi = roiData;
        }

        // BandMerge operation
        RenderedOp merged = BandMergeDescriptor
                .create(noData, destNoData, null, null, roi, sources);
        // Check if the bands number is the same
        assertEquals(BAND_NUMBER, merged.getNumBands());
        // Upper-Left tile indexes
        int minTileX = merged.getMinTileX();
        int minTileY = merged.getMinTileY();
        // Raster object
        Raster upperLeftTile = merged.getTile(minTileX, minTileY);
        // Tile bounds
        int minX = upperLeftTile.getMinX();
        int minY = upperLeftTile.getMinY();
        int maxX = upperLeftTile.getWidth() + minX;
        int maxY = upperLeftTile.getHeight() + minY;
        // Cycle on all the tile Bands
        for (int b = 0; b < BAND_NUMBER; b++) {
            // Selection of the source raster associated with the band
            Raster bandRaster = sources[b].getTile(minTileX, minTileY);
            // Cycle on the y-axis
            for (int x = minX; x < maxX; x++) {
                // Cycle on the x-axis
                for (int y = minY; y < maxY; y++) {
                    // Calculated value
                    double value = upperLeftTile.getSampleDouble(x, y, b);
                    // Old band value
                    double valueOld = bandRaster.getSampleDouble(x, y, 0);

                    // ROI CHECK
                    boolean contained = true;
                    if (roiUsed) {
                        if (!roi.contains(x, y)) {
                            contained = false;
                            // Comparison if the final value is not inside a ROI
                            assertEquals(value, destNoData, TOLERANCE);
                        }
                    }

                    if (contained) {
                        // If no Data are present, no data check is performed
                        if (noDataUsed) {
                            switch (dataType) {
                            case DataBuffer.TYPE_BYTE:
                                byte sampleB = ImageUtil.clampRoundByte(value);
                                byte sampleBOld = ImageUtil.clampRoundByte(valueOld);
                                if (noData[0].contains(sampleBOld)) {
                                    assertEquals(sampleB, destNoData, TOLERANCE);
                                } else {
                                    assertEquals(sampleB, valueOld, TOLERANCE);
                                }
                                break;
                            case DataBuffer.TYPE_USHORT:
                                short sampleUS = ImageUtil.clampRoundUShort(value);
                                short sampleUSOld = ImageUtil.clampRoundUShort(valueOld);
                                if (noData[0].contains(sampleUSOld)) {
                                    assertEquals(sampleUS, destNoData, TOLERANCE);
                                } else {
                                    assertEquals(sampleUS, valueOld, TOLERANCE);
                                }
                                break;
                            case DataBuffer.TYPE_SHORT:
                                short sampleS = ImageUtil.clampRoundShort(value);
                                short sampleSOld = ImageUtil.clampRoundShort(valueOld);
                                if (noData[0].contains(sampleSOld)) {
                                    assertEquals(sampleS, destNoData, TOLERANCE);
                                } else {
                                    assertEquals(sampleS, valueOld, TOLERANCE);
                                }
                                break;
                            case DataBuffer.TYPE_INT:
                                int sampleI = ImageUtil.clampRoundInt(value);
                                int sampleIOld = ImageUtil.clampRoundInt(valueOld);
                                if (noData[0].contains(sampleIOld)) {
                                    assertEquals(sampleI, destNoData, TOLERANCE);
                                } else {
                                    assertEquals(sampleI, valueOld, TOLERANCE);
                                }
                                break;
                            case DataBuffer.TYPE_FLOAT:
                                float sampleF = ImageUtil.clampFloat(value);
                                float sampleFOld = ImageUtil.clampFloat(valueOld);
                                if (noData[0].contains(sampleFOld)) {
                                    assertEquals(sampleF, destNoData, TOLERANCE);
                                } else {
                                    assertEquals(sampleF, valueOld, TOLERANCE);
                                }
                                break;
                            case DataBuffer.TYPE_DOUBLE:
                                if (noData[0].contains(valueOld)) {
                                    assertEquals(value, destNoData, TOLERANCE);
                                } else {
                                    assertEquals(value, valueOld, TOLERANCE);
                                }
                                break;
                            default:
                                throw new IllegalArgumentException("Wrong data type");
                            }
                        } else {
                            // Else a simple value comparison is done
                            assertEquals(value, valueOld, TOLERANCE);
                        }
                    }
                }
            }
        }
        // Disposal of the output image
        merged.dispose();
    }

