    @Test
    public void testRasterToTransformVectorWrapping() throws Exception {
        StyleFactory factory = CommonFactoryFinder.getStyleFactory(null);
        java.net.URL surl = TestData.getResource(this, "arrows.sld");
        SLDParser stylereader = new SLDParser(factory, surl);
        Style style = stylereader.readXML()[0];

        GeoTiffReader reader = new GeoTiffReader(TestData.file(this, "current.tif"));

        MapContent mc = new MapContent();
        ParameterValue<String> suggestedTileSize = GeoTiffFormat.SUGGESTED_TILE_SIZE.createValue();
        suggestedTileSize.setValue("512,512");

        mc.addLayer(
                new GridCoverageReaderLayer(
                        reader, style, new GeneralParameterValue[] {suggestedTileSize}));

        StreamingRenderer renderer = new StreamingRenderer();
        Map<Object, Object> rendererParams = new HashMap<>();
        rendererParams.put(StreamingRenderer.ADVANCED_PROJECTION_HANDLING_KEY, true);
        rendererParams.put(StreamingRenderer.CONTINUOUS_MAP_WRAPPING, true);
        renderer.setRendererHints(rendererParams);
        renderer.setMapContent(mc);

        // Request a region a couple of times away from the classic 180Â° dateline, spanning the
        // world several times
        ReferencedEnvelope reWgs84 =
                new ReferencedEnvelope(800, 1880, -35, 35, CRS.decode("EPSG:4326", true));
        ReferencedEnvelope re = reWgs84.transform(CRS.decode("EPSG:3857"), true);

        final int w = 1080;
        final int h = 70;
        final BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
        Graphics g = image.getGraphics();
        g.setColor(Color.white);
        g.fillRect(0, 0, w, h);
        Rectangle paintArea = new Rectangle(0, 0, w, h);

        renderer.paint(
                (Graphics2D) g,
                paintArea,
                re,
                RendererUtilities.worldToScreenTransform(re, paintArea));
        final int reducedWidth = 360;
        final int reducedHeight = h;
        final int minX = w - reducedWidth;

        Raster raster = image.getData(new Rectangle(minX, 0, reducedWidth, reducedHeight));

        int blackSamples = 0;
        int graySamples = 0;
        for (int i = 0; i < reducedWidth; i++) {
            for (int j = 0; j < reducedHeight; j++) {
                blackSamples += raster.getSample(minX + i, j, 0) == 0 ? 1 : 0;
                graySamples += raster.getSample(minX + i, j, 0) == 128 ? 1 : 0;
            }
        }
        // Check that we aren't getting a whole white image on a big part of the rightern
        // side of the image. this was happening before the fix on wrapping on rendering
        // transformation since it was only rendering a smaller area (NO wrapping at all)
        assertNotEquals(0, blackSamples);
        // Confirm that the NODATA values (-32767.0 in the test image) were preserved
        // by checking for samples in the image that are not black (non-NODATA values)
        // or white (background).
        assertNotEquals(0, graySamples);
    }

