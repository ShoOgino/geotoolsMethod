    /**
     * Main Constructor using {@link RenderedImage} as input. Returned footprint coordinates will be
     * in raster space.
     *
     * @param ri the input {@link RenderedImage}
     * @param hints hints to be used by inner processing, it usually contains tile caches,
     *     schedulers
     * @param thresholdArea the minimum area required by a polygon to be included in the result
     * @param imageLoadingType the type of imageLoading (DEFERRED vs IMMEDIATE).
     * @param exclusionLuminanceRanges the range of luminance values to be excluded by the
     *     computation.
     */
    public MarchingSquaresVectorizer(
            final RenderedImage ri,
            final RenderingHints hints,
            final double thresholdArea,
            ImageLoadingType imageLoadingType,
            final List<Range<Integer>> exclusionLuminanceRanges) {
        this.inputRenderedImage = ri;
        this.footprintCoordinates = FootprintCoordinates.RASTER_SPACE;
        this.computeSimplifiedFootprint = false;
        this.thresholdArea = thresholdArea;
        this.exclusionLuminanceRanges = exclusionLuminanceRanges;

        RenderingHints localHints = (hints != null) ? (RenderingHints) hints.clone() : null;
        if ((localHints != null) && localHints.containsKey(JAI.KEY_IMAGE_LAYOUT)) {
            Object l = localHints.get(JAI.KEY_IMAGE_LAYOUT);
            if ((l != null) && (l instanceof ImageLayout)) {
                final ImageLayout layout = (ImageLayout) ((ImageLayout) l).clone();
                localHints.put(JAI.KEY_IMAGE_LAYOUT, layout);
            }
        }
        this.hints = localHints;
        this.imageLoadingType = imageLoadingType;
    }

