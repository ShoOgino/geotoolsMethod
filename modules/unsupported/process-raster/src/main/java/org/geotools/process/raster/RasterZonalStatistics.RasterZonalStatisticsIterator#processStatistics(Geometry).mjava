        private ZonalStats processStatistics(Geometry geometry) throws TransformException {
            // double checked with the tasmania simple test data, this transformation
            // actually lines up the polygons where they are supposed to be in raster space
            final AffineTransform dataG2WCorrected =
                    new AffineTransform(
                            (AffineTransform)
                                    dataCoverage
                                            .getGridGeometry()
                                            .getGridToCRS2D(PixelOrientation.UPPER_LEFT));
            final MathTransform w2gTransform;
            try {
                w2gTransform = ProjectiveTransform.create(dataG2WCorrected.createInverse());
            } catch (NoninvertibleTransformException e) {
                throw new IllegalArgumentException(e.getLocalizedMessage());
            }

            GridCoverage2D cropped = null;
            try {
                // first off, cut the geometry around the coverage bounds if necessary
                ReferencedEnvelope coverageEnvelope =
                        new ReferencedEnvelope(dataCoverage.getEnvelope2D());
                ReferencedEnvelope geometryEnvelope =
                        new ReferencedEnvelope(
                                geometry.getEnvelopeInternal(),
                                dataCoverage.getCoordinateReferenceSystem());
                if (!coverageEnvelope.intersects((Envelope) geometryEnvelope)) {
                    // no intersection, no stats
                    return null;
                } else if (!coverageEnvelope.contains((Envelope) geometryEnvelope)) {
                    // the geometry goes outside of the coverage envelope, that makes
                    // the stats fail for some reason
                    geometry = JTS.toGeometry((Envelope) coverageEnvelope).intersection(geometry);
                    geometryEnvelope =
                            new ReferencedEnvelope(
                                    geometry.getEnvelopeInternal(),
                                    dataCoverage.getCoordinateReferenceSystem());
                }

                // check if the novalue is != from NaN
                GridSampleDimension sampleDimension = dataCoverage.getSampleDimension(0);
                List<Category> categories = sampleDimension.getCategories();
                List<Range<Double>> novalueRangeList = null;
                if (categories != null) {
                    for (Category category : categories) {
                        String catName = category.getName().toString();
                        if (catName.equalsIgnoreCase("no data")) {
                            NumberRange range = category.getRange();
                            double min = range.getMinimum();
                            double max = category.getRange().getMaximum();
                            if (!Double.isNaN(min) && !Double.isNaN(max)) {
                                // we have to filter those out
                                Range<Double> novalueRange = new Range<>(min, true, max, true);
                                novalueRangeList = new ArrayList<>();
                                novalueRangeList.add(novalueRange);
                            }
                            break;
                        }
                    }
                }

                /*
                 * crop on region of interest
                 */
                ParameterValueGroup param = PROCESSOR.getOperation("CoverageCrop").getParameters();
                param.parameter("Source").setValue(dataCoverage);
                param.parameter("Envelope").setValue(new GeneralEnvelope(geometryEnvelope));
                cropped = (GridCoverage2D) PROCESSOR.doOperation(param);

                // transform the geometry to raster space so that we can use it as a ROI source
                Geometry rasterSpaceGeometry = JTS.transform(geometry, w2gTransform);
                // System.out.println(rasterSpaceGeometry);
                // System.out.println(rasterSpaceGeometry.getEnvelopeInternal());

                // simplify the geometry so that it's as precise as the coverage, excess coordinates
                // just make it slower to determine the point in polygon relationship
                Geometry simplifiedGeometry =
                        DouglasPeuckerSimplifier.simplify(rasterSpaceGeometry, 1);
                // System.out.println(simplifiedGeometry.getEnvelopeInternal());

                // compensate for the jaitools range lookup poking the corner of the cells instead
                // of their center, this makes for odd results if the polygon is just slightly
                // misaligned with the coverage
                AffineTransformation at = new AffineTransformation();

                at.setToTranslation(-0.5, -0.5);
                simplifiedGeometry.apply(at);

                // build a shape using a fast point in polygon wrapper
                ROI roi = new ROIGeometry(simplifiedGeometry, false);

                // run the stats via JAI
                Statistic[] reqStatsArr = {
                    Statistic.MAX,
                    Statistic.MIN,
                    Statistic.RANGE,
                    Statistic.MEAN,
                    Statistic.SDEV,
                    Statistic.SUM
                };
                final ZonalStatsOpImage zsOp =
                        new ZonalStatsOpImage(
                                cropped.getRenderedImage(),
                                classificationRaster,
                                null,
                                null,
                                reqStatsArr,
                                new Integer[] {band},
                                roi,
                                null,
                                null,
                                null,
                                false,
                                novalueRangeList);
                return (ZonalStats) zsOp.getProperty(ZonalStatsDescriptor.ZONAL_STATS_PROPERTY);
            } finally {
                // dispose coverages
                if (cropped != null) {
                    cropped.dispose(true);
                }
            }
        }

