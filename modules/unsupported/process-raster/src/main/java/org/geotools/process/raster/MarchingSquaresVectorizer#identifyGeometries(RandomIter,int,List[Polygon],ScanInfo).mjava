    private void identifyGeometries(final RandomIter iter, final int sampleDataType, 
            final List<Polygon> geometriesList, ScanInfo scanInfo) throws TransformException {

        // Preliminar check
        if (sampleDataType == DataBuffer.TYPE_DOUBLE) {
            scanInfo.fullyCovered = checkFullyCovered(iter, D_VALUE, geometriesList);
        } else if (sampleDataType == DataBuffer.TYPE_BYTE) {
            scanInfo.fullyCovered = checkFullyCovered(iter, I_VALUE, geometriesList);
        }
        boolean firstRef = true;
        java.awt.Polygon awtPolygon = new java.awt.Polygon();

        // Looking for polygons
        // To a tile based scan here, the iterator keeps a strong reference to a tile, we want
        // to exhaust it fully before moving on to the next tile instead of doing a simple row
        // based scan, which only requires two loops, but throws away a tile after consuming just
        // one row out of it (over large rasters it's unlikely that we'll have the old tiles
        // still in the cache once we finished scanning the first row and moved to the next one)

        if (!scanInfo.fullyCovered) {
            // Initialize search area
            final int minX = imageProperties.minX;
            final int minY = imageProperties.minY;
            final int maxX = imageProperties.maxX;
            final int maxY = imageProperties.maxY;
            final int minTileY = imageProperties.minTileY;
            final int minTileX = imageProperties.minTileX;
            final int maxTileY = imageProperties.maxTileY;
            final int maxTileX = imageProperties.maxTileX;
            final int tileWidth = imageProperties.tileWidth;
            final int tileHeight = imageProperties.tileHeight;

            if (sampleDataType == DataBuffer.TYPE_DOUBLE) {
                for (int tileY = minTileY; tileY <= maxTileY; tileY++) {
                    for (int tileX = minTileX; tileX <= maxTileX; tileX++) {
                        for (int trow = 0; trow < tileHeight; trow++) {
                            int row = (tileY * tileHeight) + trow;
                            if ((row >= minY) && (row <= maxY)) {
                                for (int tcol = 0; tcol < tileWidth; tcol++) {
                                    int col = (tileX * tileWidth) + tcol;
                                    if ((col >= minX) && (col <= maxX)) {
                                        double value = iter.getSampleDouble(col, row, 0);
                                        if (!bitSet.get(col - minX, row - minY)
                                                && !Double.isNaN(value)) {
                                            if (areEqual(value, D_VALUE)) {
                                                Polygon polygon = identifyPerimeter(iter, col,
                                                        row, awtPolygon, sampleDataType, scanInfo);
                                                if (polygon != null) {
                                                    if (removeCollinear) {
                                                        if (LOGGER.isLoggable(Level.FINE)) {
                                                            LOGGER.fine("Removing collinear points");
                                                        }
                                                        polygon = (Polygon) JTS
                                                                .removeCollinearVertices(polygon);
                                                    }
                                                    bitSet.set(polygon);
                                                    geometriesList.add(polygon);
                                                } else if (scanInfo.firstFound && firstRef) {
                                                    // Taking note of the coordinates of the
                                                    // first polygon found which is smaller
                                                    // than the threshold area
                                                    scanInfo.refColumn = col;
                                                    scanInfo.refRow = row;
                                                    firstRef = false;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (sampleDataType == DataBuffer.TYPE_BYTE) {
                for (int tileY = minTileY; tileY <= maxTileY; tileY++) {
                    for (int tileX = minTileX; tileX <= maxTileX; tileX++) {
                        for (int trow = 0; trow < tileHeight; trow++) {
                            int row = (tileY * tileHeight) + trow;
                            if ((row >= minY) && (row <= maxY)) {
                                for (int tcol = 0; tcol < tileWidth; tcol++) {
                                    int col = (tileX * tileWidth) + tcol;
                                    if ((col >= minX) && (col <= maxX)) {
                                        int value = iter.getSample(col, row, 0);
                                        if (!bitSet.get(col - minX, row - minY)) {
                                            if (value == I_VALUE) {
                                                Polygon polygon = identifyPerimeter(iter, col,
                                                        row, awtPolygon, sampleDataType, scanInfo);
                                                if (polygon != null) {
                                                    if (removeCollinear) {
                                                        if (LOGGER.isLoggable(Level.FINE)) {
                                                            LOGGER.fine("Removing collinear points");
                                                        }
                                                        polygon = (Polygon) JTS
                                                                .removeCollinearVertices(polygon);
                                                    }
                                                    geometriesList.add(polygon);
                                                    bitSet.set(polygon);
                                                } else if (scanInfo.firstFound && firstRef) {
                                                    // Taking note of the coordinates of the
                                                    // first polygon found which is smaller
                                                    // than the threshold area
                                                    scanInfo.refColumn = col;
                                                    scanInfo.refRow = row;
                                                    firstRef = false;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        if (!scanInfo.fullyCovered && geometriesList.isEmpty() && (scanInfo.refColumn != Integer.MIN_VALUE)
                && (scanInfo.refColumn != Integer.MAX_VALUE)) {
            // We didn't find any polygon bigger than threshold area.
            // Let's take the first one we found, smaller than that threshold area
            scanInfo.takeFirst = true;

            Polygon polygon = identifyPerimeter(iter, scanInfo.refColumn, scanInfo.refRow, awtPolygon,
                    sampleDataType, scanInfo);
            geometriesList.add(polygon);
        }
    }

