    @DescribeResult(name = "reclassified", description = "The reclassified raster")
    public GridCoverage2D execute(
            @DescribeParameter(name = "coverage", description = "Input raster")
                    GridCoverage2D coverage,
            @DescribeParameter(
                        name = "band",
                        description = "Source band to use for classification (default is 0)",
                        min = 0,
                        defaultValue = "0"
                    )
                    Integer classificationBand,
            @DescribeParameter(
                        name = "ranges",
                        description =
                                "Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.",
                        collectionType = Range.class
                    )
                    List<Range> classificationRanges,
            @DescribeParameter(
                        name = "outputPixelValues",
                        description = "Value to be assigned to corresponding range",
                        min = 0
                    )
                    int[] outputPixelValues,
            @DescribeParameter(
                        name = "noData",
                        description =
                                "Value to be assigned to pixels outside any range (defaults to 0)",
                        min = 0,
                        defaultValue = "0"
                    )
                    Double noData,
            ProgressListener listener)
            throws ProcessException {

        //
        // initial checks
        //
        if (coverage == null) {
            throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, "coverage"));
        }
        if (classificationRanges == null) {
            throw new ProcessException(
                    Errors.format(ErrorKeys.NULL_ARGUMENT_$1, "classificationRanges"));
        }
        double nd = DEFAULT_NODATA;
        NoDataContainer noDataProperty =
                org.geotools.resources.coverage.CoverageUtilities.getNoDataProperty(coverage);
        if (noData != null) {
            nd = noData.doubleValue();
        } else if (noDataProperty != null) {
            nd = noDataProperty.getAsSingleValue();
        }

        if (outputPixelValues != null && outputPixelValues.length > 0) {
            final int ranges = classificationRanges.size();
            if (ranges != outputPixelValues.length) {
                throw new ProcessException(
                        Errors.format(ErrorKeys.MISMATCHED_ARRAY_LENGTH, "outputPixelValues"));
            }
        }

        RenderedImage sourceImage = coverage.getRenderedImage();

        ImageWorker worker = new ImageWorker(sourceImage);

        // parse the band
        if (classificationBand != null) {
            final int band = classificationBand;
            final int numbands = sourceImage.getSampleModel().getNumBands();
            if (band < 0 || numbands <= band) {
                throw new ProcessException(
                        Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, "band", band));
            }

            if (band == 0 && numbands > 0 || band > 0) {
                worker.retainBands(new int[] {band});
            }
        }

        //
        // Check the number of ranges we have in order to decide which type we can use for the
        // output values.
        // Our goal is to use the smallest possible data type that can hold the image values.
        //
        Object lookupTable;
        final int size = classificationRanges.size();
        int transferType = ColorUtilities.getTransferType(size);
        if (JAIExt.isJAIExtOperation("RLookup")) {
            lookupTable =
                    CoverageUtilities.getRangeLookupTableJAIEXT(
                            classificationRanges, outputPixelValues, nd, transferType);
        } else {
            // Builds the range lookup table
            // final RangeLookupTable lookupTable;

            switch (transferType) {
                case DataBuffer.TYPE_BYTE:
                    lookupTable =
                            CoverageUtilities.getRangeLookupTable(
                                    classificationRanges, outputPixelValues, (byte) nd);
                    break;
                case DataBuffer.TYPE_USHORT:
                    lookupTable =
                            CoverageUtilities.getRangeLookupTable(
                                    classificationRanges, outputPixelValues, (short) nd);
                    break;
                case DataBuffer.TYPE_INT:
                    lookupTable =
                            CoverageUtilities.getRangeLookupTable(
                                    classificationRanges, outputPixelValues, nd);
                    break;
                default:
                    throw new IllegalArgumentException(
                            org.geotools.resources.i18n.Errors.format(
                                    ErrorKeys.ILLEGAL_ARGUMENT_$2,
                                    "classification ranges size",
                                    size));
            }
        }
        worker.setROI(org.geotools.resources.coverage.CoverageUtilities.getROIProperty(coverage));
        worker.setBackground(new double[] {nd});
        final RenderedOp indexedClassification =
                worker.rangeLookup(lookupTable).getRenderedOperation();

        //
        // build the output coverage
        //

        // build the output sample dimensions, use the default value ( 0 ) as the no data
        final GridSampleDimension outSampleDimension =
                new GridSampleDimension("classification", new Category[] {Category.NODATA}, null);
        final GridCoverageFactory factory =
                CoverageFactoryFinder.getGridCoverageFactory(GeoTools.getDefaultHints());
        HashMap<String, Object> properties =
                new HashMap<String, Object>() {
                    {
                        put(NoDataContainer.GC_NODATA, new NoDataContainer(0d));
                    }
                };
        org.geotools.resources.coverage.CoverageUtilities.setROIProperty(
                properties, worker.getROI());
        final GridCoverage2D output =
                factory.create(
                        "reclassified",
                        indexedClassification,
                        coverage.getGridGeometry(),
                        new GridSampleDimension[] {outSampleDimension},
                        new GridCoverage[] {coverage},
                        properties);
        return output;
    }

