    @DescribeResult(name = "reclassified", description = "The reclassified raster")
    public GridCoverage2D execute(
            @DescribeParameter(name = "coverage", description = "Input raster") GridCoverage2D coverage,
            @DescribeParameter(name = "band", description = "Source band to use for classification (default is 0)", min = 0) Integer classificationBand,
            @DescribeParameter(name = "ranges", description = "Specifier for a value range in the format ( START ; END ).  START and END values are optional. [ and ] can also be used as brackets, to indicate inclusion of the relevant range endpoint.", 
            collectionType=Range.class) List<Range> classificationRanges,
            @DescribeParameter(name = "outputPixelValues", description = "Value to be assigned to corresponding range", min = 0 ) int[] outputPixelValues,
            @DescribeParameter(name = "noData", description = "Value to be assigned to pixels outside any range (defaults to 0)", min = 0 ) Double noData,
            ProgressListener listener) throws ProcessException {
    	
    	//
    	// initial checks
    	//
    	if(coverage==null){
    		throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1,"coverage"));
    	}
    	if(classificationRanges==null){
    		throw new ProcessException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1,"classificationRanges"));
    	}
    	double nd = DEFAULT_NODATA;
    	if (noData != null){
    	    nd = noData.doubleValue();
    	}
    	if (outputPixelValues != null && outputPixelValues.length > 0){
    	    final int ranges = classificationRanges.size();
    	    if (ranges != outputPixelValues.length){
    	        throw new ProcessException(Errors.format(ErrorKeys.MISMATCHED_ARRAY_LENGTH, "outputPixelValues"));
    	    }
    	}

        RenderedImage sourceImage = coverage.getRenderedImage();
    	
        // parse the band
        if (classificationBand != null) {
            final int band = classificationBand;
            final int numbands=sourceImage.getSampleModel().getNumBands();
            if(band<0 || numbands<=band){
            	throw new ProcessException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2,"band",band));
            }
            
            if(band==0 && numbands>0 || band>0)
            	sourceImage=BandSelectDescriptor.create(sourceImage, new int []{band}, null);
        }


        //
        // Check the number of ranges we have in order to decide which type we can use for the output values. 
        // Our goal is to use the smallest possible data type that can hold the image values.
        //
        
        // Builds the range lookup table
        final RangeLookupTable lookupTable;
        final int size=classificationRanges.size();
        switch (ColorUtilities.getTransferType(size)) {
		case DataBuffer.TYPE_BYTE:
			lookupTable = CoverageUtilities.getRangeLookupTable(classificationRanges, outputPixelValues, (byte) nd );
			break;
		case DataBuffer.TYPE_USHORT:
			lookupTable = CoverageUtilities.getRangeLookupTable(classificationRanges, outputPixelValues, (short) nd );
			break;
		case DataBuffer.TYPE_INT:
			lookupTable = CoverageUtilities.getRangeLookupTable(classificationRanges, outputPixelValues, nd );
			break;			
		default:
			throw new IllegalArgumentException(org.geotools.resources.i18n.Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2,
			        "classification ranges size",size));
		}
        // reclassify the source image
        ParameterBlockJAI pb = new ParameterBlockJAI("RangeLookup");
        pb.setSource("source0", sourceImage);
        pb.setParameter("table", lookupTable);
        final RenderedOp indexedClassification = JAI.create("RangeLookup", pb);

        
        //
        // build the output coverage
        //
        
        
        // build the output sample dimensions, use the default value ( 0 ) as the no data
        final GridSampleDimension outSampleDimension = new GridSampleDimension("classification",
                new Category[] { Category.NODATA }, null).geophysics(true);
        final GridCoverageFactory factory = CoverageFactoryFinder.getGridCoverageFactory(null);
        final GridCoverage2D output = factory.create("reclassified", indexedClassification, coverage
                .getGridGeometry(), new GridSampleDimension[] { outSampleDimension },
                new GridCoverage[] { coverage }, new HashMap<String,Double>(){{
                	put("GC_NODATA",0d);
                }});
        return output;
    }

