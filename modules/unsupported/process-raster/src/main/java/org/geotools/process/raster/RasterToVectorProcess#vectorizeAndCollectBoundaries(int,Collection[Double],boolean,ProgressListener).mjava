    /**
     * Vectorize the boundaries of regions of uniform value in the input grid coverage
     * and collect the boundaries as LineStrings
     *
     * @param band index of the band which contains the data to be vectorized
     * @param outsideValues a collection of one or more values which represent 'outside'
     *        or no data (may be {@code null} or empty)
     * @param insideEdges whether to vectorize inside edges (those separating grid regions
     *        with non-outside values)
     * @param monitor a progress listener (may be {@code null})
     */
    private void vectorizeAndCollectBoundaries(int band, Collection<Double> outsideValues, boolean insideEdges, ProgressListener monitor) {
        if (monitor == null) {
            monitor = new NullProgressListener();
        }

        try {
            // a 2x2 matrix of double values used as a moving window
            double[] curData = new double[4];
            RandomIter imageIter = RandomIterFactory.create(image, null);

            outside = new TreeSet<Double>();
            if (outsideValues == null || outsideValues.isEmpty()) {
                outside.add(Double.NaN);
            } else {
                outside.addAll(outsideValues);
            }

            if (!insideEdges) {
                setInsideValue();
            }

            // we add a virtual border, one cell wide, coded as 'outside'
            // around the raster
            float progressScale = 100.0f / (imageBounds.y + imageBounds.height - 1);
            for (int row = imageBounds.y - 1; row < imageBounds.y + imageBounds.height; row++) {
                if (monitor.isCanceled()) {
                    throw new CancellationException();
                }

                monitor.progress(progressScale * row);
                curData[TR] = curData[BR] = outside.first();

                for (int col = imageBounds.x - 1; col < imageBounds.x + imageBounds.width; col++) {
                    boolean[] ok = inDataWindow(row, col);

                    curData[TL] = curData[TR];
                    curData[BL] = curData[BR];

                    curData[TR] = (ok[TR] ? imageIter.getSampleDouble(col + 1, row, band) : outside.first());
                    if (isOutside(curData[TR])) {
                        curData[TR] = outside.first();
                    } else if (!insideEdges) {
                        curData[TR] = inside;
                    }

                    curData[BR] = (ok[BR] ? imageIter.getSampleDouble(col + 1, row + 1, band) : outside.first());
                    if (isOutside(curData[BR])) {
                        curData[BR] = outside.first();
                    } else if (!insideEdges) {
                        curData[BR] = inside;
                    }

                    updateCoordList(row, col, curData);
                }
            }
        } finally {
            monitor.complete();
        }
    }

