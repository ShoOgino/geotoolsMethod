    @DescribeResult(
        name = "zonal statistics",
        description =
                "A feature collection with the attributes of the zone layer (prefixed by 'z_') and the statistics fields min,max,sum,avg,stddev"
    )
    public List<ZoneGeometry> execute(
            @DescribeParameter(
                        name = "source",
                        description = "Input raster to compute statistics for"
                    )
                    GridCoverage2D coverage,
            @DescribeParameter(
                        name = "bands",
                        description = "Source band used to compute statistics (default is 0)"
                    )
                    int[] bands,
            @DescribeParameter(
                        name = "zones",
                        description = "Zone polygon features for which to compute statistics"
                    )
                    List<SimpleFeature> zones,
            @DescribeParameter(
                        name = "classifier",
                        description =
                                "Raster whose values will be used as classes for the statistical analysis. Each zone reports statistics partitioned "
                                        + "by classes according to the values of the raster. Must be a single band raster with integer values.",
                        min = 0
                    )
                    GridCoverage2D classifier,
            @DescribeParameter(name = "nodata", description = "Input Range for NoData")
                    Range nodata,
            @DescribeParameter(
                        name = "mask",
                        description = "Optional mask for the statistic calculations"
                    )
                    Geometry mask,
            @DescribeParameter(
                        name = "useROIAccessor",
                        description =
                                "Boolean indicating if a RasterAccessor associated to the Mask should be used for calculating statistics. (Only with Mask field present)",
                        defaultValue = "false"
                    )
                    boolean useROIAccessor,
            @DescribeParameter(
                        name = "roi",
                        description = "Optional roi object, if the zones parameter is not used"
                    )
                    Polygon roi,
            @DescribeParameter(
                        name = "statistics",
                        description = "Statistics to calculate (default are min,max,sum,avg,stddev)"
                    )
                    StatsType[] stats,
            @DescribeParameter(
                        name = "minbounds",
                        description =
                                "Minimum bounds used for calculating Histogram, median and mode operations (for each band)"
                    )
                    double[] minbounds,
            @DescribeParameter(
                        name = "maxbounds",
                        description =
                                "Maximum bounds used for calculating Histogram, median and mode operations (for each band)"
                    )
                    double[] maxbounds,
            @DescribeParameter(
                        name = "numbins",
                        description =
                                "Number of Bins used for calculating Histogram, median and mode operations (for each band)"
                    )
                    int[] numbins,
            @DescribeParameter(
                        name = "rangeData",
                        description =
                                "Maximum bounds used for calculating Histogram, median and mode operations (for each band)"
                    )
                    List<Range> rangeData,
            @DescribeParameter(
                        name = "localStats",
                        description =
                                "Number of Bins used for calculating Histogram, median and mode operations (for each band)"
                    )
                    boolean localStats) {

        // If no band is indicated, then the first band is taken
        int[] ibands = new int[] {0};
        if (bands == null) {
            bands = ibands;
        }

        // If no statistic is defined, then the default statistics are taken
        if (stats == null) {
            stats = DEFAULT_STATISTICS;
        }

        RenderedImage classificationRaster = null;

        // prepare the classification image if necessary
        if (classifier != null) {
            // find nodata values
            GridSampleDimension sampleDimension = classifier.getSampleDimension(0);
            double[] nodataarr = sampleDimension.getNoDataValues();
            // Setting of the No Data values
            double[] noDataClassifier = nodataarr != null ? nodataarr : new double[] {Double.NaN};

            // this will adapt the classification image to the projection and image layout
            // of the data coverage
            classificationRaster = GridCoverage2DRIA.create(classifier, coverage, noDataClassifier);
            // Definition of the JAI TileCache to use
            RenderingHints hints = new RenderingHints(JAI.KEY_TILE_CACHE, new SunTileCache());
            // Wrap of the classification raster with a NullDescriptor for adding the TileCache
            // hints
            classificationRaster = NullDescriptor.create(classificationRaster, hints);
        }

        // Selection of the operation
        final ParameterValueGroup param = PROCESSOR.getOperation("Zonal").getParameters();
        // Setting of the parameters
        param.parameter("Source").setValue(coverage);
        param.parameter("bands").setValue(bands);
        param.parameter("classifier").setValue(classificationRaster);
        param.parameter("roi").setValue(roi);
        param.parameter("roilist").setValue(zones);
        param.parameter("NoData").setValue(nodata);
        param.parameter("mask").setValue(mask);
        param.parameter("useROIAccessor").setValue(useROIAccessor);
        param.parameter("stats").setValue(stats);
        param.parameter("minbound").setValue(minbounds);
        param.parameter("maxbound").setValue(maxbounds);
        param.parameter("numbin").setValue(numbins);
        param.parameter("rangeData").setValue(rangeData);
        param.parameter("localstats").setValue(localStats);
        // Operation execution
        GridCoverage2D output = (GridCoverage2D) PROCESSOR.doOperation(param);
        // Retrieval of the result
        @SuppressWarnings("unchecked")
        List<ZoneGeometry> value =
                (List<ZoneGeometry>) output.getProperty(ZonalStatsDescriptor.ZS_PROPERTY);
        return value;
    }

