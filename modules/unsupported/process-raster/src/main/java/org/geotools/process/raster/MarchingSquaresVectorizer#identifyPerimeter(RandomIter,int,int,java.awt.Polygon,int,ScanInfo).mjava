    /**
     * @param initialX
     * @param initialY
     * @param awtPolygon
     * @param sampleDataType
     * @return
     * @throws TransformException
     */
    private Polygon identifyPerimeter(
            final RandomIter iter,
            final int initialX,
            final int initialY,
            java.awt.Polygon awtPolygon,
            final int sampleDataType,
            final ScanInfo scanInfo)
            throws TransformException {
        if ((initialX < imageProperties.minX)
                || (initialX > imageProperties.maxX)
                || (initialY < imageProperties.minY)
                || (initialY > imageProperties.maxY)) {
            throw new IllegalArgumentException("Coordinate outside the bounds.");
        }

        int initialValue = value(iter, initialX, initialY, sampleDataType, false);
        if (initialValue == 0) {
            throw new IllegalArgumentException(
                    String.format(
                            "Supplied initial coordinates (%d, %d) do not lie on a perimeter.",
                            initialX, initialY));
        }
        if (initialValue == 15) {
            // not a border pixel
            return null;
        }

        final Point2D worldPosition = new Point2D.Double(initialX - 1, initialY - 1);
        Coordinate startCoordinate = new Coordinate(worldPosition.getX(), worldPosition.getY());
        List<Coordinate> coordinateList = new ArrayList<Coordinate>(200);

        int x = initialX;
        int y = initialY;
        awtPolygon.reset();
        awtPolygon.addPoint(x, y);

        boolean previousWentNorth = false;
        boolean previousWentEast = true;
        int v = value(iter, x, y, sampleDataType, true);
        do {
            int dx = 0;
            int dy = 0;
            switch (v) {
                case 1:
                    dy = NEGATIVE_STEP; // N
                    previousWentNorth = true;
                    break;
                case 2:
                    dx = POSITIVE_STEP; // E
                    previousWentEast = true;
                    break;
                case 3:
                    dx = POSITIVE_STEP; // E
                    previousWentEast = true;
                    break;
                case 4:
                    dx = NEGATIVE_STEP; // W
                    previousWentEast = false;
                    break;
                case 5:
                    dy = NEGATIVE_STEP; // N
                    previousWentNorth = true;
                    break;
                case 6:
                    if (!previousWentNorth) // W
                    {
                        dx = NEGATIVE_STEP;
                        previousWentEast = false;
                    } else {
                        dx = POSITIVE_STEP; // E
                        previousWentEast = true;
                    }
                    break;
                case 7:
                    dx = POSITIVE_STEP; // E
                    previousWentEast = true;
                    break;
                case 8:
                    dy = POSITIVE_STEP; // S
                    previousWentNorth = false;
                    break;
                case 9:
                    if (previousWentEast) {
                        if (isLowerCorner(iter, x, y, sampleDataType)) {
                            dy = POSITIVE_STEP; // S
                            previousWentNorth = false;
                        } else {
                            dy = NEGATIVE_STEP; // N
                            previousWentNorth = true;
                        }
                    } else {
                        if (isLowerCorner(iter, x, y, sampleDataType)) {
                            dy = NEGATIVE_STEP; // N
                            previousWentNorth = true;
                        } else {
                            dy = POSITIVE_STEP; // S
                            previousWentNorth = false;
                        }
                    }
                    break;
                case 10:
                    dy = POSITIVE_STEP; // S
                    previousWentNorth = false;
                    break;
                case 11:
                    dy = POSITIVE_STEP; // S
                    previousWentNorth = false;
                    break;
                case 12:
                    dx = NEGATIVE_STEP; // W
                    previousWentEast = false;
                    break;
                case 13:
                    dy = NEGATIVE_STEP; // N
                    previousWentNorth = true;
                    break;
                case 14:
                    dx = NEGATIVE_STEP; // W
                    previousWentEast = false;
                    break;
                default:
                    throw new IllegalStateException("Illegal state: " + v);
            }

            Coordinate direction = new Coordinate(x - 1, y - 1);
            coordinateList.add(direction);
            x = x + dx;
            y = y + dy;
            v = value(iter, x, y, sampleDataType, true);
            awtPolygon.addPoint(x, y);
        } while ((x != initialX) || (y != initialY));

        double polygonArea =
                getPolygonArea(awtPolygon.xpoints, awtPolygon.ypoints, awtPolygon.npoints - 1);
        if (polygonArea < thresholdArea) {
            if (!scanInfo.firstFound) {
                // Taking note that at least a polygon have
                // been found even if smaller than the threshold area
                scanInfo.firstFound = true;
            }
            if (!scanInfo.takeFirst) {
                // This check allow to return this polygon in case no others have been found
                // at the end of the scan and we are looking back for the first one.
                // This may be useful when each polygon is smaller than the threshold
                // but we want to return at least one of them, which may happen when
                // scanning a valid image resulting from a request with very big subsampling or
                // decimation
                return null;
            }
        }

        coordinateList.add(startCoordinate);

        Coordinate[] coordinateArray =
                (Coordinate[]) coordinateList.toArray(new Coordinate[coordinateList.size()]);

        LinearRing linearRing = GF.createLinearRing(coordinateArray);
        Polygon polygon = GF.createPolygon(linearRing, null);

        return polygon;
    }

