    /**
     * Run the raster to vector process.
     * The returned {@code Map} will contain a single object: the FeatureCollection
     * of vector polygons which can be retrieved as follows
     * <pre><code>
     * FeatureCollection&lt;SimpleFeatureType, SimpleFeature> features =
     *     (FeatureCollection&lt;SimpleFeatureType, SimpleFeature>) resultsMap.get(
     *         RasterToVectorFactory.RESULT_FEATURES.key);
     * </code></pre>
     *
     * @param input a map of input parameters (see {@linkplain RasterToVectorFactory} for details)
     *
     * @param monitor an optional {@code ProgressListener} (may be {@code null})
     *
     * @return a {@code Map} containing the vectorized features
     */
    public Map<String, Object> execute(Map<String, Object> input, ProgressListener monitor)
            throws ProcessException {

        Object o;

        GridCoverage2D cov = (GridCoverage2D) input.get(RasterToVectorFactory.RASTER.key);

        int band = 0;
        o = input.get(RasterToVectorFactory.BAND.key);
        if (o != null) {
            band = (Integer) o;
        }

        Envelope bounds = (Envelope) input.get(RasterToVectorFactory.BOUNDS.key);

        Collection<Double> outsideValues = (Collection<Double>) input.get(
                RasterToVectorFactory.OUTSIDE.key);
        if(outsideValues == null) {
        	outsideValues = Collections.emptyList();
        }

        boolean insideEdges = true;
        o = input.get(RasterToVectorFactory.INSIDE_EDGES.key);
        if (o != null) {
            insideEdges = (Boolean) o;
        }

        FeatureCollection features = convert(cov, band, bounds, outsideValues, insideEdges, monitor);

        Map<String, Object> results = new HashMap<String, Object>();
        results.put(RasterToVectorFactory.RESULT_FEATURES.key, features);
        return results;
    }

