    /**
     * Executes the raster to vector process.
     * 
     * @param coverage the data coverage
     * 
     * @param exclusionRange An optional {@code exclusionRange} parameter is supported to define 
     *        which luminance values should be excluded from the search. This allows you, as an 
     *        instance, to exclude "Dark pixels / Almost black pixels" from the results.
     * 
     * @param thresholdArea An optional {@code thresholdArea} parameter is supported to exclude 
     *        small polygons from the final result. In case a polygon has an area (in pixels) 
     *        smaller than the provided value it will not be included in the footprint. Default 
     *        Threshold Area is {@link MarchingSquaresVectorizer#DEFAULT_THRESHOLD_AREA}
     * 
     * @param computeSimplifiedFootprint An optional {@code computeSimplifiedFootprint} 
     *        parameter is supported to return a simplified version of the biggest polygon.
     * 
     * @param simplifierFactor the simplifier factor to be applied to compute the simplified 
     *        version of the biggest polygon.
     * 
     * @param imageLoadingType the type of imageLoading (DEFERRED vs IMMEDIATE).
     * 
     * @param removeCollinear specifies whether the collinear vertices of the retrieved 
     *        polygon should be removed (Default is true)
     * 
     * @param forceValid specifies whether polygons should be forced to be valid (also removing holes)
     * 
     * @param imageLoadingType specifies the type of imageLoading (DEFERRED vs IMMEDIATE). 
     *        Default is {@link ImageLoadingType#getDefault()}.
     * 
     * @param progressListener
     * @return
     * @throws ProcessException
     */
    @DescribeResult(name = "result", description = "The compute footprint geometry")
    public SimpleFeatureCollection execute(
            @DescribeParameter(name = "data", description = "Source raster") GridCoverage2D coverage,
            @DescribeParameter(name = "exclusionRange", description = "the range of luminance values to be excluded by the computation.", min = 0) Range<Integer> exclusionRange,
            @DescribeParameter(name = "thresholdArea", description = "Indicates the minimum area of a polygon to be included in the final result", min = 0) Double thresholdArea, 
            @DescribeParameter(name = "computeSimplifiedFootprint", description = "Indicates whether the simplified footprint should be computed", min = 0) Boolean computeSimplifiedFootprint, 
            @DescribeParameter(name = "simplifierFactor", description = "Indicates the simplifier factor to be applied when computing the simplified footprint", min = 0) Double simplifierFactor, 
            @DescribeParameter(name = "removeCollinear", description = "Indicates whether remove collinear point should be applied", min = 0) Boolean removeCollinear,
            @DescribeParameter(name = "forceValid", description = "Indicates whether polygon should be forced to be valid, also removing holes", min = 0) Boolean forceValid,
            @DescribeParameter(name = "loadingType", description = "Indicates which type of imageLoading should be performed (DEFERRED vs IMMEDIATE)", min = 0) ImageLoadingType imageLoadingType,
            ProgressListener progressListener)
            throws ProcessException {

        //
        // initial checks
        //
        if (coverage == null) {
            throw new ProcessException("Invalid input, source grid coverage should be not null");
        }

        // Checking for defaults
        if (exclusionRange == null) {
            exclusionRange = MarchingSquaresVectorizer.DEFAULT_RANGE;
        }

        if (computeSimplifiedFootprint == null) {
            computeSimplifiedFootprint = false;
        }

        if (simplifierFactor == null) {
            simplifierFactor = MarchingSquaresVectorizer.DEFAULT_SIMPLIFIER_FACTOR;
        }

        if (forceValid == null) {
            forceValid = true;
        }

        if (removeCollinear == null) {
            removeCollinear = true;
        }

        if (imageLoadingType == null) {
            imageLoadingType = ImageLoadingType.getDefault();
        }

        if (thresholdArea == null) {
            thresholdArea = MarchingSquaresVectorizer.DEFAULT_THRESHOLD_AREA;
        }

        MarchingSquaresVectorizer vectorizer = new MarchingSquaresVectorizer(coverage, null, thresholdArea, simplifierFactor, imageLoadingType, exclusionRange);
        vectorizer.setComputeSimplifiedFootprint(computeSimplifiedFootprint);
        vectorizer.setForceValid(forceValid);
        vectorizer.setRemoveCollinear(removeCollinear);
        try {
            vectorizer.process();

            Geometry geometry = vectorizer.getFootprint();

            // wrap as a feature collection and return
            final SimpleFeatureType featureType = CoverageUtilities.createFeatureType(coverage,
                    Geometry.class);
            final SimpleFeatureBuilder builder = new SimpleFeatureBuilder(featureType);
            int i = 0;
            final ListFeatureCollection featureCollection = new ListFeatureCollection(featureType);

            // create feature and add to list
            builder.set("the_geom", geometry);

            featureCollection.add(builder.buildFeature(String.valueOf(i++)));
            if (computeSimplifiedFootprint) {
                builder.set("the_geom", vectorizer.getSimplifiedFootprint());
                featureCollection.add(builder.buildFeature(String.valueOf(i++)));
            }
            return featureCollection;
        } catch (Exception e) {
            throw new ProcessException("Exception occurred while computing the footprint", e);
        } finally {
            vectorizer.dispose();
        }
    }

