    /**
     * Rescale the image to byte/ushort and setup a lookup which maps valid values to zero. The
     * algorithm will indeed looks for zero (after the lookup mapping), which means valid pixels
     */
    private RenderedImage prepareMaskingLookup(RenderedImage inputRI, RenderingHints localHints) {
        final int dataType = inputRI.getSampleModel().getDataType();
        double scale = 1;
        double offset = 0;
        ImageWorker worker = new ImageWorker(inputRI);
        worker.setRenderingHints(localHints);
        if (dataType != DataBuffer.TYPE_BYTE) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine(
                        "Rescaling dynamic to fit BYTE datatype from "
                                + ImageUtilities.getDatabufferTypeName(dataType));
            }

            switch (dataType) {
                case DataBuffer.TYPE_USHORT:
                    inputRI =
                            worker.lookup(
                                            createLookupTableUShort(
                                                    exclusionLuminanceRanges, dataType))
                                    .getRenderedImage();
                    break;
                case DataBuffer.TYPE_SHORT:
                    scale = MAX_8BIT_VALUE / Short.MAX_VALUE;
                    offset = MAX_8BIT_VALUE * Short.MIN_VALUE / (Short.MIN_VALUE - Short.MAX_VALUE);
                    worker.rescale(new double[] {scale}, new double[] {offset});
                    imagesStack.push(worker.getRenderedImage());
                    inputRI =
                            worker.lookup(createLookupTableByte(exclusionLuminanceRanges, dataType))
                                    .getRenderedImage();
                    break;
                case DataBuffer.TYPE_INT:
                    scale = MAX_8BIT_VALUE / Integer.MAX_VALUE;
                    offset =
                            MAX_8BIT_VALUE
                                    * Integer.MIN_VALUE
                                    / (Integer.MIN_VALUE - Integer.MAX_VALUE);
                    worker.rescale(new double[] {scale}, new double[] {offset});
                    imagesStack.push(worker.getRenderedImage());
                    inputRI =
                            worker.lookup(createLookupTableByte(exclusionLuminanceRanges, dataType))
                                    .getRenderedImage();
                    break;
                default:
                    throw new UnsupportedOperationException("Wrong data type:" + dataType);
            }

            assert inputRI.getSampleModel().getDataType() == DataBuffer.TYPE_BYTE;
        } else {
            inputRI =
                    worker.lookup(createLookupTableByte(exclusionLuminanceRanges, dataType))
                            .getRenderedImage();
        }
        return inputRI;
    }

