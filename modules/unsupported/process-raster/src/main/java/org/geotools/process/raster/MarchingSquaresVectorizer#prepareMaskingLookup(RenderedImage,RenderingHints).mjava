    /**
     * Rescale the image to byte/ushort and setup a lookup which maps valid values to zero. 
     * The algorithm will indeed looks for zero (after the lookup mapping), which means 
     * valid pixels
     * 
     * @param inputRI
     * @param localHints
     * @return
     */
    private RenderedImage prepareMaskingLookup(RenderedImage inputRI, RenderingHints localHints) {
        final int dataType = inputRI.getSampleModel().getDataType();
        double scale = 1;
        double offset = 0;
        if (dataType != DataBuffer.TYPE_BYTE) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Rescaling dynamic to fit BYTE datatype from "
                        + ImageUtilities.getDatabufferTypeName(dataType));
            }

            switch (dataType) {
            case DataBuffer.TYPE_USHORT:
                inputRI = LookupDescriptor.create(inputRI, createLookupTableUShort(exclusionLuminanceRange),
                        localHints);
                break;
            case DataBuffer.TYPE_SHORT:
                scale = MAX_8BIT_VALUE / Short.MAX_VALUE;
                offset = MAX_8BIT_VALUE * Short.MIN_VALUE / (Short.MIN_VALUE - Short.MAX_VALUE);
                inputRI = RescaleDescriptor.create(inputRI, new double[] { scale },
                        new double[] { offset }, localHints);
                imagesStack.push(inputRI);
                inputRI = LookupDescriptor.create(inputRI, createLookupTableByte(exclusionLuminanceRange), localHints);
                break;
            case DataBuffer.TYPE_INT:
                scale = MAX_8BIT_VALUE / Integer.MAX_VALUE;
                offset = MAX_8BIT_VALUE * Integer.MIN_VALUE / (Integer.MIN_VALUE - Integer.MAX_VALUE);
                inputRI = RescaleDescriptor.create(inputRI, new double[] { scale },
                        new double[] { offset }, localHints);
                imagesStack.push(inputRI);
                inputRI = LookupDescriptor.create(inputRI, createLookupTableByte(exclusionLuminanceRange), localHints);
                break;
            default:
                throw new UnsupportedOperationException("Wrong data type:" + dataType);

            }

            assert inputRI.getSampleModel().getDataType() == DataBuffer.TYPE_BYTE;
        } else {
            inputRI = LookupDescriptor.create(inputRI, createLookupTableByte(exclusionLuminanceRange), localHints);
        }
        return inputRI;
    }

