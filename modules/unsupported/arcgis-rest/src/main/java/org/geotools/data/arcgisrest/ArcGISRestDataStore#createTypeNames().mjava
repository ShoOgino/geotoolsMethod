    @Override
    protected List<Name> createTypeNames() {

        if (this.entries.isEmpty() == false) {
            return new ArrayList<Name>(this.entries.keySet());
        }

        final List<Dataset> datasetList = this.getCatalog().getDataset();
        List<Name> typeNames = new ArrayList<Name>();

        // Starts an executor with a fixed numbe rof threads
        ExecutorService executor = Executors.newFixedThreadPool(REQUEST_THREADS);

        /**
         * Since there could be many datasets in the FeatureServer, it makes sense to parallelize
         * the requests to cut down processing time
         */
        final class WsCallResult {
            public Dataset dataset;
            public Webservice webservice;

            public WsCallResult(Dataset ds, Webservice ws) {
                this.dataset = ds;
                this.webservice = ws;
            };
        }

        final class WsCall implements Callable<WsCallResult> {
            public final Dataset dataset;

            public WsCall(Dataset dsIn) {
                this.dataset = dsIn;
            }

            public WsCallResult call() throws Exception {

                Webservice ws = null;
                InputStream responseWs = null;
                String responseWSString = null;

                try {
                    responseWSString =
                            ArcGISRestDataStore.InputStreamToString(
                                    retrieveJSON(
                                            "GET",
                                            new URL(this.dataset.getWebService().toString()),
                                            ArcGISRestDataStore.DEFAULT_PARAMS));
                } catch (IOException e) {
                    LOGGER.log(
                            Level.SEVERE,
                            "Error during retrieval of dataset '"
                                    + this.dataset.getWebService()
                                    + "' "
                                    + e.getMessage(),
                            e);
                    return null;
                }

                try {
                    ws = (new Gson()).fromJson(responseWSString, Webservice.class);
                    if (ws == null || ws.getCurrentVersion() == null) {
                        throw (new JsonSyntaxException("Malformed JSON"));
                    }
                } catch (JsonSyntaxException e) {
                    // Checks whether we have an ArcGIS error message
                    Error__1 errWS = (new Gson()).fromJson(responseWSString, Error__1.class);
                    LOGGER.log(
                            Level.SEVERE,
                            "Error during retrieval of dataset "
                                    + this.dataset.getWebService()
                                    + " "
                                    + errWS.getCode()
                                    + " "
                                    + errWS.getMessage(),
                            e);
                    return null;
                }

                // Checks whether the web-service API version is supported and
                // supports GeoJSON
                if (ws.getCurrentVersion() < MINIMUM_API_VERSION
                        || ws.getSupportedQueryFormats()
                                        .toString()
                                        .toLowerCase()
                                        .contains(FORMAT_JSON.toLowerCase())
                                == false) {
                    LOGGER.log(
                            Level.SEVERE,
                            "Dataset "
                                    + this.dataset.getWebService()
                                    + " does not support either the API version supported ,or the GeoJSON format");
                    return null;
                }

                return new WsCallResult(this.dataset, ws);
            }
        }

        // Builds a list of calls to be made to retrieve FeatureServer web services
        // metadata that support the ReST API (if there are not distribution
        // elements, it
        // is supposed NOT to support it)
        try {
            Collection<WsCall> calls = new ArrayList<WsCall>();
            datasetList
                    .stream()
                    .forEach(
                            (ds) -> {
                                if (ds.getWebService().toString().contains(FEATURESERVER_SERVICE)) {
                                    calls.add(new WsCall(ds));
                                }
                            });

            List<Future<WsCallResult>> futures =
                    executor.invokeAll(
                            calls,
                            (REQUEST_TIMEOUT * calls.size()) / REQUEST_THREADS,
                            TimeUnit.SECONDS);

            for (Future<WsCallResult> future : futures) {

                WsCallResult result = future.get();

                // Checks whether the lasyer supports query and JSON
                // TODO: I am not quite sure this catches cases in which ESRI JSON is
                // supporte, but NOT GeoJSON
                if (result != null
                        && result.webservice
                                .getSupportedQueryFormats()
                                .toLowerCase()
                                .contains(FORMAT_JSON.toLowerCase())
                        && result.webservice
                                .getCapabilities()
                                .toLowerCase()
                                .contains(CAPABILITIES_QUERY.toLowerCase())) {
                    Name dsName =
                            new NameImpl(namespace.toExternalForm(), result.webservice.getName());
                    ContentEntry entry = new ContentEntry(this, dsName);
                    this.datasets.put(dsName, result.dataset);
                    this.entries.put(dsName, entry);
                }
            }
        } catch (Exception e) {
            java.util.logging.Logger.getGlobal().log(java.util.logging.Level.INFO, "", e);
        }

        // Shutdowsn the executor thread pool
        executor.shutdown();

        // Returns the list of datastore entries
        return new ArrayList<Name>(this.entries.keySet());
    }

