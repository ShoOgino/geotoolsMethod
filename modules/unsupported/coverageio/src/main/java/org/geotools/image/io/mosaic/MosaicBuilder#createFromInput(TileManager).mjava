    /**
     * Implementation of {@link #createTileManager()} with a given input. This method is not
     * public because it expects an argument controlling the behavior of tile writting, while
     * this method actually does not write anything to disk. The policy is used in order to
     * determine whatever this method should skip empty tiles or not. Skipping empty tiles are
     * usually performed when reading the original untiled image, because we know only at that
     * time which tiles are going to contain non-zero pixels. However it is possible to skip the
     * tiles that do not intersect any input tile. This is incomplete since some of the remaining
     * tiles may need to be skipped as well (we will do that later, during the write process),
     * but doing this early pre-filtering here can improve a lot the performance and memory usage.
     *
     * @param  input
     *          The tile manager for the input tiles, or {@code null} if none. If non-null, this is
     *          used only in order to filter the output tiles to the ones that intersect the input
     *          tiles. This value should be {@code null} if no such filtering should be applied.
     * @return The tile manager created from the information returned by getter methods.
     * @throws IOException if an I/O operation was required and failed.
     */
    @SuppressWarnings("fallthrough")
    private TileManager createFromInput(final TileManager input) throws IOException {
        tileReaderSpi = getTileReaderSpi();
        if (tileReaderSpi == null) {
            // TODO: We may try to detect automatically the Spi in a future version.
            throw new IllegalStateException(Errors.format(ErrorKeys.NO_IMAGE_READER));
        }
        untiledBounds = getUntiledImageBounds(); // Forces computation, if any.
        if (untiledBounds == null) {
            throw new IllegalStateException(Errors.format(ErrorKeys.UNSPECIFIED_IMAGE_SIZE));
        }
        tileSize = getTileSize(); // Forces computation
        if (tileSize == null) {
            tileSize = ImageUtilities.toTileSize(untiledBounds.getSize());
        }
        formatter.initialize(tileReaderSpi);
        final TileManager output;
        /*
         * Delegates to a method using an algorithm appropriate for the requested layout.
         */
        boolean constantArea = false;
        switch (layout) {
            case CONSTANT_GEOGRAPHIC_AREA: {
                constantArea = true;
                // Fall through
            }
            case CONSTANT_TILE_SIZE: {
                output = createFromInput(constantArea, canUsePattern(), input);
                break;
            }
            default: {
                throw new IllegalStateException(layout.toString());
            }
        }
        /*
         * After TileManager creation, computes the "grid to CRS" transform
         * if an envelope was given to this builder.
         */
        if (mosaicEnvelope != null && !mosaicEnvelope.isNull()) {
            final GridToEnvelopeMapper mapper = createGridToEnvelopeMapper(output);
            mapper.setGridRange(new GridEnvelope2D(untiledBounds));
            mapper.setEnvelope(mosaicEnvelope);
            output.setGridToCRS((AffineTransform) mapper.createTransform());
        }
        return output;
    }

