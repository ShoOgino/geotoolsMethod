    /**
     * Returns a helper parser for metadata associated with the given image. This implementation
     * invokes  <code>{@linkplain #getImageMetadata getImageMetadata}(imageIndex)</code>,  wraps
     * the result in a {@link GeographicMetadata} object if non-null and caches the result.
     * <p>
     * Note that this method forces {@link #ignoreMetadata} to {@code false} for the time of
     * <code>{@linkplain #getImageMetadata getImageMetadata}(imageIndex)</code> execution,
     * because some image reader implementations need geographic metadata in order to infer
     * a valid {@linkplain ColorModel color model}.
     *
     * @param  imageIndex The image index.
     * @return The geographic metadata, or {@code null} if none.
     * @throws IOException if an error occurs during reading.
     */
    public GeographicMetadata getGeographicMetadata(final int imageIndex) throws IOException {
        // Checks if a cached instance is available.
        if (metadata != null && imageIndex >= 0 && imageIndex < metadata.length) {
            final GeographicMetadata parser = metadata[imageIndex];
            if (parser != null) {
                return parser;
            }
        }
        // Checks if metadata are availables. If the user set 'ignoreMetadata' to 'true',
        // we override his setting since we really need metadata for creating a ColorModel.
        final IIOMetadata candidate;
        final boolean oldIgnore = ignoreMetadata;
        try {
            ignoreMetadata = false;
            candidate = getImageMetadata(imageIndex);
        } finally {
            ignoreMetadata = oldIgnore;
        }
        if (candidate == null) {
            return null;
        }
        // Wraps the IIOMetadata into a GeographicMetadata object,
        // if it was not already of the appropriate type.
        final GeographicMetadata parser;
        if (candidate instanceof GeographicMetadata) {
            parser = (GeographicMetadata) candidate;
        } else {
            parser = new GeographicMetadata(this);
            parser.mergeTree(candidate);
        }
        if (metadata == null) {
            metadata = new GeographicMetadata[Math.max(imageIndex+1, 4)];
        }
        if (imageIndex >= metadata.length) {
            metadata = XArray.resize(metadata, Math.max(imageIndex+1, metadata.length*2));
        }
        metadata[imageIndex] = parser;
        return parser;
    }

