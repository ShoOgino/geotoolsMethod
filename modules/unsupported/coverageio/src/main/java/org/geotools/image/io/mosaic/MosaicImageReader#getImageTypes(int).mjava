    /**
     * Returns possible image types to which the given image may be decoded. The default
     * implementation depends on the {@linkplain #getDefaultImageTypePolicy default image
     * type policy}:
     * <ul>
     *   <li>For {@link ImageTypePolicy#SUPPORTED_BY_ONE SUPPORTED_BY_ONE}, this method delegates
     *       directly to the reader of an arbitrary tile (typically the first one).</li>
     *   <li>For {@link ImageTypePolicy#SUPPORTED_BY_ALL SUPPORTED_BY_ALL}, this method invokes
     *       <code>{@linkplain ImageReader#getImageTypes getImageTypes}(imageIndex)</code> on
     *       every tile readers and returns the intersection of all sets (i.e. only the types
     *       that are supported by every readers).</li>
     * </ul>
     *
     * @param  imageIndex  The image index, from 0 inclusive to {@link #getNumImages} exclusive.
     * @return The image type specifiers that are common to all tiles.
     * @throws IOException If an error occurs reading the information from the input source.
     */
    public Iterator<ImageTypeSpecifier> getImageTypes(final int imageIndex) throws IOException {
        Iterator<ImageTypeSpecifier> types;
        final ImageTypePolicy policy = getDefaultImageTypePolicy();
        switch (policy) {
            default: {
                types = Collections.singleton(getPredefinedImageType(policy)).iterator();
                break;
            }
            case SUPPORTED_BY_ONE: {
                final Collection<Tile> tiles = getTileManager(imageIndex).getTiles();
                final Tile tile = getSpecificTile(tiles);
                if (tile == null) {
                    final Collection<ImageTypeSpecifier> t = Collections.emptySet();
                    return t.iterator();
                }
                types = tile.getImageReader(this, true, true).getImageTypes(imageIndex);
                assert (types = containsAll(getImageTypes(tiles, null), types)) != null : incompatibleImageType(tile);
                break;
            }
            case SUPPORTED_BY_ALL: {
                final Collection<Tile> tiles = getTileManager(imageIndex).getTiles();
                types = getImageTypes(tiles, null).iterator();
                break;
            }
        }
        return types;
    }

