    /**
     * From the given set of tiles, select one tile to use as a prototype.
     * This method tries to select the tile which use the most specific reader.
     *
     * @return The most specific tile, or {@code null} if none.
     */
    private Tile getSpecificTile(final Collection<Tile> tiles) {
        Tile fallback = null;
        final Set<ImageReader> readers = getTileReaders();
        Class<?> type = Classes.specializedClass(readers);
        while (type!=null && ImageReader.class.isAssignableFrom(type)) {
            for (final ImageReader reader : readers) {
                if (type.equals(reader.getClass())) {
                    final ImageReaderSpi provider = reader.getOriginatingProvider(); // May be null
                    for (final Tile tile : tiles) {
                        /*
                         * We give precedence to ImageReaderSpi.equals(ImageReaderSpi) over
                         * ImageReaderSpi.isOwnReader(ImageReader) because we need consistency
                         * with the 'readers' HashMap. However the later will be used as a
                         * fallback if no exact match has been found.
                         */
                        final ImageReaderSpi candidate = tile.getImageReaderSpi(); // Never null
                        if (candidate.equals(provider)) {
                            return tile;
                        }
                        if (fallback == null && candidate.isOwnReader(reader)) {
                            fallback = tile;
                        }
                    }
                }
            }
            type = type.getSuperclass();
        }
        return fallback;
    }

