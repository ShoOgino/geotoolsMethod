    /**
     * Builds the root of a tree for the given tiles.
     *
     * @param  tiles The tiles to be inserted in the tree.
     * @throws IOException if an I/O operation was required and failed.
     */
    public GridNode(final Tile[] tiles) throws IOException {
        /*
         * Sorts the TreeNode with biggest tree first (this is required for the algorithm building
         * the tree). Note that the TreeNode array should be created before any sorting is applied,
         * because its creation may involve disk reading and those reading are more efficient when
         * performed in the tiles iteration order (assuming this array was sorted by TileManager).
         */
        GridNode[] nodes = new GridNode[tiles.length];
        for (int i=0; i<tiles.length; i++) {
            nodes[i] = new GridNode(tiles[i], i);
        }
        Arrays.sort(nodes, PRE_PROCESSING);
        /*
         * If every tiles have the same subsampling, we are probably in the case where a set of
         * input tiles, all having similar size, are given to MosaicImageWriter for creating a
         * pyramid of images. The RTree creating from such set of tiles will be very inefficient.
         * Adds a couple of fictious nodes with greater area so that the code after this block
         * can create a deeper tree structure. Note that this is a somewhat naive algorithm.
         * The aim is not to create a sophesticated RTree here; it is just to atenuate the
         * worst case scenario.
         */
        final boolean isFlat = isFlat(nodes);
        if (isFlat) {
            nodes = prependTree(nodes);
        }
        /*
         * Special case: checks if the first node contains all subsequent nodes. If this is true,
         * then there is no need to keep the special root TreeNode with the tile field set to null.
         * We can keep directly the first node instead. Note that this special case should NOT be
         * extended further the first node, otherwise the tiles prior the retained node would be
         * discarted.
         */
        GridNode root = null;
        if (nodes.length != 0) {
            root = nodes[0];
            for (int i=1; i<nodes.length; i++) {
                if (!root.contains(nodes[i])) {
                    root = null;
                    break;
                }
            }
        }
        if (root != null) {
            setBounds(root);
            tile         = root.tile;
            index        = root.index;
            xSubsampling = root.xSubsampling;
            ySubsampling = root.ySubsampling;
        } else {
            index = -1;
        }
        /*
         * Now inserts every nodes in the tree. At first we try to add each node into the smallest
         * parent that can contain it and align it on a grid. If the node can not be aligned, then
         * we add it into the smallest parent regardless of alignment. The grid condition produces
         * good results for TileLayout.CONSTANT_TILE_SIZE. However it may not work so well with
         * random tiles (open issue).
         */
        for (int i=(root != null ? 1 : 0); i<nodes.length; i++) {
            final GridNode child = nodes[i];
            final GridNode parent = smallest(child);
            if (!parent.overlaps) {
                TreeNode existing = parent.firstChildren();
                while (existing != null) {
                    if (child.intersects(existing) && !child.equals(existing)) {
                        parent.overlaps = true;
                        break;
                    }
                    existing = existing.nextSibling();
                }
            }
            parent.addChild(child);
        }
        if (isFlat) {
            removeEmpty();
        }
        /*
         * Calculates the bounds only for root node, if not already computed. We do not iterate
         * down the tree since every children should have their bounds set to the tile bounds.
         */
        if (root == null) {
            assert (width | height) < 0 : this;
            TreeNode child = firstChildren();
            while (child != null) {
                // No need to invoke setBounds for the first child since Rectangle.add(Rectangle)
                // takes care of that if the width or height is negative (specified in javadoc).
                add(child);
                child = child.nextSibling();
            }
        }
        splitOverlappingChildren(); // Must be after bounds calculation.
        postTreeCreation();
        assert checkValidity() : toTree();
    }

