    /**
     * Formats a collection of tiles in a table. The tiles are appended in iteration
     * order. Tip: consider sorting the tiles before to invoke this method; tiles are
     * {@linkplain Comparable comparable} for this purpose.
     *
     * @param tiles
     *          The tiles to format in a table.
     * @param out
     *          Where to write the table.
     * @param maximum
     *          The maximum number of tiles to format. If there is more tiles, a message will be
     *          formatted below the table. A reasonable value like 5000 is recommanded since
     *          attempt to format millions of tiles leads to {@link OutOfMemoryError}.
     * @throws IOException
     *          If an error occured while writing to the given writer.
     *
     * @see java.util.Collections#sort(List)
     */
    public static void writeTable(final Collection<Tile> tiles, final Writer out, final int maximum)
            throws IOException
    {
        int remaining = maximum;
        final TableWriter table = new TableWriter(out);
        table.nextLine(TableWriter.DOUBLE_HORIZONTAL_LINE);
        table.write("Format\tInput\tindex\tx\ty\twidth\theight\tdx\tdy\n");
        table.nextLine(TableWriter.SINGLE_HORIZONTAL_LINE);
        table.setMultiLinesCells(true);
        for (final Tile tile : tiles) {
            if (--remaining < 0) {
                break;
            }
            table.setAlignment(TableWriter.ALIGN_LEFT);
            final String format = tile.getFormatName();
            if (format != null) {
                table.write(format);
            }
            table.nextColumn();
            table.write(tile.getInputName());
            table.nextColumn();
            table.setAlignment(TableWriter.ALIGN_RIGHT);
            table.write(String.valueOf(tile.getImageIndex()));
            table.nextColumn();
            /*
             * Extracts now the tile information that we are going to format, but those
             * informations may be overriden later if the current tile is some subclass
             * of Tile. We format Tile instances in a special way since it allows us to
             * left a blank for subsampling and tile size if they are not yet computed,
             * rather than throwing an exception.
             */
            int x            = tile.x;
            int y            = tile.y;
            int width        = tile.width        & MASK;
            int height       = tile.height       & MASK;
            int xSubsampling = tile.xSubsampling & MASK;
            int ySubsampling = tile.ySubsampling & MASK;
            if (!tile.getClass().equals(Tile.class)) {
                final Dimension subsampling = tile.getSubsampling();
                xSubsampling = subsampling.width;
                ySubsampling = subsampling.height;
                try {
                    final Rectangle region = tile.getRegion();
                    x      = region.x;
                    y      = region.y;
                    width  = region.width;
                    height = region.height;
                } catch (IOException e) {
                    // The (x,y) are likely to be correct since only (width,height) are read
                    // from the image file. So set only (width,height) to "unknown" and keep
                    // the remaining, with (x,y) obtained from direct access to Tile fields.
                    width  = 0;
                    height = 0;
                }
            }
            table.write(String.valueOf(x));
            table.nextColumn();
            table.write(String.valueOf(y));
            if (width != 0 || height != 0) {
                table.nextColumn();
                table.write(String.valueOf(width));
                table.nextColumn();
                table.write(String.valueOf(height));
            } else {
                table.nextColumn();
                table.nextColumn();
            }
            if (xSubsampling != 0 || ySubsampling != 0) {
                table.nextColumn();
                table.write(String.valueOf(xSubsampling));
                table.nextColumn();
                table.write(String.valueOf(ySubsampling));
            }
            table.nextLine();
        }
        table.nextLine(TableWriter.DOUBLE_HORIZONTAL_LINE);
        /*
         * Table completed. Flushs to the writer and appends additional text if we have
         * not formatted every tiles. IOException may be trown starting from this point
         * (the above code is not expected to thrown any IOException).
         */
        table.flush();
        if (remaining < 0) {
            out.write(Vocabulary.format(VocabularyKeys.MORE_$1, tiles.size() - maximum));
            out.write(System.getProperty("line.separator", "\n"));
        }
    }

