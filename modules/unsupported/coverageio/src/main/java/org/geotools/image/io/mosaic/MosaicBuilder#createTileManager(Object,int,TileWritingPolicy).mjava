    /**
     * Creates a tile manager from an untiled image. The {@linkplain #getUntiledImageBounds
     * untiled image bounds} and {@linkplain #getTileReaderSpi tile reader SPI} are inferred
     * from the input, unless they were explicitly specified.
     * <p>
     * Optionnaly if the tile writing policy is anything else than
     * {@link TileWritingPolicy#NO_WRITE NO_WRITE}, then pixel values are read from the untiled
     * images, organized in tiles as specified by the {@link TileManager} to be returned and saved
     * to disk. This work is done using a default {@link MosaicImageWriter}.
     *
     * @param  input The image input, typically as a {@link File} or an other {@link TileManager}.
     * @param  inputIndex Index of image to read, typically 0.
     * @param  policy Sets whatever tiles are created and saved to disk.
     * @return The tiles, or {@code null} if the process has been aborted while writing tiles.
     * @throws IOException if an error occured while reading the untiled image or (only if
     *         {@code writeTiles} is {@code true}) while writting the tiles to disk.
     */
    public TileManager createTileManager(final Object input, final int inputIndex,
                                         final TileWritingPolicy policy) throws IOException
    {
        formatter.ensurePrefixSet(input);
        final Writer writer = new Writer(inputIndex, policy);
        writer.setLogLevel(getLogLevel());
        final MosaicImageWriteParam param = writer.getDefaultWriteParam();
        param.setTileWritingPolicy(policy);
        try {
            if (!writer.writeFromInput(input, inputIndex, param)) {
                return null;
            }
        } finally {
            writer.dispose();
        }
        TileManager tiles = writer.outputTiles;
        /*
         * Before to return the tile manager, if no geometry has been inferred from the target
         * tiles (typically because no setEnvelope(...) has not been invoked), then inherit the
         * geometry from the source tile, if there is any. This operation is conservative and
         * performed only on a "best effort" basis.
         */
        if (tiles.geometry == null) {
            if (writer.inputTiles != null) {
                for (final TileManager candidate : writer.inputTiles) {
                    final ImageGeometry geometry = candidate.getGridGeometry();
                    if (geometry != null) {
                        tiles.setGridToCRS(geometry.getGridToCRS());
                        break;
                    }
                }
            }
        }
        return tiles;
    }

