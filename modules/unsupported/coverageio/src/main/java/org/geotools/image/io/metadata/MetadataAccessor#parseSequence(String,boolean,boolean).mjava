    /**
     * Implementation of {@link #getAttributeAsIntegers} and {@link #getAttributeAsDoubles} methods.
     *
     * @param  sequence The sequence to parse.
     * @param  unique {@code true} if duplicated values should be collapsed into unique values,
     *         or {@code false} for preserving duplicated values.
     * @param  integers {@code true} for parsing as {@code int}, or {@code false} for parsing as
     *         {@code double}.
     * @return The attribute values, or {@code null} if none.
     */
    private Object parseSequence(final String sequence, final boolean unique, final boolean integers) {
        if (sequence == null) {
            return null;
        }
        final Collection<Number> numbers;
        if (unique) {
            numbers = new LinkedHashSet<Number>();
        } else {
            numbers = new ArrayList<Number>();
        }
        final StringTokenizer tokens = new StringTokenizer(sequence);
        while (tokens.hasMoreTokens()) {
            final String token = tokens.nextToken();
            final Number number;
            try {
                if (integers) {
                    number = Integer.valueOf(token);
                } else {
                    number = Double.valueOf(token);
                }
            } catch (NumberFormatException e) {
                warning(integers ? "getAttributeAsIntegers" : "getAttributeAsDoubles", ErrorKeys.UNPARSABLE_NUMBER_$1, token);
                continue;
            }
            numbers.add(number);
        }
        int count = 0;
        final Object values;
        if (integers) {
            values = new int[numbers.size()];
        } else {
            values = new double[numbers.size()];
        }
        for (final Iterator it=numbers.iterator(); it.hasNext();) {
            Array.set(values, count++, it.next());
        }
        assert Array.getLength(values) == count;
        return values;
    }

