    /**
     * Returns a pattern for the given tile. If no pattern can be found, returns {@code null}.
     * This method accepts only tile and input of specific types in order to be able to rebuild
     * later an exactly equivalent object from the pattern.
     *
     * @param  tile The tile to inspect for a pattern in the input object.
     * @return The pattern, or {@code null} if none.
     */
    private String inputPattern(final Tile tile) {
        /*
         * Accepts only instance of Tile (not a subclass), otherwise we will not know how to create
         * the instance on the fly. Once we have verified that the class is Tile, we are allowed to
         * check the tile size using the 'isSizeEquals' shortcut. We accept only tiles that fill
         * completly the cell size, otherwise we can not recreate the tile from a pattern.
         */
        if (!Tile.class.equals(tile.getClass()) || !tile.isSizeEquals(dx, dy)) {
            return null;
        }
        final Object input = tile.getInput();
        final Class<?> type = input.getClass();
        if (!INPUT_TYPES.contains(type)) {
            return null;
        }
        final Point index = getIndex2D(tile);
        String pattern = input.toString();
        pattern = formatter.guessPattern(ordinal, index.x, index.y, pattern);
        if (pattern != null) {
            pattern = type.getSimpleName() + ':' + pattern;
        }
        return pattern;
    }

