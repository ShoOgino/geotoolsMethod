    /**
     * Returns a number format to be used for formatting the sample values in the given image.
     *
     * @param image The image or raster to be written.
     * @param parameters The write parameters, or {@code null} if the whole image will be written.
     * @return A number format appropriate for the given image.
     */
    protected strictfp NumberFormat createNumberFormat(final IIOImage        image,
                                                       final ImageWriteParam parameters)
    {
        final Locale locale = getDataLocale(parameters);
        final int type = image.hasRaster() ? image.getRaster().getTransferType() :
                         image.getRenderedImage().getSampleModel().getDataType();
        if (type != DataBuffer.TYPE_FLOAT && type != DataBuffer.TYPE_DOUBLE) {
            maximum = Short.MAX_VALUE; // TODO: This is not really accurate...
            return (locale != null) ? NumberFormat.getIntegerInstance(locale)
                                    : NumberFormat.getIntegerInstance();
        }
        int digits = 0;
        double multiple = 1;
        maximum = Double.NEGATIVE_INFINITY;
        final RectIter iterator = createRectIter(image, parameters);
        if (!iterator.finishedBands()) do {
            if (!iterator.finishedLines()) do {
                if (!iterator.finishedPixels()) do {
                    final double value = Math.abs(iterator.getSampleDouble());
                    if (Double.isInfinite(value)) {
                        continue;
                    }
                    // Following code is NaN tolerant - no need for explicit check.
                    if (value > maximum) {
                        maximum = value;
                    }
                    while (true) {
                        double scaled = value * multiple;
                        if (type == DataBuffer.TYPE_FLOAT) {
                            scaled = (float) scaled; // Drops the extra digits.
                        }
                        // Condition below uses '!' in order to cath NaN values.
                        if (!(StrictMath.abs(scaled - StrictMath.rint(scaled)) >= DELTA_THRESHOLD)) {
                            break;
                        }
                        if (++digits > MAXIMUM_DIGITS) {
                            return NumberFormat.getNumberInstance(locale);
                        }
                        multiple *= 10;
                    }
                } while (!iterator.nextPixelDone());
                iterator.startPixels();
            } while (!iterator.nextLineDone());
            iterator.startLines();
        } while (!iterator.nextBandDone());
        /*
         * 'digits' should now be the exact number of fraction digits to format. However the above
         * algorithm do not work if all values are smaller (in absolute value) to DELTA_THRESHOLD,
         * in which case 'digits' is still set to 0. In such case it is better to keep the default
         * format unchanged, since it should be generic enough.
         */
        final NumberFormat format = (locale != null) ?
                NumberFormat.getNumberInstance(locale) : NumberFormat.getNumberInstance();
        if (digits != 0 || maximum >= DELTA_THRESHOLD) {
            format.setMaximumFractionDigits(digits);
            if (maximum < NODIGITS_THRESHOLD) {
                format.setMinimumFractionDigits(digits);
            }
        }
        return format;
    }

