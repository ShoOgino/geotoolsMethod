    /**
     * Returns the {@linkplain #input input} as a {@linkplain Reader reader}, which doesn't need to
     * be {@linkplain BufferedReader buffered}. If the reader is an instance supplied explicitly by
     * the user, then it will be {@linkplain Reader#mark marked} with the specified read ahead limit.
     *
     * @return {@link #getInput} as a {@link Reader}, or {@code null} if this method
     *         can't provide a reader suitable for {@code canDecode}.
     * @throws IllegalStateException if the {@linkplain #input input} is not set.
     * @throws IOException If the input stream can't be created for an other reason.
     */
    private Reader getReader(final int readAheadLimit) throws IllegalStateException, IOException {
        final Object input = getInput();
        if (input instanceof Reader) {
            final Reader reader = (Reader) input;
            if (!reader.markSupported()) {
                return null;
            }
            reader.mark(readAheadLimit);
            return reader;
            // Do not set 'closeOnReset' since we don't own the reader.
        }
        final InputStream stream = getInputStream();
        if (closeOnReset == null) {
            // If we are not allowed to close and reopen a new stream on ImageReader.read, then
            // we must be able to mark the stream otherwise we will not support canDecode(...).
            if (!stream.markSupported()) {
                return null;
            }
            stream.mark(readAheadLimit);
        }
        final Reader reader = getInputStreamReader(stream);
        if (closeOnReset == stream) {
            closeOnReset = reader;
        }
        return reader;
    }

