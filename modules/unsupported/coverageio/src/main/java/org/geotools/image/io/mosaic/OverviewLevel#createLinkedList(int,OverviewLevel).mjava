    /**
     * Once every tiles have been {@linkplain #add added} to this grid level, search for a pattern.
     *
     * @param ordinal The overview level of this {@code OverviewLevel}. 0 is finest subsampling.
     * @param finer A level with finer (smaller) subsampling value than this level, or {@code null}.
     * @throws MalformedURLException if an error occured while creating the URL for the tile.
     */
    final void createLinkedList(final int ordinal, final OverviewLevel finer)
            throws MalformedURLException
    {
        this.ordinal = ordinal;
        this.finer   = finer;
        assert getFinerLevel() == finer; // For running the assertions inside getFinerLevel().
        nx = (mosaic.width  + (dx - 1)) / dx;  // Round toward positive infinity.
        ny = (mosaic.height + (dy - 1)) / dy;
        assert (tiles == null) != (patterns == null); // Exactly one of those should be non-null.
        if (patterns != null) {
            /*
             * If this overview level has been created from a pattern, then we are done.
             */
            return;
        }
        /*
         * Searchs for the most common tuple of ImageReaderSpi, imageIndex, input pattern. The
         * rectangle below is named "size" because the (x,y) location is not representative.
         * The tiles that we failed to modelize by a pattern will be stored under the null key.
         */
        formatter = new FilenameFormatter();
        final Rectangle size = new Rectangle(xOffset, yOffset, dx, dy);
        final Map<Tile,List<Tile>> models = new HashMap<Tile,List<Tile>>();
        for (final Tile tile : tiles) {
            final String input = inputPattern(tile);
            final Tile model = (input != null) ? new Tile(tile, input, size) : null;
            List<Tile> similar = models.get(model);
            if (similar == null) {
                similar = new ArrayList<Tile>();
                models.put(model, similar);
            }
            similar.add(tile);
        }
        /*
         * If there is at least one tile that can not be processed, keep them in an array.
         * The array length is exactly (nx*ny) but contains only the elements that should
         * not be computed on the fly (other elements are null). Note that if the number
         * of elements to be computed on the fly is less than some arbitrary threshold,
         * it is not worth to compute them on the fly so we move them to the tiles list.
         */
        tiles = models.remove(null);
        for (final Iterator<List<Tile>> it = models.values().iterator(); it.hasNext();) {
            final List<Tile> similar = it.next();
            if (similar.size() < 4) {
                if (tiles == null) {
                    tiles = similar;
                } else {
                    tiles.addAll(similar);
                }
                it.remove();
            }
        }
        if (tiles != null) {
            tiles = UnmodifiableArrayList.wrap(toArray(tiles));
        }
        /*
         * If there is no recognized pattern, clears the unused fields and finish immediately
         * this method, so we skip the construction of "pattern used" list (which may be large).
         * Note that we clears the formatter unconditionnaly because the last pattern guessed
         * in the 'inputPattern' method may be wrong.
         */
        formatter = null;
        if (models.isEmpty()) {
            return;
        }
        /*
         * Sets the pattern index. Index in the 'tile' array are numbered from 0 (like usual),
         * but values in the 'patternUsed' list are numbered from 1 because we reserve the 0
         * value for non-existant tiles.
         */
        patterns = new Tile[models.size()];
        patternUsed = new IntegerList(nx*ny, patterns.length, true);
        int index = 0;
        for (final Map.Entry<Tile,List<Tile>> entry : models.entrySet()) {
            patterns[index++] = entry.getKey();
            for (final Tile tile : entry.getValue()) {
                final Point pt = getIndex2D(tile);
                final int i = getIndex(pt.x, pt.y);
                final int p = patternUsed.getInteger(i);
                if ((p != 0 && p != index) || (tiles != null && tiles.get(i) != null)) {
                    throw duplicatedTile(pt);
                }
                patternUsed.setInteger(i, index);
            }
        }
        /*
         * In the common case where there is only one pattern and no missing tiles,
         * clears the 'patternUsed' construct since we don't need it.
         */
        if (patterns.length == 1) {
            for (int i=patternUsed.size(); --i >= 0;) {
                if (patternUsed.getInteger(i) == 0) {
                    if (tiles == null || tiles.get(i) == null) {
                        // We have at least one hole, so we need to keep the list of them.
                        return;
                    }
                }
            }
            patternUsed = null;
        }
    }

