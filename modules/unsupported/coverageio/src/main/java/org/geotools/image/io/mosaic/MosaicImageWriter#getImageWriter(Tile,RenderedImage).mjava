    /**
     * Gets and initializes an {@linkplain ImageWriter image writer} that can encode the specified
     * image. The returned writer has its {@linkplain ImageWriter#setOutput output} already set.
     * If the output is different than the {@linkplain Tile#getInput tile input}, then it is
     * probably an {@linkplain ImageOutputStream image output stream} and closing it is caller's
     * responsability.
     * <p>
     * This method must returns a new instance. We are not allowed to cache and recycle writers,
     * because more than one writer may be used simultaneously.
     *
     * @param  tile The tile to encode.
     * @param  image The image associated to the specified tile.
     * @return The image writer that seems to be the most appropriated (never {@code null}).
     * @throws IOException If no suitable image writer has been found or if an error occured
     *         while creating an image writer or initiazing it.
     */
    private ImageWriter getImageWriter(final Tile tile, final RenderedImage image)
            throws IOException
    {
        // Note: we rename "Tile.input" as "output" because we want to write in it.
        final Object         output      = tile.getInput();
        final Class<?>       outputType  = output.getClass();
        final ImageReaderSpi readerSpi   = tile.getImageReaderSpi();
        final String[]       formatNames = readerSpi.getFormatNames();
        final String[]       spiNames    = readerSpi.getImageWriterSpiNames();
        ImageOutputStream    stream      = null; // Created only if needed.
        /*
         * The search will be performed at most twice. In the first try (code below) we check the
         * plugins specified in 'spiNames' since we assume that they will encode the image in the
         * best suited format for the reader. In the second try (to be run if the first one found
         * no suitable writer), we look for providers by their name.
         */
        if (spiNames != null) {
            final IIORegistry registry = IIORegistry.getDefaultInstance();
            final ImageWriterSpi[] providers = new ImageWriterSpi[spiNames.length];
            int count = 0;
            for (final String name : spiNames) {
                final Class<?> spiType;
                try {
                    spiType = Class.forName(name);
                } catch (ClassNotFoundException e) {
                    // May be normal.
                    continue;
                }
                /*
                 * For each image writers, checks if at least one format name is an expected one
                 * and check if the writer can encode the image. If a suitable writter is found
                 * and is capable to encode the output, returns it immediately. Otherwise the
                 * writers are stored in an array as we found it, in order to try them again with
                 * an ImageOutputStream after this loop.
                 */
                final Object candidate = registry.getServiceProviderByClass(spiType);
                if (candidate instanceof ImageWriterSpi) {
                    final ImageWriterSpi spi = (ImageWriterSpi) candidate;
                    final String[] names = spi.getFormatNames();
                    if (XArray.intersects(formatNames, names) && spi.canEncodeImage(image)) {
                        providers[count++] = spi;
                        for (final Class<?> legalType : spi.getOutputTypes()) {
                            if (legalType.isAssignableFrom(outputType)) {
                                final ImageWriter writer = spi.createWriterInstance();
                                writer.setOutput(output);
                                if (filter(writer)) {
                                    return writer;
                                }
                                writer.dispose();
                                break;
                            }
                        }
                    }
                }
            }
            /*
             * No provider accepts the output directly. This output is typically a File or URL.
             * Creates an image output stream from it and try again.
             */
            if (count != 0) {
                stream = ImageIO.createImageOutputStream(output);
                if (stream != null) {
                    final Class<? extends ImageOutputStream> streamType = stream.getClass();
                    for (int i=0; i<count; i++) {
                        final ImageWriterSpi spi = providers[i];
                        for (final Class<?> legalType : spi.getOutputTypes()) {
                            if (legalType.isAssignableFrom(streamType)) {
                                final ImageWriter writer = spi.createWriterInstance();
                                writer.setOutput(stream);
                                if (filter(writer)) {
                                    return writer;
                                }
                                writer.dispose();
                                break;
                            }
                        }
                    }
                }
            }
        }
        /*
         * No suitable writer found from 'spiNames'. Try again using format name.
         * At the difference of the previous try, this one works on ImageWriters
         * instead of ImageWriterSpi instances.
         */
        for (final String name : formatNames) {
            final List<ImageWriter> writers = new ArrayList<ImageWriter>();
            final Iterator<ImageWriter> it = ImageIO.getImageWritersByFormatName(name);
            while (it.hasNext()) {
                final ImageWriter writer = it.next();
                final ImageWriterSpi spi = writer.getOriginatingProvider();
                if (spi == null || !spi.canEncodeImage(image)) {
                    writer.dispose();
                    continue;
                }
                writers.add(writer);
                for (final Class<?> legalType : spi.getOutputTypes()) {
                    if (legalType.isAssignableFrom(outputType)) {
                        writer.setOutput(output);
                        if (filter(writer)) {
                            return writer;
                        }
                        // Do not dispose the writer since we will try it again later.
                        break;
                    }
                }
            }
            if (!writers.isEmpty()) {
                if (stream == null) {
                    stream = ImageIO.createImageOutputStream(output);
                    if (stream == null) {
                        break;
                    }
                }
                final Class<? extends ImageOutputStream> streamType = stream.getClass();
                for (final ImageWriter writer : writers) {
                    final ImageWriterSpi spi = writer.getOriginatingProvider();
                    for (final Class<?> legalType : spi.getOutputTypes()) {
                        if (legalType.isAssignableFrom(streamType)) {
                            writer.setOutput(stream);
                            if (filter(writer)) {
                                return writer;
                            }
                            break;
                        }
                    }
                    writer.dispose();
                }
            }
        }
        if (stream != null) {
            stream.close();
        }
        throw new IIOException(Errors.format(ErrorKeys.NO_IMAGE_WRITER));
    }

