    /**
     * Returns the smallest tree node containing the given region. This method assumes that
     * {@code this} node, if non-empty, {@linkplain #contains contains} the given bounds.
     * Note that the constructor may invoke this method from the root with an empty bounding
     * box, which is valid.
     * <p>
     * This method tries to returns the smallest {@linkplain #isGridded gridded} node, if any.
     * By "gridded" we mean a node that can align the given bounds on a grid. If there is no
     * such node, then any node containing the bounds is returned.
     *
     * @param  The bounds to check for inclusion.
     * @return The smallest node, or {@code this} if none (never {@code null}).
     */
    private GridNode smallest(final Rectangle bounds) {
        long smallestArea;
        boolean gridded;
        if (isEmpty()) {
            smallestArea = Long.MAX_VALUE;
            gridded = false;
        } else {
            assert contains(bounds);
            smallestArea = (long) width * (long) height;
            gridded = isGridded(bounds);
        }
        GridNode smallest = this;
        GridNode child = (GridNode) firstChildren();
        while (child != null) {
            if (child.contains(bounds)) {
                final GridNode candidate = child.smallest(bounds);
                final boolean cg = candidate.isGridded(bounds);
                if (!gridded || cg) {
                    final long area = (long) candidate.width * (long) candidate.height;
                    if ((!gridded && cg) || (area < smallestArea)) {
                        // If the smallest node was not gridded while the candidate is gridded,
                        // retains the candidate inconditionnaly. Otherwise retains only if smaller.
                        smallestArea = area;
                        smallest = candidate;
                        gridded = cg;
                    }
                }
            }
            child = (GridNode) child.nextSibling();
        }
        return smallest;
    }

