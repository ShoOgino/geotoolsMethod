    /**
     * Defines valid and fill <em>packed</em> values as a combinaison of
     * <code>{@linkplain #setValidRange(double,double) setValidRange}(minValue, maxValue)</code>
     * and <code>{linkplain #setNoDataValues(double[]) setNoDataValues}(fillValues)</code>.
     * <p>
     * If the minimal or maximal value is {@linkplain Double#isInfinite infinite} and the data
     * type is an integer type, then this method replaces the infinite values by default bounds
     * inferred from the data type and the fill values.
     *
     * @param minValue   The minimal valid <em>packed</em> value,
     *                   or {@link Double#NEGATIVE_INFINITY} if unknown.
     * @param maxValue   The maximal valid <em>packed</em> value,
     *                   or {@link Double#POSITIVE_INFINITY} if unknown.
     * @param fillValues The packed values used for missing data, or {@code null} if none.
     * @param dataType   The raw data type as one of {@link DataBuffer} constants, or
     *                   {@link DataBuffer#TYPE_UNDEFINED} if unknown.
     *
     * @see #setValidRange
     * @see #setNoDataValues
     */
    public void setPackedValues(double minValue, double maxValue, final double[] fillValues,
            final int dataType)
    {
        minValue = replaceInfinity(minValue, fillValues, dataType);
        maxValue = replaceInfinity(maxValue, fillValues, dataType);
        setValidRange(minValue, maxValue);
        setNoDataValues(fillValues);
    }

