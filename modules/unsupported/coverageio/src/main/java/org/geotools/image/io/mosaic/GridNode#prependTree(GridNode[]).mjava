    /**
     * Inserts a tree of nodes without tiles before the nodes in the given array. This method is
     * typically invoked for {@linkplain #isFlat flat} array of nodes only, which are the "worst
     * case" scenario. This method tries to attenuate the effect of worst case scenario.
     * <p>
     * The order of nodes is significant. This method must prepend bigger nodes first, like what
     * we would get if the nodes where associated with real tiles and the array sorted with the
     * {@link #PRE_PROCESSING} comparator.
     *
     * @param  nodes The nodes for which to prepend a tree.
     * @return The nodes with a tree prepend before them.
     */
    private static GridNode[] prependTree(GridNode[] nodes) {
        final Dimension largest = new Dimension();
        final Rectangle bounds = new Rectangle(-1,-1);
        for (final GridNode node : nodes) {
            bounds.add(node);
            if (node.width  > largest.width)  largest.width  = node.width;
            if (node.height > largest.height) largest.height = node.height;
        }
        if (!bounds.isEmpty()) {
            /*
             * Asks for node that can contain at least 2Ã—2 tiles, otherwise creating
             * those nodes would consume memory without significant performance gain.
             */
            largest.width  *= 2;
            largest.height *= 2;
            final int[][] divisors = MosaicBuilder.suggestedNumTiles(bounds, largest, 16, false);
            final int[] sx = divisors[0];
            final int[] sy = divisors[1];
            final Rectangle part = new Rectangle();
            final List<GridNode> list = new ArrayList<GridNode>();
            for (int i=0; i<sx.length; i++) {
                final int nx = sx[i];
                final int ny = sy[i];
                part.y      = bounds.y;
                part.width  = bounds.width  / nx;
                part.height = bounds.height / ny;
                for (int y=0; y<ny; y++) {
                    part.x = bounds.x;
                    for (int x=0; x<nx; x++) {
                        list.add(new GridNode(part));
                        part.x += part.width;
                    }
                    part.y += part.height;
                }
            }
            final int size = list.size();
            final GridNode[] old = nodes;
            nodes = list.toArray(new GridNode[size + old.length]);
            System.arraycopy(old, 0, nodes, size, old.length);
        }
        return nodes;
    }

