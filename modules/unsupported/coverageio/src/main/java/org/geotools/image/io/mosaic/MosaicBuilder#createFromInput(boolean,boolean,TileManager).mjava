    /**
     * Creates tiles for the following cases:
     * <ul>
     *   <li>covering a constant geographic region. The tile size will reduce as we progress into
     *       overviews levels. The {@link #minimumTileSize} value is the stop condition - no smaller
     *       tiles will be created.</li>
     *   <li>tiles of constant size in pixels. The stop condition is when a single tile cover
     *       the whole image.</li>
     * </ul>
     *
     * @param  constantArea
     *          {@code true} for constant area layout, or {@code false} for constant
     *          tile size layout.
     * @param  usePattern
     *          {@code true} for creating tiles using a pattern instead of creating
     *          individual instance of every tiles.
     * @param  input
     *          The tile manager for the input tiles, or {@code null} if none. If non-null, this is
     *          used only in order to filter the output tiles to the ones that intersect the input
     *          tiles. This value should be {@code null} if no such filtering should be applied.
     * @return The tile manager.
     * @throws IOException if an I/O operation was requested and failed.
     */
    private TileManager createFromInput(final boolean constantArea, final boolean usePattern,
                                        final TileManager input)
            throws IOException
    {
        final Dimension tileSize      = this.tileSize;      // Paranoiac compile-time safety against
        final Rectangle untiledBounds = this.untiledBounds; // unwanted reference assignments.
        final Rectangle imageBounds   = new Rectangle(untiledBounds);
        final Rectangle tileBounds    = new Rectangle(tileSize);
        Dimension[] subsamplings = getSubsamplings();
        if (subsamplings == null) {
            final int n;
            if (constantArea) {
                n = Math.max(tileBounds.width, tileBounds.height) / MIN_TILE_SIZE;
            } else {
                n = Math.max(imageBounds.width  / tileBounds.width,
                             imageBounds.height / tileBounds.height);
            }
            subsamplings = new Dimension[n];
            for (int i=1; i<=n; i++) {
                subsamplings[i-1] = new Dimension(i,i);
            }
        }
        final List<Tile> tiles;
        final OverviewLevel[] levels;
        if (usePattern) {
            tiles  = null;
            levels = new OverviewLevel[subsamplings.length];
        } else {
            tiles  = new ArrayList<Tile>();
            levels = null;
        }
        final Rectangle absoluteBounds = new Rectangle();
        /*
         * For each overview level, computes the size of tiles and the size of the mosaic as
         * a whole. The 'tileBounds' and 'imageBounds' rectangles are overwritten during each
         * iteration. The filename formatter is configured according the expected number of
         * tiles computed from the bounds.
         */
        formatter.computeLevelFieldSize(subsamplings.length);
        for (int level=0; level<subsamplings.length; level++) {
            final Dimension subsampling = subsamplings[level];
            final int xSubsampling = subsampling.width;
            final int ySubsampling = subsampling.height;
            imageBounds.setBounds(untiledBounds.x      / xSubsampling,
                                  untiledBounds.y      / ySubsampling,
                                  untiledBounds.width  / xSubsampling,
                                  untiledBounds.height / ySubsampling);
            tileBounds.setBounds(imageBounds);
            tileBounds.setSize(tileSize);
            if (constantArea) {
                tileBounds.width  /= xSubsampling;
                tileBounds.height /= ySubsampling;
            } else {
                if (tileBounds.width  > imageBounds.width)  tileBounds.width  = imageBounds.width;
                if (tileBounds.height > imageBounds.height) tileBounds.height = imageBounds.height;
            }
            formatter.computeFieldSizes(imageBounds, tileBounds);
            /*
             * If we are allowed to use a pattern, create directly the pattern string.
             * Example of pattern: "File:directory/L{level:1}_{column:2}{row:2}.png".
             * It will take much less memory than creating every individual tiles, but
             * is possible only if the user didn't customized too much the tiles creation.
             */
            if (usePattern) {
                String pattern = formatter.toString();
                pattern = new File(directory, pattern).getPath();
                pattern = "File:" + pattern;
                final Tile tile = new Tile(tileReaderSpi, pattern, 0, tileBounds, subsampling);
                final OverviewLevel ol = new OverviewLevel(tile, imageBounds);
                ol.createLinkedList(level, (level != 0) ? levels[level - 1] : null);
                if (input != null) {
                    final int nx = ol.getNumXTiles();
                    final int ny = ol.getNumYTiles();
                    absoluteBounds.width  = xSubsampling * tileBounds.width;
                    absoluteBounds.height = ySubsampling * tileBounds.height;
                    absoluteBounds.y      = ySubsampling * tileBounds.y;
                    for (int y=0; y<ny; y++) {
                        absoluteBounds.x = xSubsampling * tileBounds.x;
                        for (int x=0; x<nx; x++) {
                            if (!input.intersects(absoluteBounds, subsampling)) {
                                ol.removeTile(x, y);
                            }
                            absoluteBounds.x += absoluteBounds.width;
                        }
                        absoluteBounds.y += absoluteBounds.height;
                    }
                }
                levels[level] = ol;
            } else {
                /*
                 * If we are not allowed to use a pattern, enumerate every tiles individually.
                 * We will let TileManagerFactory tries to figure out a layout from them. Note
                 * that the factory may create a GridTileManager instance anyway, but the later
                 * will typically be more customized than the one created in the 'usePattern' case.
                 */
                final int xmin = imageBounds.x;
                final int ymin = imageBounds.y;
                final int xmax = imageBounds.width  + xmin;
                final int ymax = imageBounds.height + ymin;
                final int dx   = tileBounds.width;
                final int dy   = tileBounds.height;
                absoluteBounds.width  = xSubsampling * dx;
                absoluteBounds.height = ySubsampling * dy;
                int y = 0;
                for (tileBounds.y = ymin; tileBounds.y < ymax; tileBounds.y += dy, y++) {
                    int x = 0;
                    absoluteBounds.y = ySubsampling * tileBounds.y;
                    for (tileBounds.x = xmin; tileBounds.x < xmax; tileBounds.x += dx, x++) {
                        if (input != null) {
                            absoluteBounds.x = xSubsampling * tileBounds.x;
                            if (!input.intersects(absoluteBounds, subsampling)) {
                                continue;
                            }
                        }
                        Rectangle clippedBounds = tileBounds.intersection(imageBounds);
                        File file = new File(directory, generateFilename(level, x, y));
                        Tile tile = new Tile(tileReaderSpi, file, 0, clippedBounds, subsampling);
                        tiles.add(tile);
                    }
                }
            }
        }
        /*
         * Creates the tile manager. If assertions are enabled, the manager created using
         * patterns will be compared to the manager created by enumerating every tiles.
         */
        final TileManager manager;
        if (usePattern) {
            manager = new GridTileManager(levels[levels.length - 1]);
            /*
             * Following assertion creates a new TileManager by enumerating every tiles
             * (instead than using the pattern) and makes sure that we get the same set
             * of tiles. The later comparaison is trigged by the call to getTiles().
             */
            assert !(new ComparedTileManager(manager,
                    createFromInput(constantArea, false, input)).getTiles().isEmpty());
        } else {
            final TileManager[] managers = factory.create(tiles);
            manager = managers[0];
        }
        return manager;
    }

