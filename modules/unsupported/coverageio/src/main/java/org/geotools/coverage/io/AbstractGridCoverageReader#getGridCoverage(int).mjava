    /**
     * Reads the grid coverage. The default implementation gets the default {@link ImageReadParam}
     * and checks if it is an instance of {@link RawBinaryImageReadParam}. If it is, this method
     * then invokes {@link RawBinaryImageReadParam#setStreamImageSize} with informations provided
     * by {@link #getGridRange}. Finally, a grid coverage is constructed using informations provided
     * by {@link #getName}, {@link #getCoordinateReferenceSystem} and {@link #getEnvelope}.
     *
     * @param  index The index of the image to be queried.
     * @return The {@link GridCoverage} at the specified index.
     * @throws IllegalStateException if the input source has not been set.
     * @throws IndexOutOfBoundsException if the supplied index is out of bounds.
     * @throws IOException if an error occurs reading the width information from the input source.
     */
    public synchronized GridCoverage getGridCoverage(final int index) throws IOException {
        checkImageIndex(index);
        final ImageReadParam param = reader.getDefaultReadParam();
        if (param instanceof RawBinaryImageReadParam) {
            final RawBinaryImageReadParam rawParam = (RawBinaryImageReadParam) param;
            final GridEnvelope range = getGridRange(index);
            final Dimension  size = new Dimension(range.getSpan(0), range.getSpan(1));
            rawParam.setStreamImageSize(size);
        }
        final String                   name = getName(index);
        final MathTransform       gridToCRS = getMathTransform(index);
        final CoordinateReferenceSystem crs = getCoordinateReferenceSystem(index);
        final GridSampleDimension[]   bands = getSampleDimensions(index);
        final RenderedImage           image = reader.readAsRenderedImage(index, param);
        if (LOGGER.isLoggable(Level.FINE)) {
            /*
             * Log the arguments used for creating the GridCoverage. This is a costly logging:
             * the string representations for some argument are very long   (RenderedImage and
             * CoordinateReferenceSystem), and string representation for sample dimensions may
             * use many lines.
             */
            final Envelope   envelope = getEnvelope(index);
            final StringWriter buffer = new StringWriter(         );
            final LineWriter   trimer = new LineWriter  (buffer   );
            final TableWriter   table = new TableWriter (trimer, 1);
            final PrintWriter     out = new PrintWriter (table    );
            buffer.write("Creating GridCoverage[\"");
            buffer.write(name);
            buffer.write("\"] with:");
            buffer.write(trimer.getLineSeparator());
            table.setMultiLinesCells(true);
            final int sdCount = (bands != null) ? bands.length : 0;
            for (int i=-3; i<sdCount; i++) {
                String key = "";
                Object value;
                switch (i) {
                    case -3: key="RenderedImage";             value=image;    break;
                    case -2: key="CoordinateReferenceSystem"; value=crs;      break;
                    case -1: key="Envelope";                  value=envelope; break;
                    case  0: key="SampleDimensions"; // fall through
                    default: value = bands[i]; break;
                }
                out.print("    ");
                out.print(key   ); table.nextColumn();
                out.print('='   ); table.nextColumn();
                out.print(value ); table.nextLine();
            }
            out.flush();
            LOGGER.fine(buffer.toString());
        }
        return factory.create(name, image, crs, gridToCRS, bands, null, null);
    }

