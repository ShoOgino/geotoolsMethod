    /**
     * Reads the image indexed by {@code imageIndex} using a supplied parameters.
     * <strong>See {@link MosaicImageReadParam} for a performance recommandation</strong>.
     * If the parameters allow subsampling changes, then the subsampling effectively used
     * will be written back in the given parameters.
     *
     * @param  imageIndex The index of the image to be retrieved.
     * @param  param The parameters used to control the reading process, or {@code null}.
     *         An instance of {@link MosaicImageReadParam} is expected but not required.
     * @return The desired portion of the image.
     * @throws IOException if an error occurs during reading.
     */
    public BufferedImage read(final int imageIndex, final ImageReadParam param) throws IOException {
        clearAbortRequest();
        processImageStarted(imageIndex);
        final Dimension subsampling = new Dimension(1,1);
        boolean subsamplingChangeAllowed = false;
        MosaicImageReadParam mosaicParam = null;
        boolean nullForEmptyImage = false;
        if (param != null) {
            subsampling.width  = param.getSourceXSubsampling();
            subsampling.height = param.getSourceYSubsampling();
            if (param instanceof MosaicImageReadParam) {
                mosaicParam = (MosaicImageReadParam) param;
                subsamplingChangeAllowed = mosaicParam.isSubsamplingChangeAllowed();
                nullForEmptyImage = mosaicParam.getNullForEmptyImage();
            }
            // Note: we don't extract subsampling offsets because they will be taken in account
            //       in the 'sourceRegion' to be calculated by ImageReader.computeRegions(...).
        }
        final int srcWidth  = getWidth (imageIndex);
        final int srcHeight = getHeight(imageIndex);
        final Rectangle sourceRegion = getSourceRegion(param, srcWidth, srcHeight);
        final Collection<Tile> tiles = getTileManager(imageIndex)
                .getTiles(sourceRegion, subsampling, subsamplingChangeAllowed);
        if (nullForEmptyImage && tiles.isEmpty()) {
            processImageComplete();
            return null;
        }
        /*
         * If the subsampling changed as a result of TileManager.getTiles(...) call,
         * stores the new subsampling values in the parameters. Note that the source
         * region will need to be computed again, which we will do later.
         */
        final int xSubsampling = subsampling.width;
        final int ySubsampling = subsampling.height;
        if (subsamplingChangeAllowed) {
            if (param.getSourceXSubsampling() != xSubsampling ||
                param.getSourceYSubsampling() != ySubsampling)
            {
                final int xOffset = param.getSubsamplingXOffset() % xSubsampling;
                final int yOffset = param.getSubsamplingYOffset() % ySubsampling;
                param.setSourceSubsampling(xSubsampling, ySubsampling, xOffset, yOffset);
            } else {
                subsamplingChangeAllowed = false;
            }
        }
        /*
         * If there is exactly one image to read, we will left the image reference to null. It will
         * be understood later as an indication to delegate directly to the sole image reader as an
         * optimization (no search for raw data type). Otherwise, we need to create the destination
         * image here. Note that this is the only image ever to be created during a mosaic read,
         * unless some underlying ImageReader do not honor our ImageReadParam.setDestination(image)
         * setting. In such case, the default behavior is to thrown an exception.
         */
        BufferedImage image = null;
        final Rectangle destRegion;
        final Point destinationOffset;
        ImageTypePolicy policy = null;
        if (canDelegate(tiles, sourceRegion) && (policy = getImageTypePolicy(param)).canDelegate) {
            destRegion = null;
            if (subsamplingChangeAllowed) {
                sourceRegion.setBounds(getSourceRegion(param, srcWidth, srcHeight));
            }
            destinationOffset = (param != null) ? param.getDestinationOffset() : new Point();
        } else {
            if (param != null) {
                image = param.getDestination();
            }
            destRegion = new Rectangle(); // Computed by the following method call.
            computeRegions(param, srcWidth, srcHeight, image, sourceRegion, destRegion);
            if (image == null) {
                /*
                 * If no image was explicitly specified, creates one using a raw image type
                 * acceptable for all tiles. An exception will be thrown if no such raw type
                 * was found. Note that this fallback may be a little bit costly since it may
                 * imply to open, close and reopen later some streams.
                 */
                ImageTypeSpecifier imageType = null;
                if (param != null) {
                    imageType = param.getDestinationType();
                }
                if (imageType == null) {
                    if (policy == null) {
                        policy = getImageTypePolicy(param);
                    }
                    switch (policy) {
                        default: {
                            imageType = getPredefinedImageType(policy);
                            break;
                        }
                        case SUPPORTED_BY_ONE: {
                            final Tile tile = getSpecificTile(tiles);
                            if (tile != null) {
                                imageType = tile.getImageReader(this, true, true).getRawImageType(imageIndex);
                                assert imageType.equals(getRawImageType(tiles)) : incompatibleImageType(tile);
                            }
                            break;
                        }
                        case SUPPORTED_BY_ALL: {
                            imageType = getRawImageType(tiles);
                            break;
                        }
                    }
                    if (imageType == null) {
                        /*
                         * This case occurs if the tiles collection is empty.  We want to produce
                         * a fully transparent (or empty) image in such case. Remember that tiles
                         * are not required to exist everywhere in the mosaic bounds,  so the set
                         * of tiles in a particular sub-area is allowed to be empty.
                         */
                        imageType = getRawImageType(imageIndex);
                    }
                }
                final int width  = destRegion.x + destRegion.width;
                final int height = destRegion.y + destRegion.height;
                image = imageType.createBufferedImage(width, height);
                computeRegions(param, srcWidth, srcHeight, image, sourceRegion, destRegion);
            }
            destinationOffset = destRegion.getLocation();
        }
        /*
         * Gets a MosaicImageReadParam instance to be used for caching Tile parameters. There is
         * no need to invokes 'getDefaultReadParam()' since we are interrested only in the cache
         * that MosaicImageReadParam provide.
         */
        MosaicController controller = null;
        if (mosaicParam == null) {
            mosaicParam = new MosaicImageReadParam();
        } else if (mosaicParam.hasController()) {
            final IIOParamController candidate = mosaicParam.getController();
            if (candidate instanceof MosaicController) {
                controller = (MosaicController) candidate;
            }
        }
        /*
         * If logging are enabled, we will format the tiles that we read in a table and logs
         * the table as one log record before the actual reading. If there is nothing to log,
         * then the table will be left to null. If non-null, the table will be completed in
         * the 'do' loop below.
         */
        final Logger logger = Logging.getLogger(MosaicImageReader.class);
        TableWriter table = null;
        if (logger.isLoggable(level)) {
            table = new TableWriter(null, TableWriter.SINGLE_VERTICAL_LINE);
            table.writeHorizontalSeparator();
            table.write("Reader\tTile\tIndex\tSize\tSource\tDestination\tSubsampling");
            table.writeHorizontalSeparator();
        }
        /*
         * Now read every tiles... If logging is disabled, then this loop will be executed exactly
         * once. If logging is enabled, then this loop will be executed twice where the first pass
         * is used only in order to format the table to be logged. In every cases, the last pass is
         * the one where the actual reading occur. We do this two pass approach in order to get the
         * table logged before loading rather than after. This is more useful in case of exception.
         */
        do {
            for (final Tile tile : tiles) {
                if (abortRequested()) {
                    processReadAborted();
                    break;
                }
                final Rectangle tileRegion = tile.getAbsoluteRegion();
                final Rectangle regionToRead = tileRegion.intersection(sourceRegion);
                /*
                 * Computes the location of the region to read relative to the source region
                 * requested by the user, and make sure that this location is a multiple of
                 * subsampling (if any). The region to read may become bigger by one pixel
                 * (in tile units) as a result of this calculation.
                 */
                int xOffset = (regionToRead.x - sourceRegion.x) % xSubsampling;
                int yOffset = (regionToRead.y - sourceRegion.y) % ySubsampling;
                if (xOffset != 0) {
                    regionToRead.x     -= xOffset;
                    regionToRead.width += xOffset;
                    if (regionToRead.x < tileRegion.x) {
                        regionToRead.x = tileRegion.x;
                        if (regionToRead.width > tileRegion.width) {
                            regionToRead.width = tileRegion.width;
                        }
                    }
                }
                if (yOffset != 0) {
                    regionToRead.y      -= yOffset;
                    regionToRead.height += yOffset;
                    if (regionToRead.y < tileRegion.y) {
                        regionToRead.y = tileRegion.y;
                        if (regionToRead.height > tileRegion.height) {
                            regionToRead.height = tileRegion.height;
                        }
                    }
                }
                if (regionToRead.isEmpty()) {
                    continue;
                }
                /*
                 * Now that the offset is a multiple of subsampling, computes the destination offset.
                 * Then translate the region to read from "this image reader" space to "tile" space.
                 */
                if (destRegion != null) {
                    xOffset = (regionToRead.x - sourceRegion.x) / xSubsampling;
                    yOffset = (regionToRead.y - sourceRegion.y) / ySubsampling;
                    destinationOffset.x = destRegion.x + xOffset;
                    destinationOffset.y = destRegion.y + yOffset;
                }
                assert tileRegion.contains(regionToRead) : regionToRead;
                regionToRead.translate(-tileRegion.x, -tileRegion.y);
                /*
                 * Sets the parameters to be given to the tile reader. We don't use any subsampling
                 * offset because it has already been calculated in the region to read. Note that
                 * the tile subsampling should be a divisor of image subsampling; this condition must
                 * have been checked by the tile manager when it selected the tiles to be returned.
                 */
                subsampling.setSize(tile.getSubsampling());
                assert xSubsampling % subsampling.width  == 0 : subsampling;
                assert ySubsampling % subsampling.height == 0 : subsampling;
                /*
                 * Transform the region to read from "absolute" coordinates to "relative to tile"
                 * coordinates. We want to round x and y toward negative infinity, which require
                 * special processing for negative numbers since integer arithmetic round toward
                 * zero. The xOffset and yOffset values are the remainding of the division which
                 * will be added to the width and height in order to get (xmax, ymax) unchanged.
                 */
                xOffset = regionToRead.x % subsampling.width;
                yOffset = regionToRead.y % subsampling.height;
                regionToRead.x /= subsampling.width;
                regionToRead.y /= subsampling.height;
                if (xOffset < 0) {
                    regionToRead.x--;
                    xOffset = subsampling.width - xOffset;
                }
                if (yOffset < 0) {
                    regionToRead.y--;
                    yOffset = subsampling.height - yOffset;
                }
                regionToRead.width  += xOffset;
                regionToRead.height += yOffset;
                regionToRead.width  /= subsampling.width;
                regionToRead.height /= subsampling.height;
                subsampling.width  = xSubsampling / subsampling.width;
                subsampling.height = ySubsampling / subsampling.height;
                final int tileIndex = tile.getImageIndex();
                if (table != null) {
                    /*
                     * We are only logging - we are not going to read in this first pass.
                     */
                    table.write(Tile.toString(tile.getImageReaderSpi()));
                    table.nextColumn();
                    table.write(tile.getInputName());
                    table.nextColumn();
                    table.write(String.valueOf(tileIndex));
                    format(table, regionToRead.width,  regionToRead.height);
                    format(table, regionToRead.x,      regionToRead.y);
                    format(table, destinationOffset.x, destinationOffset.y);
                    format(table, subsampling.width,   subsampling.height);
                    table.nextLine();
                    continue;
                }
                final ImageReader reader = tile.getImageReader(this, true, true);
                final ImageReadParam tileParam = mosaicParam.getCachedTileParameters(reader);
                tileParam.setDestinationType(null);
                tileParam.setDestination(image); // Must be after setDestinationType and may be null.
                tileParam.setDestinationOffset(destinationOffset);
                if (tileParam.canSetSourceRenderSize()) {
                    tileParam.setSourceRenderSize(null); // TODO.
                }
                tileParam.setSourceRegion(regionToRead);
                tileParam.setSourceSubsampling(subsampling.width, subsampling.height, 0, 0);
                if (controller != null) {
                    controller.configure(tile, tileParam);
                }
                final BufferedImage output;
                synchronized (this) {  // Same lock than ImageReader.abort()
                    reading = reader;
                }
                try {
                    output = reader.read(tileIndex, tileParam);
                } finally {
                    synchronized (this) {  // Same lock than ImageReader.abort()
                        reading = null;
                    }
                }
                if (image == null) {
                    image = output;
                } else if (output != image) {
                    /*
                     * The read operation ignored our destination image.  By default we treat that
                     * as an error since the SampleModel may be incompatible and changing it would
                     * break the geophysics meaning of pixel values. However if we are interrested
                     * only in the visual aspect, we can copy the data (slow, consumes memory) and
                     * let Java2D performs the required color conversions. Note that it should not
                     * occur anyway if we choose correctly the raw image type in the code above.
                     */
                    if (PRESERVE_DATA) {
                        throw new IIOException("Incompatible data format."); // TODO: localize
                    }
                    final AffineTransform at = AffineTransform.getTranslateInstance(
                            destinationOffset.x, destinationOffset.y);
                    final Graphics2D graphics = image.createGraphics();
                    graphics.drawRenderedImage(output, at);
                    graphics.dispose();
                }
            }
            /*
             * Finished a pass. If it was the reading pass, then we are done. If it was the logging
             * pass, then send the log and redo the look a second time for the actual reading.
             */
            if (table == null) {
                break;
            }
            table.writeHorizontalSeparator();
            final StringBuilder message = new StringBuilder();
            message.append('[').append(sourceRegion.x).append(',').append(sourceRegion.y).
                    append(" - ").append(sourceRegion.x + sourceRegion.width).append(',').
                    append(sourceRegion.y + sourceRegion.height).append(']');
            final String area = message.toString();
            message.setLength(0);
            message.append(Vocabulary.format(VocabularyKeys.LOADING_$1, area)).
                    append(System.getProperty("line.separator", "\n")).append(table);
            final LogRecord record = new LogRecord(level, message.toString());
            record.setSourceClassName(MosaicImageReader.class.getName());
            record.setSourceMethodName("read");
            record.setLoggerName(logger.getName());
            logger.log(record);
            table = null;
        } while (true);
        processImageComplete();
        return image;
    }

