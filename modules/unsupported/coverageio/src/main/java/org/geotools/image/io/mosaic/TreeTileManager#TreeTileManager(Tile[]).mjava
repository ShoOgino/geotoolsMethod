    /**
     * Creates a manager for the given tiles. This constructor is protected for subclassing,
     * but should not be invoked directly. {@code TreeTileManager} instances should be created
     * by {@link TileManagerFactory}.
     *
     * @param tiles The tiles. This array is not cloned and elements in this array may be
     *        reordered by this constructor. The public methods in {@link TileManagerFactory}
     *        are reponsible for cloning the user-provided arrays if needed.
     */
    protected TreeTileManager(final Tile[] tiles) {
        /*
         * Puts together the tiles that use the same input. For those that use
         * different input, we will order by image index first, then (y,x) order.
         */
        Tile.ensureNonNull("tiles", tiles);
        final Map<ReaderInputPair,List<Tile>> tilesByInput =
                new LinkedHashMap<ReaderInputPair, List<Tile>>(tiles.length + tiles.length/4 + 1);
        providers = new FrequencySortedSet<ImageReaderSpi>(4, true);
        for (final Tile tile : tiles) {
            tile.checkGeometryValidity();
            final ImageReaderSpi  spi = tile.getImageReaderSpi();
            final ReaderInputPair key = new ReaderInputPair(spi, tile.getInput());
            List<Tile> sameInputs = tilesByInput.get(key);
            if (sameInputs == null) {
                /*
                 * We will usually have only one element in each list. Because we may create
                 * thousands of them, it is better to stick to such a small size. If we have
                 * more elements, the number of distinct lists will be smaller and they will
                 * be reasonably cheap to growth.
                 */
                sameInputs = new ArrayList<Tile>(1);
                tilesByInput.put(key, sameInputs);
                providers.add(spi);
            }
            sameInputs.add(tile);
        }
        providers = Collections.unmodifiableSet(providers);
        /*
         * Overwrites the tiles array with the same tiles, but ordered with same input firsts.
         */
        @SuppressWarnings("unchecked")
        final List<Tile>[] asArray = tilesByInput.values().toArray(new List[tilesByInput.size()]);
        final Comparator<List<Tile>> comparator = Comparators.forLists();
        Arrays.sort(asArray, comparator);
        int numTiles = 0;
        for (final List<Tile> sameInputs : asArray) {
            switch (sameInputs.size()) {
                case 0:  throw new AssertionError(); // Should never happen.
                case 1:  break; // Worthly optimization when we have thousands of lists of lenght 1.
                default: Collections.sort(sameInputs); break;
            }
            for (final Tile tile : sameInputs) {
                tiles[numTiles++] = tile;
            }
        }
        this.tiles = tiles;
        allTiles = UnmodifiableArrayList.wrap(tiles);
    }

