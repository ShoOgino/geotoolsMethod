    /**
     * Returns the amount of pixels in this tile that would be useless if reading the given region
     * at the given subsampling. This method is invoked by {@link TileManager} when two or more
     * tile overlaps, in order to choose the tiles that would minimize the amount of pixels to
     * read. The default implementation computes the sum of:
     * <ul>
     *   <li>the amount of tile pixels skipped because of the given subsampling</li>
     *   <li>the amount of pixels in this {@linkplain #getRegion tile region} that are outside
     *       the given region, including the pixels below the bottom.</li>
     * </ul>
     * The later is conservative since many file formats will stop reading as soon as they reach
     * the region bottom. We may consider allowing overriding in order to alter this calculation
     * if a subclass is sure that pixels below the region have no disk seed cost.
     *
     * @param  toRead The region to read, in the same units than {@link #getAbsoluteRegion}.
     * @param  subsampling The number of columns and rows to advance between pixels
     *         in the given region. Must be strictly positive (not zero).
     * @return The amount of pixels which would be unused if the reading was performed on this
     *         tile. Smaller number is better.
     * @throws IOException if it was necessary to fetch the image dimension from the
     *         {@linkplain #getImageReader reader}Â and this operation failed.
     */
    final int countUnwantedPixelsFromAbsolute(final Rectangle toRead, final Dimension subsampling)
            throws IOException
    {
        final int sx = xSubsampling & MASK;
        final int sy = ySubsampling & MASK;
        assert subsampling.width >= sx && subsampling.height >= sy : subsampling;
        final Rectangle region = getRegion();
        /*
         * Converts the tile region to absolute coordinates and clips it to the region to read.
         */
        final long xmin, ymin, xmax, ymax;
        xmin = max((long) toRead.x,                 sx * ((long) region.x));
        ymin = max((long) toRead.y,                 sy * ((long) region.y));
        xmax = min((long) toRead.x + toRead.width,  sx * ((long) region.x + region.width));
        ymax = min((long) toRead.y + toRead.height, sy * ((long) region.y + region.height));
        /*
         * Computes the amount of pixels to keep for the given region and subsampling.
         */
        long count = max(xmax - xmin, 0) * max(ymax - ymin, 0);
        count /= (subsampling.width * subsampling.height);
        /*
         * Computes the amount of pixels from the current tile that would be unused. Note that
         * we are substracting a quantity derived from the absolute space from a quantity in the
         * relative space. The result should be positive anyway because we divided the former by
         * (s.width * s.height), which should be greater than (xSubsampling * ySubsampling).
         */
        count = (region.width * region.height) - count;
        assert count >= 0 && count <= Integer.MAX_VALUE : count;
        return (int) count;
    }

