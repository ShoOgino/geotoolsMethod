    /**
     * Creates a new tile manager for the given tiles, which must be distributed on a grid.
     * This constructor is protected for subclassing, but should not be invoked directly.
     * {@code GridTileManager} instances should be created by {@link TileManagerFactory}.
     *
     * @param  tiles The tiles.
     * @throws IOException if an I/O operation was required and failed.
     * @throws IllegalArgumentException if this class can not handle the given tiles.
     */
    protected GridTileManager(final Tile[] tiles)
            throws IOException, IllegalArgumentException
    {
        Tile.ensureNonNull("tiles", tiles);
        Tile[] modifiedOrder = tiles; // May be modified later.
        final Map<Dimension,OverviewLevel> levelsBySubsampling = new HashMap<Dimension,OverviewLevel>();
        for (int i=0; i<modifiedOrder.length; i++) {
            Tile tile = modifiedOrder[i];
            Dimension subsampling = tile.getSubsampling();
            OverviewLevel level = levelsBySubsampling.get(subsampling);
            if (level == null) {
                /*
                 * We are about to create a new OverviewLevel. We need to know the grid cell size.
                 * We assume that this is the size of the largest tiles. Since the last row and the
                 * last column may contain smaller tiles, and since the order of tiles in the user-
                 * supplied array may be random, we search for larger tiles now.
                 */
                for (int j=i; ++j<modifiedOrder.length;) {
                    final Tile candidate = modifiedOrder[j];
                    if (candidate.isLargerThan(tile)) {
                        if (modifiedOrder == tiles) {
                            modifiedOrder = modifiedOrder.clone();
                        }
                        modifiedOrder[j] = tile;
                        tile = candidate;
                        subsampling = tile.getSubsampling();
                    }
                }
                level = new OverviewLevel(tile, subsampling);
                levelsBySubsampling.put(subsampling, level);
            } else {
                level.add(tile, subsampling);
            }
        }
        final OverviewLevel[] levels;
        levels = levelsBySubsampling.values().toArray(new OverviewLevel[levelsBySubsampling.size()]);
        Arrays.sort(levels);
        region = new Rectangle(-1, -1);
        int count = 0;
        for (int i=0; i<levels.length; i++) {
            final OverviewLevel level = levels[i];
            level.createLinkedList(i, (i != 0) ? levels[i-1] : null);
            region.add(level.getAbsoluteRegion());
            count += level.getNumTiles();
        }
        this.count = count;
        root = (levels.length != 0) ? levels[levels.length - 1] : null;
    }

