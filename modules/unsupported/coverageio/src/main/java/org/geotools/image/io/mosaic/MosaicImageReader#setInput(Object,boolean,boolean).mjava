    /**
     * Sets the input source, which is expected to be an array of
     * {@linkplain TileManager tile managers}. If the given input is a singleton, an array or a
     * {@linkplain Collection collection} of {@link Tile} objects, then it will be wrapped in an
     * array of {@link TileManager}s.
     *
     * @param input The input.
     * @param seekForwardOnly if {@code true}, images and metadata may only be read in ascending
     *        order from this input source.
     * @param ignoreMetadata if {@code true}, metadata may be ignored during reads.
     * @throws IllegalArgumentException if {@code input} is not an instance of one of the
     *         expected classes, or if the input can not be used because of an I/O error
     *         (in which case the exception has a {@link IOException} as its
     *         {@linkplain IllegalArgumentException#getCause cause}).
     */
    @Override
    public void setInput(Object input, final boolean seekForwardOnly, final boolean ignoreMetadata)
            throws IllegalArgumentException
    {
        final TileManager[] managers;
        try {
            managers = TileManagerFactory.DEFAULT.createFromObject(input);
        } catch (IOException e) {
            throw new IllegalArgumentException(e.getLocalizedMessage(), e);
        }
        final int numImages = (managers != null) ? managers.length : 0;
        super.setInput(input=managers, seekForwardOnly, ignoreMetadata);
        availableLocales = null; // Will be computed by getAvailableLocales() when first needed.
        /*
         * For every tile readers, closes the stream and disposes the ones that are not needed
         * anymore for the new input. The image readers that may still useful will be recycled.
         * We keep their streams open since it is possible that the new input uses the same ones
         * (the old streams will be closed later if appears to not be used).
         */
        Set<ImageReaderSpi> providers = Collections.emptySet();
        try {
            switch (numImages) {
                case 0: {
                    // Keep the empty provider set.
                    break;
                }
                case 1: {
                    providers = managers[0].getImageReaderSpis();
                    break;
                }
                default: {
                    providers = new HashSet<ImageReaderSpi>(managers[0].getImageReaderSpis());
                    for (int i=1; i<numImages; i++) {
                        providers.addAll(managers[i].getImageReaderSpis());
                    }
                    break;
                }
            }
        } catch (IOException e) {
            /*
             * Failed to get the set of providers.  This is not a big issue; the only consequence
             * is that we will dispose more readers than necessary, which means that we will need
             * to recreate them later. Note that the set of providers may be partially filled.
             */
            Logging.unexpectedException(MosaicImageReader.class, "setInput", e);
        }
        final Iterator<Map.Entry<ImageReaderSpi,ImageReader>> it = readers.entrySet().iterator();
        while (it.hasNext()) {
            final Map.Entry<ImageReaderSpi,ImageReader> entry = it.next();
            if (!providers.contains(entry.getKey())) {
                final ImageReader reader = entry.getValue();
                if (reader != null) {
                    /*
                     * Closes previous streams, if any. It is not a big deal if this operation
                     * fails, since we will not use anymore the old streams anyway. However it
                     * is worth to log.
                     */
                    final Object rawInput = readerInputs.remove(reader);
                    final Object tileInput = reader.getInput();
                    if (rawInput != tileInput) try {
                        Tile.close(tileInput);
                    } catch (IOException exception) {
                        Logging.unexpectedException(MosaicImageReader.class, "setInput", exception);
                    }
                    reader.dispose();
                }
                it.remove();
            }
        }
        for (final ImageReaderSpi provider : providers) {
            if (!readers.containsKey(provider)) {
                readers.put(provider, null);
            }
        }
        assert providers.equals(this.providers);
        assert readers.values().containsAll(readerInputs.keySet());
    }

