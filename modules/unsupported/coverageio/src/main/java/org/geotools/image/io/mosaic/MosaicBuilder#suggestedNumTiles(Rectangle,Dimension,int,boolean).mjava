    /**
     * Returns a suggested set of divisors of the number of tiles that can fit in an image.
     * More specifically, this method executes the following pseudo code twice, once for
     * {@linkplain Dimension#width width} and once for {@linkplain Dimension#height height},
     * resulting in two arrays of type {@code int[]}:
     *
     * <blockquote><code>
     * {@linkplain XMath#divisors divisors}({@linkplain Fraction#round round}(imageBounds / tileSize))
     * </code></blockquote>
     *
     * The two arrays are then decimated using the following procedures:
     * <p>
     * <ul>
     *   <li>If {@code multiples} is {@code true}, then the arrays are decimated in such a way
     *       that each value {@code divisors[i]} is a multiple of {@code divisors[i-1]}. This
     *       is useful for getting only tiles that can fit entirely in bigger tiles.</li>
     *   <li>The largest of the two arrays is trimmed in order to get arrays of the same
     *       length.</li>
     * <p>
     * If the number of divisors is lower than the {@code preferredCount}, then this method will
     * try again for smaller tiles until the preferred count or some other (currently undocumented)
     * stop condition is reached.
     * <p>
     * Let {@code r} be the return value. The following contract should hold in all cases:
     * <p>
     * <ul>
     *   <li>{@code r} is never {@code null}</li>
     *   <li>{@code r.length} is always 2</li>
     *   <li>{@code r[0].length} == {@code r[1].length} and this length is greater than 0</li>
     *   <li>{@code r[0][0]} == {@code r[1][0]} == 1 (i.e. the first divisor is always 1)</li>
     * </ul>
     *
     * @param  imageBounds The image size.
     * @param  tileSize The tile size.
     * @param  preferredCount The preferred minimal amount of divisors, or 0 if there is no
     *         minimal count.
     * @param  multiples If {@code true}, then the returned numbers are restricted to multiples.
     * @return Two arrays of the same length, which are respectively the divisors of
     *         image {@linkplain Rectangle#width width} and the divisors of image
     *         {@linkplain Rectangle#height height}.
     */
    public static int[][] suggestedNumTiles(final Rectangle imageBounds, final Dimension tileSize,
                                            final int preferredCount, final boolean multiples)
    {
        final int width  = tileSize.width;
        final int height = tileSize.height;
        final int[][] divisors = new int[2][];
        final int xmax = imageBounds.width  / width;
        final int ymax = imageBounds.height / height;
        final int maxScale = Math.min(tileSize.width, tileSize.height) / MIN_TILE_SIZE;
        int scale = 1;
        boolean oldTileDivideImage = false;
        do {
            final int[] oldX = divisors[0];
            final int[] oldY = divisors[1];
            final long dx = scale * (long) imageBounds.width;
            final long dy = scale * (long) imageBounds.height;
            final int  nx = (int) Fraction.round(dx, width);
            final int  ny = (int) Fraction.round(dy, height);
            final boolean tileDivideImage = (nx * width == dx) && (ny * height == dy);
            if (oldTileDivideImage && !tileDivideImage) {
                continue; // Doesn't worth to continue for this scale.
            }
            int[] sx = XMath.divisors(nx);
            int[] sy;
            if (nx == ny) {
                sx = XArray.resize(sx, decimate(sx, Math.min(xmax, ymax), multiples));
                divisors[0] = divisors[1] = sy = sx;
            } else {
                sy = XMath.divisors(ny);
                divisors[0] = sx = XArray.resize(sx, decimate(sx, xmax, multiples));
                divisors[1] = sy = XArray.resize(sy, decimate(sy, ymax, multiples));
                reduceLargest(divisors);
            }
            final int length = divisors[0].length;
            if (tileDivideImage && length >= preferredCount) {
                // In addition of the preferred count, we also favorise the results
                // computed from a tile size which is a divisor of the image bounds.
                break;
            }
            if (oldX != null) {
                if (tileDivideImage && !oldTileDivideImage) {
                    oldTileDivideImage = true;
                    continue; // Keep the new divisors.
                }
                if (length <= oldX.length) {
                    divisors[0] = oldX;
                    divisors[1] = oldY;
                }
            }
        } while (++scale <= maxScale);
        return divisors;
    }

