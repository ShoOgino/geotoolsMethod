    /**
     * Returns every tiles that intersect the {@linkplain #regionOfInterest region of interest},
     * which must be set before this method is invoked. This method does not use any cache - the
     * search is performed inconditionnaly.
     * <p>
     * On input, the following fields must be set:
     * <ul>
     *   <li>{@link #regionOfInterest}</li>
     *   <li>{@link #subsampling}</li>
     *   <li>{@link #subsamplingChangeAllowed}</li>
     * </ul>
     * <p>
     * On output, the following fields will be set:
     * <ul>
     *   <li>{@link #subsampling} if {@link #subsamplingChangeAllowed} is {@code true}</li>
     * </ul>
     */
    public List<Tile> searchTiles() throws IOException {
        assert subsamplingDone.isEmpty() && subsamplingToTry.isEmpty() && distinctBounds.isEmpty();
        Dimension bestSubsampling = subsamplingCandidate = subsampling;
        SelectedNode bestCandidate = null;
        int bestCandidateCount = 0;
        long lowestCost = Long.MAX_VALUE;
        try {
            /*
             * Before to perform the exaustive search, get a subsampling which is likely to lead to
             * one of the lowest costs. Trying this subsampling first will help us to compute a low
             * cost early, and consequently stop more aggresively the subsequent searchs when their
             * cost appear higher. This optimization can be safely disabled if we suspect that
             * something is wrong with it.
             */
            if (subsamplingChangeAllowed) {
                final Dimension floor = getSubsamplingFloor(root, subsampling);
                if (floor != subsampling) {
                    subsamplingDone.add(subsampling);
                    subsamplingToTry.add(subsampling);
                    subsamplingCandidate = floor;
                }
            }
            do {
                final SelectedNode candidate = addTileCandidate(root, lowestCost);
                /*
                 * We now have the final set of tiles for current subsampling. Checks if the cost
                 * of this set is lower than previous sets, and keep as "best candidates" if it is.
                 * If there is other subsamplings to try, we redo the process again in case we find
                 * cheaper set of tiles.
                 */
                if (candidate != null) {
                    final int candidateCount;
                    try {
                        candidate.removeTrivialOverlaps(distinctBounds);
                        candidateCount = distinctBounds.size();
                    } finally {
                        distinctBounds.clear();
                    }
                    if (bestCandidate != null) {
                        if (!candidate.isCheaperThan(bestCandidate)) {
                            continue;
                        }
                    }
                    bestCandidate = candidate;
                    bestCandidateCount = candidateCount;
                    bestSubsampling = subsamplingCandidate;
                    lowestCost = candidate.cost;
                }
            } while ((subsamplingCandidate = subsamplingToTry.poll()) != null);
        } finally {
            subsamplingToTry.clear();
            subsamplingDone .clear();
        }
        /*
         * TODO: sort the result. I'm not sure that it is worth, but if we decide that it is,
         * we could use the Comparator<GridNode> implemented by the GridNode class.
         */
        subsampling.setSize(bestSubsampling); // Must be set only when the loop above is over.
        final List<Tile> tiles = new ArrayList<Tile>(bestCandidateCount);
        if (bestCandidate != null) {
            assert bestCandidate.checkValidity() : bestCandidate.toTree();
            bestCandidate.getTiles(tiles);
            if (LOGGER.isLoggable(LEVEL)) {
                final String lineSeparator = System.getProperty("line.separator", "\n");
                final StringBuilder message = new StringBuilder("Tiles count: ")
                        .append(tiles.size()).append(lineSeparator);
                OptionalDependencies.format(bestCandidate, message, lineSeparator);
                final LogRecord record = new LogRecord(LEVEL, message.toString());
                record.setSourceClassName("org.geotools.image.io.mosaic.TileManager");
                record.setSourceMethodName("getTiles"); // This is the public API for this method.
                record.setLoggerName(LOGGER.getName());
                LOGGER.log(record);
            }
        }
        assert tiles.isEmpty() == !intersects() : tiles;
        return tiles;
    }

