    /**
     * Checks if the {@linkplain #getReader reader} seems to contains a readeable ASCII file.
     * This method tries to read the first few lines. The caller is responsable for invoking
     * {@link #close} after this method.
     *
     * @param  readAheadLimit Maximum number of characters to read. If this amount is reached
     *         but this method still unable to make a choice, then it returns {@code null}.
     * @return {@code true} if the source <em>seems</em> readable, {@code false} otherwise.
     * @throws IOException If an error occured during reading.
     */
    final boolean canDecode(final int readAheadLimit) throws IOException {
        final Reader input = getReader(readAheadLimit);
        if (input == null) {
            return false;
        }
        final TextImageReader.Spi spi = (TextImageReader.Spi) originatingProvider;
        final char[]     buffer = new char[readAheadLimit];
        final int        length = input.read(buffer);
        final LineFormat parser = getLineFormat(0);
        double[][] rows = new double[16][];
        int rowCount = 0;
        int lower = 0;
scan:   while (lower < readAheadLimit) {
            // Skip line feeds at the begining of the line.
            // They may be a rest from the previous line.
            char c = buffer[lower];
            if (c == '\r' || c == 'n') {
                lower++;
                continue;
            }
            // Search the end of line. If we reach the end of the buffer,
            // do not attempt to parse that last line since it is incomplete.
            int upper = lower;
            while ((c = buffer[upper]) != '\r' && c != '\n') {
                if (++upper >= readAheadLimit) {
                    break scan;
                }
            }
            // Try to parse a line.
            final String line = new String(buffer, lower, upper-lower);
            if (!isComment(line)) {
                try {
                    if (parser.setLine(line) != 0) {
                        if (rowCount == rows.length) {
                            rows = XArray.resize(rows, rows.length * 2);
                        }
                        rows[rowCount] = parser.getValues(rows[rowCount]);
                        rowCount++;
                    }
                } catch (ParseException exception) {
                    return false;
                }
            }
            lower = upper;
        }
        if (originatingProvider instanceof TextImageReader.Spi) {
            rows = XArray.resize(rows, rowCount);
            return ((TextImageReader.Spi) originatingProvider).isValidContent(rows);
        }
        return true;
    }

