    /**
     * Retourne l'interval entre les points de la colonne spécifiée, en supposant que les
     * points se trouvent à un interval régulier. Si ce n'est pas le cas, une exception
     * sera lancée.
     *
     * @param  column Colonne dont on veut l'interval entre les points.
     * @param  eps Petit facteur de tolérance (par exemple 1E-6).
     * @throws IIOException si les points de la colonne spécifiée
     *         ne sont pas distribués à un interval régulier.
     */
    private float getInterval(final int column, final float eps) throws IIOException {
        if (interval == null) {
            if (columnCount <= 0) {
                return Float.NaN;
            }
            interval = new float[columnCount];
        }
        if (interval[column] != 0) {
            return interval[column];
        }
        /*
         * Obtient toutes les valeurs de la colonne
         * spécifiée en ordre croissant.
         */
        int count=0;
        final float[] array = new float[getLineCount()];
        for (int i=column; i<upper; i+=columnCount) {
            array[count++] = data[i];
        }
        assert count == array.length;
        Arrays.sort(array);
        /*
         * Elimine les doublons. Lorsque des doublons seront trouvés, ils iront de
         * {@code lower} à {@code upper} <strong>inclusivement</strong>.
         */
        int upper = count-1;
        int lower = count;
        while (--lower>=1) {
            if (array[upper] != array[lower-1]) {
                if (upper != lower) {
                    System.arraycopy(array, upper, array, lower, count-upper);
                    final int oldCount = count;
                    count -= (upper-lower);
                    Arrays.fill(array, count, oldCount, Float.NaN); // Par prudence.
                }
                upper = lower-1;
            }
        }
        if (upper != lower) {
            System.arraycopy(array, upper, array, lower, count-upper);
            final int oldCount = count;
            count -= (upper-lower);
            Arrays.fill(array, count, oldCount, Float.NaN); // Par prudence.
        }
        /*
         * Recherche le plus petit interval entre deux points. Vérifie ensuite que
         * l'interval entre tous les points est un multiple entier de cet interval
         * minimal (on tient compte ainsi des éventuels données manquantes).
         */
        float delta = Float.POSITIVE_INFINITY;
        for (int i=1; i<count; i++) {
            final float d = array[i] - array[i-1];
            assert d>0;
            if (d < delta) {
                delta = d;
            }
        }
        for (int i=1; i<count; i++) {
            float e = (array[i] - array[i-1]) / delta;
            if (Math.abs(e-Math.rint(e)) > eps) {
                throw new IIOException(Errors.format(ErrorKeys.NOT_A_GRID));
            }
        }
        return interval[column] = Float.isInfinite(delta) ? Float.NaN : delta;
    }

