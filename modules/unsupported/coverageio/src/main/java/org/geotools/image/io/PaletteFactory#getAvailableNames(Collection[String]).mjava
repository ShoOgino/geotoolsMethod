    /**
     * Adds available palette names to the specified collection.
     */
    private void getAvailableNames(final Collection<String> names) {
        /*
         * First, parses the content of every "list.txt" files found on the classpath. Those files
         * are optional. But if they are present, we assume that their content are accurate.
         */
        String filename = new File(directory, LIST_FILE).getPath();
        BufferedReader in = getReader(LIST_FILE, "getAvailableNames");
        try {
            if (in != null) {
                readNames(in, names);
            }
            if (classloader != null) {
                for (final Enumeration<URL> it=classloader.getResources(filename); it.hasMoreElements();) {
                    final URL url = it.nextElement();
                    in = getReader(url.openStream());
                    readNames(in, names);
                }
            }
        } catch (IOException e) {
            /*
             * Logs a warning but do not stop. The only consequence is that the names list
             * will be incomplete. We log the message as if came from getAvailableNames(),
             * which is the public method that invoked this one.
             */
            Logging.unexpectedException(PaletteFactory.class, "getAvailableNames", e);
        }
        /*
         * After the "list.txt" files, check if the resources can be read as a directory.
         * It may happen if the classpath point toward a directory of .class files rather
         * than a JAR file.
         */
        File dir = (directory != null) ? directory : new File(".");
        if (classloader != null) {
            dir = toFile(classloader.getResource(dir.getPath()));
            if (dir == null) {
                // Directory not found.
                return;
            }
        } else if (loader != null) {
            dir = toFile(loader.getResource(dir.getPath()));
            if (dir == null) {
                // Directory not found.
                return;
            }
        }
        if (!dir.isDirectory()) {
            return;
        }
        final String[] list = dir.list(new DefaultFileFilter('*' + extension));
        final int extLg = extension.length();
        for (int i=0; i<list.length; i++) {
            filename = list[i];
            final int lg = filename.length();
            if (lg>extLg && filename.regionMatches(true, lg-extLg, extension, 0, extLg)) {
                names.add(filename.substring(0, lg-extLg));
            }
        }
    }

