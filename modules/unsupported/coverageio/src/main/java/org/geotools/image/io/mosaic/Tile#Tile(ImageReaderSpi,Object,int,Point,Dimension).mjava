    /**
     * Creates a tile for the given provider, input and location. This constructor can be used when
     * the size of the image to be read by the supplied reader is unknown. This size will be
     * fetched automatically the first time {@link #getRegion} is invoked.
     *
     * @param provider
     *          The image reader provider to use. The same provider is typically given to every
     *          {@code Tile} objects to be given to the same {@link TileManager} instance, but
     *          this is not mandatory. If {@code null}, the provider will be inferred from the
     *          input. If it can't be inferred, then an exception is thrown.
     * @param input
     *          The input to be given to the image reader.
     * @param imageIndex
     *          The image index to be given to the image reader for reading this tile.
     * @param location
     *          The upper-left corner in the destination image.
     * @param subsampling
     *          The subsampling relative to the tile having the finest resolution, or {@code null}
     *          if none. If non-null, width and height should be strictly positive. This argument
     *          if of {@linkplain Dimension dimension} kind because it can also be understood as
     *          relative "pixel size".
     *
     * @throws IllegalArgumentException
     *          If a required argument is {@code null} or some argument has an invalid value.
     */
    public Tile(ImageReaderSpi provider, final Object input, final int imageIndex,
                final Point location, final Dimension subsampling)
                throws IllegalArgumentException
    {
        if (provider == null) {
            provider = getImageReaderSpi(input);
        }
        ensureNonNull("provider", provider);
        ensureNonNull("input",    input);
        ensureNonNull("location", location);
        this.provider   = provider;
        this.input      = input;
        this.imageIndex = ensurePositive(imageIndex);
        this.x          = location.x;
        this.y          = location.y;
        if (subsampling != null) {
            xSubsampling = ensureStrictlyPositive(subsampling.width);
            ySubsampling = ensureStrictlyPositive(subsampling.height);
        } else {
            xSubsampling = ySubsampling = 1;
        }
    }

