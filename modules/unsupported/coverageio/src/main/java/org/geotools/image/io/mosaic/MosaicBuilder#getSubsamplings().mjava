    /**
     * Returns the subsampling for overview computations. If no subsamplings were {@linkplain
     * #setSubsamplings(Dimension[]) explicitly set}, then this method computes automatically
     * some subsamplings from the {@linkplain #getUntiledImageBounds untiled image bounds} and
     * {@linkplain #getTileSize tile size}, with the following properties (note that those
     * properties are not garanteed if the subsampling was explicitly specified rather than
     * computed):
     * <p>
     * <ul>
     *   <li>The first element in the returned array is (1,1).</li>
     *   <li>Elements are sorted by increasing subsampling values.</li>
     *   <li>At most one subsampling (the last one) results in an image big enough for holding
     *       the whole mosaic.</li>
     * </ul>
     * <p>
     * If no subsampling can be computed, then this method returns {@code null}.
     *
     * @return The current subsamplings for each overview levels.
     */
    public Dimension[] getSubsamplings() {
        if (subsamplings == null) {
            final Rectangle untiledBounds = getUntiledImageBounds();
            if (untiledBounds == null) {
                return null;
            }
            final Dimension tileSize = getTileSize();
            if (tileSize == null) {
                return null;
            }
            /*
             * If the tile layout is CONSTANT_GEOGRAPHIC_AREA, increasing the subsampling will have
             * the effect of reducing the tile size by the same amount, so we are better to choose
             * subsamplings that are divisors of the tile size.
             *
             * If the tile layout is CONSTANT_TILE_SIZE, increasing the subsampling will have the
             * effect of reducing the number of tiles required for covering the whole image. So we
             * are better to choose subsamplings that are divisors of the number of tiles. If the
             * number of tiles are not integers, we round towards nearest integers in the hope that
             * we get a number closer to user's intend.
             *
             * If the tile layout is unknown, we don't really know what to choose. We fallback on
             * some values that seem reasonable, but our fallback may change in future version.
             * It doesn't hurt any code in this module - the only consequence is that tiling may
             * be suboptimal.
             */
            final boolean constantArea = TileLayout.CONSTANT_GEOGRAPHIC_AREA.equals(layout);
            int nx = tileSize.width;
            int ny = tileSize.height;
            if (!constantArea) {
                // Must performs the division in the same way than in suggestedTileSize(...).
                nx = Fraction.round(untiledBounds.width,  nx);
                ny = Fraction.round(untiledBounds.height, ny);
            }
            int[] xSubsamplings = XMath.divisors(nx);
            if (nx != ny) {
                /*
                 * Subsamplings are different along x and y axis. We need at least arrays of the
                 * same length. While not strictly required, it is better that xSubsampling and
                 * ySubsampling are equal, assuming that pixels are square (otherwise we could
                 * multiply by a height/width ratio; it may be done in a future version). Current
                 * implementation keep the union of divisors.
                 *
                 * TODO: move the code that computes the union in XArray.union(int[],int[]).
                 */
                final int[] ySubsamplings = XMath.divisors(ny);
                final int[] union  = new int[xSubsamplings.length + ySubsamplings.length];
                int nu=0;
                for (int ix=0, iy=0;;) {
                    if (ix == xSubsamplings.length) {
                        final int no = ySubsamplings.length - iy;
                        System.arraycopy(ySubsamplings, iy, union, nu, no);
                        nu += no;
                        break;
                    }
                    if (iy == ySubsamplings.length) {
                        final int no = xSubsamplings.length - ix;
                        System.arraycopy(xSubsamplings, ix, union, nu, no);
                        nu += no;
                        break;
                    }
                    final int sx = xSubsamplings[ix];
                    final int sy = ySubsamplings[iy];
                    final int s;
                    if (sx <= sy) {
                        s = sx;
                        ix++;
                        if (sx == sy) {
                            iy++;
                        }
                    } else {
                        s = sy;
                        iy++;
                    }
                    union[nu++] = s;
                }
                xSubsamplings = XArray.resize(union, nu);
            }
            /*
             * Trims the subsamplings which would produce tiles smaller than the minimum size
             * (for CONSTANT_GEOGRAPHIC_AREA layout) or which would produce more than one tile
             * enclosing the whole image (for CONSTANT_TILE_SIZE layout). First, we calculate
             * as (nx,ny) the maximum subsamplings expected (inclusive). Then we search those
             * maximum in the actual subsampling and assign to (nx,ny) the new array length.
             */
            if (constantArea) {
                nx = tileSize.width  / MIN_TILE_SIZE;
                ny = tileSize.height / MIN_TILE_SIZE;
            } else {
                nx = (untiledBounds.width  - 1) / tileSize.width  + 1;
                ny = (untiledBounds.height - 1) / tileSize.height + 1;
            }
            // Increments (++) below are inconditional (outside the "if" block).
            nx = Arrays.binarySearch(xSubsamplings, nx); if (nx < 0) nx = ~nx; nx++;
            ny = Arrays.binarySearch(xSubsamplings, ny); if (ny < 0) ny = ~ny; ny++;
            final int length = Math.min(Math.max(nx, ny), xSubsamplings.length);
            subsamplings = new int[length * 2];
            int source = 0;
            for (int i=0; i<length; i++) {
                subsamplings[source++] = xSubsamplings[i];
                subsamplings[source++] = xSubsamplings[i];
            }
        }
        final Dimension[] dimensions = new Dimension[subsamplings.length / 2];
        int source = 0;
        for (int i=0; i<dimensions.length; i++) {
            dimensions[i] = new Dimension(subsamplings[source++], subsamplings[source++]);
        }
        return dimensions;
    }

