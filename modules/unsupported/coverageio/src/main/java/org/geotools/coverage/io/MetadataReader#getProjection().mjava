    /**
     * Returns the projection. The default implementation performs the following steps:
     * <p>
     * <ul>
     *   <li>Gets a {@linkplain ParameterValueGroup parameter value group} from a
     *       {@link MathTransformFactory}</li>
     *
     *   <li>Gets the metadata values for each parameters in the above step. If a parameter is not
     *       defined in this {@code MetadataReader}, then it will be left to its (projection
     *       dependent) default value. Parameters are projection dependent, but will typically
     *       include
     *
     *           {@code "semi_major"},
     *           {@code "semi_minor"} (or {@code "inverse_flattening"}),
     *           {@code "central_meridian"},
     *           {@code "latitude_of_origin"},
     *           {@code "false_easting"} and
     *           {@code "false_northing"}.
     *
     *       The names actually used in the metadata file to be parsed must be declared as usual,
     *       e.g. <code>{@linkplain TextMetadataParser#addAlias addAlias}
     *                  ({@linkplain TextMetadataParser#SEMI_MAJOR}, ...)</code></li>
     *
     *   <li>Computes and returns a {@linkplain DefiningConversion conversion} using the name of the
     *       projection and the parameter value group previously filled.</li>
     * </ul>
     * </p>
     * @return The projection.
     * @throws MetadataException if the operation failed for some other reason
     *         (for example if a parameter value can't be parsed as a {@code double}).
     *
     * @see TextMetadataParser#SEMI_MAJOR
     * @see TextMetadataParser#SEMI_MINOR
     * @see TextMetadataParser#INVERSE_FLATTENING
     * @see TextMetadataParser#LATITUDE_OF_ORIGIN
     * @see TextMetadataParser#CENTRAL_MERIDIAN
     * @see TextMetadataParser#FALSE_EASTING
     * @see TextMetadataParser#FALSE_NORTHING
     */
    public synchronized Conversion getProjection() throws MetadataException {
        final MathTransformFactory mathTransformFactory = factories.getMathTransformFactory();
        final ImageReferencing referencing = metadata.getReferencing();
        final String projectionName = referencing.getProjectionName();
        if (projectionName == null) {
            throw new MetadataException("Projection name is not defined.");
        }
        final ParameterValueGroup paramValueGroup;
        try {
            paramValueGroup = mathTransformFactory.getDefaultParameters(projectionName);
        } catch (NoSuchIdentifierException e) {
            throw new MetadataException(e.getLocalizedMessage());
        }
        for (final Parameter parameter : referencing.getParameters()) {
            final String name = parameter.getName();
            if (name == null) {
                continue;
            }
            final double value = parameter.getValue();
            if (Double.isNaN(value)) {
                continue;
            }
            try {
                paramValueGroup.parameter(name).setValue(value);
            } catch (ParameterNotFoundException e) {
                // Should not happened. Continue with the next parameter, the current one
                // will be ignored.
                continue;
            }
        }
        return new DefiningConversion(projectionName, paramValueGroup);
    }

