    /**
     * Given two arrays which may be of different length, remove some elements from the largest
     * array in order to get the same length than the shortest array. Arrays most be sorted in
     * strictly increasing order.
     *
     * @return The divisors of image {@linkplain Rectangle#width width} and the divisors of image
     *         {@linkplain Rectangle#height height}. The largest array will be replaced by a new
     *         one.
     */
    private static void reduceLargest(final int[][] divisors) {
        int[] large = divisors[0];
        int[] small = divisors[1];
        assert XArray.isStrictlySorted(large) && XArray.isStrictlySorted(small);
        if (large.length == small.length) {
            return;
        }
        final int target;
        if (large.length >= small.length) {
            target = 0;
        } else {
            target = 1;
            final int[] tmp = large;
            large = small;
            small = tmp;
        }
        final int[] reduced = new int[small.length];
        for (int i=0; i<small.length; i++) {
            int value = small[i];
            int k = Arrays.binarySearch(large, value);
            if (k < 0) {
                k = ~k; // Really tilde, not minus operator.
                if (k != 0 && (k == large.length || (large[k] - value) >= (value - large[k-1]))) {
                    k--;
                }
                value = large[k];
            }
            reduced[i] = value;
        }
        divisors[target] = reduced;
    }

