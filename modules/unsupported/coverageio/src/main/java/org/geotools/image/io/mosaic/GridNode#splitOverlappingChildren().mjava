    /**
     * Makes sure that this node and all its children do not contains overlapping tiles. If at
     * least one overlapping is found, then the nodes are reorganized in non-overlapping sub-nodes.
     * Algorithm overview:
     * <p>
     * <ol>
     *   <li>For the current {@linkplain #children}, keeps the first node and remove every nodes
     *       that overlap with a previous one (except special cases described above). The removed
     *       nodes are stored in a temporary list.</li>
     *   <li>The nodes selected in the previous step are groupped in a new {@link GridNode},
     *       which will be the first {@linkplain #children} of this tile.</li>
     *   <li>Repeat the process with the nodes that were removed in the first step. Each new
     *       group is added as a new {@linkplain #children} in this node.</li>
     * </ol>
     * <p>
     * <b>special case:</b> if an overlapping is found but the two nodes have identical bounds,
     * then they are considered as if they did not overlap. This exception exists because this
     * trivial overlap is easy to detect and to process by {@link RTree}.
     */
    private void splitOverlappingChildren() {
        assert isLeaf() || !isEmpty() : this; // Requires that bounds has been computed.
        GridNode child = (GridNode) firstChildren();
        while (child != null) {
            child.splitOverlappingChildren();
            child = (GridNode) child.nextSibling();
        }
        if (!overlaps) {
            return;
        }
        List<GridNode> toProcess = new LinkedList<GridNode>();
        final List<GridNode> retained = new ArrayList<GridNode>();
        child = (GridNode) firstChildren();
        while (child != null) {
            toProcess.add(child);
            child = (GridNode) child.nextSibling();
        }
        removeChildren(); // Necessary in order to give children to other nodes.
        int bestIndex=0, bestDistance=0;
        /*
         * The loop below is for processing a group of nodes. A "group of nodes" is either
         * the initial children list (on the first iteration), or the nodes that have not be
         * retained in a previous run of this loop. In the later case, those remaining nodes
         * need to be examined again and again until they are classified in some group.
         */
        while (!toProcess.isEmpty()) {
            final List<GridNode> removed = new LinkedList<GridNode>();
            GridNode added = toProcess.remove(0);
            retained.add(added);
            /*
             * The loop below is for moving every non-overlapping nodes to the "retained" list,
             * begining with the first node that we retained unconditionnaly in the above line
             * (we need to start with one node in order to select non-overlapping nodes...)
             */
            ListIterator<GridNode> it;
            while ((it = toProcess.listIterator()).hasNext()) {
                GridNode best = null;
                /*
                 * The loop below is for removing every nodes that overlap with the "added" node,
                 * and select only one node (the "best" one) in the non-overlapping nodes. We
                 * select the closest tile (relative to the "added" one) rather than the first
                 * one because the retention order is significant.
                 */
                do {
                    final GridNode candidate = it.next();
                    final int distance = added.distance(candidate);
                    if (distance < 0) {
                        /*
                         * Found an overlapping tile.  Accept inconditionnaly the tile if its bounds
                         * is exactly equals to the "added" tile (this is the special case described
                         * in the method javadoc above). Otherwise remove it from the toProcess list
                         * and search for an other tile.
                         */
                        if (added.equals(candidate)) {
                            retained.add(candidate);
                        } else {
                            removed.add(candidate);
                        }
                        it.remove();
                    } else if (best == null || distance < bestDistance) {
                        /*
                         * The tile do not overlaps. Retain it only if it is the closest one
                         * to the "added" tile.  Otherwise left it in the toProcess list for
                         * consideration in a future iteration.
                         */
                        bestDistance = distance;
                        bestIndex = it.previousIndex();
                        best = candidate;
                        // Note: if the distance is 0 we could break the loop as an optimization
                        // (since we can't get anything better), but we don't because we still
                        // need to remove the overlapping tiles that may be present in toProcess.
                    }
                } while (it.hasNext());
                /*
                 * If we found no non-overlapping tile, we are done. The toProcess list should be
                 * empty now (it will be tested in an assert statement after the loop). Otherwise
                 * move the best tile from the "toProcess" to the "retained" list.
                 */
                if (best == null) {
                    break;
                }
                if (toProcess.remove(bestIndex) != best) {
                    throw new AssertionError(bestIndex);
                }
                retained.add(best);
                added = best;
            }
            assert toProcess.isEmpty() : toProcess;
            assert Collections.disjoint(retained, removed);
            final GridNode[] sorted = retained.toArray(new GridNode[retained.size()]);
            retained.clear();
            Arrays.sort(sorted, PRE_PROCESSING);
            child = new GridNode(this);
            assert child.isLeaf();
            for (TreeNode newChild : sorted) {
                child.addChild(newChild);
            }
            addChild(child);
            toProcess = removed;
        }
        overlaps = false;
    }

