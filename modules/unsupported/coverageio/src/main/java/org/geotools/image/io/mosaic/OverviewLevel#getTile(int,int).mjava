    /**
     * Returns the tile at the given index.
     *
     * @param  x,y The tile location, with (0,0) as the upper-left tile.
     * @return The tile at the given location, or {@code null} if none.
     * @throws IndexOutOfBoundsException if the given index is out of bounds.
     * @throws MalformedURLException if an error occured while creating the URL for the tile.
     */
    final Tile getTile(int x, int y) throws IndexOutOfBoundsException, MalformedURLException {
        final int index = getIndex(x, y);
        /*
         * Checks for fully-created instance. Those instances are expected to exist if
         * some tile do not comply to a general pattern that this class can recognize.
         */
        if (tiles != null) {
            final Tile tile = tiles.get(index);
            if (tile != null) {
                // If a tile is explicitly defined, it should not have a pattern.
                assert patternUsed == null || patternUsed.getInteger(index) == 0 : index;
                return tile;
            }
            // Tests here because it would be an error to have null patterns when tiles == null,
            // so we are better to lets NullPointerException been thrown in such case so we can
            // debug.
            if (patterns == null) {
                return null;
            }
        }
        /*
         * The requested tile does not need to be handled in a special way, so now get the
         * pattern for this tile and generate the filename of the fly. Doing so avoid the
         * consumption of memory for the thousands of tiles we may have.
         */
        int p = 0;
        if (patternUsed != null) {
            p = patternUsed.get(index);
            if (p == 0) {
                return null;
            }
            p--;
        }
        final Tile tile = patterns[p];
        final String pattern = tile.getInput().toString();
        if (formatter == null) {
            formatter = new FilenameFormatter();
            lastPattern = -1;
        }
        if (p != lastPattern) {
            formatter.applyPattern(pattern.substring(pattern.indexOf(':') + 1));
            lastPattern = p;
        }
        final String filename = formatter.generateFilename(ordinal, x, y);
        /*
         * We now have the filename to be given to the tile. Creates the appropriate object
         * (File, URL, URI or String) from it.
         */
        final Object input;
        if (pattern.startsWith("File")) {
            input = new File(filename);
        } else if (pattern.startsWith("URL")) {
            input = new URL(filename);
        } else if (pattern.startsWith("URI")) try {
            input = new URI(filename);
        } catch (URISyntaxException cause) { // Rethrown as an IOException subclass.
            MalformedURLException e = new MalformedURLException(cause.getLocalizedMessage());
            e.initCause(cause);
            throw e;
        } else {
            input = filename;
        }
        assert INPUT_TYPES.contains(input.getClass()) : input;
        /*
         * Now creates the definitive tile. The tiles in the last
         * row or last column may be smaller than other tiles.
         */
        final Rectangle bounds = new Rectangle(
                mosaic.x + (x *= dx),
                mosaic.y + (y *= dy),
                Math.min(dx, mosaic.width  - x),
                Math.min(dy, mosaic.height - y));
        return new Tile(tile, input, bounds);
    }

