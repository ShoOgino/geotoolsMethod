    /**
     * Returns a tile which enclose other tiles at finer resolution. Some tile layouts have a few
     * big tiles with low resolution covering the same geographic area than many smaller tiles with
     * finer resolution. If such overlapping is found, then this method returns one of the big tiles
     * and sets {@code imageSubsampling} to some subsampling that may be finer than usual for the
     * returned tile. Reading the big tile with that subsampling allows {@code MosaicImageWriter}
     * to use the same {@link RenderedImage} for writing both the big tile and the finer ones.
     * Example:
     *
     * <blockquote>
     *   +-----------------------+          +-----------+-----------+
     *   |                       |          |Subsampling|Subsampling|
     *   |      Subsampling      |          |  = (2,2)  |  = (2,2)  |
     *   |        = (4,4)        |          +-----------+-----------+
     *   |                       |          |Subsampling|Subsampling|
     *   |                       |          |  = (2,2)  |  = (2,2)  |
     *   +-----------------------+          +-----------+-----------+
     * </blockquote>
     *
     * Given the above, this method will returns the tile illustrated on the left side and set
     * {@code imageSubsampling} to (2,2).
     * <p>
     * The algorithm implemented in this method is far from optimal and surely doesn't return
     * the best tile in all case. It is a compromize attempting to reduce the amount of image
     * data to load without too much CPU cost.
     *
     * @param tiles The tiles to examine. This collection is not modified.
     * @param tree Same as {@code tiles}, but as a tree for faster searchs.
     * @param imageSubsampling Where to store the subsampling to use for reading the tile.
     *        This is an output parameter only.
     */
    private static Tile getEnclosingTile(final List<Tile> tiles, final TreeNode tree,
            final Dimension imageSubsampling, Dimension preferredSize, final int maximumPixelCount)
            throws IOException
    {
        if (preferredSize != null) {
            final int area = preferredSize.width * preferredSize.height;
            if (area < maximumPixelCount / 2) {
                // The image size was small, probably due to memory constraint in a previous
                // iteration. Allow this method to try more aggresive memory usage.
                preferredSize = null;
            }
        }
        final Set<Dimension> subsamplingDone = tiles.size() > 24 ? new HashSet<Dimension>() : null;
        boolean selectedHasPreferredSize = false;
        int     selectedCount = 0;
        Tile    selectedTile  = null;
        Tile    fallbackTile  = null; // Used only if we failed to select a tile.
        long    fallbackArea  = Long.MAX_VALUE;
        assert tree.containsAll(tiles);
search: for (final Tile tile : tiles) {
            /*
             * Gets the collection of tiles in the same area than the tile we are examinating.
             * We will retain the tile with the largest filtered collection. Filtering will be
             * performed only if there is some chance to get a larger collection than the most
             * sucessful one so far.
             */
            final Rectangle region = tile.getAbsoluteRegion();
            final Dimension subsampling = tile.getSubsampling();
            if (subsamplingDone != null && !subsamplingDone.add(subsampling)) {
                /*
                 * In order to speedup this method, examine only one tile for each subsampling
                 * value. This is a totally arbitrary choice but work well for the most common
                 * tile layouts (constant area & constant size). Without such reduction, the
                 * execution time of this method is too long for large tile collections. For
                 * smaller collections, we can afford a systematic examination of all tiles.
                 */
                continue;
            }
            // Reminder: Collection in next line will be modified, so it needs to be mutable.
            final Collection<Tile> enclosed = tree.containedIn(region);
            assert enclosed.contains(tile) : tile;
            if (enclosed.size() <= selectedCount) {
                assert selectedTile != null : selectedCount;
                continue; // Already a smaller collection - no need to do more in this iteration.
            }
            /*
             * Found a collection that may be larger than the most successful one so far. First,
             * gets the smallest subsampling. We will require tiles at the finest resolution to
             * be written in the first pass before to go up in the pyramid. If they were written
             * last, those small tiles would be read one-by-one, which defeat the purpose of this
             * method (to read a bunch of tiles at once).
             */
            Dimension finestSubsampling = subsampling;
            int smallestPixelArea = subsampling.width * subsampling.height;
            for (final Tile subtile : enclosed) {
                final Dimension s = subtile.getSubsampling();
                final int pixelArea = s.width * s.height;
                if (pixelArea < smallestPixelArea) {
                    smallestPixelArea = pixelArea;
                    finestSubsampling = s;
                }
            }
            long area = (long) region.width * (long) region.height;
            area /= smallestPixelArea;
            if (area > maximumPixelCount) {
                if (area < fallbackArea) {
                    fallbackArea = area;
                    fallbackTile = tile;
                }
                continue;
            }
            /*
             * Found a subsampling that may be finer than the tile subsampling. Now removes
             * every tiles which would consume too much memory if we try to read them using
             * that subsampling. If the tiles to be removed are the finest ones, search for
             * an other tile to write because we really want the finest resolution to be
             * written first (see previous comment).
             */
            for (final Iterator<Tile> it=enclosed.iterator(); it.hasNext();) {
                final Tile subtile = it.next();
                final Dimension s = subtile.getSubsampling();
                if (!isDivisor(subsampling, s)) {
                    it.remove();
                    if (s.equals(finestSubsampling)) {
                        continue search;
                    }
                    continue;
                }
                final Rectangle subregion = subtile.getAbsoluteRegion();
                area = (long) subregion.width * (long) subregion.height;
                area /= smallestPixelArea;
                if (area > maximumPixelCount) {
                    it.remove();
                    if (s.equals(finestSubsampling)) {
                        continue search;
                    }
                }
            }
            /*
             * Retains the tile with the largest filtered collection of sub-tiles.
             * A special case is made for tile having the preferred size, in order
             * to recycle the existing BufferedImage.
             */
            final int tileCount = enclosed.size();
            final boolean isPreferredSize = (preferredSize != null) &&
                    region.width  / finestSubsampling.width  == preferredSize.width &&
                    region.height / finestSubsampling.height == preferredSize.height;
            if (selectedTile == null || tileCount > selectedCount ||
                    (isPreferredSize && !selectedHasPreferredSize))
            {
                selectedTile = tile;
                selectedCount = tileCount;
                selectedHasPreferredSize = isPreferredSize;
                imageSubsampling.setSize(finestSubsampling);
            }
        }
        /*
         * The selected tile may still null if 'maximumPixelCount' is so small than even the
         * smallest tile doesn't fit. We will return the smallest tile anyway, maybe letting
         * a OutOfMemoryError to occurs in the caller if really the tile can't hole in the
         * available memory. We perform this try anyway because estimation of available memory
         * in Java is only approximative.
         */
        if (selectedTile == null) {
            selectedTile = fallbackTile;
            imageSubsampling.setSize(fallbackTile.getSubsampling());
        }
        return selectedTile;
    }

