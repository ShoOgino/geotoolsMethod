    /** Returns the boundary of this geometry. Returns null if the boundary is empty. */
    public Boundary getBoundary() {
        // PENDING(CSD):
        // Need to find out if MultiPrimitives are handled correctly.  (I think
        // they are, but 19107's boundary semantics for multi-primitives are
        // not well-specified.)
        // Need to find out if GeometryCollections are handled correctly.  (I
        // don't think they are, but it's not clear what it would mean, nor is
        // it obvious why anyone would call it in the first place.)

        com.vividsolutions.jts.geom.Geometry jtsGeom = getJTSGeometry();

        // PENDING(CSD):
        // As far as I could tell, it's not defined what it would mean to
        // compute the boundary of a collection object in 19107.
        if (jtsGeom instanceof com.vividsolutions.jts.geom.GeometryCollection) {
            throw new UnsupportedOperationException(
                    "Boundary cannot be computed for multi-primitives.");
        }

        com.vividsolutions.jts.geom.Geometry jtsBoundary = jtsGeom.getBoundary();
        int d = jtsGeom.getDimension();
        if (d == 0) {
            // If d is zero, then our geometry is a point.  So the boundary is
            // empty.  ISO 19107 defines the boundary of a point to
            // be NULL.
            return null;
        } else if (d == 1) {
            // If d is 1, then the boundary is either empty (if it's a ring) or
            // it's two points at either end of the curve.
            // We've ruled out the possibility of multi-primitives (see the
            // instanceof check above), so we know that the boundary can't be
            // more than 2 points.

            com.vividsolutions.jts.geom.Coordinate[] coords = jtsBoundary.getCoordinates();
            // If coords is emtpy, then this geometry is a ring.  So we return
            // an empty CurveBoundary object (i.e. one with both points set to
            // null).
            if ((coords == null) || (coords.length == 0)) {
                CurveBoundaryImpl result =
                        new CurveBoundaryImpl(getCoordinateReferenceSystem(), null, null);
                return result;
            } else {
                // If it wasn't empty, then return a CurveBoundary with the two
                // endpoints.
                if (coords.length != 2) {
                    // Should this be an assert instead?
                    throw new RuntimeException(
                            "ERROR: One dimensional "
                                    + "primitive had wrong number of boundary points ("
                                    + coords.length
                                    + ")");
                }
                CoordinateReferenceSystem crs = getCoordinateReferenceSystem();
                CurveBoundaryImpl result =
                        new CurveBoundaryImpl(
                                crs,
                                new PointImpl(JTSUtils.coordinateToDirectPosition(coords[0], crs)),
                                new PointImpl(JTSUtils.coordinateToDirectPosition(coords[1], crs)));
                return result;
            }
        } else if (d == 2) {
            // If d == 2, then the boundary is a collection of rings.
            // In particular, the JTS tests indicate that it'll be a
            // MultiLineString.
            com.vividsolutions.jts.geom.MultiLineString mls =
                    (com.vividsolutions.jts.geom.MultiLineString) jtsBoundary;
            int n = mls.getNumGeometries();
            CoordinateReferenceSystem crs = getCoordinateReferenceSystem();
            Ring exteriorRing =
                    JTSUtils.linearRingToRing(
                            (com.vividsolutions.jts.geom.LineString) mls.getGeometryN(0), crs);
            Ring[] interiorRings = new Ring[n - 1];
            for (int i = 1; i < n; i++) {
                interiorRings[n - 1] =
                        JTSUtils.linearRingToRing(
                                (com.vividsolutions.jts.geom.LineString) mls.getGeometryN(i), crs);
            }
            SurfaceBoundaryImpl result = new SurfaceBoundaryImpl(crs, exteriorRing, interiorRings);
            return result;
        } else {
            throw new UnsupportedOperationException(
                    "Computing the boundary "
                            + "for geometries of dimension larger than 2 is not "
                            + "supported.");
        }
    }

