    protected Feature computeNext() throws IOException {
        if (curSrcFeature == null) {
            throw new UnsupportedOperationException("No features found in next()."
                    + "This wouldn't have happenned if hasNext() was called beforehand.");
        }

        setHasNextCalled(false);

        String id = extractIdForFeature(curSrcFeature);
        List<Feature> sources = getSources();
                
        final AttributeDescriptor targetNode = mapping.getTargetFeature();
        final Name targetNodeName = targetNode.getName();
        
        AttributeBuilder builder = new AttributeBuilder(attf);
        builder.setDescriptor(targetNode);
        Feature target = (Feature) builder.build(id);

        for (AttributeMapping attMapping : selectedMapping) { 
            try {
                if (isTopLevelmapping(targetNodeName, attMapping.getTargetXPath())) {
                    // ignore the top level mapping for the Feature itself
                    // as it was already set
                    continue;
                }
                
                // extract the values from multiple source features of the same id
                // and set them to one built feature
                if (attMapping.isMultiValued()) {
                    for (Feature source : sources) {
                        setAttributeValue(target, source, attMapping, null, null, selectedProperties.get(attMapping));
                    }
                } else {
                    setAttributeValue(target, sources.get(0), attMapping, null, null, selectedProperties.get(attMapping));
                    // When a feature is not multi-valued but still has multiple rows with the same ID in 
                    // a denormalised table, by default app-schema only takes the first row and ignores 
                    // the rest (see above). The following line is to make sure that the cursors in the 
                    // 'joining nested mappings'skip any extra rows that were linked to those rows that are being ignored. 
                    // Otherwise the cursor will stay there in the wrong spot and none of the following feature chaining 
                    // will work. That can really only occur if the foreign key is not unique for the ID of the parent 
                    // feature (otherwise all of those rows would be already passed when creating the feature based on 
                    // the first row). This never really occurs in practice I have noticed, but it is a theoretic 
                    // possibility, as there is no requirement for the foreign key to be unique per id.
                    skipNestedMapping(attMapping, sources.subList(1, sources.size()));
                }
            } catch (Exception e) {
                throw new RuntimeException("Error applying mapping with targetAttribute "
                        + attMapping.getTargetXPath(), e);    
            }             
        }       
        return target;
    }

