    /**
     * Test that the re-mapping from MO:EarthResource to GSML:GeologicUnit is successful. This also
     * tests feature chaining for the mapped GU features.
     * 
     * @throws IOException
     */
    @Override
    @Test
    public void testMappings() throws IOException {
        FeatureCollection<FeatureType, Feature> guCollection = (FeatureCollection<FeatureType, Feature>) guFeatureSource
                .getFeatures();
        // mo:EarthResource -> gsml:GeologicUnit output iterator
        AbstractMappingFeatureIterator iterator = (AbstractMappingFeatureIterator) guCollection.features();
        FeatureTypeMapping guSchema = AppSchemaDataAccessRegistry.getMappingByElement(GEOLOGIC_UNIT);
        Hints hints = new Hints(FeaturePropertyAccessorFactory.NAMESPACE_CONTEXT, guSchema
                .getNamespaces());
        // find attribute mappings for chained features
        final String composition = "composition";
        final String occurrence = "occurrence";
        final String commodity = "commodityDescription";
        List<AttributeMapping> otherMappings = new ArrayList<AttributeMapping>();
        AttributeMapping compositionMapping = null;
        AttributeMapping occurrenceMapping = null;
        for (AttributeMapping attMapping : guSchema.getAttributeMappings()) {
            String attName = attMapping.getTargetXPath().toString();
            if (attName.equals("gsml:" + composition)) {
                compositionMapping = attMapping;
            } else if (attName.equals("gsml:" + occurrence)) {
                occurrenceMapping = attMapping;
            } else {
                // normal inline attribute mappings (not chained)
                otherMappings.add(attMapping);
            }
        }
        // make sure all the mappings are there
        assertNotNull(occurrenceMapping);
        assertNotNull(compositionMapping);
        assertEquals(guSchema.getAttributeMappings().size() - 2, otherMappings.size());

        int guCount = 0;
        ArrayList<Feature> guFeatures = new ArrayList<Feature>();
        while (iterator.hasNext()) {
            Feature next = (Feature) iterator.next();
            FeatureId fId = next.getIdentifier();
            Feature moFeature = null;
            // find matching input MO feature to compare the values with
            for (Feature inputFeature : inputFeatures) {
                if (inputFeature.getIdentifier().equals(fId)) {
                    moFeature = inputFeature;
                }
            }
            assertNotNull(moFeature);

            /**
             * Check Feature Chaining : Composition Part as composition
             */
            Collection<Property> gsmlCompositions = (Collection<Property>) next
                    .getProperties(composition);
            Collection<Property> moCompositions = (Collection<Property>) moFeature
                    .getProperties(composition);
            Collection<String> cpIds = new ArrayList<String>();
            for (Property inputProperty : moCompositions) {
                Collection<Attribute> values = (Collection<Attribute>) inputProperty.getValue();
                for (Attribute attrib : values) {
                    cpIds.add(attrib.getValue().toString());
                }
            }
            assertTrue(cpIds.size() > 0);
            assertEquals(gsmlCompositions.size(), cpIds.size());
            ArrayList<String> nestedCpIds = new ArrayList<String>(cpIds.size());
            for (Property outputProperty : gsmlCompositions) {
                Collection<Feature> values = (Collection<Feature>) outputProperty.getValue();
                Feature compositionPart = values.iterator().next();
                // check the values
                assertTrue(cpFeatures.contains(compositionPart));
                nestedCpIds.add(compositionPart.getIdentifier().toString());
            }

            // check the feature has the correct id
            assertTrue(cpIds.containsAll(nestedCpIds));

            /**
             * Check Feature Chaining : Mapped Feature as occurrence
             */
            Collection<Property> occurrences = (Collection<Property>) next
                    .getProperties(occurrence);
            Collection<Property> commodities = (Collection<Property>) moFeature
                    .getProperties(commodity);
            Collection<String> mfIds = new ArrayList<String>();
            for (Property property : commodities) {
                Collection<Attribute> values = (Collection<Attribute>) property.getValue();
                for (Attribute attrib : values) {
                    mfIds.add(attrib.getValue().toString());
                }
            }
            assertTrue(mfIds.size() > 0);
            assertEquals(occurrences.size(), mfIds.size());
            ArrayList<String> nestedMfIds = new ArrayList<String>(mfIds.size());
            for (Property mf : occurrences) {
                Collection<Feature> values = (Collection<Feature>) mf.getValue();
                Feature mfFeature = values.iterator().next();
                // check the values
                assertTrue(mfFeatures.contains(mfFeature));
                nestedMfIds.add(mfFeature.getIdentifier().toString());
            }

            // check the feature has the correct id
            assertTrue(mfIds.containsAll(nestedMfIds));

            // check multi-valued properties are all mapped
            // there should be 2 gml:name attributes, although only mapped once
            // <AttributeMapping>
            // <!-- All instances of gml:name should be mapped, how many is not known -->
            // <targetAttribute>gml:name</targetAttribute>
            // <sourceExpression>
            // <inputAttribute>gml:name</inputAttribute>
            // </sourceExpression>
            // <isMultiple>true</isMultiple>
            // </AttributeMapping>
            assertEquals(2, next.getProperties("name").size());

            /**
             * Check normal in-line attribute mappings
             */
            for (AttributeMapping attMapping : otherMappings) {
                Expression sourceExpr = attMapping.getSourceExpression();
                // make sure the mapping has the right values
                if (!(sourceExpr instanceof AttributeExpressionImpl)) {
                    // ignore attributes that aren't mapped from the input features, such as id
                    continue;
                }
                AttributeExpressionImpl outputExpr = new AttributeExpressionImpl(attMapping
                        .getTargetXPath().toString(), hints);
                Object inputValue = sourceExpr.evaluate(moFeature);
                while (inputValue instanceof Attribute) {
                    inputValue = ((Attribute) inputValue).getValue();
                }
                Object outputValue = outputExpr.evaluate(next);
                while (outputValue instanceof Attribute) {
                    outputValue = ((Attribute) outputValue).getValue();
                }
                assertEquals(inputValue, outputValue);
            }
            guFeatures.add(next);
            guCount++;
        }
        // make sure number of re-mapped features is consistent with input complex features
        assertEquals(inputFeatures.size(), guCount);

        /**
         * Feature chaining : Make sure the features can be chained as well. The re-mapped Geologic
         * Unit features are chained inside Mapped Features as specification.
         */
        mfDataAccess.dispose();
        // recreate mapped features from another mapping file to avoid circular reference
        Map<String, Serializable> dsParams = new HashMap<String, Serializable>();
        URL url = getClass().getResource(schemaBase + "MappedFeaturePropertyfile.xml");
        assertNotNull(url);
        dsParams.put("dbtype", "app-schema");
        dsParams.put("url", url.toExternalForm());
        mfDataAccess = DataAccessFinder.getDataStore(dsParams);
        assertNotNull(mfDataAccess);
        FeatureType mappedFeatureType = mfDataAccess.getSchema(MAPPED_FEATURE);
        assertNotNull(mappedFeatureType);
        FeatureSource<FeatureType, Feature> mfSource = mfDataAccess
                .getFeatureSource(MAPPED_FEATURE);
        FeatureCollection<FeatureType, Feature> mfCollection = mfSource.getFeatures();

        FeatureIterator<Feature> mfIterator = mfCollection.features();
        while (mfIterator.hasNext()) {
            Feature mf = mfIterator.next();
            Property spec = mf.getProperty("specification");
            assertNotNull(spec);
            Object guObject = spec.getValue();
            assertNotNull(guObject);
            assertTrue(guObject instanceof Collection);
            assertEquals(1, ((Collection<Feature>) guObject).size());
            guObject = ((Collection<Feature>) guObject).iterator().next();
            assertTrue(guObject instanceof Feature);
            Feature guFeature = (Feature) guObject;
            // make sure this is the re-mapped geologic unit feature
            assertTrue(guFeatures.contains(guFeature));
            String propertyGuId = FeatureChainingTest.mfToGuMap.get(mf.getIdentifier().toString())
                    .split("gu.")[1];
            assertEquals(((Feature) guObject).getIdentifier().toString(), propertyGuId);
        }
        mfIterator.close();

        mfDataAccess.dispose();
    }

