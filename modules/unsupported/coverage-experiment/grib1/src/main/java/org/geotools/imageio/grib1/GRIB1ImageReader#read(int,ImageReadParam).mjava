    /**
     * @see javax.imageio.ImageReader#read(int, javax.imageio.ImageReadParam)
     */
    @Override
    public BufferedImage read( int imageIndex, ImageReadParam param ) throws IOException {
        BufferedImage image = null;
        Variable variable = null;
        Range indexRange = null;
        GribVariableWrapper wrapper = null;
        for( Range range : indexMap.keySet() ) {
            if (range.contains(imageIndex) && range.first() <= imageIndex && imageIndex < range.last()) {
                wrapper = indexMap.get(range);
                indexRange = range;
                break;
            }
        }
        variable = wrapper.getVariable();

        /*
         * Fetches the parameters that are not already processed by utility
         * methods like 'getDestination' or 'computeRegions' (invoked below).
         */
        final int strideX, strideY;
        final int[] srcBands, dstBands;
        if (param != null) {
            strideX = param.getSourceXSubsampling();
            strideY = param.getSourceYSubsampling();
            srcBands = param.getSourceBands();
            dstBands = param.getDestinationBands();
        } else {
            strideX = 1;
            strideY = 1;
            srcBands = null;
            dstBands = null;
        }
        final int rank = wrapper.getRank();
        final int bandDimension = rank - NetCDFUtilities.Z_DIMENSION;

        /*
         * Gets the destination image of appropriate size. We create it now
         * since it is a convenient way to get the number of destination bands.
         */
        final int width = wrapper.getWidth();
        final int height = wrapper.getHeight();
        /*
         * Computes the source region (in the NetCDF file) and the destination
         * region (in the buffered image). Copies those informations into UCAR
         * Range structure.
         */
        final Rectangle srcRegion = new Rectangle();
        final Rectangle destRegion = new Rectangle();
        computeRegions(param, width, height, null, srcRegion, destRegion);
        // flipVertically(param, height, srcRegion);
        int destWidth = destRegion.x + destRegion.width;
        int destHeight = destRegion.y + destRegion.height;

        final List<Range> ranges = new LinkedList<Range>();
        for( int i = 0; i < rank; i++ ) {
            final int first, length, stride;
            switch( rank - i ) {
            case NetCDFUtilities.X_DIMENSION: {
                first = srcRegion.x;
                length = srcRegion.width;
                stride = strideX;
                break;
            }
            case NetCDFUtilities.Y_DIMENSION: {
                first = srcRegion.y;
                length = srcRegion.height;
                stride = strideY;
                break;
            }
            default: {
                if (i == bandDimension) {
                    first = NetCDFUtilities.getZIndex(variable, indexRange, imageIndex);
                } else {
                    first = NetCDFUtilities.getTIndex(variable, indexRange, imageIndex);
                }
                length = 1;
                stride = 1;
                break;
            }
            }
            try {
                ranges.add(new Range(first, first + length - 1, stride));
            } catch (InvalidRangeException e) {
            }
        }
        final Section sections = new Section(ranges);

        /*
         * Setting SampleModel and ColorModel.
         */
        SampleModel sampleModel = wrapper.getSampleModel().createCompatibleSampleModel(destWidth, destHeight);
        ColorModel colorModel = ImageIOUtilities.createColorModel(sampleModel);

        /*
         * Reads the requested sub-region only.
         */
        final int numDstBands = 1;
        final int size = destHeight * destWidth * numDstBands;
        for( int zi = 0; zi < numDstBands; zi++ ) {
            // final int dstBand = (dstBands == null) ? zi : dstBands[zi];
            final Array array;
            try {
                array = variable.read(sections);
                DataBuffer dataBuffer = null;
                if (array instanceof ArrayByte) {
                    dataBuffer = new DataBufferByte((byte[]) array.get1DJavaArray(byte.class), size);
                } else if (array instanceof ArrayShort) {
                    dataBuffer = new DataBufferShort((short[]) array.get1DJavaArray(short.class), size);
                } else if (array instanceof ArrayInt) {
                    dataBuffer = new DataBufferInt((int[]) array.get1DJavaArray(int.class), size);
                } else if (array instanceof ArrayFloat) {
                    dataBuffer = new DataBufferFloat((float[]) array.get1DJavaArray(float.class), size);
                } else if (array instanceof ArrayDouble) {
                    dataBuffer = new DataBufferDouble((double[]) array.get1DJavaArray(double.class), size);
                }

                WritableRaster raster = Raster.createWritableRaster(sampleModel, dataBuffer, new Point(0, 0));
                image = new BufferedImage(colorModel, raster, colorModel.isAlphaPremultiplied(), null);
            } catch (InvalidRangeException e) {

            }
        }
        return image;
    }

