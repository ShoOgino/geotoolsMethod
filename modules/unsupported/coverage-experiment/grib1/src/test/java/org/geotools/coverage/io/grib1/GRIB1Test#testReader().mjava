    @org.junit.Test
    public void testReader() throws IllegalArgumentException, IOException,
            NoSuchAuthorityCodeException, InterruptedException {
        final BaseFileDriver driver = new GRIB1Driver();
        
        File dir = TestData.file(this, "");
        File[] files = dir.listFiles(new FileFilter() {
            public boolean accept(File pathname) {
                final String path = pathname.getAbsolutePath();
                if (path.endsWith(".grib") || path.endsWith(".grb"))
                    return true;
                return false;
            }
        });
        for (File inputFile : files) {
        	if(LOGGER.isLoggable(Level.INFO))
        		LOGGER.info("Testing file "+ inputFile.getAbsolutePath());
	
	        final URL source = inputFile.toURI().toURL();
	        if (driver.canProcess(DriverOperation.CONNECT,source,null)) {
	        	LOGGER.info("ACCEPTED: "+source.toString());
	
	            // getting access to the file
	            final CoverageAccess access = driver.process(DriverOperation.CONNECT,source, null, null,null);
	            if (access == null)
	                throw new IOException("Unable to connect");          
	
	            // get the names
	            final List<Name> names = access.getNames(null);
	            for (Name name : names) {
	                // get a source
	                final CoverageSource gridSource = access.access(name, null,AccessType.READ_ONLY, null, null);
	                if (gridSource == null)
	                    throw new IOException("Unable to access");    
	                LOGGER.info("Connected to coverage: "+name.toString());
	                
	                
	                
	                // TEMPORAL DOMAIN
	                final TemporalDomain temporalDomain = gridSource.getTemporalDomain();
	                if(temporalDomain==null)
	                	LOGGER.info("Temporal domain is null");
	                else{
	                	// temporal crs
	                	LOGGER.info("TemporalCRS: "+temporalDomain.getCoordinateReferenceSystem());
	                	
	                	// print the temporal domain elements
	                	for(TemporalGeometricPrimitive tg:temporalDomain.getTemporalElements(null)){
	                		LOGGER.info("TemporalGeometricPrimitive: "+tg.toString());
	                	}
	                }
	                
	                // VERTICAL DOMAIN
	                final VerticalDomain verticalDomain= gridSource.getVerticalDomain();
	                if(verticalDomain==null)
	                	LOGGER.info("Vertical domain is null");
	                else{
	                	// vertical  crs
	                	LOGGER.info("VerticalCRS: "+verticalDomain.getCoordinateReferenceSystem());
	                	
	                	// print the temporal domain elements
	                	for(NumberRange<Double> vg:verticalDomain.getVerticalElements(true, null)){
	                		LOGGER.info("Vertical domain element: "+vg.toString());
	                	}
	                }
	                
	                
	                // HORIZONTAL DOMAIN
	                final HorizontalDomain horizontalDomain= gridSource.getHorizontalDomain();
	                if(horizontalDomain==null)
	                	LOGGER.info("Horizontal domain is null");
	                else{
	                	// print the horizontal domain elements
	                	final CoordinateReferenceSystem crs2D=horizontalDomain.getCoordinateReferenceSystem2D();
	                	assert crs2D!=null;
	                	final MathTransform2D g2w=horizontalDomain.getGridToWorldTransform(null);
	                	assert g2w !=null;
	                	final Set<? extends BoundingBox> spatialElements = horizontalDomain.getSpatialElements(true,null);
	                	assert spatialElements!=null&& !spatialElements.isEmpty();
	                	
	                	final StringBuilder buf= new StringBuilder();
	                	buf.append("Horizontal domain is as follows:\n");
	                	buf.append("G2W:").append("\t").append(g2w).append("\n");
	                	buf.append("CRS2D:").append("\t").append(crs2D).append("\n");
	                	for(BoundingBox bbox:spatialElements)
	                		buf.append("BBOX:").append("\t").append(bbox).append("\n");
	                	LOGGER.info(buf.toString());
	                }	
	                RangeType range = gridSource.getRangeType(null);
	                CoverageReadRequest readRequest = new CoverageReadRequest();
	                // //
	                //
	                // Setting up a limited range for the request.
	                //
	                // //
	                Iterator<FieldType> ftIterator = range.getFieldTypes().iterator();
	                HashSet<FieldType> fieldSet = new HashSet<FieldType>();
	                FieldType ft = null;
	                while (ftIterator.hasNext()) {
	                    ft = ftIterator.next();
	                    if (ft != null) {
	                        fieldSet.add(ft);
	                    }
	                    if (!isExtensiveTest)
	                        break;
	                }
	                RangeType rangeSubset = new DefaultRangeType(range.getName(),range.getDescription(), fieldSet);
	                readRequest.setRangeSubset(rangeSubset);
	                CoverageResponse response = gridSource.read(readRequest, null);
	                if (response == null || response.getStatus() != Status.SUCCESS|| !response.getExceptions().isEmpty())
	                    throw new IOException("Unable to read");
	
	                final Collection<? extends Coverage> results = response.getResults(null);
	                for (Coverage c : results) {
	                    GridCoverage2D coverage = (GridCoverage2D) c;
	                    // Crs and envelope
	                    if (TestData.isInteractiveTest()) {
	                    	coverage.show();
	                    }
	                    else
	                    	PlanarImage.wrapRenderedImage(coverage.getRenderedImage()).getTiles();
	                    

                    	final StringBuilder buffer= new StringBuilder();
                        buffer.append("GridCoverage CRS: ").append(coverage.getCoordinateReferenceSystem2D().toWKT()).append("\n");
                        buffer.append("GridCoverage GG: ").append(coverage.getGridGeometry().toString()).append( "\n");
                        LOGGER.info(buffer.toString());
	                }
	            }
	        } else
	        	LOGGER.info("NOT ACCEPTED");
        }
    }

