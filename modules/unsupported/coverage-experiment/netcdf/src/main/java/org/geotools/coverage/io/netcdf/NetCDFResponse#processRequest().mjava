    /**
     * This method creates the GridCoverage2D from the underlying file given a specified envelope, and a requested dimension.
     * 
     * @param iUseJAI specify if the underlying read process should leverage on a JAI ImageRead operation or a simple direct call to the {@code read}
     *        method of a proper {@code ImageReader}.
     * @param overviewPolicy the overview policy which need to be adopted
     * @return a {@code GridCoverage}
     * 
     * @throws java.io.IOException
     */
    private void processRequest() throws IOException {

        // is this query empty?
        if (request.spatialRequestHelper.isEmpty()) {
            if (LOGGER.isLoggable(Level.FINE)){
                LOGGER.log(Level.FINE, "Request is empty: " + request.toString());
            }
            return;
        }

        // assemble granules
        prepareParams();
        String timeFilterAttribute = null;
        String elevationFilterAttribute = null;
        CoverageReadRequest readRequest = (CoverageReadRequest) /*response.*/getRequest();
        RangeType rangeType = request.source.getRangeType(null);
        List<DimensionDescriptor> dimensionDescriptors = request.source.getDimensionDescriptors();
        for (DimensionDescriptor dimensionDescriptor : dimensionDescriptors) {
            if (dimensionDescriptor.getName().equalsIgnoreCase(UnidataUtilities.ELEVATION_DIM)) {
                // TODO Update this with ranged attributes
                elevationFilterAttribute = dimensionDescriptor.getStartAttribute();
            } else if (dimensionDescriptor.getName().equalsIgnoreCase(UnidataUtilities.TIME_DIM)) {
                // TODO Update this with ranged attributes
                timeFilterAttribute = dimensionDescriptor.getStartAttribute();
            }
        }

        Set<DateRange> temporalSubset = readRequest.getTemporalSubset();
        Set<NumberRange<Double>> verticalSubset = readRequest.getVerticalSubset();
        RangeType requestedRange = readRequest.getRangeSubset();
        Set<FieldType> fieldTypes = requestedRange.getFieldTypes();

        //
        // adding GridCoverages to the results list
        //
        // //
       Set<SampleDimension> sampleDims = null;
       for (FieldType fieldType : fieldTypes) {
           final Name name = fieldType.getName();
           sampleDims = fieldType.getSampleDimensions();
           if (rangeType != null) {
               final FieldType ft = rangeType.getFieldType(name.getLocalPart());
               if (ft != null)
                   sampleDims = ft.getSampleDimensions();
           }
       }
       final GridSampleDimension[] sampleDimensions = sampleDims.toArray(new GridSampleDimension[sampleDims.size()]);

       // Forcing creation of subsets (even with a single null element)
       Set<DateRange> tempSubset = null;
       if (!temporalSubset.isEmpty()) {
           tempSubset = temporalSubset;
       } else {
           tempSubset = new HashSet<DateRange>();
           tempSubset.add(null);
       }

       Set<NumberRange<Double>> vertSubset = null;
       if (!verticalSubset.isEmpty()) {
           vertSubset = verticalSubset;
       } else {
           vertSubset = new HashSet<NumberRange<Double>>();
           vertSubset.add(null);
       }
       

       Map<String, Set<?>> domainsSubset = readRequest.getAdditionalDomainsSubset();     
       Filter requestFilter = request.originalRequest.getFilter();

       // handling date and time
       for (DateRange timeRange : tempSubset) {
           for (NumberRange<Double> elevation : vertSubset) {

               Query query = new Query();
               // handle time and elevation
               createTimeElevationQuery(timeRange, elevation, query, requestFilter, timeFilterAttribute, elevationFilterAttribute);

               // handle additional params
               additionalParamsManagement(query,domainsSubset, dimensionDescriptors);
               
               // bbox
               query.setFilter(
                       FeatureUtilities.DEFAULT_FILTER_FACTORY.and(
                               query.getFilter(),
                               FeatureUtilities.DEFAULT_FILTER_FACTORY.bbox(
                                       FeatureUtilities.DEFAULT_FILTER_FACTORY.property("the_geom"),
                                       targetBBox)));
                
               
               
               query.setTypeName(request.source.reader.getTypeName(request.name));
               List<Integer> indexes = request.source.reader.getImageIndex(query);
               if (indexes == null || indexes.isEmpty()) {
                   if (LOGGER.isLoggable(Level.FINE)) {
                       LOGGER.fine(" No indexes found for this query: " + query.toString());
                   }
                   continue;
               } 
               int imageIndex = indexes.get(0);
               final RenderedImage image = loadRaster(baseReadParameters, imageIndex, targetBBox, finalWorldToGridCorner, hints);

               // postproc
               RenderedImage finalRaster = postProcessRaster(image);
               // create the coverage
               GridCoverage2D gridCoverage = prepareCoverage(finalRaster, sampleDimensions);

               // Adding coverage domain
               if (gridCoverage != null) {
                   GridCoverage gcResponse = new DefaultGridCoverageResponse(gridCoverage, timeRange, elevation);
                   addResult(gcResponse);
               }
           }
       }
       
       // success
       setStatus(Status.SUCCESS);

    }

