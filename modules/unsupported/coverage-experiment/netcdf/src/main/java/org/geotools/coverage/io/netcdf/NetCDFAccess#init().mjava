    private  void init() {
        // get the needed info from them to set the extent
        try {
            final SpatioTemporalImageReader reader = (SpatioTemporalImageReader) NetCDFDriver.spi.createReaderInstance();
            reader.setInput(this.input);

            int numCoverages = 0;

            // Setting the name
            final Name mainCoverageName = Utilities.buildCoverageName(input);
            Name coverageName = mainCoverageName;

            // TODO: Add more checks on Vertical/Temporal dimension availability
            final int numImages = reader.getNumImages(false);

            // //
            //
            // Setting Envelope and Extents
            //
            // //
            Map<Name, Map<String, NetCDFProductFieldType>> fieldsMap = new HashMap<Name, Map<String, NetCDFProductFieldType>>();
            for (int imageIndex = 0; imageIndex < numImages; imageIndex++) {
            	
            	// get the slice descriptor and repack things
                final SpatioTemporalMetadata metadata = reader.getSpatioTemporalMetadata(imageIndex);
                final SliceDescriptor sd = reader.getSliceDescriptor(imageIndex);
                if (sd == null)
                    throw new IllegalStateException("unable to get the required sliceDescriptor");
                // //
                //
                // Getting slice extent
                // 
                // //
                BoundingBox boundingBox = sd.getHorizontalExtent();
                VerticalExtent ve = sd.getVerticalExtent();
                TemporalGeometricPrimitive time = sd.getTemporalExtent();
                int nDim = 2;
                boolean hasVertical = false;
                if (ve != null) {
                    nDim++;
                    hasVertical = true;
                }

                if (time != null)
                    nDim++;

                Band sampleDim = metadata.getBand(0);

                Set<TemporalGeometricPrimitive> temporalExtent;
                Set<NumberRange<Double>> verticalExtent;
                Map<String, NetCDFProductFieldType> fields;

                // //
                //
                // Firstly, group coverages having the same bounding Box.
                // Some datasources may contain data coming from acquisitions
                // on different areas. We divide them in different groups.
                //
                // //
                HashMap<BoundingBox, Name> referenceMap = getNDMap(nDim,hasVertical);
                if (!referenceMap.containsKey(boundingBox)) {
                    // //
                    //
                    // This is the first occurrence. Setting coverageName,
                    // as well as the extents.
                    //
                    // //
                    coverageName = new NameImpl(mainCoverageName.getLocalPart()+ "_" + Integer.toString(numCoverages++));
                    coverageNames.add(coverageName);
                    referenceMap.put(boundingBox, coverageName);

                    temporalExtent = new TreeSet<TemporalGeometricPrimitive>();
                    verticalExtent = new TreeSet<NumberRange<Double>>(new Comparator<NumberRange<Double>>(){
                    	// TODO comparator for ranges, this must be generalized!!!
						public int compare(
								NumberRange<Double> one,
								NumberRange<Double> two) {
							// comparator for number ranges
							final double min1=one.getMinimum(true);
							final double min2=two.getMinimum(true);
							
							if(one.contains(two)||two.contains(one))
								return 0;
							if(min1<min2)
								return -1;
							else
								return 1;
						}});
                    fields = new HashMap<String, NetCDFProductFieldType>();
                    temporalExtentMap.put(coverageName, temporalExtent);
                    verticalExtentMap.put(coverageName, verticalExtent);
                    fieldsMap.put(coverageName, fields);
                } else {
                    coverageName = referenceMap.get(boundingBox);
                    // for (Name name : boundingBoxesMap.keySet()) {
                    // if (boundingBoxesMap.get(name).equals(boundingBox)) {
                    // coverageName = name;
                    // break;
                    // }
                    // }
                }

                if (!envelopesMap.containsKey(coverageName)) {
                    // //
                    //
                    // In case this coverage's properties haven't been
                    // initialized yet, init them.
                    //
                    // //
                    initOriginalEnvelopeAndCRS(coverageName, sd);
                    final GridGeometry2D gridGeometry2D = buildGridGeometry2D(coverageName, metadata);
                    gridGeometry2DMap.put(coverageName, gridGeometry2D);
                } else {
                    GeneralEnvelope envelope = envelopesMap.get(coverageName);
                    envelope.add(sd.getGeneralEnvelope());
                    envelopesMap.put(coverageName, envelope);
                }

                // //
                //
                // Update the temporal, vertical extent for this coverage
                //
                // //
                temporalExtent = temporalExtentMap.get(coverageName);
                verticalExtent = verticalExtentMap.get(coverageName);
                if (ve != null) {
                	NumberRange<Double> verticalRange =NumberRange.create(ve.getMinimumValue().doubleValue(), ve.getMaximumValue().doubleValue());
                    if (!verticalExtent.contains(verticalRange))// TODO is this correct???
                        verticalExtent.add(verticalRange);
                }

                if (time != null) {
                    if (!temporalExtent.contains(time))
                        temporalExtent.add(time);
                }

                // //
                //
                // Update the fields for this coverage
                //
                // //
                fields = fieldsMap.get(coverageName);

                String elementName = sampleDim.getName();
                if (!fields.containsKey(elementName)) {

                    Product product = NetCDFProductFieldType.getProduct(elementName);
                    Unit<?> unit = Unit.ONE;
                    if (product != null) {
                        unit = product.getUoM();
                    } else {
                        String uOm = sampleDim.getUoM();
                        if (uOm != null) {
                            try {
                                unit = Unit.valueOf(uOm);

                            } catch (IllegalArgumentException iae) {
                                try {
                                    unit = Unit.ONE.alternate(uOm);

                                } catch (IllegalArgumentException iae2) {
                                    if (LOGGER.isLoggable(Level.FINE)) {
                                        LOGGER.log(Level.FINE,"Unable to parse the provided unit "+ uOm, iae2);
                                    }

                                } catch (UnsupportedOperationException uoe) {
                                    if (LOGGER.isLoggable(Level.FINE)) {
                                        LOGGER.log(Level.FINE,"Unable to parse the provided unit "+ uOm, uoe);
                                    }
                                }
                            }
                        }

                    }
                    // unit = Utilities.parseUnit(sampleDim.getUoM());
                    final Name nameImpl = new NameImpl(coverageName.getLocalPart(), elementName);
                    final InternationalString description = new SimpleInternationalString(elementName);

                    // setting bands names.
                    final GridSampleDimension band = Utilities.buildBands(sampleDim, elementName, unit);
                    final NetCDFProductFieldType fd = new NetCDFProductFieldType(nameImpl, description, band);
                    fields.put(elementName, fd);
                }

                // //
                //
                // Updating the sliceDescriptor Map
                //
                // //
                sliceDescriptorsMap.put(imageIndex, sd);
                spatioTemporalMetadataMap.put(imageIndex, metadata);
            }

            // //
            //
            // Checking sets
            //
            // //
            for (Name covName : coverageNames) {
                Set<NumberRange<Double>> verticalExtent = verticalExtentMap.get(covName);
                if (verticalExtent.size() == 0) {
                    verticalExtent = Collections.emptySet();
                    verticalExtentMap.put(covName, verticalExtent);
                }
                Set<TemporalGeometricPrimitive> temporalExtent = temporalExtentMap.get(covName);
                if (temporalExtent.size() == 0) {
                    temporalExtent = Collections.emptySet();
                    temporalExtentMap.put(covName, temporalExtent);
                }

                // //
                //
                // Setting a proper RangeType using the FieldTypes found
                //
                // //
                Map<String, NetCDFProductFieldType> fields =fieldsMap.get(covName);
                if (fields != null && !fields.isEmpty()) {
                    final Set<FieldType> fieldTypes = new LinkedHashSet<FieldType>(fields.size());
                    final StringBuilder sb = new StringBuilder();
                    for (NetCDFProductFieldType fd : fields.values()) {
                        fieldTypes.add(fd);
                        final InternationalString description = fd.getDescription();
                        sb.append(description != null ? description.toString()+ "," : "");
                    }
                    String description = sb.toString();
                    int pos = -1;
                    if (description.length() > 0&& (pos = description.lastIndexOf(",")) != -1) {
                        description = description.substring(0, pos);
                    }
                    DefaultRangeType range = new DefaultRangeType(covName,new SimpleInternationalString(description),fieldTypes);
                    rangeMap.put(covName, range);
                }

            }

            numberOfCoverages = numCoverages;
            // dispose the reader
            reader.dispose();
        } catch (IOException e) {
            this.numberOfCoverages = 1;

        } catch (FactoryException fe) {
            this.numberOfCoverages = 1;

        } catch (TransformException fe) {
            this.numberOfCoverages = 1;
        }

    }

