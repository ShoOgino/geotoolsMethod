    /**
     * 
     * 
     * @param crs
     * @param coordinateAxis
     */
    private void addCoordinateAxis(AbstractCoordinateReferenceSystem crs, CoordinateAxis axis) {
        final String name = axis.getName();
        final AxisType type = axis.getAxisType();
        String units = axis.getUnitsString();
        Date epoch = null;

        /*
         * Gets the axis direction, taking in account the possible reversal or
         * vertical axis. Note that geographic and projected
         * CoordinateReferenceSystem have the same directions. We can
         * distinguish them either using the ISO CoordinateReferenceSystem type
         * ("geographic" or "projected"), the ISO CS type ("ellipsoidal" or
         * "cartesian") or the units ("degrees" or "m").
         */
        String direction = DIRECTIONS.get(type);
        if (direction != null) {
            if (CF.POSITIVE_DOWN.equalsIgnoreCase(axis.getPositive())) {
                direction = OPPOSITES.get(type);
            }
            final int offset = units.lastIndexOf('_');
            if (offset >= 0) {
                final String unitsDirection = units.substring(offset + 1).trim();
                final String opposite = OPPOSITES.get(type);
                if (unitsDirection.equalsIgnoreCase(opposite)) {
                    // TODO WARNING: INCONSISTENT AXIS ORIENTATION
                    direction = opposite;
                }
                if (unitsDirection.equalsIgnoreCase(direction)) {
                    units = units.substring(0, offset).trim();
                }
            }
        }
        /*
         * Gets the axis origin. In the particular case of time axis, units are
         * typically written in the form "days since 1990-01-01 00:00:00". We
         * extract the part before "since" as the units and the part after
         * "since" as the date.
         */
        Axis netCDFaxis = crs.addAxis(new Identification(name), direction, units, null);

        if (AxisType.Time.equals(type)) {
            String origin = null;
            final String[] unitsParts = units.split("(?i)\\s+since\\s+");
            if (unitsParts.length == 2) {
                units = unitsParts[0].trim();
                origin = unitsParts[1].trim();
            } else {
                final Attribute attribute = axis.findAttribute("time_origin");
                if (attribute != null) {
                    origin = attribute.getStringValue();
                }
            }
            if (origin != null) {
                origin = NetCDFUtilities.trimFractionalPart(origin);
                // add 0 digits if absent
                origin = NetCDFSliceUtilities.checkDateDigits(origin);

                try {
                    epoch = (Date) NetCDFUtilities.getAxisFormat(type, origin).parseObject(origin);
                    if (crs instanceof TemporalCRS) {
                        GregorianCalendar cal = new GregorianCalendar();
                        cal.setTime(epoch);
                        DefaultInstant instant = new DefaultInstant(new DefaultPosition(cal.getTime()));
                        final String originDate = instant.getPosition().getDateTime().toString();
                        // TODO: Check this toString method
                        ((TemporalCRS) crs).addOrigin(originDate);
                    }
                } catch (ParseException e) {
                    throw new IllegalArgumentException(e);
                    // TODO: Change the handle this exception
                }
            }
        }

        /*
         * If the axis is not numeric, we can't process any further. If it is,
         * then adds the coordinate and index ranges.
         */
        if (!axis.isNumeric()) {
            return;
        }
        if (axis instanceof CoordinateAxis1D) {
            final CoordinateAxis1D axis1D = (CoordinateAxis1D) axis;
            final int length = axis1D.getDimension(0).getLength();
            AxisType axisType = axis1D.getAxisType();
            final boolean isZ = axisType == AxisType.Height
                    || axisType == AxisType.GeoZ
                    || axisType == AxisType.Pressure;
            if (length > 2 && axis1D.isRegular()) {
                // Reminder: pixel orientation is "center", maximum value is
                // inclusive.
                final double increment = axis1D.getIncrement();
                double start = axis1D.getStart();
                double end = start + increment * (length - 1); // Inclusive
                if (netCDFaxis != null) {
                    if (start > end && !isZ) {
                        double temp = start;
                        start = end;
                        end = temp;
                    }
                    netCDFaxis.setMinimumValue(String.valueOf(start));
                    netCDFaxis.setMaximumValue(String.valueOf(end));
                    // netCDFaxis.setRangeMeaning("exact");
                }
            } else {
                final double[] values = axis1D.getCoordValues();
                if (netCDFaxis != null) {
                    double start = values[0];
                    double end = values[values.length - 1];
                    if (start > end && !isZ) {
                        double temp = start;
                        start = end;
                        end = temp;
                    }
                    netCDFaxis.setMinimumValue(String.valueOf(start));
                    netCDFaxis.setMaximumValue(String.valueOf(end));
                    // netCDFaxis.setRangeMeaning("exact");
                }
            }
        }
    }

