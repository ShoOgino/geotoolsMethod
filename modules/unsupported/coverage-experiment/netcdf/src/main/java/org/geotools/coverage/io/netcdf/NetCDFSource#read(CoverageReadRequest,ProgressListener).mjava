    public CoverageResponse read(CoverageReadRequest request,
            ProgressListener listener) throws IOException {
        ensureNotDisposed();

        // //
        //
        // Checking the request and filling the missing fields
        //
        // //

        checkRequest(request);
        BoundingBox requestedBoundingBox = request.getGeographicArea();
        Rectangle requestedRasterArea = request.getRasterArea();
        Set<TemporalGeometricPrimitive> temporalSubset = request.getTemporalSubset();
        Set<NumberRange<Double>> verticalSubset = request.getVerticalSubset();
        RangeType range = request.getRangeSubset();
        Set<FieldType> fieldTypes = range.getFieldTypes();

        // TODO on NetCDF adopt the suggested policy: see the google document
        final boolean useJAI = false;
        // TODO: Parse coverageRequest additional parameters.

        final CoverageResponse response = new CoverageResponse();
        response.setRequest(request);

        Rectangle sourceRasterRegion = new Rectangle();
        GeneralEnvelope adjustedRequestedEnvelope2D;
        GeneralEnvelope requestedEnvelope2D = new GeneralEnvelope(requestedBoundingBox);
        final MathTransform2D grid2WorldTransform = request.getGridToWorldTransform();
        final ImageReadParam imageReadParam = new ImageReadParam();
        try {
            // //
            //
            // Set envelope and source region
            //
            // //
            adjustedRequestedEnvelope2D = Utilities.evaluateRequestedParams(
                    access.gridGeometry2DMap.get(this.name).getGridRange(),
                    access.baseEnvelope2DMap.get(this.name),
                    access.spatialReferenceSystem2DMap.get(this.name),
                    access.raster2ModelMap.get(this.name), requestedEnvelope2D,
                    sourceRasterRegion, requestedRasterArea,
                    grid2WorldTransform, access.wgs84BaseEnvelope2DMap.get(this.name));

            // //
            //
            // Set specific imageIO parameters: type of read operation,
            // imageReadParams
            //
            // //
            // useJAI = requestUsesJaiImageread();
            // if (useMultithreading) {
            // imageReadParam = new DefaultCloneableImageReadParam();
            // } else {
            // imageReadParam = new ImageReadParam();
            // }
            if (adjustedRequestedEnvelope2D != null) {
                final GeneralEnvelope req = (adjustedRequestedEnvelope2D
                        .isEmpty()) ? requestedEnvelope2D
                        : adjustedRequestedEnvelope2D;
                Utilities.setReadParameters(null /* OverviewPolicy */,
                        imageReadParam, req, requestedRasterArea,
                        access.highestResMap.get(this.name),
                        access.gridGeometry2DMap.get(this.name).getGridRange(),
                        PixelInCell.CELL_CORNER);
            }
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, e.getLocalizedMessage(), e);
            adjustedRequestedEnvelope2D = null;
        } catch (TransformException e) {
            LOGGER.log(Level.SEVERE, e.getLocalizedMessage(), e);
            adjustedRequestedEnvelope2D = null;
        }
        if (adjustedRequestedEnvelope2D != null && sourceRasterRegion != null
                && !sourceRasterRegion.isEmpty()) {
            imageReadParam.setSourceRegion(sourceRasterRegion);
        }

        // A transformation is requested in case the requested envelope has been
        // adjusted
        final boolean needTransformation = (adjustedRequestedEnvelope2D != null && !adjustedRequestedEnvelope2D
                .isEmpty());

        // In case the adjusted requested envelope is null, no intersection
        // between requested envelope and base envelope have been found. Hence,
        // no valid coverage will be loaded and the request should be considered
        // as producing an empty result.
        final boolean emptyRequest = adjustedRequestedEnvelope2D == null;

        // //
        //
        // adding GridCoverages to the results list
        //
        // //
        for (FieldType fieldType : fieldTypes) {
            final Name name = fieldType.getName();

            // TODO: Fix this leveraging on the proper Band
            Set<SampleDimension> sampleDims = fieldType.getSampleDimensions();
            if (sampleDims == null || sampleDims.isEmpty()) {
                final RangeType innerRange = access.rangeMap.get(this.name);
                if (innerRange != null) {
                    final FieldType ft = innerRange.getFieldType(name
                            .getLocalPart());
                    if (ft != null)
                        sampleDims = ft.getSampleDimensions();
                }

            }

            final GridSampleDimension[] sampleDimensions = sampleDims
                    .toArray(new GridSampleDimension[sampleDims.size()]);
            final Collection<SliceDescriptor> sliceDescriptors = access.sliceDescriptorsMap.values();
            for (SliceDescriptor sd : sliceDescriptors) {
                if (name.getLocalPart().equals(sd.getElementName())) {
                    // //
                    //
                    // Has Time?
                    // 
                    // //
                    if (!temporalSubset.isEmpty()) {
                        for (TemporalGeometricPrimitive time : temporalSubset) {
                            TemporalGeometricPrimitive sdTime = sd
                                    .getTemporalExtent();
                            if (isTimeAccepted(time, sdTime)) {
                                addCoverage(response, verticalSubset, sd,
                                        needTransformation, emptyRequest,
                                        useJAI, imageReadParam,
                                        sampleDimensions);
                            }
                        }
                    } else {
                        addCoverage(response, verticalSubset, sd,
                                needTransformation, emptyRequest, useJAI,
                                imageReadParam, sampleDimensions);
                    }
                }
            }
        }
        response.setStatus(Status.SUCCESS);

        return response;
    }

