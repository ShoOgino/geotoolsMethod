    private void checkRequest(CoverageReadRequest request) {
        BoundingBox requestedBoundingBox = request.getGeographicArea();

        // //
        //
        // Checking RequestedRasterArea setting
        //
        // //
        Rectangle requestedRasterArea = request.getRasterArea();
        if (requestedRasterArea == null || requestedBoundingBox == null) {
            if (requestedRasterArea == null) {
                // requestedRasterArea =
                // access.coverageGeometries.get(access.coverageNames.get(0))
                // .getGridRange2D().getBounds();
                requestedRasterArea = access.gridGeometry2DMap.get(this.name)
                        .getGridRange2D().getBounds();
            }
            if (requestedBoundingBox == null) {
                requestedBoundingBox = (BoundingBox) new ReferencedEnvelope(access.gridGeometry2DMap.get(this.name).getEnvelope());

            }

            request.setDomainSubset(requestedRasterArea, requestedBoundingBox);
        }

        // //
        //
        // Checking TemporalSubset setting
        //
        // //
        SortedSet<TemporalGeometricPrimitive> temporalSubset = request.getTemporalSubset();
        if (temporalSubset.isEmpty()) {
            Set<TemporalGeometricPrimitive> temporalExtent = access.temporalExtentMap.get(this.name);
            temporalSubset = new TreeSet<TemporalGeometricPrimitive>(temporalExtent);
            request.setTemporalSubset(temporalSubset);
        }

//        // //
//        //
//        // Checking VerticalSubset setting
//        //
//        // //
//        Set<NumberRange<Double>> verticalSubset = request.getVerticalSubset();
//        if (verticalSubset.isEmpty()) {
//            Set<NumberRange<Double>> verticalExtent = access.verticalExtentMap.get(this.name);
//            if (verticalExtent != null)
//                verticalSubset = new HashSet<NumberRange<Double>>(verticalExtent);
//            request.setVerticalSubset(verticalSubset);
//        } else {
//            final Set<NumberRange<Double>> availableSet = access.verticalExtentMap.get(this.name);
//            final NumberRange<Double> requestedEnvelope = verticalSubset.iterator().next();
//            if (!availableSet.contains(requestedEnvelope)) {//TODO is this correct?
//                // TODO: Actually, support for a single vertical element search
//                // Find the nearest vertical Envelope
//            	NumberRange<Double> nearestEnvelope = availableSet.iterator().next();
//
//                double minimumDistance = Math.abs(nearestEnvelope.getMinimum()- requestedEnvelope.getMinimum());
//                for (NumberRange<Double> env : availableSet) {
//                    double distance = Math.abs(env.getMinimum()- requestedEnvelope.getMinimum());
//                    if (distance < minimumDistance) {
//                        nearestEnvelope = env;
//                        minimumDistance = distance;
//                    }
//                }
//                verticalSubset = new HashSet<NumberRange<Double>>(1);
//                verticalSubset.add(nearestEnvelope);
//                request.setVerticalSubset(verticalSubset);
//            }
//        }

        // //
        //
        // Checking RangeSubset setting
        //
        // //
        RangeType range = request.getRangeSubset();
        if (range == null)
            request.setRangeSubset(access.rangeMap.get(this.name));
    }

