    /**
     * Returns the intersection between the base envelope and the requested
     * envelope.
     * 
     * @param requestedEnvelope2D
     *                the requested 2D envelope to be intersected with the base
     *                envelope.
     * @param requestedDim
     *                is the requested region where to load data of the
     *                specified envelope.
     * @param readGridToWorld
     *                the Grid to world transformation to be used in read
     * @return the resulting intersection of envelopes. In case of empty
     *         intersection, this method is allowed to return {@code null}
     * @throws TransformException
     * @throws FactoryException
     */
    private GeneralEnvelope getIntersection(
            GeneralEnvelope requestedEnvelope2D, Rectangle requestedDim,
            MathTransform2D readGridToWorld) throws TransformException,
            FactoryException {

        GeneralEnvelope adjustedRequestedEnvelope = new GeneralEnvelope(2);
        final CoordinateReferenceSystem requestedEnvelopeCRS2D = requestedEnvelope2D
                .getCoordinateReferenceSystem();
        boolean tryWithWGS84 = false;

        try {
            // convert the requested envelope 2D to this coverage native crs.
            MathTransform transform = null;
            if (!CRS.equalsIgnoreMetadata(requestedEnvelopeCRS2D,
                    spatialReferenceSystem2D))
                transform = CRS.findMathTransform(requestedEnvelopeCRS2D,
                        spatialReferenceSystem2D, true);
            // now transform the requested envelope to source crs
            if (transform != null && !transform.isIdentity())
                adjustedRequestedEnvelope = CRS.transform(transform,
                        requestedEnvelope2D);
            else
                adjustedRequestedEnvelope.setEnvelope(requestedEnvelope2D);

            // intersect the requested area with the bounds of this
            // layer in native crs
            if (!adjustedRequestedEnvelope.intersects(baseEnvelope2D, true))
                return null;
            adjustedRequestedEnvelope.intersect(baseEnvelope2D);
            adjustedRequestedEnvelope
                    .setCoordinateReferenceSystem(spatialReferenceSystem2D);

            // //
            //
            // transform the intersection envelope from the destination world
            // space to the requested raster space
            //
            // //
            final Envelope requestedEnvelopeCropped = (transform != null && !transform
                    .isIdentity()) ? CRS.transform(transform.inverse(),
                    adjustedRequestedEnvelope) : adjustedRequestedEnvelope;
            final Rectangle2D ordinates = CRS.transform(
                    readGridToWorld.inverse(), requestedEnvelopeCropped)
                    .toRectangle2D();
            final GeneralGridEnvelope finalRange = new GeneralGridEnvelope(ordinates
                    .getBounds());
            final Rectangle tempRect = finalRange.toRectangle();
            // check that we stay inside the source rectangle
            XRectangle2D.intersect(tempRect, requestedDim, tempRect);
            requestedDim.setRect(tempRect);
        } catch (TransformException te) {
            // something bad happened while trying to transform this
            // envelope. let's try with wgs84
            tryWithWGS84 = true;
        } catch (FactoryException fe) {
            // something bad happened while trying to transform this
            // envelope. let's try with wgs84
            tryWithWGS84 = true;
        }

        // //
        //
        // If this does not work, we go back to reproject in the wgs84
        // requested envelope
        //              
        // //
        if (tryWithWGS84) {
            initWGS84BaseEnvelope();
            final GeneralEnvelope requestedEnvelopeWGS84 = (GeneralEnvelope) getEnvelopeAsWGS84(
                    requestedEnvelope2D, false);

            // checking the intersection in wgs84
            if (!requestedEnvelopeWGS84.intersects(wgs84BaseEnvelope2D, true))
                return null;

            // intersect
            adjustedRequestedEnvelope = new GeneralEnvelope(
                    requestedEnvelopeWGS84);
            adjustedRequestedEnvelope.intersect(wgs84BaseEnvelope2D);
            adjustedRequestedEnvelope = CRS.transform(CRS.findMathTransform(
                    requestedEnvelopeWGS84.getCoordinateReferenceSystem(),
                    spatialReferenceSystem2D, true), adjustedRequestedEnvelope);
            adjustedRequestedEnvelope
                    .setCoordinateReferenceSystem(spatialReferenceSystem2D);

        }
        return adjustedRequestedEnvelope;
    }

