    /**
     * If the specified value is infinity, then replace that values by a bounds
     * inferred from the specified fill values and data type.
     * 
     * @param value
     *                The value.
     * @param fillValues
     *                The packed values used for missing data, or {@code null}
     *                if none.
     * @param dataType
     *                The raw data type as one of {@link DataBuffer} constants,
     *                or {@link DataBuffer#TYPE_UNDEFINED} if unknown.
     */
    private static double replaceInfinity(double value, final double[] fillValues, final int dataType) {
        final boolean negative;
        if (value == Double.NEGATIVE_INFINITY) {
            negative = true;
        } else if (value == Double.POSITIVE_INFINITY) {
            negative = false;
        } else {
            return value;
        }
        final double midValue;
        switch (dataType) {
        default: {
            // Unsigned integer: computes the upper bound according the data
            // length.
            final long range = 1L << DataBuffer.getDataTypeSize(dataType);
            value = negative ? 0 : range - 1;
            midValue = range >>> 1;
            break;
        }
        case DataBuffer.TYPE_SHORT: {
            value = negative ? Short.MIN_VALUE : Short.MAX_VALUE;
            midValue = 0;
            break;
        }
        case DataBuffer.TYPE_INT: {
            value = negative ? Integer.MIN_VALUE : Integer.MAX_VALUE;
            midValue = 0;
            break;
        }
        case DataBuffer.TYPE_FLOAT:
        case DataBuffer.TYPE_DOUBLE:
        case DataBuffer.TYPE_UNDEFINED: {
            // Unbounded or undefined type: nothing to do.
            return value;
        }
        }
        /*
         * Considers only the fill values that are close to the bounds we just
         * computed. We use the middle value (always 0 for signed data type) as
         * the threshold for choosing which bounds is close to that value. In
         * other words, for signed data type we consider only positive or
         * negative fill values (depending the 'value' sign), not both in same
         * time.
         * 
         * For each fill value to consider, reduces the range of valid values in
         * such a way that it doesn't include that fill value. The exclusion is
         * performed by subtracting 1, which should be okay since we known at
         * this stage that the data type is integer.
         */
        if (fillValues != null) {
            double valueDistance = Math.abs(value - midValue);
            for (int i = 0; i < fillValues.length; i++) {
                final double fillValue = fillValues[i];
                if ((fillValue < midValue) == negative) {
                    final double fillDistance = Math.abs(fillValue - midValue);
                    if (fillDistance <= valueDistance) {
                        valueDistance = fillDistance;
                        value = fillValue - 1; // Value must be exclusive.
                    }
                }
            }
        }
        return value;
    }

