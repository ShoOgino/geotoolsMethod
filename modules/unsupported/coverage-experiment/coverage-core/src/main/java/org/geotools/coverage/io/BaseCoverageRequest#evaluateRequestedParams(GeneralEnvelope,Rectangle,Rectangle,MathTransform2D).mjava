    /**
     * Evaluates the requested envelope and builds a new adjusted version of it
     * fitting this coverage envelope.
     * 
     * <p>
     * While adjusting the requested envelope this methods also compute the
     * source region as a rectangle which is suitable for a successive read
     * operation with {@link ImageIO} to do crop-on-read.
     * 
     * 
     * @param requestedEnvelope
     *                is the envelope we are requested to load.
     * @param sourceRegion
     *                represents the area to load in raster space. This
     *                parameter cannot be null since it gets filled with
     *                whatever the crop region is depending on the
     *                <code>requestedEnvelope</code>.
     * @param requestedDim
     *                is the requested region where to load data of the
     *                specified envelope.
     * @param readGridToWorld
     *                the Grid to world transformation to be used
     * @return the adjusted requested envelope, empty if no requestedEnvelope
     *         has been specified, {@code null} in case the requested envelope
     *         does not intersect the coverage envelope or in case the adjusted
     *         requested envelope is covered by a too small raster region (an
     *         empty region).
     * 
     * @throws DataSourceException
     *                 in case something bad occurs
     */
    private GeneralEnvelope evaluateRequestedParams(
            GeneralEnvelope requestedEnvelope, Rectangle sourceRegion,
            Rectangle requestedDim, MathTransform2D readGridToWorld)
            throws DataSourceException {
        GeneralEnvelope adjustedRequestedEnvelope = new GeneralEnvelope(2);
        try {
            // ////////////////////////////////////////////////////////////////
            //
            // Check if we have something to load by intersecting the
            // requested envelope with the bounds of this data set.
            //
            // ////////////////////////////////////////////////////////////////
            if (requestedEnvelope != null) {
                initBaseEnvelope2D();
                final GeneralEnvelope requestedEnvelope2D = getRequestedEnvelope2D(requestedEnvelope);

                // ////////////////////////////////////////////////////////////
                //
                // INTERSECT ENVELOPES AND CROP Destination REGION
                //
                // ////////////////////////////////////////////////////////////
                adjustedRequestedEnvelope = getIntersection(
                        requestedEnvelope2D, requestedDim, readGridToWorld);
                if (adjustedRequestedEnvelope == null)
                    return null;

                // /////////////////////////////////////////////////////////////////////
                //
                // CROP SOURCE REGION
                //
                // /////////////////////////////////////////////////////////////////////
                sourceRegion.setRect(getCropRegion(adjustedRequestedEnvelope));
                if (sourceRegion.isEmpty()) {
                    if (LOGGER.isLoggable(Level.INFO)) {
                        LOGGER.log(Level.INFO,
                                "Too small envelope resulting in "
                                        + "empty cropped raster region");
                    }
                    return null;
                    // TODO: Future versions may define a 1x1 rectangle starting
                    // from the lower coordinate
                }
                if (!sourceRegion.intersects(baseGridRange.toRectangle())
                        || sourceRegion.isEmpty())
                    throw new DataSourceException("The crop region is invalid.");
                sourceRegion.setRect(sourceRegion.intersection(baseGridRange
                        .toRectangle()));

                if (LOGGER.isLoggable(Level.FINE)) {
                    StringBuffer sb = new StringBuffer(
                            "Adjusted Requested Envelope = ").append(
                            adjustedRequestedEnvelope.toString()).append("\n")
                            .append("Requested raster dimension = ").append(
                                    requestedDim.toString()).append("\n")
                            .append("Corresponding raster source region = ")
                            .append(sourceRegion.toString());
                    LOGGER.log(Level.FINE, sb.toString());
                }

            } else {
                // don't use the source region. Set an empty one
                sourceRegion.setBounds(new Rectangle(0, 0, Integer.MIN_VALUE,
                        Integer.MIN_VALUE));
            }
        } catch (TransformException e) {
            throw new DataSourceException(
                    "Unable to create a coverage for this source", e);
        } catch (FactoryException e) {
            throw new DataSourceException(
                    "Unable to create a coverage for this source", e);
        }
        return adjustedRequestedEnvelope;
    }

