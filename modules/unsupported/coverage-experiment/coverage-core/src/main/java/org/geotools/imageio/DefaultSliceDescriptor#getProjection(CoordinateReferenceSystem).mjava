    /**
     * Returns the projection. The default implementation performs the following
     * steps:
     * <p>
     * <ul>
     * <li>Gets a {@linkplain ParameterValueGroup parameter value group} from a
     * {@link MathTransformFactory}</li>
     * 
     * <li>Gets the metadata values for each parameters in the above step. If a
     * parameter is not defined in this {@code MetadataReader}, then it will be
     * left to its (projection dependent) default value. Parameters are
     * projection dependent, but will typically include
     * 
     * {@code "semi_major"}, {@code "semi_minor"} (or
     * {@code "inverse_flattening"}), {@code "central_meridian"},
     * {@code "latitude_of_origin"}, {@code "false_easting"} and
     * {@code "false_northing"}.
     * 
     * <li>Computes and returns a {@linkplain DefiningConversion conversion}
     * using the name of the projection and the parameter value group previously
     * filled.</li>
     * </ul>
     * </p>
     * 
     * @return The projection.
     * @throws MetadataException
     *                 if the operation failed for some other reason (for
     *                 example if a parameter value can't be parsed as a
     *                 {@code double}).
     * 
     */
    private Conversion getProjection(final CoordinateReferenceSystem metaCRS) throws Exception {
        final MathTransformFactory mathTransformFactory = getFactoryContainer().getMathTransformFactory();

        DefinedByConversion conversionDefinition = metaCRS.getDefinedByConversion();
        String projectionName = conversionDefinition.getIdentification().getName();
        if (projectionName == null) {
            throw new MetadataException("Projection name is not defined.");
        }
        final ParameterValueGroup paramValueGroup;
        try {
            paramValueGroup = mathTransformFactory.getDefaultParameters(projectionName);
        } catch (NoSuchIdentifierException e) {
            throw new MetadataException(e.getLocalizedMessage());
        }
        for (int i = 0; i < conversionDefinition.numParams(); i++) {
            final ParameterValue parameter = conversionDefinition.getParameterValue(i);
            final String name = parameter.getIdentification().getName();
            if (name == null) {
                continue;
            }
            final double value = parameter.getValue();
            if (Double.isNaN(value)) {
                continue;
            }
            try {
                paramValueGroup.parameter(name).setValue(value);
            } catch (ParameterNotFoundException e) {
                // Should not happened. Continue with the next parameter, the
                // current one will be ignored.
                continue;
            }
        }
        return new DefiningConversion(projectionName, paramValueGroup);
    }

