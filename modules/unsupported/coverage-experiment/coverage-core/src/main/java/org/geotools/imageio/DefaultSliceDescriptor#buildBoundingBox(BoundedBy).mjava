    /**
     * Set the {@link GeneralEnvelope} object referring to this object given a
     * {@link BoundedBy} metadata element.
     * 
     * @param boundedBy
     *                the metadata node to be used to set envelope.
     */
    private void buildBoundingBox(BoundedBy boundedBy) {
        if (boundedBy == null)
            throw new NullPointerException("Specified boundedBy metadata node is null");
        final List<Double> minDP = new ArrayList<Double>();
        final List<Double> maxDP = new ArrayList<Double>();
        final double[] lowers = boundedBy.getLowerCorner();
        final double[] uppers = boundedBy.getUpperCorner();

        // temporal extent
        final TemporalGeometricPrimitive temporalExtent = getTemporalExtent();
        final VerticalExtent verticalExtent = getVerticalExtent();
        org.opengis.referencing.crs.CoordinateReferenceSystem coordinateReferenceSystem = getCoordinateReferenceSystem();

        // build the various elements
        int i=0;
        for (CRSType crsType : CRSTypes) {
        	switch (crsType) {
			case TEMPORAL:
				if (temporalExtent != null) {
					final TemporalCRS temporalCRS ;
					if(CRSTypes.length == 1)
						 temporalCRS=(TemporalCRS) coordinateReferenceSystem;
	                else {
	                	// get the compound crs
	                	final CompoundCRS compoundCRS=(CompoundCRS) coordinateReferenceSystem;
	                	temporalCRS=(TemporalCRS) compoundCRS.getCoordinateReferenceSystems().get(i);
	                }

	                if (temporalExtent instanceof Instant) {
	                    double time = DefaultTemporalCRS.wrap(temporalCRS).toValue(((Instant) temporalExtent).getPosition().getDate());
	                    minDP.add(time);
	                    maxDP.add(time);
	                } else if (temporalExtent instanceof Period) {
	                    double beginTime = DefaultTemporalCRS.wrap(temporalCRS).toValue(((Period) temporalExtent).getBeginning().getPosition().getDate());
	                    double endTime = DefaultTemporalCRS.wrap(temporalCRS).toValue(((Period) temporalExtent).getEnding().getPosition().getDate());
	                    minDP.add(beginTime);
	                    maxDP.add(endTime);
	                }
	            } 
				break;
			case VERTICAL:
				 if (verticalExtent != null) {
		                final VerticalExtent.VerticalLevelType verticalType = verticalExtent.getType();
		                if (verticalType == VerticalExtent.VerticalLevelType.SINGLE_NUMBER|| verticalType == VerticalExtent.VerticalLevelType.NUMBER_RANGE) {
		                    minDP.add(verticalExtent.getMinimumValue());
		                    maxDP.add(verticalExtent.getMaximumValue());
		                } // if UNKNOWN ???
		            }
				 break;
			case GEO2D:case PROJECTED: case PROJECTED3D: 
				final org.opengis.referencing.crs.CoordinateReferenceSystem spatialCRS ;
                if(CRSTypes.length == 1)
                	spatialCRS=coordinateReferenceSystem;
                else {
                	// get the compound crs
                	final CompoundCRS compoundCRS=(CompoundCRS) coordinateReferenceSystem;
                	spatialCRS=compoundCRS.getCoordinateReferenceSystems().get(i);
                }

                if (spatialCRS.getCoordinateSystem().getDimension() == lowers.length&& lowers.length == uppers.length) {
                    for (int j = 0; j < lowers.length; j++) {
                        minDP.add(lowers[j]);
                        maxDP.add(uppers[j]);
                    }
                } // not matching dimensions ???
                break;
			default:
				throw new UnsupportedOperationException(Errors.format(ErrorKeys.UNSUPPORTED_COORDINATE_SYSTEM_$1,crsType.toString()));
			}

        	i++;
        }

        final double[] ordinates = new double[minDP.size() + maxDP.size()];
        int index = 0;
        for (Double value : minDP) {
            ordinates[index++] = value;
        }
        for (Double value : maxDP) {
            ordinates[index++] = value;
        }

        //TODO Improve checks: A slice could be without an Horizontal Extent
        final GeneralEnvelope generalEnvelope = new GeneralEnvelope(coordinateReferenceSystem);
        generalEnvelope.setEnvelope(ordinates);
        setGeneralEnvelope(generalEnvelope);
        
        // try to get the spatial BBOX
        try {
        	
        	GeneralEnvelope spatialBBOX =null;
        	
        	// we have a compound CRS
        	if (coordinateReferenceSystem instanceof CompoundCRS){
        		final org.opengis.referencing.crs.CoordinateReferenceSystem spatialCRS= CRS.getHorizontalCRS(coordinateReferenceSystem);
        		if(spatialCRS!=null){
        			// get the transform from the compound to the spatial crs
        			final MathTransform tr= CRS.findMathTransform(coordinateReferenceSystem, spatialCRS,true);
        			// extract the spatial envelope
        			spatialBBOX=CRS.transform(tr, generalEnvelope);
        			spatialBBOX.setCoordinateReferenceSystem(spatialCRS);
        		}
        	}
        	// we do not have a compound CRS
        	else if (coordinateReferenceSystem instanceof GeographicCRS || coordinateReferenceSystem instanceof ProjectedCRS)
        	{
        		spatialBBOX= new GeneralEnvelope(generalEnvelope);
        		spatialBBOX.setCoordinateReferenceSystem(coordinateReferenceSystem);
        	}

        	// at this point we might have not found a spatial CRS then the bbox should be empty      
        	if(spatialBBOX!=null)
        	{
        		setHorizontalExtent((BoundingBox) new ReferencedEnvelope(spatialBBOX));
        		return;
        	}
		} catch (FactoryException e) {
			if(LOGGER.isLoggable(Level.FINE))
				LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
		} catch (TransformException e) {
			if(LOGGER.isLoggable(Level.FINE))
				LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
		}

		// if we got here, either we got an error or we have no spatial crs
		setHorizontalExtent(null);
    }

