    /**
     * Enables versioning for the specified feature type, appending a commit message to the
     * changeset
     * 
     * @param typeName
     * @param author
     * @param message
     * @throws IOException
     * @throws DataSourceException
     */
    private void enableVersioning(String typeName, String author, String message)
            throws IOException, DataSourceException {
        // this will make the fid mapper be computed and stick... but we do have
        // timeouts...
        FIDMapper mapper = wrapped.getFIDMapper(typeName);

        // check we can version enable this table, we need a supported fid
        // mapper
        if (!checkSupportedMapper(mapper)) {
            if (mapper instanceof TypedFIDMapper)
                mapper = ((TypedFIDMapper) mapper).getWrappedMapper();
            throw new IOException("This feature type (" + typeName + ") is associated to "
                    + "an unsupported fid mapper: " + mapper.getClass() + "\n"
                    + "The supported fid mapper classes are: "
                    + Arrays.asList(SUPPORTED_FID_MAPPERS));
        }
        // TODO: check for tables that have version reserved column names,
        // we may throw better error messages

        // have a default message
        if (message == null)
            message = "Version enabling " + typeName;

        // alter table structure in a transaction
        Connection conn = null;
        Statement st = null;
        ResultSet rs = null;
        PostgisSQLBuilder sqlb = wrapped.createSQLBuilder();
        Transaction t = new DefaultTransaction();
        t.putProperty(VersioningDataStore.AUTHOR, author);
        t.putProperty(VersioningDataStore.MESSAGE, message);
        try {
            // gather the transaction state and pick the version number, also
            // update the dirty feature types
            // --> if we do this among other alter tables a deadlock occurs,
            // don't know why...
            VersionedJdbcTransactionState state = wrapped.getVersionedJdbcTransactionState(t);
            state.setTypeNameDirty(typeName);
            long revision = state.getRevision();

            // gather bbox, we need it for the first commit msg
            Envelope envelope = wrapped.getFeatureSource(typeName).getBounds();
            if (envelope != null) {
                final GeometryDescriptor defaultGeometry = wrapped.getSchema(typeName).getGeometryDescriptor();
                if(defaultGeometry != null) {
                    CoordinateReferenceSystem crs = defaultGeometry.getCoordinateReferenceSystem();
                    if (crs != null)
                        envelope = JTS.toGeographic(envelope, crs);
                    state.expandDirtyBounds(envelope);
                }
            }

            // setup for altering tables (and ensure a versioned state is
            // attached to the transaction
            conn = state.getConnection();
            PkDescriptor pk = getPrimaryKeyConstraintName(conn, typeName);
            if (pk == null)
                throw new DataSourceException("Cannot version tables without primary keys");

            // build a comma separated list of old pk columns
            String colList = "";
            for (int i = 0; i < pk.columns.length; i++) {
                colList += "," + pk.columns[i];
            }

            // drop the old primary key
            st = conn.createStatement();
            execute(st, "ALTER TABLE " + sqlb.encodeTableName(typeName) + " DROP CONSTRAINT "
                    + pk.name);

            execute(st, "ALTER TABLE " + sqlb.encodeTableName(typeName)
                    + " ADD COLUMN REVISION BIGINT REFERENCES " + TBL_CHANGESETS);
            // TODO: add some runtime check that acts as a foreign key iif
            // the value is not Long.MAX_VALUE
            execute(st, "ALTER TABLE " + sqlb.encodeTableName(typeName)
                    + " ADD COLUMN EXPIRED BIGINT NOT NULL DEFAULT " + Long.MAX_VALUE);
            execute(st, "ALTER TABLE " + sqlb.encodeTableName(typeName)
                    + " ADD COLUMN CREATED BIGINT REFERENCES " + TBL_CHANGESETS);

            // update all rows in the table with the new revision number
            // and turn revision into a not null column
            execute(st, "UPDATE " + sqlb.encodeTableName(typeName) 
                    + " SET REVISION = " + revision
                    + " , CREATED = " + revision);
            execute(st, "ALTER TABLE " + sqlb.encodeTableName(typeName)
                    + " ALTER REVISION SET NOT NULL");
            execute(st, "ALTER TABLE " + sqlb.encodeTableName(typeName)
                    + " ALTER CREATED SET NOT NULL");

            // now recreate the primary key with revision as first column
            execute(st, "ALTER TABLE " + sqlb.encodeTableName(typeName) + " ADD CONSTRAINT "
                    + pk.name + " PRIMARY KEY(REVISION " + colList + ")");
            // add secondary index
            execute(st, "CREATE INDEX " + typeName.toUpperCase() + "_REVIDX" + " ON " + typeName
                    + "(EXPIRED" + colList + ")");

            // mark the table as versioned. First check if we already have
            // records for this table
            // then insert or update
            rs = executeQuery(st, "SELECT VERSIONED from " + sqlb.encodeTableName(TBL_VERSIONEDTABLES)
                    + " WHERE SCHEMA = '" + getConfig().getDatabaseSchemaName() + "'" //
                    + " AND NAME='" + typeName + "'");
            if (rs.next()) {
                // we already have the table listed, it was versioned in the past
                execute(st, "UPDATE " + sqlb.encodeTableName(TBL_VERSIONEDTABLES) //
                        + " SET VERSIONED = TRUE " //
                        + " WHERE SCHEMA = '" + getConfig().getDatabaseSchemaName() + "'" //
                        + " AND NAME='" + typeName + "'");
            } else {
                // this has never been versioned, insert new records
                execute(st, "INSERT INTO " + sqlb.encodeTableName(TBL_VERSIONEDTABLES)
                        + " VALUES(default, " + "'" + getConfig().getDatabaseSchemaName() + "','"
                        + typeName + "', TRUE)");
            }
            rs.close();
            
            // create view to support versioned feature collection extraction
            createVersionedFeatureCollectionView(typeName, conn);

            // phew... done!
            t.commit();

            // and now wipe out the cached feature type, we just changed it, but
            // do not change the fid mapper, it's still ok (or it isn't?)
            // MIND, this needs to be done _after_ the transaction is committed,
            // otherewise transaction writing will try to get metadata with
            // alters still in progress and the whole thing will lock up
            resetTypeInfo();
        } catch (SQLException sql) {
            throw new DataSourceException("Error occurred during version enabling. "
                    + "Does your table have columns with reserved names?", sql);
        } catch (TransformException e) {
            throw new DataSourceException(
                    "Error occurred while trying to compute the lat/lon bounding box "
                            + "affected by this operation", e);
        } finally {
            JDBCUtils.close(rs);
            JDBCUtils.close(st);
            JDBCUtils.close(conn, t, null);
            t.close();
        }
    }

