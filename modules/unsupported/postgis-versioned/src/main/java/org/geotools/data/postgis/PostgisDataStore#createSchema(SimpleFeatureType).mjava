    /**
     * Creates a FeatureType in this instance of the PostgisDataStore. Since we
     * don't yet know which attribute in the FeatureType is the primary key, we
     * will create our own called "fid_tablename", which has its own sequence
     * called "tablename_fid_seq". The user should not interact with this
     * column, although its value will be the FID. This method currently assumes
     * there are only 2 dimensions.
     *
     * @throws IOException
     *             if something goes horribly wrong or the table already exists
     * @see org.geotools.data.DataStore#createSchema(org.geotools.feature.FeatureType)
     */
    public void createSchema(SimpleFeatureType featureType) throws IOException {
    	String tableName = featureType.getTypeName();

    	String lcTableName = tableName.toLowerCase();

        AttributeDescriptor[] attributeType = (AttributeDescriptor[]) featureType.getAttributeDescriptors().toArray(new AttributeDescriptor[featureType.getAttributeDescriptors().size()]);
        String dbSchema = config.getDatabaseSchemaName();

        PostgisSQLBuilder sqlb = createSQLBuilder();


        //the featureType won't tell us who the primary key is, so we'll create
        //our own "fid_tablename".  Later when we load the featureType, we will
        //pretend we didn't see fid_tablename when we return the attributes.
        String fidColumn = lcTableName + "_fid";

        //make sure the fid column doesn't already exist
        for (int i = 0; i < attributeType.length; i++) {
        	if (attributeType[i].getLocalName().equalsIgnoreCase(fidColumn)) {
                String message = "The featuretype cannot contain the column "
                    + fidColumn + ", since this is used as the hidden FID column";
                throw new IOException(message);
            }
        }

        Connection con = this.getConnection(Transaction.AUTO_COMMIT);
        Statement st = null;

        boolean shouldExecute = !tablePresent(tableName, con);

        try {
            con.setAutoCommit(false);
            st = con.createStatement();

            StringBuffer sql = new StringBuffer("CREATE TABLE ");
			sql.append(sqlb.encodeTableName(tableName));
            sql.append(" (");
            sql.append(sqlb.encodeColumnName(fidColumn));
            sql.append(" serial PRIMARY KEY,");
            sql.append(makeSqlCreate(attributeType));
            sql.append(");");

            String sqlStr = sql.toString();
            LOGGER.info(sqlStr);

            if (shouldExecute) {
                st.execute(sqlStr);
            }

            //fix from pr: it may be that table existed and then was dropped
            //without removing its geometry info from GEOMETRY_COLUMNS.
            //To support this, try to delete before inserting.
            //Preserving case for table names gives problems,
            //so convert to lower case

            sql = new StringBuffer("DELETE FROM GEOMETRY_COLUMNS WHERE f_table_catalog=''");
            sql.append(" AND f_table_schema = '");
            sql.append(dbSchema);
            sql.append("'");
            sql.append("AND f_table_name = '");
            sql.append(tableName);
            sql.append("';");

            //prints statement for later reuse
            sqlStr = sql.toString();
            LOGGER.info(sqlStr);

            if (shouldExecute) {
                st.execute(sqlStr);
            }

            //Ok, so Paolo Rizzi suggested that we get rid of our hand-adding
            //of geometry column information and use AddGeometryColumn instead
            //as it is better (this is in GEOT-379, he attached an extended
            //datastore that does postgis fixes).  But I am pretty positive
            //the reason we are doing things this way is to preserve the order
            //of FeatureTypes.  I know this is fairly silly, from most
            //information perspectives, but from another perspective it seems
            //to make sense - if you were transfering a featureType from one
            //data store to another then it should have the same order, right?
            //And order is important in WFS.  There are a few caveats though
            //for one I don't even know if things work right.  I imagine the
            //proper constraints that a AddGeometryColumn operation does are
            //not set in our hand version, for one.  I would feel better about
            //ignoring the order and just doing things as we like if we had
            //views in place, if users could add the schema, and then be able
            //to get it back in exactly the order they wanted.  So for now
            //let's leave things as is, and maybe talk about it in an irc. -ch
            for (int i = 0; i < attributeType.length; i++) {
                if (!(attributeType[i] instanceof GeometryDescriptor)) {
                    continue;
                }
                GeometryDescriptor geomAttribute = (GeometryDescriptor) attributeType[i];
                String columnName = attributeType[i].getLocalName();

                CoordinateReferenceSystem refSys = geomAttribute.getCoordinateReferenceSystem();
                int SRID;

                if (refSys != null) {
                	try {
                        Set ident = refSys.getIdentifiers();
                        if ((ident == null || ident.isEmpty()) && refSys == DefaultGeographicCRS.WGS84) {
                            SRID = 4326;
                        } else {
                            String code = ((NamedIdentifier) ident.toArray()[0]).getCode();
                            SRID = Integer.parseInt(code);
                        }
                    } catch (Exception e) {
                        LOGGER.warning("SRID could not be determined");
                        SRID = -1;
                    }
                } else {
                    SRID = -1;
                }

//                DatabaseMetaData metaData = con.getMetaData();
//                ResultSet rs = metaData.getCatalogs();
//                rs.next();
//
//                //String dbName = rs.getString(1);
//                rs.close();

                String typeName = null;

                //this construct seems unnecessary, since we already would
                //pass over if this wasn't a geometry...
                Class type = geomAttribute.getType().getBinding();


                int dimension = 2;
                typeName = getGeometrySQLTypeName(type);

                GeometryDescriptor gd = (GeometryDescriptor) geomAttribute;
                if(gd.getUserData().get(Hints.COORDINATE_DIMENSION) instanceof Integer) {
                    dimension = (Integer) gd.getUserData().get(Hints.COORDINATE_DIMENSION);
                }

                if (typeName != null) {
//                    statementSQL = new StringBuffer(
//                        "SELECT AddGeometryColumn('" + dbSchema + "','"
//                        + tableName + "','" + attributeType[i].getName()
//                        + "','" + SRID + "','" + typeName + "',2);"
//                    ); //assumes 2-D

                	//add a row to the geometry_columns table
                    sql = new StringBuffer("INSERT INTO GEOMETRY_COLUMNS VALUES (");
                    sql.append("'','");
                    sql.append(dbSchema);
                    sql.append("','");
                    sql.append(tableName);
                    sql.append("','");
                    sql.append(columnName);
                    sql.append("',");
                    sql.append(dimension);
                    sql.append(",");
                    sql.append(SRID);
                    sql.append(",'");
                    sql.append(typeName);
                    sql.append("');");

                    sqlStr = sql.toString();
                    LOGGER.info(sqlStr);

                    if (shouldExecute) {
                        st.execute(sqlStr);
                    }

                    //add geometry constaints to the table
                    if (SRID > -1) {
                        sql = new StringBuffer("ALTER TABLE ");
                        sql.append(sqlb.encodeTableName(tableName));
                        sql.append(" ADD CONSTRAINT enforce_srid_");
                        sql.append( columnName );
                        sql.append(" CHECK (SRID(");
                        sql.append(sqlb.encodeColumnName(columnName));
                        sql.append(") = ");
                        sql.append(SRID);
                        sql.append(");");
                        sqlStr = sql.toString();
	                    LOGGER.info(sqlStr);
	                    if (shouldExecute) {
	                        st.execute(sqlStr);
	                    }
                    }

                    sql = new StringBuffer("ALTER TABLE ");
                    sql.append(sqlb.encodeTableName(tableName));
                    sql.append(" ADD CONSTRAINT enforce_dims_");
                    sql.append(columnName);
                    sql.append(" CHECK (ndims(");
                    sql.append(sqlb.encodeColumnName(columnName));
                    sql.append(") = ");
                    sql.append(dimension);
                    sql.append(");");
                    sqlStr = sql.toString();
                    LOGGER.info(sqlStr);
                    if (shouldExecute) {
                        st.execute(sqlStr);
                    }

                    if (!typeName.equals("GEOMETRY")) {
                        sql = new StringBuffer("ALTER TABLE ");
                        sql.append(sqlb.encodeTableName(tableName));
                        sql.append(" ADD CONSTRAINT enforce_geotype_");
                        sql.append(columnName);
                        sql.append(" CHECK (geometrytype(");
                        sql.append(sqlb.encodeColumnName(columnName));
                        sql.append(") = '");
                        sql.append(typeName);
                        sql.append("'::text OR ");
                        sql.append(sqlb.encodeColumnName(columnName));
                        sql.append(" IS NULL);");
	                    sqlStr = sql.toString();
                        LOGGER.info(sqlStr);
	                    if (shouldExecute) {
	                        st.execute(sqlStr);
	                    }
                    }

                } else {
                	LOGGER.warning("Error: " + geomAttribute.getLocalName()+ " unknown type!!!");
                }



                //also build a spatial index on each geometry column.
                sql = new StringBuffer("CREATE INDEX spatial_");
                sql.append(tableName);
                sql.append("_");
                sql.append(attributeType[i].getLocalName().toLowerCase());
                sql.append(" ON ");
                sql.append(sqlb.encodeTableName(tableName));
                sql.append(" USING GIST (");
                sql.append(sqlb.encodeColumnName(attributeType[i].getLocalName()));
                sql.append(");");

                sqlStr = sql.toString();
                LOGGER.info(sqlStr);

                if (shouldExecute) {
                    st.execute(sqlStr);
                }
            }

            con.commit();

        } catch (SQLException e) {
            try {
                if (con != null) {
                    con.rollback();
                }
            } catch (SQLException sqle) {
                throw new IOException(sqle.getMessage());
            }

            throw (IOException) new IOException(e.getMessage()).initCause( e );
        } finally {
            try {
                if (st != null) {
                    st.close();
                }
            } catch (SQLException e) {
                throw new IOException(e.getMessage());
            } finally {
                try {
                    if (con != null) {
                        con.setAutoCommit(true);
                        con.close();
                    }
                } catch (SQLException e) {
                    throw new IOException(e.getMessage());
                }
            }
        }

        if (!shouldExecute) {
            throw new IOException("The table " + tableName + " already exists.");
        }
    }

