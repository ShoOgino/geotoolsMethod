	/**
	 * Executes the SQL Query.
	 *
	 * <p>
	 * This is private in the expectation that subclasses should not need to
	 * change this behaviour.
	 * </p>
	 *
	 * <p>
	 * Jody with a question here - I have stopped this method from closing
	 * connection shared by a Transaction. It sill seems like we are leaving
	 * connections open by using this method. I have also stopped QueryData from
	 * doing the same thing.
	 * </p>
	 *
	 * <p>
	 * Answer from Sean: Resources for successful queries are closed when close
	 * is called on the AttributeReaders constructed with the QueryData. We
	 * can't close them here since they need to be open to read from the
	 * ResultSet.
	 * </p>
	 *
	 * <p>
	 * Jody AttributeReader question: I looked at the code and Attribute Readers
	 * do not close with respect to Transactions (they need to as we can issue a
	 * Reader against a Transaction. I have changed the JDBCDataStore.close
	 * method to force us to keep track of these things.
	 * </p>
	 *
	 * <p>
	 * SG: I've marked this as final since I don't think it shoudl be overriden,
	 * but Im not sure
	 * </p>
	 *
	 * @param featureTypeInfo
	 * @param tableName
	 * @param sqlQuery
	 *            The SQL query to execute.
	 * @param transaction
	 *            The Transaction is included here for handling transaction
	 *            connections at a later stage. It is not currently used.
	 * @param forWrite
	 * @param hints the {@link Query} hints
	 *
	 * @return The QueryData object that contains the resources for the query.
	 * 
	 *
	 * @throws IOException
	 * @throws DataSourceException
	 *             If an error occurs performing the query.
	 *
	 * @task HACK: This is just protected for postgis FeatureWriter purposes.
	 *       Should move back to private when that stuff moves more abstract
	 *       here.
	 */
	protected QueryData executeQuery(FeatureTypeInfo featureTypeInfo,
			String tableName, String sqlQuery, Transaction transaction,
			boolean forWrite, Hints hints) throws IOException {
		LOGGER.fine("About to execute query: " + sqlQuery);

		Connection conn = null;
		Statement statement = null;
		ResultSet rs = null;

		try {
			conn = getConnection(transaction);

			setAutoCommit(forWrite, conn);
			statement = conn.createStatement(getResultSetType(forWrite),
					getConcurrency(forWrite));
			statement.setFetchSize(1000);
			rs = statement.executeQuery(sqlQuery);

			return new QueryData(featureTypeInfo, this, conn, statement, rs,
					transaction, hints);
		} catch (SQLException e) {
			// if an error occurred we close the resources
			String msg = "Error Performing SQL query: " + sqlQuery;
			LOGGER.log(Level.SEVERE, msg, e);
			JDBCUtils.close(rs);
			JDBCUtils.close(statement);
			JDBCUtils.close(conn, transaction, e);
			throw new DataSourceException(msg, e);
		}
	}

