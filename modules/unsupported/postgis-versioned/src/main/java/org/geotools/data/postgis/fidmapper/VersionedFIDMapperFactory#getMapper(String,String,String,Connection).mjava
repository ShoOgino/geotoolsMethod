    /**
     * Gets the appropriate FIDMapper for the specified table.
     * 
     * @param catalog
     * @param schema
     * @param tableName
     * @param connection
     *            the active database connection to get table key information
     * 
     * @return the appropriate FIDMapper for the specified table.
     * 
     * @throws IOException
     *             if any error occurs.
     */
    public FIDMapper getMapper(String catalog, String schema, String tableName,
            Connection connection) throws IOException {
        // handle changesets as a special one
        if(VersionedPostgisDataStore.TBL_CHANGESETS.equals(tableName)) {
            PostGISAutoIncrementFIDMapper mapper = new PostGISAutoIncrementFIDMapper(VersionedPostgisDataStore.TBL_CHANGESETS, "revision", Types.NUMERIC, true);
            return new TypedFIDMapper(mapper, VersionedPostgisDataStore.TBL_CHANGESETS);
        }
        
        // for non versioned types we're good with the standard mappers, but we
        // must remember that versioned data store uses typed fids externally
        // (only internal ones are non typed)
        if (!versionedTypes.contains(tableName)) {
            if(tableName.endsWith("_vfc_view")) {
                try {
                    String otn = VersionedPostgisDataStore.getVFCTableName(tableName);
                    // let's see if the original feature table is there and versioned
                    VersionedFIDMapper mapper = (VersionedFIDMapper) getMapper(catalog, schema,otn, connection);
                    return new VersionedFeatureCollectionFidMapper(mapper);
//                    return new VersionedFeatureCollectionFidMapper(mapper);
                } catch(Exception e ) {
                    // ok, it wasn't a versioned feature collection view
                }
            }
            
            return unversionedFactory.getMapper(catalog, schema, tableName, connection);
        }

        ColumnInfo[] colInfos = getPkColumnInfo(catalog, schema, tableName, connection);
        if (colInfos.length <= 1)
            throw new IOException("Versioned type (" + tableName
                    + ") with a primary key with less than 2 columns,"
                    + " this cannot be, there's a error");

        // assume revision is the last column
        if (colInfos.length == 2) {
            return buildSingleColumnVersionedFidMapper(schema, tableName, connection, colInfos);
        } else {
            return buildMultiColumnFIDMapper(schema, tableName, connection, colInfos);
        }
    }

