	/**
	 * The top level method for getting a FeatureReader.
	 *
	 * <p>
	 * Chris- I've gone with the Query object aswell. It just seems to make more
	 * sense. This is pretty well split up across methods. The hooks for DB
	 * specific AttributeReaders are createResultSetReader and
	 * createGeometryReader.
	 * </p>
	 *
	 * <p>
	 * JG- I have implemented getFeatureReader( FeatureType, Filter,
	 * Transasction) ontop of this method, it will Retype as required
	 * </p>
	 *
	 * @param query
	 *            The Query to get a  FeatureReader<SimpleFeatureType, SimpleFeature> for.
	 * @param trans
	 *            The transaction this read operation is being performed in.
	 *
	 * @return A  FeatureReader<SimpleFeatureType, SimpleFeature> that contains features defined by the query.
	 *
	 * @throws IOException
	 *             If an error occurs executing the query.
	 * @throws DataSourceException
	 */
	public  FeatureReader<SimpleFeatureType, SimpleFeature> getFeatureReader(Query query, Transaction trans)
			throws IOException {
		String typeName = query.getTypeName();
		SimpleFeatureType featureType = getSchema(typeName);
		FeatureTypeInfo typeInfo = typeHandler.getFeatureTypeInfo(typeName);

		SQLBuilder sqlBuilder = getSqlBuilder(typeName);
		
		Filter preFilter = (Filter) sqlBuilder.getPreQueryFilter(query.getFilter()); //process in DB
		Filter postFilter = (Filter) sqlBuilder.getPostQueryFilter(query.getFilter()); //process after DB
		
		// simplify the filters before using them, often they contain extra
		// Filter.INCLUDE/Filter.EXCLUDE items
		SimplifyingFilterVisitor simplifier = new SimplifyingFilterVisitor();
		preFilter = (Filter) preFilter.accept(simplifier, null);
		postFilter = (Filter) postFilter.accept(simplifier, null);
		
		//JD: This is bad, we should not assume we have the right to change the query object
		Filter originalFilter = (Filter) query.getFilter();
		((DefaultQuery) query).setFilter(preFilter);
		
		String[] requestedNames = propertyNames(query);
		String[] propertyNames;

		// DJB: changed to account for miss-ordered queries
		if (allSameOrder(requestedNames, featureType)) {
			// because we have everything, the filter can run
			propertyNames = requestedNames;
		} else if (requestedNames.length <= featureType.getAttributeCount()) {
			// we will need to reType this :-)
			//
			// check to make sure we have enough for the post filter
			//
			String[] filterNames = DataUtilities.attributeNames(postFilter, featureType);

			//JD: using a list here to maintain order
			List list = new ArrayList();
			list.addAll(Arrays.asList(requestedNames));
			for ( int i = 0; i < filterNames.length; i++ ) {
				if ( !list.contains( filterNames[ i ] ) ) {
					list.add( filterNames[i] );
				}
			}
			
			if (list.size() == requestedNames.length) {
				propertyNames = requestedNames;
			} else {
				propertyNames = (String[]) list.toArray(new String[list.size()]);
			}

			try {
				typeInfo = new FeatureTypeInfo(typeInfo.getFeatureTypeName(),
						DataUtilities.createSubType(typeInfo.getSchema(),
								propertyNames), typeInfo.getFIDMapper());
			} catch (SchemaException e1) {
				throw new DataSourceException("Could not create subtype", e1);
			}
		} else { // too many requested (duplicates?)
			throw new DataSourceException(typeName
					+ " does not contain requested properties:" + query);
		}

		AttributeDescriptor[] attrTypes = null;

		try {
			attrTypes = getAttributeTypes(typeName, propertyNames, query.getHints());
		} catch (SchemaException schemaException) {
			throw new DataSourceException(
					"Some Attribute Names were specified that"
							+ " do not exist in the FeatureType " + typeName
							+ ". " + "Requested names: "
							+ Arrays.asList(propertyNames) + ", "
							+ "FeatureType: " + featureType, schemaException);
		}

		String sqlQuery = constructQuery(query, attrTypes);
		LOGGER.fine(sqlQuery );
		
		//JD: This is bad, we should not assume we have the right to change the query object
		((DefaultQuery) query).setFilter(originalFilter);
		
		QueryData queryData = executeQuery(typeInfo, typeName, sqlQuery, trans,
				false, query.getHints());

		SimpleFeatureType schema;

		try {
			SimpleFeatureTypeBuilder ftb = new SimpleFeatureTypeBuilder();
			ftb.setName(typeName);
			ftb.addAll(attrTypes);
			ftb.setNamespaceURI(getNameSpace());
			schema = ftb.buildFeatureType();
		} catch (FactoryRegistryException e) {
			throw new DataSourceException(
					"Schema Factory Error when creating schema for FeatureReader",
					e);
		}

		FeatureReader<SimpleFeatureType, SimpleFeature> reader;
		reader = createFeatureReader(schema, postFilter, queryData);

		try {
			SimpleFeatureType requestType = DataUtilities.createSubType(schema,
					requestedNames);
			if ( !FeatureTypes.equalsExact(requestType, reader.getFeatureType()) ) {
                reader = new ReTypeFeatureReader(reader, requestType, false);
            }
        } catch (SchemaException schemaException) {
            throw new DataSourceException("Could not handle query",
                    schemaException);
        }

        // chorner: this is redundant, since we've already created the reader with the post filter attached		
        // if (postFilter != null && !postFilter.equals(Filter.INCLUDE)) {
        //     reader = new FilteringFeatureReader<SimpleFeatureType, SimpleFeature>(reader, postFilter);
        // }
		
		return reader;
	}

