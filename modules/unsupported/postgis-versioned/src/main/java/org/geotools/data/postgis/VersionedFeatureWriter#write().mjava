    public void write() throws IOException {
        Statement st = null;
        try {
            /*
             Ok, this is complex. We have to deal with four separate cases:
             1) the old feature is not there, meaning we're inserting a new feature
             2) the old feature is there, the new feature is equal to the old one -> no changes, 
                let's just move on
             3) the old feature is there, and it's the first time we modify that feature
                in this transactions, meaning we need to expire the old feature, and 
                create a new, non expired one
             4) the old feature is there, but we already modified it during this transaction. This
                means we have to update the old feature 
             */ 
            
            boolean dirtyFeature = false;
            if (oldFeature != null) {
                // if there is an old feature, make sure to write a new revision only if the
                // feauture was modified
                boolean dirty = false;
                for (int i = 0; i < liveFeature.getAttributeCount(); i++) {
                    AttributeDescriptor at = liveFeature.getFeatureType().getDescriptor(i);
                    Object newValue = liveFeature.getAttribute(at.getLocalName());
                    Object oldValue = oldFeature.getAttribute(at.getLocalName());
                    newFeature.setAttribute(at.getLocalName(), newValue);
                    if (!DataUtilities.attributesEqual(newValue, oldValue)) {
                        dirty = true;
                    }
                }
                if (!dirty)
                    return;
            }
            
            // check if the feature is dirty. The live feature has the right external id
            String typeName = liveFeature.getFeatureType().getTypeName();
            String fid = liveFeature.getID();
            dirtyFeature = state.isFidDirty(typeName, fid);
            
            SimpleFeature writtenFeature = null;
            if(dirtyFeature) {
                // we're updating again a feature we already touched, so we have to move
                // attributes from the live to the old, and make sure the old is not expired
                // (we may have deleted and then re-inserted that feature, if FID are the user
                // assigned kind we can get into troubles with duplicated primary keys)
                
                // copy attributes from live to new
                for (int i = 0; i < liveFeature.getAttributeCount(); i++) {
                    AttributeDescriptor at = liveFeature.getFeatureType().getDescriptor(i);
                    oldFeature.setAttribute(at.getLocalName(), liveFeature.getAttribute(at.getLocalName()));
                }
                
                // write the old one
                writeOldFeature(false);
                
                writtenFeature = oldFeature;
            } else {
                // expire if needed
                if(oldFeature != null)
                    writeOldFeature(true);
                
                // copy attributes from live to new
                for (int i = 0; i < liveFeature.getAttributeCount(); i++) {
                    AttributeDescriptor at = liveFeature.getFeatureType().getDescriptor(i);
                    newFeature.setAttribute(at.getLocalName(), liveFeature.getAttribute(at.getLocalName()));
                }
    
                //set revision and expired,
                newFeature.setAttribute("expired", NON_EXPIRED);
                newFeature.setAttribute("revision", new Long(state.getRevision()));
                
                // mark the feature creation
                if (oldFeature != null) {
                    newFeature.setAttribute("created", oldFeature.getAttribute("created"));
                } else {
                    newFeature.setAttribute("created", new Long(state.getRevision()));
                }
    
                // set FID to the old one
                // TODO: check this, I'm not sure this is the proper handling
                String id = null;
                if (oldFeature != null) {
                    id = mapper.createVersionedFid(liveFeature.getID(), state.getRevision()); 
                    newFeature.setAttribute("created", oldFeature.getAttribute("created"));
                } else if (!mapper.hasAutoIncrementColumns()) {
                    // preserve the outer id for UUID insertions
                    ((MutableFIDFeature) newFeature).setID(liveFeature.getID());
                    id = mapper.createID(state.getConnection(), newFeature, null);
                    newFeature.setAttribute("created", new Long(state.getRevision()));
                }
                
                // transfer generated id values to the primary key attributes
                if (id != null) {
                    ((MutableFIDFeature) newFeature).setID(id);
    
                    Object[] pkatts = mapper.getPKAttributes(id);
                    for (int i = 0; i < pkatts.length; i++) {
                        newFeature.setAttribute(mapper.getColumnName(i), pkatts[i]);
                    }
                } else {
                    
                }
                
                // write
                appendWriter.write();
                
                // if the id is auto-generated, gather it from the db
                if (oldFeature == null && mapper.hasAutoIncrementColumns()) {
                    st = state.getConnection().createStatement();
                    id = mapper.createID(state.getConnection(), newFeature, st);
                }

                // make sure the newly generated id is set into the live
                // feature, and that it's typed, too
                ((MutableFIDFeature) newFeature).setID(id);
                ((MutableFIDFeature) liveFeature).setID(mapper.getUnversionedFid(id));
                
                // mark the fid as dirty
                state.setFidDirty(liveFeature.getFeatureType().getTypeName(), liveFeature.getID());
                
                writtenFeature = newFeature;
            }

            // update dirty bounds
            state.expandDirtyBounds(getWgs84FeatureEnvelope(writtenFeature));

            // and finally notify the user
            if (oldFeature != null) {
                ReferencedEnvelope bounds = ReferencedEnvelope.reference(oldFeature.getBounds());
                bounds.include(liveFeature.getBounds());
                listenerManager.fireFeaturesChanged(getFeatureType().getTypeName(), state
                        .getTransaction(), bounds, false);
            } else {
                listenerManager.fireFeaturesAdded(getFeatureType().getTypeName(), state
                        .getTransaction(), ReferencedEnvelope.reference(liveFeature.getBounds()), false);
            }
        } catch (IllegalAttributeException e) {
            throw new DataSourceException("Error writing expiration tag on old feature. "
                    + "Should not happen, there's a bug at work.", e);
        } catch (SQLException e) {
            throw new DataSourceException(
                    "Error creating a new statement for primary key generation", e);
        } finally {
            JDBCUtils.close(st);
        }
    }

