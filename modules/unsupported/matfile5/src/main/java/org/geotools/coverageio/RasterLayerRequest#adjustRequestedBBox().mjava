    /**
     * Returns the intersection between the base envelope and the requested
     * envelope.
     * 
     * @param requestedBBox
     *                the requested 2D envelope to be intersected with the base
     *                envelope.
     * @param requestedDim
     *                is the requested region where to load data of the
     *                specified envelope.
     * @param readGridToWorld
     *                the Grid to world transformation to be used in read
     * @return the resulting intersection of envelopes. In case of empty
     *         intersection, this method is allowed to return {@code null}
     * @throws TransformException
     * @throws FactoryException
     */
    private void adjustRequestedBBox() throws TransformException,
            FactoryException {

        final CoordinateReferenceSystem requestedBBoxCRS2D = requestedBBox.getCoordinateReferenceSystem();
        try {
        	////
        	//
            // STEP 1: requested BBox to native CRS
        	//
        	////
            if (!CRS.equalsIgnoreMetadata(requestedBBoxCRS2D,coverageCRS2D))
            {
                final GeneralEnvelope temp = new GeneralEnvelope(CRS.transform(requestedBBox,
                        coverageCRS2D));
            	temp.setCoordinateReferenceSystem(coverageCRS2D);
                requestedBBox = new ReferencedEnvelope(temp);
            }
            else
            	//we do not need to do anything, but we do this in order to aboid problems with the envelope checks
            	requestedBBox=new ReferencedEnvelope(
            			requestedBBox.getMinX(),
            			requestedBBox.getMaxX(),
            			requestedBBox.getMinY(),
            			requestedBBox.getMaxY(),
            			coverageCRS2D);
            

        	////
        	//
            // STEP 2: intersect requested BBox in native CRS with native bbox
        	//
        	////
            // intersect the requested area with the bounds of this
            // layer in native crs
            if (!requestedBBox.intersects((BoundingBox)coverageBBox))
            {
            	requestedBBox =  null;
            	return;
            }
            // XXX Optimize when referenced envelope has intersection method that actually retains the CRS, this is the JTS one
            requestedBBox=new ReferencedEnvelope(((ReferencedEnvelope) requestedBBox).intersection(coverageBBox),coverageCRS2D);
            //compute approximate full resolution
            // compute the approximated full resolution in wgs84
            final GridToEnvelopeMapper geMapper= new GridToEnvelopeMapper(new GridEnvelope2D(requestedRasterArea),requestedBBox);
            requestedResolution=CoverageUtilities.getResolution(geMapper.createAffineTransform());
 
//        	////
//        	//
//            // STEP 3: Go back to destination space with the nevelope
//        	//
//        	////            
//            // transform the intersection envelope from the destination world
//            // space to the requested raster space
//            if (destinationToSourceTransform != null&& !destinationToSourceTransform.isIdentity() )
//            {
//            	final GeneralEnvelope temp =CRS.transform(destinationToSourceTransform.inverse(),requestedBBoxInSourceCRS2D) ;
//            	temp.setCoordinateReferenceSystem(requestedBBoxCRS2D);
//            	requestedBBox = new ReferencedEnvelope(temp);
//            	
//            }
//            else
//            	//we do not need to do anything
//            	requestedBBox=new ReferencedEnvelope(
//            			requestedBBoxInSourceCRS2D.getMinX(),
//            			requestedBBoxInSourceCRS2D.getMaxX(),
//            			requestedBBoxInSourceCRS2D.getMinY(),
//            			requestedBBoxInSourceCRS2D.getMaxY(),
//            			coverageCRS2D);
//            
            
            return;
        } catch (TransformException te) {
            // something bad happened while trying to transform this
            // envelope. let's try with wgs84
            if(LOGGER.isLoggable(Level.FINE))
            	LOGGER.log(Level.FINE,te.getLocalizedMessage(),te);
        }

        // //
        //
        // If this does not work, we go back to reproject in the wgs84
        // requested envelope
        //              
        // //
    	//convert to WGS84
    	final GeographicBoundingBoxImpl geographicRequestedBBox = new GeographicBoundingBoxImpl(requestedBBox);
        ReferencedEnvelope approximateWGS84requestedBBox =GridCoverageUtilities.getReferencedEnvelopeFromGeographicBoundingBox(geographicRequestedBBox);

        // checking the intersection in wgs84 with the geographicbbox for this coverage
        if (!approximateWGS84requestedBBox.intersects((BoundingBox)coverageGeographicBBox))
        {
        	requestedBBox =  null;
        	return;
        }
        //compute approximate full resolution
        // compute the approximated full resolution in wgs84
        final GridToEnvelopeMapper geMapper= new GridToEnvelopeMapper(new GridEnvelope2D(requestedRasterArea),approximateWGS84requestedBBox);
        approximateWGS84RequestedResolution=CoverageUtilities.getResolution(geMapper.createAffineTransform());

        // intersect with the coverage native WGS84 bbox
        // note that for the moment we got to use general envelope since there is no intersection othrewise
        // TODO fix then we'll have intersection in ReferencedEnvelope
        approximateWGS84requestedBBox=new ReferencedEnvelope(approximateWGS84requestedBBox.intersection(coverageGeographicBBox),DefaultGeographicCRS.WGS84);
        final GeneralEnvelope approximateRequestedBBoInNativeCRS = new GeneralEnvelope(
                CRS.transform(approximateWGS84requestedBBox, coverageCRS2D));
    	approximateRequestedBBoInNativeCRS.setCoordinateReferenceSystem(coverageCRS2D);
    	requestedBBox = new ReferencedEnvelope(approximateRequestedBBoInNativeCRS);        


    }

