    /**
     * Since this is not a real process, but a representation of one, this method doesn't actually
     * execute the process. Instead it builds a request to send to the server to execute the
     * process. The response is parsed and returned as a map just like a process would return
     * locally. The inputs are not validated, they are just built and sent to the server in a
     * request. If they result in a bad request, the request system will handle the returned error.
     *
     * @param input the map of inputs to process
     * @param monitor currently this is not used for this process reprensentation but it could be
     *     implemented in some form in the future.
     */
    @SuppressWarnings("unchecked")
    public Map<String, Object> execute(Map<String, Object> input, ProgressListener monitor) {

        // Get the describeprocess object so we can use it to build up a request and
        // get the server url to send the request to.
        WPSFactory wpsfactory = (WPSFactory) this.factory;
        ProcessDescriptionType pdt = wpsfactory.getProcessDescriptionType();
        URL url = wpsfactory.getServerURL();
        WebProcessingService wps;
        try {
            wps = new WebProcessingService(url);
        } catch (ServiceException e) {
            return null;
        } catch (IOException e) {
            return null;
        }

        // create the execute request object
        ExecuteProcessRequest exeRequest = wps.createExecuteProcessRequest();
        exeRequest.setIdentifier(wpsfactory.getIdentifier());

        // loop through each expected input in the describeprocess, and set it
        // based on what we have in the provided input map.
        EList inputs = pdt.getDataInputs().getInput();
        Iterator iterator = inputs.iterator();
        while (iterator.hasNext()) {
            InputDescriptionType idt = (InputDescriptionType) iterator.next();
            String identifier = idt.getIdentifier().getValue();
            Object inputValue = input.get(identifier);
            if (inputValue != null) {
                // if our value is some sort of collection, then created multiple
                // dataTypes for this inputdescriptiontype.
                List<EObject> list = new ArrayList<EObject>();
                if (inputValue instanceof Map) {
                    for (Object inVal : ((Map) inputValue).values()) {
                        DataType createdInput = WPSUtils.createInputDataType(inVal, idt);
                        list.add(createdInput);
                    }
                } else if (inputValue instanceof Collection) {
                    for (Object inVal : (Collection) inputValue) {
                        DataType createdInput = WPSUtils.createInputDataType(inVal, idt);
                        list.add(createdInput);
                    }
                } else {
                    // our value is a single object so create a single datatype for it
                    DataType createdInput = WPSUtils.createInputDataType(inputValue, idt);
                    list.add(createdInput);
                }
                // add the input to the execute request
                exeRequest.addInput(identifier, list);
            }
        }

        // send the request and get the response
        ExecuteProcessResponse response;
        try {
            response = wps.issueRequest(exeRequest);
        } catch (ServiceException e) {
            return null;
        } catch (IOException e) {
            return null;
        }

        // if there is an exception in the response, return null
        // TODO:  properly handle the exception?
        if (response.getExceptionResponse() != null || response.getExecuteResponse() == null) {
            return null;
        }

        // get response object and create a map of outputs from it
        ExecuteResponseType executeResponse = response.getExecuteResponse();

        // create the result map of outputs
        Map<String, Object> results = new TreeMap<String, Object>();
        results = WPSUtils.createResultMap(executeResponse, results);

        return results;
    }

