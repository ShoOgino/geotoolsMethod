    /**
     * This function looks in the cache for missing tiles.
     *
     * @param e
     * @return if there are more than 10 missing tiles than a single envelope is returned that
     *     encompasses all missing tiles; otherwise only the envelopes for the tiles that are
     *     missing are returned.
     */
    public List<Envelope> match(Envelope e) {
        Region search = CacheUtil.convert(e);
        ArrayList<Envelope> missing = new ArrayList<Envelope>();

        if (!this.tracker.getRootNode().getShape().intersects(search)) {
            // this request is outside of the cached area so nothing to be found
            return new ArrayList<Envelope>();
        }
        if (!this.tracker.getRootNode().getShape().contains(search)) {
            // query is partially outside of root mbr;  we limit our search to the inside of the
            // root mbr
            Envelope r = CacheUtil.convert((Region) this.tracker.getRootNode().getShape());
            r = r.intersection(e);
            search = CacheUtil.convert(r);
        }

        List<NodeIdentifier>[] tiles = tracker.findMissingTiles(search);
        List<NodeIdentifier> missing_tiles = tiles[0];

        if (missing_tiles.size() > max_tiles) {
            Envelope env = new Envelope(e);
            for (Iterator<NodeIdentifier> it = missing_tiles.iterator(); it.hasNext(); ) {
                NodeIdentifier id = it.next();
                Envelope nextenv = CacheUtil.convert((Region) (id.getShape()));
                env.expandToInclude(nextenv);
            }
            missing.add(env);
        } else {
            for (Iterator<NodeIdentifier> it = missing_tiles.iterator(); it.hasNext(); ) {
                NodeIdentifier id = it.next();
                Region next = (Region) (id.getShape());
                missing.add(CacheUtil.convert(next));
            }
        }

        return missing;
    }

