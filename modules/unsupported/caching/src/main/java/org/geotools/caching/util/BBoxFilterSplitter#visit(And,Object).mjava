    public Object visit(And f, Object arg1) {
        int envSize = envelopes.size();
        int othSize = otherRestrictions.size();

        for (Iterator<Filter> it = f.getChildren().iterator(); it.hasNext(); ) {
            Filter child = (Filter) it.next();
            child.accept(this, arg1);
        }

        if (envelopes.size() >= (envSize + 2)) {
            Envelope e = (Envelope) envelopes.pop();
            for (int i = envelopes.size(); i > envSize; i--) {
                Envelope curr = (Envelope) envelopes.pop();
                if (curr.equals(EMPTY_ENVELOPE) || e.equals(EMPTY_ENVELOPE)) {
                    e = new Envelope(EMPTY_ENVELOPE);
                } else if (curr.equals(UNIVERSE_ENVELOPE)) {
                    // do nothing leave e alone
                    // universe & envelope = enevelope
                } else if (e.equals(UNIVERSE_ENVELOPE)) {
                    e = curr;
                } else {
                    // must expand to include instead of intersects
                    // because two bounding boxes may be disjoint
                    // but a geometry may still intersect both of the
                    // bounding boxes
                    e.expandToInclude(curr);
                }
            }
            envelopes.push(e);
        }

        // in all case, we'll need original filter as computed SpatialRestriction is a rough
        // approximation
        multiplePop(otherRestrictions, othSize);
        Envelope top = envelopes.peek();
        if (!(top.equals(EMPTY_ENVELOPE))) {
            otherRestrictions.push(f);
        }

        return null;
    }

