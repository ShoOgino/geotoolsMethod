    /**
     * Converts and envelope into a list of nodes that
     * the envelope covers.  This returns array that contains
     * two lists; the first is all the nodes that intersect the envelope
     * and are missing from the cache; the second contains all the nodes that intersect
     * the envelope and are present in the cache.
     *
     * @param e envelope to search
     * 
     * @return list of two arrays {missing nodes, present nodes}
     */
    public List<NodeIdentifier>[] matchNodeIds(Envelope e) {
        Region search = CacheUtil.convert(e);

        if (!this.tracker.getRootNode().getShape().intersects(search)){
            //this request is outside of the cached area so nothing to be found or missing
            return new List[]{Collections.emptyList(), Collections.emptyList()};
        }
        if (!this.tracker.getRootNode().getShape().contains(search)) { 
            // query is partially outside of root mbr;  we limit our search to the inside of the root mbr
            Envelope r = CacheUtil.convert((Region) this.tracker.getRootNode().getShape());
            r = r.intersection(e);
            search = CacheUtil.convert(r);
        }

        List<NodeIdentifier>[] tiles = tracker.findMissingTiles(search);
        List<NodeIdentifier> missing_tiles = tiles[0];
        List<NodeIdentifier> found_tiles = tiles[1];
        return new List[]{missing_tiles, found_tiles};
    }

