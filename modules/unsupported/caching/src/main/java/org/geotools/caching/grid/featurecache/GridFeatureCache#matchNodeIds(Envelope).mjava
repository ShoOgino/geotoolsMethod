    /**
     * Converts and envelope into a list of nodes that the envelope covers. This returns array that
     * contains two lists; the first is all the nodes that intersect the envelope and are missing
     * from the cache; the second contains all the nodes that intersect the envelope and are present
     * in the cache.
     *
     * @param e envelope to search
     * @return list of two arrays {missing nodes, present nodes}
     */
    public List<NodeIdentifier>[] matchNodeIds(Envelope e) {
        Region search = CacheUtil.convert(e);

        if (!this.tracker.getRootNode().getShape().intersects(search)) {
            // this request is outside of the cached area so nothing to be found or missing
            return new List[] {Collections.emptyList(), Collections.emptyList()};
        }
        if (!this.tracker.getRootNode().getShape().contains(search)) {
            // query is partially outside of root mbr;  we limit our search to the inside of the
            // root mbr
            Envelope r = CacheUtil.convert((Region) this.tracker.getRootNode().getShape());
            r = r.intersection(e);
            search = CacheUtil.convert(r);
        }

        List<NodeIdentifier>[] tiles = tracker.findMissingTiles(search);
        List<NodeIdentifier> missing_tiles = tiles[0];
        List<NodeIdentifier> found_tiles = tiles[1];
        return new List[] {missing_tiles, found_tiles};
    }

