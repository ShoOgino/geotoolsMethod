    /**
     * Get all features within a given envelope as a in memory feature collection.
     */
    public SimpleFeatureCollection get(Envelope e) throws IOException {
    	SimpleFeatureCollection fromCache;
        SimpleFeatureCollection fromSource;
        List<Envelope> notcached = null;
        
        String geometryname = getSchema().getGeometryDescriptor().getLocalName();
        String srs = getSchema().getGeometryDescriptor().getCoordinateReferenceSystem().toString();

        //      acquire R-lock
        lock.readLock().lock();
        try {
            notcached = match(e);
            if (notcached.isEmpty()) { // everything in cache
                // return result from cache
                fromCache = peek(e);
                return fromCache;
            }
        } finally {
            lock.readLock().unlock();
        }

        // got a miss from cache, need to get more data
        lock.writeLock().lock();
        try {
            notcached = match(e); // check again because another thread may have inserted data in between
            if (notcached.isEmpty()) {
                fromCache = peek(e);
                return fromCache;
            }
            
            //get items from cache
            fromCache = peek(e);
             
            // get what data we are missing from the cache based on the not cached array.
            Filter filter = null;
            if (notcached.size() == 1){
                Envelope env = notcached.get(0);
                filter = ff.bbox(geometryname, env.getMinX(), env.getMinY(), env.getMaxX(), env.getMaxY(), srs);
            }else{
                //or the envelopes together into a single or filter
                ArrayList<Filter> filters = new ArrayList<Filter>(notcached.size());
                for (Iterator<Envelope> it = notcached.iterator(); it.hasNext();) {
                    Envelope next = (Envelope) it.next();
                    Filter bbox = ff.bbox(geometryname, next.getMinX(), next.getMinY(), next.getMaxX(), next.getMaxY(), srs);
                    filters.add(bbox);
                }
                filter = ff.or(filters);
            }
            
            //get the data from the source
            try{
                //cache these features in a local feature collection while we deal with them
                SimpleFeatureCollection localSource = new MemoryFeatureCollection(getSchema());
                fromSource = this.fs.getFeatures(filter);
                localSource.addAll(fromSource);
                fromSource = localSource;
            }catch (Exception ex){
                //something happened getting data from source
                //return what we have from the cache
                logger.log(Level.INFO, "Error getting data for cache from source feature store.", ex);
                return fromCache;
            }
            
            //update stats
            source_hits++;
            source_feature_reads += fromSource.size();

            fromCache.addAll(fromSource);
            
            //add it to the cache; 
            try {
                isOversized(fromSource);
                try{
                    register(filter); // get notice we discovered some new part of the universe
                    // add new data to cache - will raise an exception if cache is over sized
                    //here we are adding the everything (include the stuff that's already in the cache
                    //which is done to prevent multiple wfs calls 
                    put(fromCache);  
                    
                }catch (Exception ex){
                    //something happened here so we better unregister this area
                    //so if we try again next time we'll try getting data again
                    unregister(filter);
                }
            } catch (CacheOversizedException e1) {
                logger.log(Level.INFO, "Adding data to cache : " + e1.toString());
            }

        } finally {
            lock.writeLock().unlock();
        }
        
        return fromCache;
    }

