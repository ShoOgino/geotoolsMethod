    /**
     * Get all features with satisfy a given filter.
     *
     * <p>This version gets all features from the cache and from memory and combines them in a
     * memory feature collection.
     *
     * <p>This should probably be overwritten for any implementations.
     */
    public SimpleFeatureCollection getFeatures(Filter filter) throws IOException {

        /* PostPreProcessFilterSplittingVisitor may return
        a mixture of logical filters (or, and, not) and bbox filters,
        and for now I do not know how to handle this */

        // PostPreProcessFilterSplittingVisitor splitter = new
        // PostPreProcessFilterSplittingVisitor(caps, this.fs.getSchema(), null) ;
        /* so we use this splitter which will return a single BBOX */
        BBoxFilterSplitter splitter = new BBoxFilterSplitter();
        filter.accept(splitter, null);

        Filter spatial_restrictions = splitter.getFilterPre();
        Filter other_restrictions = splitter.getFilterPost();

        if (spatial_restrictions == Filter.EXCLUDE) {
            // nothing to get
            return new EmptyFeatureCollection(this.getSchema());
        } else if (spatial_restrictions == Filter.INCLUDE) {
            // we could not isolate any spatial restriction
            // delegate to source
            return this.fs.getFeatures(filter);
        } else {
            SimpleFeatureCollection fc;

            try {
                // first pre-process query from cache
                fc = _getFeatures(spatial_restrictions);
            } catch (UnsupportedOperationException e) {
                logger.log(Level.WARNING, "Querying cache : " + e.toString());
                return this.fs.getFeatures(filter);
            }

            // refine result set before returning
            return fc.subCollection(other_restrictions);
        }
    }

