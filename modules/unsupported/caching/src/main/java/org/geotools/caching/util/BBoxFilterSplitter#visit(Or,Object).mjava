    public Object visit(Or f, Object arg1) {
        int envSize = envelopes.size();
        int othSize = otherRestrictions.size();

        for (Iterator<Filter> it = f.getChildren().iterator(); it.hasNext();) {
            Filter child = (Filter) it.next();
            child.accept(this, arg1);
        }

        if (envelopes.size() > (envSize + 1)) {
            Envelope e = (Envelope) envelopes.pop();

            for (int i = envelopes.size(); i > envSize; i--) {
                e.expandToInclude((Envelope) envelopes.pop());
            }

            envelopes.push(e);
        } else if (envelopes.size() == (envSize + 1)) {
            // the trick is we cannot separate this filter in the form of SpatialRestriction && OtherRestriction
            // so we add this part to OtherRestriction
            envelopes.pop();
            envelopes.push(new Envelope(UNIVERSE_ENVELOPE));
        }

        // in all case, we'll need original filter as computed SpatialRestriction is a rough approximation
        int size = otherRestrictions.size();
        multiplePop(otherRestrictions, othSize);
        if (size > othSize){
            otherRestrictions.push(f);
        }

        return null;
    }

