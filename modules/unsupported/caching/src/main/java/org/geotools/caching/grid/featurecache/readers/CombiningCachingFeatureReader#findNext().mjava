    /**
     * Finds the next feature to return in the given collection.
     *
     * <p>This function is responsible for caching the features as it processes them. All features
     * are cached however only features which pass the postFilter are returned.
     *
     * <p>The function iterators through all the features in the first feature reader; then moves on
     * to the features in the second feature reader.
     *
     * @return the next feature in the collection
     */
    private SimpleFeature findNext() throws IOException {
        while (r1.hasNext()) {
            SimpleFeature sf = (SimpleFeature) r1.next();
            if (cache1) {
                this.index.insertData(sf, CacheUtil.convert((Envelope) sf.getBounds()));
            }
            if (postFilter.evaluate(sf) && !collectedFeatureIds.contains(sf.getID())) {
                return sf;
            }
        }
        while (r2.hasNext()) {
            SimpleFeature sf = (SimpleFeature) r2.next();
            if (cache2) {
                this.index.insertData(sf, CacheUtil.convert((Envelope) sf.getBounds()));
            }
            if (postFilter.evaluate(sf) && !collectedFeatureIds.contains(sf.getID())) {
                return sf;
            }
        }
        return null;
    }

