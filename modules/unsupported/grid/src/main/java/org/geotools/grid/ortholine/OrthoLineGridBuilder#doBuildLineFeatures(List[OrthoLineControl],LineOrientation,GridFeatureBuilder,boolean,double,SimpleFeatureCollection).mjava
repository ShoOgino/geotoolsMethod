    private void doBuildLineFeatures(List<OrthoLineControl> controls, 
            LineOrientation orientation,
            GridFeatureBuilder lineFeatureBuilder, 
            boolean densify,
            double vertexSpacing,
            SimpleFeatureCollection fc) {

        final int NLINES = controls.size();
        if (NLINES > 0) {
            double minOrdinate, maxOrdinate;
            
            if (orientation == LineOrientation.HORIZONTAL) {
                minOrdinate = bounds.getMinY();
                maxOrdinate = bounds.getMaxY();
            } else {
                minOrdinate = bounds.getMinX();
                maxOrdinate = bounds.getMaxX();
            }
            
            double[] pos = new double[NLINES];
            boolean[] active = new boolean[NLINES];
            boolean[] atCurPos = new boolean[NLINES];
            boolean[] generate = new boolean[NLINES];

            Map<String, Object> attributes = new HashMap<String, Object>();
            String geomPropName = lineFeatureBuilder.getType().getGeometryDescriptor().getLocalName();
            
            for (int i = 0; i < NLINES; i++) {
                pos[i] = minOrdinate;
                active[i] = true;
            }
            
            int numActive = NLINES;
            while (numActive > 0) {
                /*
                 * Update scan position (curPos)
                 */
                double curPos = maxOrdinate;
                for (int i = 0; i < NLINES; i++) {
                    if (active[i] && pos[i] < curPos - TOL) {
                        curPos = pos[i];
                    }
                }

                /*
                 * Check which line elements are at the current scan position
                 */
                for (int i = 0; i < NLINES; i++) {
                    atCurPos[i] = active[i] && Math.abs(pos[i] - curPos) < TOL;
                }
                
                /*
                 * Get line with highest precedence for the current position
                 */
                System.arraycopy(atCurPos, 0, generate, 0, NLINES);
                for (int i = 0; i < NLINES - 1; i++) {
                    if (generate[i] && atCurPos[i]) {
                        for (int j = i + 1; j < NLINES; j++) {
                            if (generate[j] && atCurPos[j]) {
                                if (controls.get(i).getLevel() >= controls.get(j).getLevel()) {
                                    generate[j] = false;
                                } else {
                                    generate[i] = false;
                                    break;
                                }
                            }
                        }
                    } else {
                        generate[i] = false;
                    }
                }

                /*
                 * Create the line feature with highest precedence
                 */
                for (int i = 0; i < NLINES; i++) {
                    if (generate[i]) {
                        OrthoLine element = new OrthoLineImpl(
                                bounds, orientation, pos[i],
                                controls.get(i).getLevel(), new Double(pos[i]));

                        if (lineFeatureBuilder.getCreateFeature(element)) {
                            lineFeatureBuilder.setAttributes(element, attributes);

                        if (densify) {
                            featureBuilder.set(geomPropName, element.toDenseGeometry(vertexSpacing));
                        } else {
                            featureBuilder.set(geomPropName, element.toGeometry());
                        }

                        for (String propName : attributes.keySet()) {
                            featureBuilder.set(propName, attributes.get(propName));
                        }

                        fc.add(featureBuilder.buildFeature(lineFeatureBuilder.getFeatureID(element)));
                        }
                    }
                }

                /*
                 * Update line element positions 
                 */
                for (int i = 0; i < NLINES; i++) {
                    if (atCurPos[i]) {
                        pos[i] += controls.get(i).getSpacing();
                        if (pos[i] > maxOrdinate + TOL) {
                            active[i] = false;
                            numActive-- ;
                        }
                    }
                }
            }
        }
    }

