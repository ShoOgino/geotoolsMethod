    /**
     * Creates a new OGR layer with provided data and options. This call is specifically made
     * available for the OGC store since for some data source types, such as GML or KML, it is not
     * possible to call createSchema() independently from a write, as the result will not contain
     * the schema definition without having data too. Also, in those formats, the output is writable
     * only so as long as it's empty, it's not possible to write against an existing GML file for
     * example.
     *
     * @param data The data to fill into the newly created layer
     * @param approximateFields if true, OGR will try to create fields that are approximations of
     *     the required ones when an exact match cannt be provided
     * @param options OGR data source/layer creation options
     */
    public void createSchema(
            SimpleFeatureCollection data, boolean approximateFields, String[] options)
            throws IOException {
        OGRDataSource dataSource = null;
        Object layer = null;
        SimpleFeatureType schema = data.getSchema();
        try {
            // either open datasource, or try creating one
            dataSource = dataSourcePool.openOrCreateDataSource(options);

            FeatureTypeMapper mapper = new FeatureTypeMapper(ogr);

            // layer = createNewLayer(schema, dataSource, optionsPointer, mapper);
            layer = createNewLayer(schema, dataSource, options, mapper);

            // check the ability to create fields
            Object driver = dataSource.getDriver();
            String driverName = ogr.DriverGetName(driver);
            ogr.DriverRelease(driver);
            if (!driverName.equalsIgnoreCase("georss")
                    && !driverName.equalsIgnoreCase("gpx")
                    && !driverName.equalsIgnoreCase("sosi")
                    && !driverName.equalsIgnoreCase("geojson")
                    && !ogr.LayerCanCreateField(layer)) {
                throw new DataSourceException(
                        "OGR reports it's not possible to create fields on this layer");
            }

            // create fields
            Map<String, String> nameMap = new HashMap<>();
            for (int i = 0; i < schema.getAttributeCount(); i++) {
                AttributeDescriptor ad = schema.getDescriptor(i);
                if (ad == schema.getGeometryDescriptor()) {
                    continue;
                }

                Object fieldDefinition = mapper.getOGRFieldDefinition(ad);
                ogr.LayerCreateField(layer, fieldDefinition, approximateFields ? 1 : 0);
                // the data source might have changed the name of the field, map them
                String newName = ogr.FieldGetName(fieldDefinition);
                nameMap.put(newName, ad.getLocalName());
            }

            // get back the feature definition
            Object layerDefinition = ogr.LayerGetLayerDefn(layer);

            // remap positions, as the store might add extra attributes (and the field api is
            // positional)
            Map<Integer, Integer> indexMap = new HashMap<>();
            int count = ogr.LayerGetFieldCount(layerDefinition);
            for (int i = 0; i < count; i++) {
                Object fd = ogr.LayerGetFieldDefn(layerDefinition, i);
                String newName = ogr.FieldGetName(fd);
                if (newName != null) {
                    String oldName = nameMap.get(newName);
                    // Check case insensitive because sqlite can convert names to lowercase
                    if (oldName == null) {
                        oldName = nameMap.get(newName.toLowerCase());
                    }
                    if (oldName == null) {
                        oldName = nameMap.get(newName.toUpperCase());
                    }
                    for (int j = 0; j < schema.getAttributeCount(); j++) {
                        if (schema.getDescriptor(j).getLocalName().equals(oldName)) {
                            indexMap.put(j, i);
                        }
                    }
                }
            }

            // iterate and write out without going throught the ContentDataStore api, which
            // assumes it's possible to let go of it later
            GeometryMapper geomMapper = new GeometryMapper.WKB(new GeometryFactory(), ogr);
            try (SimpleFeatureIterator features = data.features()) {
                while (features.hasNext()) {
                    SimpleFeature feature = features.next();

                    // create the equivalent ogr feature
                    Object ogrFeature = ogr.LayerNewFeature(layerDefinition);
                    for (int i = 0; i < schema.getAttributeCount(); i++) {
                        Object value = feature.getAttribute(i);
                        if (value instanceof Geometry) {
                            // using setGeoemtryDirectly the feature becomes the owner of the
                            // generated
                            // OGR geometry and we don't have to .delete() it (it's faster, too)
                            Object geometry = geomMapper.parseGTGeometry((Geometry) value);
                            ogr.FeatureSetGeometryDirectly(ogrFeature, geometry);
                        } else {
                            // remap index
                            int ogrIndex = indexMap.get(i);
                            FeatureMapper.setFieldValue(
                                    layerDefinition, ogrFeature, ogrIndex, value, ogr);
                        }
                    }

                    // write it out
                    ogr.CheckError(ogr.LayerCreateFeature(layer, ogrFeature));

                    ogr.FeatureDestroy(ogrFeature);
                }
            }
            ogr.LayerSyncToDisk(layer);
        } finally {
            if (layer != null) {
                ogr.LayerRelease(layer);
            }
            if (dataSource != null) {
                dataSource.close();
            }
        }
    }

