    /**
     * Determine correct WFSStrategy based on capabilities document.
     *
     * @return WFSStrategy to use
     */
    private WFSStrategy determineCorrectStrategy() {

        final Version capsVersion = new Version(capabilities.getVersion());
        Document capabilitiesDoc = capabilities.getRawDocument();

        final String override = config.getWfsStrategy();

        WFSStrategy strategy = null;

        // override
        if (!"auto".equals(override)) {
            if (override.equalsIgnoreCase("geoserver")) {
                strategy = new GeoServerPre200Strategy();
            } else if (override.equalsIgnoreCase("mapserver")) {
                strategy = new MapServerWFSStrategy(capabilitiesDoc);
            } else if (override.equalsIgnoreCase("cubewerx")) {
                strategy = new CubeWerxStrategy();
            } else if (override.equalsIgnoreCase("ionic")) {
                strategy = new IonicStrategy();
            } else if (override.equalsIgnoreCase("arcgis")
                    && !Versions.v2_0_0.equals(capsVersion)) {
                strategy = new ArcGisStrategy_1_X();
            }
            if (override.equalsIgnoreCase("arcgis") && Versions.v2_0_0.equals(capsVersion)) {
                strategy = new ArcGisStrategy_2_0();
            } else {
                LOGGER.warning(
                        "Could not handle wfs strategy override "
                                + override
                                + " proceeding with autodetection");
            }
        }

        // auto detection

        if (strategy == null) {
            // look in comments for indication of CubeWerx server
            NodeList childNodes = capabilitiesDoc.getChildNodes();
            for (int i = 0; i < childNodes.getLength(); i++) {
                Node child = childNodes.item(i);
                if (child.getNodeType() == Node.COMMENT_NODE) {
                    String nodeValue = child.getNodeValue();
                    nodeValue = nodeValue.toLowerCase();
                    if (nodeValue.contains("cubewerx")) {
                        strategy = new CubeWerxStrategy();
                        break;
                    }
                }
            }
        }

        if (strategy == null) {
            // Ionic declares its own namespace so that's our hook
            Element root = capabilitiesDoc.getDocumentElement();
            String ionicNs = root.getAttribute("xmlns:ionic");
            if (ionicNs != null) {
                if (ionicNs.equals("http://www.ionicsoft.com/versions/4")) {
                    strategy = new IonicStrategy();
                } else if (ionicNs.startsWith("http://www.ionicsoft.com/versions")) {
                    LOGGER.warning(
                            "Found a Ionic server but the version may not match the strategy "
                                    + "we have (v.4). Ionic namespace url: "
                                    + ionicNs);
                    strategy = new IonicStrategy();
                }
            }
        }

        if (strategy == null) {
            java.net.URL capabilitiesURL = super.serverURL;
            // guess server implementation from capabilities URI
            String uri = capabilitiesURL.toExternalForm();
            /*
             * TODO: the "file:" test is a workaround for GEOT-4223
             *
             * Gabriel RoldÃ¡n commented on GEOT-4223: sigh, yeah, that's probably that worse heuristic ever, but its inherited from the current wfs
             * 1.0 module. We've briefly discussed a better approach on the list a while back (checking for the list of supported functions to figure
             * out whether its a geoserver. Some key function names may even let you know which geoserver version it is). For the time being, please
             * feel free to apply the patch if its a blocker for you, but don't close this issue. Just add a reminder that the heuristic for geoserver
             * needs to be improved?
             */
            if (!uri.startsWith("file:")
                    && uri.contains("geoserver")
                    && !Versions.v2_0_0.equals(capsVersion)) {
                strategy = new GeoServerPre200Strategy();
            } else if (uri.toLowerCase().contains("/arcgis/services/")
                    && !Versions.v2_0_0.equals(capsVersion)) {
                strategy = new ArcGisStrategy_1_X();
            } else if (uri.toLowerCase().contains("/arcgis/services/")
                    && Versions.v2_0_0.equals(capsVersion)) {
                strategy = new ArcGisStrategy_2_0();
            } else if (uri.contains("mapserver") || uri.contains("map=")) {
                strategy = new MapServerWFSStrategy(capabilitiesDoc);
            }
        }

        if (strategy == null) {
            // use fallback strategy
            if (Versions.v1_0_0.equals(capsVersion)) {
                strategy = new StrictWFS_1_x_Strategy(Versions.v1_0_0);
            } else if (Versions.v1_1_0.equals(capsVersion)) {
                strategy = new StrictWFS_1_x_Strategy(Versions.v1_1_0);
            } else if (Versions.v2_0_0.equals(capsVersion)) {
                strategy = new StrictWFS_2_0_Strategy();
            } else {
                throw new IllegalArgumentException("Unsupported version: " + capsVersion);
            }
        }
        LOGGER.finer("Using WFS Strategy: " + strategy.getClass().getName());
        strategy.setConfig(config);

        return strategy;
    }

