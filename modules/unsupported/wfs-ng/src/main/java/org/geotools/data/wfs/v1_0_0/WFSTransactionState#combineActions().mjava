    /**
     * Combines updates and inserts reducing the number of actions in the
     * commit.
     * <p>
     * This is in response to an issue where the FID is not known until after
     * the commit so if a Feature is inserted then later updated(using a FID
     * filter to identify the feature to update) within a single transactin then
     * the commit will fail because the fid filter will be not apply once the
     * insert action is processed.
     * </p>
     * <p>
     * For Example:
     * <ol>
     * <li>Insert Feature.
     * <p>
     * Transaction assigns it the id: NewFeature.
     * </p>
     * </li>
     * <li>Update Feature.
     * <p>
     * Fid filter is used to update NewFeature.
     * </p>
     * </li>
     * <li>Commit.
     * <p>
     * Update will fail because when the Insert action is processed NewFeature
     * will not refer to any feature.
     * </p>
     * </li>
     * </ol>
     * </p>
     * <p>
     * The algorithm is essentially foreach( insertAction ){ Apply each update
     * and Delete action that applies to the inserted feature move insertAction
     * to end of list }
     * </p>
     * <p>
     * Mind you this only works assuming there aren't any direct dependencies
     * between the actions beyond the ones specified by the API. For example if
     * the value of an update depends directly on an earlier feature object
     * (which is bad practice and should never be done). Then we may have
     * problems with this solution. But I think that this solution is better
     * than doing nothing because at least in the proper use of the API the
     * correct result will be obtained. Whereas before the correct use of the
     * API could obtain incorrect results.
     * </p>
     */
    protected void combineActions() {
        EACH_FEATURE_TYPE: for (Iterator iter = actionMap.values().iterator(); iter.hasNext();) {
            List actions = (List) iter.next();

            removeFilterAllActions(actions);
            InsertAction firstAction = null;
            while (firstAction == null || !actions.contains(firstAction)) {
                firstAction = findFirstInsertAction(actions);
                if (firstAction == null)
                    continue EACH_FEATURE_TYPE;
                processInsertAction(actions, firstAction);
            }
            InsertAction current = findFirstInsertAction(actions);
            while (current != null && firstAction != current) {
                processInsertAction(actions, current);
                current = findFirstInsertAction(actions);
            }
        }
    }

