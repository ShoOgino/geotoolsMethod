    /**
     * Override that uses sql prepaired statements to perform the operation.
     *
     * @see org.geotools.data.jdbc.JDBCFeatureWriter#doInsert(org.geotools.data.jdbc.MutableFIDFeature)
     */
    protected void doInsert(MutableFIDFeature current)
        throws IOException, SQLException {
        LOGGER.fine("inserting into postgis feature " + current);

        PreparedStatement statement = null;
        Connection conn = null;
        try {
            conn = queryData.getConnection();
            String sql = makeInsertSql(current);
            statement = conn.prepareStatement( sql );
            
            int position = 1;
            SimpleFeatureType schema = current.getFeatureType();
            for( int i=0; i<current.getNumberOfAttributes();i++){
            	AttributeDescriptor type = schema.getDescriptor( i );
            	if( type instanceof GeometryDescriptor ){
            		Geometry geometry = (Geometry) current.getAttribute( i );
                    
                    // set the proper SRID, otherwise insertion will fail due to issues
                    // with the spatial index
                    int srid = queryData.getFeatureTypeInfo().getSRID(type.getLocalName());
                    geometry.setSRID(srid);
                    
            		STRUCT struct = converter.toSDO( geometry );
            		statement.setObject( position, struct );
            		position++;
            	}
            }
            LOGGER.fine(sql);
            statement.execute();

            // should the ID be generated during an insert, we need to read it back
            // and set it into the feature
          if (((mapper.getColumnCount() > 0)
          && mapper.hasAutoIncrementColumns())) {
//          if (((mapper.getColumnCount() > 0))) {
                current.setID(mapper.createID(conn, current, statement));
            }
        } catch (SQLException sqle) {
            String msg = "SQL Exception writing geometry column" + sqle.getLocalizedMessage();
            LOGGER.log(Level.SEVERE, msg, sqle);
            queryData.close(sqle);
            throw new DataSourceException(msg, sqle);
        } finally {
            if (statement != null) {
                try {
                    statement.close();
                } catch (SQLException e) {
                    String msg = "Error closing JDBC Statement";
                    LOGGER.log(Level.WARNING, msg, e);
                }
            }
        }
    }

