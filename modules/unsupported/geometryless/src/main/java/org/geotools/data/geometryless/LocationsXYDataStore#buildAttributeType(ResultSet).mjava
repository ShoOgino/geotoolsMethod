    /**
     * Constructs an AttributeType from a row in a ResultSet. The ResultSet
     * contains the information retrieved by a call to getColumns() on the
     * DatabaseMetaData object. This information can be used to construct an
     * Attribute Type.
     * 
     * <p>
     * This simply returns the constructed geometry when the column is the first
     * (X)
     * </p>
     * 
     * <p>
     * Note: Overriding methods must never move the current row pointer in the
     * result set.
     * </p>
     * 
     * @param rs
     *            The ResultSet containing the result of a
     *            DatabaseMetaData.getColumns call.
     * 
     * @return The AttributeType built from the ResultSet.
     * 
     * @throws SQLException
     *             If an error occurs processing the ResultSet.
     * @throws DataSourceException
     *             Provided for overriding classes to wrap exceptions caused by
     *             other operations they may perform to determine additional
     *             types. This will only be thrown by the default implementation
     *             if a type is present that is not present in the
     *             TYPE_MAPPINGS.
     */
    protected AttributeDescriptor buildAttributeType(ResultSet rs) throws IOException {
        final int COLUMN_NAME = 4;
        final int DATA_TYPE = 5;
        final int TYPE_NAME = 6;

        try {
            int dataType = rs.getInt(DATA_TYPE);
            String colName = rs.getString(COLUMN_NAME);
            LOGGER.fine("dataType: " + dataType + " " + rs.getString(TYPE_NAME) + " " + colName);
            Class type = (Class) TYPE_MAPPINGS.get(new Integer(dataType));

            // This should be improved - first should probably check for
            // presence of both the x and y columns, only create the geometry
            // if both are found, instead of just ignoring the y - right now
            // the y could just not exist. And then if either do not exist
            // an exception should be thrown.
            // Also, currently the name of the geometry is hard coded -
            // do we want it to be user configurable? ch
            if (colName.equals(XCoordColumnName)) {
                // do type checking here, during config, not during reading.
                if (Number.class.isAssignableFrom(type)) {
                    return new AttributeTypeBuilder().binding(Point.class).buildDescriptor(geomName);
                } else {
                    String excMesg = "Specified X column of " + colName + " of type: " + type
                            + ", can not be used as x point";
                    throw new DataSourceException(excMesg);
                }

            } else if (colName.equals(YCoordColumnName)) {
                if (Number.class.isAssignableFrom(type)) {
                    return null;
                } else {
                    String excMesg = "Specified X column of " + colName + " of type: " + type
                            + ", can not be used as x point";
                    throw new DataSourceException(excMesg);
                }
            } else {
                return super.buildAttributeType(rs);
            }
        } catch (SQLException e) {
            throw new IOException("SQL exception occurred: " + e.getMessage());
        }
    }

