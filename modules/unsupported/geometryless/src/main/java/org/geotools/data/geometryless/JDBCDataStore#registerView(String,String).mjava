    /**
     * Creates an in-process data view against one or more actual FeatureTypes
     * of this DataStore, which will be advertised as <code>typeName</code>
     * 
     * @param typeName
     *            the name of the view's FeatureType.
     * @param sqlQuery
     *            a full SQL query which will act as the view definition.
     * @throws IOException
     * @throws IllegalArgumentException
     *             if <code>typeName</code> already exists as one of this
     *             datastore's feature types, regardless of type name case.
     */
    public void registerView(final String typeName, final String sqlQuery) throws IOException {
        if (typeName == null || sqlQuery == null) {
            throw new NullPointerException(typeName + "=" + sqlQuery);
        }
        String[] existingTypeNames = getTypeNames();
        for (int i = 0; i < existingTypeNames.length; i++) {
            if (typeName.equalsIgnoreCase(existingTypeNames[i])) {
                throw new IllegalArgumentException(typeName + " already exists: "
                        + existingTypeNames[i]);
            }
        }
        LOGGER.fine("registering view " + typeName + " as " + sqlQuery);
        Connection conn = getConnection(Transaction.AUTO_COMMIT);
        ResultSetMetaData rsmd;
        try {
            Statement st = conn.createStatement();
            st.setMaxRows(1);
            
            ResultSet rs = st.executeQuery(sqlQuery);
            rsmd = rs.getMetaData();

            // TODO: set a more appropiate fid mapper
            FIDMapper fidMapper = new NullFIDMapper();
            SimpleFeatureType viewType = buildSchema(typeName, rsmd);
            BypassSqlFeatureTypeHandler th = (BypassSqlFeatureTypeHandler) typeHandler;
            th.registerView(viewType, sqlQuery, fidMapper);
        } catch (SQLException e) {
            LOGGER.log(Level.WARNING, "executing query " + sqlQuery, e);
            throw new DataSourceException("executing " + sqlQuery, e);
        } finally {
            try {
                conn.close();
            } catch (Exception e) {
                LOGGER.warning(e.getMessage());
            }
        }
    }

