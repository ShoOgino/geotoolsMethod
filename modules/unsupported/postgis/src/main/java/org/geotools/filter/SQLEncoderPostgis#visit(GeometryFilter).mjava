    /**
     * Turns a geometry filter into the postgis sql bbox statement.
     *
     * @param filter the geometry filter to be encoded.
     *
     * @throws RuntimeException for IO exception (need a better error)
     */
    public void visit(GeometryFilter filter) throws RuntimeException {
        LOGGER.finer("exporting GeometryFilter");

        short filterType = filter.getFilterType();
        DefaultExpression left = (DefaultExpression) filter.getLeftGeometry();
        DefaultExpression right = (DefaultExpression) filter.getRightGeometry();

        //if geos is not supported, all we can use is distance = 0 for bbox
        if (!supportsGEOS) {
            if (filterType != AbstractFilter.GEOMETRY_BBOX) {
                throw new RuntimeException(
                        "without GEOS support, only the BBOX function is supported; failed to encode "
                                + filterType);
            }
            encodeGeomFilter(filter, "distance", " < 0.00001", true);
            return;
        }
        
        // Figure out if we need to constrain this query with the && constraint.
        int literalGeometryCount = 0;

        if ((left != null)
                && (left.getType() == DefaultExpression.LITERAL_GEOMETRY)) {
            literalGeometryCount++;
        }

        if ((right != null)
                && (right.getType() == DefaultExpression.LITERAL_GEOMETRY)) {
            literalGeometryCount++;
        }

        boolean constrainBBOX = (literalGeometryCount == 1);
        boolean onlyBbox = filterType == AbstractFilter.GEOMETRY_BBOX
                && looseBbox;

        try {

            // DJB: disjoint is not correctly handled in the pre-march 22/05
            // version
            // I changed it to not do a "&&" index search for disjoint because
            // Geom1 and Geom2 can have a bbox overlap and be disjoint
            // I also added test case.
            // NOTE: this will not use the index, but its unlikely that using
            // the index
            // for a disjoint query will be the correct thing to do.

            // DJB NOTE: need to check for a NOT(A intersects G) filter
            // --> NOT( (A && G) AND intersects(A,G))
            // and check that it does the right thing.

            constrainBBOX = constrainBBOX
                    && (filterType != AbstractFilter.GEOMETRY_DISJOINT);

            if (constrainBBOX) {
                encodeExpression(left);
                out.write(" && ");
                encodeExpression(right);

                if (!onlyBbox) {
                    out.write(" AND ");
                }
            }

            String closingParenthesis = ")";

            if (!onlyBbox) {
                if (filterType == AbstractFilter.GEOMETRY_EQUALS) {
                    out.write("equals");
                } else if (filterType == AbstractFilter.GEOMETRY_DISJOINT) {
                    out.write("NOT (intersects");
                    closingParenthesis += ")";
                } else if (filterType == AbstractFilter.GEOMETRY_INTERSECTS) {
                    out.write("intersects");
                } else if (filterType == AbstractFilter.GEOMETRY_CROSSES) {
                    out.write("crosses");
                } else if (filterType == AbstractFilter.GEOMETRY_WITHIN) {
                    out.write("within");
                } else if (filterType == AbstractFilter.GEOMETRY_CONTAINS) {
                    out.write("contains");
                } else if (filterType == AbstractFilter.GEOMETRY_OVERLAPS) {
                    out.write("overlaps");
                } else if (filterType == AbstractFilter.GEOMETRY_BBOX) {
                    out.write("intersects");
                } else if (filterType == AbstractFilter.GEOMETRY_TOUCHES) {
                    out.write("touches");
                } else {
                    // this will choke on beyond and dwithin
                    throw new RuntimeException("does not support filter type "
                            + filterType);
                }
                out.write("(");

                encodeExpression(left);
                out.write(", ");
                encodeExpression(right);

                out.write(closingParenthesis);
            }
        } catch (java.io.IOException ioe) {
            LOGGER.warning("Unable to export filter" + ioe);
            throw new RuntimeException("io error while writing", ioe);
        }
    }

