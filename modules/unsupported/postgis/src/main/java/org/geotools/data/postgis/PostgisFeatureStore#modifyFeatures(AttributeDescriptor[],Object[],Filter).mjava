    /**
     * Modifies the passed attribute types with the passed objects in all
     * features that correspond to the passed OGS filter.
     *
     * @param type The attributes to modify.
     * @param value The values to put in the attribute types.
     * @param filter An OGC filter to note which attributes to modify.
     *
     * @throws IOException If modificaton is not supported, if the attribute
     *         and object arrays are not eqaul length, or if the object types
     *         do not match the attribute types.
     * @throws DataSourceException DOCUMENT ME!
     *
     * @task REVISIT: validate values with types.  Database does this a bit
     *       now, but should be more fully implemented.
     * @task REVISIT: do some nice prepared statement stuff like oracle.
     */
    public void modifyFeatures(AttributeDescriptor[] type, Object[] value, Filter filter)
        throws IOException {
        // check locks!
        // (won't do anything if we use our own
        // database locking)
        LOGGER.finer("asserting filter " + filter);
        assertFilter(filter);

        //boolean previousAutoCommit = getAutoCommit();
        //setAutoCommit(false);
        boolean fail = false;
        Connection conn = null;
        PreparedStatement statement = null;
        String fid = null;

        //check schema with filter???
//        SQLUnpacker unpacker = new SQLUnpacker(encoder.getCapabilities());
//        unpacker.unPackOR(filter);

        String whereStmt = null;
        Filter encodableFilter = sqlBuilder.getPreQueryFilter(filter);
        Filter unEncodableFilter = sqlBuilder.getPostQueryFilter(filter);

        try {
            conn = getConnection();

            if (encodableFilter == null && unEncodableFilter != null) {
                FidFilter fidFilter = getEncodableFilter(unEncodableFilter);
                encodableFilter = fidFilter;
            }

            if (encodableFilter != null) {
                StringBuffer sb = new StringBuffer();
                sqlBuilder.encode(sb, encodableFilter);
                whereStmt = "WHERE " + sb;
                final String sql = makeModifySqlStatement(type, value, whereStmt);
                statement = conn.prepareStatement(sql);
                LOGGER.finer("encoded modify is " + sql);
                setModifyPreparedStatementValues(statement, type, value);

                LOGGER.finer("encoded modify is " + sql);
                DefaultQuery query=new DefaultQuery(getSchema().getTypeName(), filter);
                ReferencedEnvelope bounds=bounds(query);
                statement.executeUpdate();
                if (bounds!=null && !bounds.isNull()) {
                    ReferencedEnvelope afterBounds = bounds(query);
                    if(afterBounds != null)
                        bounds.expandToInclude(afterBounds);
                } else {
                    bounds=bounds(query);
                }
                if (bounds!=null && !bounds.isNull())
	    			getJDBCDataStore().listenerManager.fireFeaturesChanged(getSchema().getTypeName(),
	    					getTransaction(), bounds, false);
            }

        } catch (SQLException sqle) {
            fail = true;
            close(conn, getTransaction(), sqle);

            String message = CONN_ERROR + sqle.getMessage();
            LOGGER.warning(message);
            throw new DataSourceException(message, sqle);
        } catch (SQLEncoderException ence) {
            fail = true;

            String message = "error encoding sql from filter " + ence.getMessage();
            LOGGER.warning(message);
            throw new DataSourceException(message, ence);
        } catch (IllegalAttributeException iae) {
            throw new DataSourceException("attribute problem", iae);
        } finally {
            close(statement);
            close(conn, getTransaction(), null);
        }
    }

