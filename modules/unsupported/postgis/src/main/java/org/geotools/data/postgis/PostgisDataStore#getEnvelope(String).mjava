    /**
     * Retrieve approx bounds of all Features.
     * <p>
     * This result is suitable for a quick map display, illustrating the data.
     * This value is often stored as metadata in databases such as oraclespatial.
     * </p>
     * @return null as a generic implementation is not provided.
     */
    public Envelope getEnvelope( String typeName ){
    	Connection conn = null;

    	try {
    		conn = createConnection();
            Statement st = null;
            ResultSet rs = null;
            Envelope envelope = null;

        	SimpleFeatureType schema = getSchema(typeName);
        	String geomName = schema.getGeometryDescriptor().getLocalName();

	    	// optimization, postgis version >= 1.0 contains estimated_extent
            // function to query the stats of the table to determine the bbox,
            // however, it may return null
		    if (getDBInfo().getMajorVersion() >= 1) {
		    	//try the estimated_extent([schema], table, geocolumn) function
	    	    String q;
                String dbSchema = config.getDatabaseSchemaName();
                if (!schemaEnabled || dbSchema == null || "".equals(dbSchema)) {
                    q = "SELECT AsText(force_2d(envelope(estimated_extent('"+typeName+"','"+geomName+"'))))";
                } else {
                    q = "SELECT AsText(force_2d(envelope(estimated_extent('"+dbSchema+"','"+typeName+"','"+geomName+"'))))";
                }
                st = conn.createStatement();
                rs = st.executeQuery(q);

		    	if (rs.next()) {
		    		//parse return value
		    		String wkt = rs.getString(1);
		    		if (wkt != null &&  !wkt.trim().equals("")) { //$NON-NLS-1$
		    			envelope = geometryReader.read(wkt).getEnvelopeInternal();

		    			// expand the bounds by 20% (10% in each direction)
		    			// Works whether or not the bounds are at the origin
		    			double minX = envelope.getMinX();
		    			double minY = envelope.getMinY();
		    			double maxX = envelope.getMaxX();
		    			double maxY = envelope.getMaxY();
		    			double deltaX = (maxX - minX)*0.1;
		    			double deltaY = (maxY - minY)*0.1;
		    			envelope.expandToInclude(minX - deltaX, minY - deltaY);
		    			envelope.expandToInclude(maxX + deltaX, maxY + deltaY);
		    		} else {
                        LOGGER.warning("PostGIS estimated_extent function did not return a result." +
                                "\nPerhaps 'ANALYZE "+typeName+";' needs to be run or the table is empty?");
                    }
		    	}

		    	rs.close();
		    	st.close();
		    }

		    if (envelope == null) {

                //try to generate an approximation
                envelope = new Envelope();
                //this is an attempt to grab a handful of envelopes without counting the features
                final int blockSize = 10; //how many features to grab on each postgis hit
                final int fetchAllLimit = 99; //if we don't exceed this value, just fetch all features
                //final int upperLimit = 1000000; //aim for this many features
                //final int nBlocks = 7; //number of times to hit postgis
                //int[] offset = new int[nBlocks];
                //automatic range calculation (for tweaking)
                //once we hit 100,000 features in our scan, things get really slow
                //therefore we'll stop around 50k
                //offset[0] = 1;
                //double magicNumber = Math.pow(upperLimit, 1.0 / (nBlocks - 1));
                //for (int i = 1; i < nBlocks; i++) {
                //    offset[i] = (int) Math.ceil(offset[i-1] * magicNumber);
                //    System.out.println(offset[i]);
                //}
                //offset[0] = 0;
                int[] offset = new int[] {0,10,100,1000,10000,20000,40000};

                int hits = 0;
                int misses = 0;
		    	for (int i = 0; i < offset.length && misses < 4; i++) {
                    String limit = " LIMIT " + blockSize + " OFFSET " + offset[i];;
                    if (i+1 < offset.length && offset[i+1]-offset[i] <= blockSize) {
                        limit = " LIMIT " + blockSize * 2 + " OFFSET " + offset[i];
                        offset[i+1] = offset[i] + blockSize;
                        i++;
                    }
                    String q = "SELECT AsText(force_2d(envelope(" + geomName + "))) FROM " + typeName;
                    if (offset[i] > -1) {
                        q = q + limit;
                    }
                    st = conn.createStatement();
                    rs = st.executeQuery(q);
                    boolean gotEnvelope = false;
                    while (rs.next()) {
                        gotEnvelope = true;
                        String wkt = rs.getString(1);
                        if (wkt != null && !wkt.trim().equals("")) { //$NON-NLS-1$
                            Envelope e = geometryReader.read(wkt)
                                .getEnvelopeInternal();

                            if (envelope.isNull())
                                envelope.init(e);
                            else
                                envelope.expandToInclude(e);
                        }
                    }
                    if (gotEnvelope) {
                        hits++;
                    } else {
                        misses++;
                        if (hits == 0) { //there are no features!
                            rs.close();
                            st.close();
                            return new Envelope();
                        }
                        if (offset[i-1] < fetchAllLimit) { //just fetch everything
                            offset[i] = -1;
                        } else {
                            //went beyond the last feature
                            //on our first miss, we move back 50% and try again
                            //on our second miss, we stop guessing and look between last 2 hits
                            int min = offset[i-1];
                            int max = offset[i];
                            if (misses == 2) {
                                min = offset[i-2];
                                max = offset[i-1];
                            }
                            if (misses < 3) {
                                offset[i] = (int) ((min + max) / 2.0);
                                int width = (int) ((max - min) / (double) (offset.length - i));
                                for (int j = i+1; j < offset.length; j++) {
                                    offset[j] = min + (width * (j-i));
                                }
                            } else {
                                rs.close();
                                st.close();
                                break;
                            }
                        }
                        i--;
                    }
                    rs.close();
                    st.close();
                    if (offset[i] == -1)
                        break;
                }

		    	// expand since this is an approximation
		    	// Works whether or not the bounds are at the origin
		    	double minX = envelope.getMinX();
		    	double minY = envelope.getMinY();
		    	double maxX = envelope.getMaxX();
		    	double maxY = envelope.getMaxY();
		    	double deltaX = (maxX - minX)*1.0;
		    	double deltaY = (maxY - minY)*1.0;
		    	envelope.expandToInclude(minX - deltaX, minY - deltaY);
		    	envelope.expandToInclude(maxX + deltaX, maxY + deltaY);

		    }
		    return envelope;
    	} catch (Exception ignore) {
			return null;
		} finally {
    		if( conn != null ){
				try {
					conn.close();
				} catch (SQLException e) {
					// I give up
				}
    		}
    	}
    }

