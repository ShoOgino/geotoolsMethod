    /**
     * Does a query over a non autocommit transaction return the added/modified features and hides
     * the deleted ones?
     */
    @Test
    public void testTransactionStateRead() throws Exception {
        // connection with a transaction in progress
        final ISession transSession;

        testData.truncateTempTable();

        {
            final ISessionPool connPool = testData.getConnectionPool();
            transSession = connPool.getSession();
            // start a transaction on transConn
            transSession.startTransaction();
        }

        // flag to rollback or not at finally{}
        boolean commited = false;

        try {
            final String[] columns = {"INT32_COL", "STRING_COL"};
            final String tableName = testData.getTempTableName(transSession);

            transSession.issue(
                    new Command<Void>() {
                        @Override
                        public Void execute(ISession session, SeConnection connection)
                                throws SeException, IOException {
                            SeInsert insert = new SeInsert(connection);
                            insert.intoTable(tableName, columns);
                            insert.setWriteMode(true);
                            SeRow row = insert.getRowToSet();
                            row.setInteger(0, Integer.valueOf(50));
                            row.setString(1, "inside transaction");

                            insert.execute();
                            // IMPORTANT to call close for the diff to take effect
                            insert.close();
                            return null;
                        }
                    });

            final SeSqlConstruct sqlConstruct = new SeSqlConstruct(tableName);

            final SeRow transRow =
                    transSession.issue(
                            new Command<SeRow>() {
                                @Override
                                public SeRow execute(ISession session, SeConnection connection)
                                        throws SeException, IOException {
                                    // the query over the transaction connection
                                    SeQuery transQuery =
                                            new SeQuery(connection, columns, sqlConstruct);
                                    // transaction is not committed, so transQuery should give
                                    // the
                                    // inserted
                                    // record and query don't
                                    transQuery.prepareQuery();
                                    transQuery.execute();
                                    SeRow transRow = transQuery.fetch();
                                    // querying over a transaction in progress does give diff
                                    // assertEquals(Integer.valueOf(50), transRow.getInteger(0))
                                    transQuery.close();
                                    return transRow;
                                }
                            });

            assertNotNull(transRow);

            // commit transaction
            transSession.commitTransaction();
            commited = true;

            final SeRow noTransRow =
                    session.issue(
                            new Command<SeRow>() {
                                @Override
                                public SeRow execute(ISession session, SeConnection connection)
                                        throws SeException, IOException {
                                    SeQuery query = new SeQuery(connection, columns, sqlConstruct);
                                    query.prepareQuery();
                                    query.execute();
                                    SeRow row = query.fetch();
                                    query.close();
                                    return row;
                                }
                            });

            assertNotNull(noTransRow);

        } catch (Exception e) {
            java.util.logging.Logger.getGlobal().log(java.util.logging.Level.INFO, "", e);
        } finally {
            if (!commited) {
                transSession.rollbackTransaction();
            }
            transSession.dispose();
            // conn.close(); closed at tearDown
        }
    }

