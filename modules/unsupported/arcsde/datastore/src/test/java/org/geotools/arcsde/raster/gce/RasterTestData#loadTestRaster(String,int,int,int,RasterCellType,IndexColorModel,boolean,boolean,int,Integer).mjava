    /**
     * Creates a a raster in the database with some default settings and the provided parameters.
     *
     * <p>Default settings
     *
     * <ul>
     *   <li>CRS: PePCSDefs.PE_PCS_NAD_1983_HARN_MA_M
     *   <li>Extent: minx=0, miny=0, maxx=512, maxy=512
     *   <li>Width: 256
     *   <li>Height: 256
     *   <li>Tile size: 64x64 (being less than the recommended minimum of 128, but ok for our
     *       testing purposes)
     *   <li>Compression: none
     * </ul>
     *
     * @param tableName the name of the table to create
     * @param numberOfBands the number of bands of the raster
     * @param pixelType the pixel (cell) depth of the raster bands (one of the {@code
     *     SeRaster#SE_PIXEL_TYPE_*} constants)
     * @param colorModel the color model to apply to the raster, may be {@code null}. A non null
     *     value adds as precondition that {@code numberOfBands == 1}
     * @param pyramiding whether to create tiles or not for the raster. If {@code true} and {@code
     *     skipLevelOne == true} a pyramid with three levels will be created, avoiding to create the
     *     pyramid tiles for level 0 (same dimension as the source raster). If {@code skipLevelOne
     *     == false}, even for level 0 the pyramid tiles will be created, that is, four levels.
     * @param skipLevelOne only relevant if {@code pyramiding == true}, {@code true} indicates not
     *     to create pyramid tiles for the first level, since its equal in dimension than the source
     *     raster
     * @param interpolationType only relevant if {@code pyramiding == true}, indicates which
     *     interpolation method to use in building the pyramid tiles. Shall be one of {@link
     *     SeRaster#SE_INTERPOLATION_BICUBIC}, {@link SeRaster#SE_INTERPOLATION_BILINEAR}, {@link
     *     SeRaster#SE_INTERPOLATION_NEAREST}. Otherwise {@link SeRaster#SE_INTERPOLATION_NONE}
     */
    public void loadTestRaster(
            final String tableName,
            final int numberOfBands,
            final int imageWidth,
            final int imageHeight,
            final RasterCellType pixelType,
            final IndexColorModel colorModel,
            final boolean pyramiding,
            final boolean skipLevelOne,
            final int interpolationType,
            final Integer forceNumLevels)
            throws Exception {

        if (colorModel != null && numberOfBands > 1) {
            throw new IllegalArgumentException(
                    "Indexed rasters shall contain a single band. numberOfBands = "
                            + numberOfBands);
        }
        {
            // clean out the table if it's currently in-place
            testData.deleteTable(tableName);
            // build the base business table. We'll add the raster data to it in a bit
            // Note that this DOESN'T LOAD THE COLORMAP RIGHT NOW.
            ISession session = getConnectionPool().getSession();
            try {
                createRasterBusinessTempTable(tableName, session);
            } finally {
                session.dispose();
            }
        }

        final SeExtent extent = new SeExtent(0, 0, 2 * imageWidth, 2 * imageHeight);
        final SeCoordinateReference crs =
                getSeCRSFromPeProjectedCSId(PePCSDefs.PE_PCS_NAD_1983_HARN_MA_M);

        final ISession session = getConnectionPool().getSession();
        try {
            createRasterColumn(tableName, crs, session);

            int maxLevels;
            if (pyramiding) {
                int tileWidth = imageWidth >> 4;
                if (forceNumLevels == null) {
                    maxLevels = (imageWidth / (4 * tileWidth)) - 1;
                } else {
                    maxLevels = forceNumLevels;
                }
            } else {
                maxLevels = 0;
            }
            addRasterAttribute(
                    tableName,
                    numberOfBands,
                    imageWidth,
                    imageHeight,
                    pixelType,
                    colorModel,
                    maxLevels,
                    skipLevelOne,
                    interpolationType,
                    extent,
                    session);

        } finally {
            session.dispose();
        }
    }

