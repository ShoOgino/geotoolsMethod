    /**
     * Ensure modified features for a given FeatureStore are returned by subsequent queries even if
     * the transaction has not been committed.
     */
    @Test
    public void testTransactionStateDiff() throws Exception {
        testData.createTempTable(true);
        // testData.insertTestData();

        final DataStore ds = testData.getDataStore();
        final String typeName = testData.getTempTableName();
        final SimpleFeatureStore transFs;
        transFs = (SimpleFeatureStore) ds.getFeatureSource(typeName);
        final SimpleFeatureType schema = transFs.getSchema();

        // once the transaction is set to the FeatureStore, it lasts until
        // another transaction
        // is set. Calling transaction.close() closes Transaction.State
        // held on it, allowing State objects to release resources. After
        // close() the transaction
        // is no longer valid.
        final Transaction transaction = new DefaultTransaction("test_handle");
        transFs.setTransaction(transaction);

        try {
            // create a feature to add
            SimpleFeatureBuilder builder = new SimpleFeatureBuilder(schema);
            builder.set("INT32_COL", Integer.valueOf(1000));
            builder.set("STRING_COL", "inside transaction");
            SimpleFeature feature = builder.buildFeature(null);

            // add the feature
            transFs.addFeatures(DataUtilities.collection(feature));

            // now confirm for that transaction the feature is fetched, and outside
            // it it's not.
            final Filter filterNewFeature = CQL.toFilter("INT32_COL = 1000");
            final Query newFeatureQuery = new Query(typeName, filterNewFeature);

            SimpleFeatureCollection features;
            features = transFs.getFeatures(filterNewFeature);
            int size = features.size();
            assertEquals(1, size);

            // ok transaction respected, assert the feature does not exist outside
            // it (except is the db is MS SQL Server)
            {
                FeatureReader<SimpleFeatureType, SimpleFeature> autoCommitReader;
                autoCommitReader = ds.getFeatureReader(newFeatureQuery, Transaction.AUTO_COMMIT);
                try {
                    if (databaseIsMsSqlServer) {
                        // SQL Server always is at READ UNCOMMITTED isolation level...
                        assertTrue(autoCommitReader.hasNext());
                    } else {
                        assertFalse(autoCommitReader.hasNext());
                    }
                } finally {
                    autoCommitReader.close();
                }
            }

            // ok, but what if we ask for a feature reader with the same transaction
            {
                FeatureReader<SimpleFeatureType, SimpleFeature> transactionReader;
                transactionReader = ds.getFeatureReader(newFeatureQuery, transaction);
                try {
                    assertTrue(transactionReader.hasNext());
                    transactionReader.next();
                    assertFalse(transactionReader.hasNext());
                } finally {
                    transactionReader.close();
                }
            }

            // now commit, and Transaction.AUTO_COMMIT should carry it over
            // do not close the transaction, we'll keep using it
            try {
                transaction.commit();
            } catch (IOException e) {
                transaction.rollback();
                throw e;
            }

            {
                FeatureReader<SimpleFeatureType, SimpleFeature> autoCommitReader;
                autoCommitReader = ds.getFeatureReader(newFeatureQuery, Transaction.AUTO_COMMIT);
                try {
                    assertTrue(autoCommitReader.hasNext());
                } finally {
                    autoCommitReader.close();
                }
            }

            // now keep using the transaction, it should still work
            transFs.removeFeatures(filterNewFeature);

            // no features removed yet outside the transaction
            {
                FeatureReader<SimpleFeatureType, SimpleFeature> autoCommitReader;
                autoCommitReader = ds.getFeatureReader(newFeatureQuery, Transaction.AUTO_COMMIT);
                try {
                    if (databaseIsMsSqlServer) {
                        // SQL Server always is at READ UNCOMMITTED isolation level...
                        assertFalse(autoCommitReader.hasNext());
                    } else {
                        assertTrue(autoCommitReader.hasNext());
                    }
                } finally {
                    autoCommitReader.close();
                }
            }

            // but yes inside it
            {
                FeatureReader<SimpleFeatureType, SimpleFeature> transactionReader;
                transactionReader = ds.getFeatureReader(newFeatureQuery, transaction);
                try {
                    assertFalse(transactionReader.hasNext());
                } finally {
                    transactionReader.close();
                }
            }

            {
                FeatureReader<SimpleFeatureType, SimpleFeature> autoCommitReader;
                try {
                    transaction.commit();
                    autoCommitReader =
                            ds.getFeatureReader(newFeatureQuery, Transaction.AUTO_COMMIT);
                    assertFalse(autoCommitReader.hasNext());
                } catch (Exception e) {
                    transaction.rollback();
                    throw e;
                }
            }
        } finally {
            transaction.close();
        }
    }

