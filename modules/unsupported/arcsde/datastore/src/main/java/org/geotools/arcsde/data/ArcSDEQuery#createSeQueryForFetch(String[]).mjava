    /**
     * creates an SeQuery with the filters provided to the constructor and returns it. Queries
     * created with this method can be used to execute and fetch results. They cannot be used for
     * other operations, such as calculating layer extents, or result count.
     *
     * <p>Difference with {@link #createSeQueryForFetch(Session, String[])} is tha this function
     * tells <code>SeQuery.setSpatialConstraints</code> to NOT return geometry based bitmasks, which
     * are needed for calculating the query extent and result count, but not for fetching SeRows.
     *
     * @param propertyNames names of attributes to build the query for, respecting order
     * @throws SeException if the ArcSDE Java API throws it while creating the SeQuery or setting it
     *     the spatial constraints.
     * @throws IOException
     */
    private SeQuery createSeQueryForFetch(String[] propertyNames) throws SeException, IOException {
        if (LOGGER.isLoggable(Level.FINEST)) {
            LOGGER.finest(
                    "constructing new sql query with connection: "
                            + session
                            + ", propnames: "
                            + java.util.Arrays.asList(propertyNames)
                            + " sqlConstruct where clause: '"
                            + this.filters.getSeSqlConstruct().getWhere()
                            + "'");
        }

        final SeQueryInfo qInfo = filters.getQueryInfo(propertyNames);
        if (sortByClause != null) {
            qInfo.setByClause(sortByClause);
        }

        final SeFilter[] spatialConstraints = this.filters.getSpatialFilters();
        if (LOGGER.isLoggable(Level.FINER)) {
            String msg = "ArcSDE query is: " + toString(qInfo);
            LOGGER.finer(msg);
        }

        final SeQuery seQuery;

        seQuery = session.prepareQuery(qInfo, spatialConstraints, versioningHandler);

        return seQuery;
    }

