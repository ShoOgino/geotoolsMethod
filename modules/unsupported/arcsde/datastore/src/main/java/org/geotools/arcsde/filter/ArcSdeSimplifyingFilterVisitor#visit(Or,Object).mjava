    @Override
    public Object visit(Or filter, Object extraData) {
        // perform the standard simplification
        Filter simplified = (Filter) super.visit(filter, extraData);

        // is it still an Or filter?
        if (simplified instanceof Or) {
            // collect spatial filters so that they are separated per attribute
            Map<String, List<SpatialOperation>> spatialOps = new HashMap<>();
            List<Filter> otherFilters = new ArrayList<>();
            List<Filter> children = ((Or) simplified).getChildren();
            for (Filter child : children) {
                // we know how to merge only bbox and intersects for the moment
                if (child instanceof BinarySpatialOperator) {
                    BinarySpatialOperator bso = (BinarySpatialOperator) child;
                    String name = null;
                    SpatialOperation so = null;
                    if (bso.getExpression1() instanceof PropertyName
                            && bso.getExpression2() instanceof Literal) {
                        name = ((PropertyName) bso.getExpression1()).getPropertyName();
                        so = new SpatialOperation(bso);
                    } else if (bso.getExpression2() instanceof PropertyName
                            && bso.getExpression1() instanceof Literal) {
                        name = ((PropertyName) bso.getExpression2()).getPropertyName();
                        so = new SpatialOperation(bso);
                    }

                    if (name != null && so != null) {
                        // handle the default geometry case
                        if ("".equals(name) && featureType.getGeometryDescriptor() != null) {
                            name = featureType.getGeometryDescriptor().getLocalName();
                        }

                        // collect into the specific geometry list
                        List<SpatialOperation> list = spatialOps.get(name);
                        if (list == null) {
                            list = new ArrayList<>();
                            spatialOps.put(name, list);
                        }
                        list.add(so);
                    } else {
                        // cannot handle this one
                        otherFilters.add(child);
                    }
                } else {
                    otherFilters.add(child);
                }
            }

            // try to merge all filters that work agains the same attribute and perform the same
            // (or similar enough) operation
            List<Filter> mergedFilters = new ArrayList<>();
            for (String property : spatialOps.keySet()) {
                List<SpatialOperation> propertyFilters = spatialOps.get(property);

                // we perform a reduction on the list of filters, trying to find groups that can be
                // merged
                while (propertyFilters.size() > 0) {
                    SpatialOperation main = propertyFilters.get(0);
                    List<SpatialOperation> toMerge = new ArrayList<>();
                    toMerge.add(main);
                    for (int j = 1; j < propertyFilters.size(); ) {
                        SpatialOperation secondary = propertyFilters.get(j);
                        // check if the two operations are compatible
                        if (secondary.operation == main.operation
                                || (secondary.operation == BBOX.class
                                        && main.operation == Intersects.class)
                                || (secondary.operation == Intersects.class
                                        && main.operation == BBOX.class)) {
                            toMerge.add(secondary);
                            propertyFilters.remove(j);
                        } else {
                            j++;
                        }
                    }

                    if (toMerge.size() == 1) {
                        // could not be merged, put in the "others" list
                        otherFilters.add(main.op);
                    } else {
                        try {
                            Filter merged = mergeOperations(property, toMerge);
                            mergedFilters.add(merged);
                        } catch (Exception e) {
                            // the operation can go belly up because of topology exceptions, in
                            // that case we just add back all the operations to the main list
                            for (SpatialOperation so : toMerge) {
                                otherFilters.add(so.op);
                            }
                        }
                    }
                    propertyFilters.remove(0);
                }
            }

            // did we manage to squash anything?
            if (mergedFilters.size() == 1 && otherFilters.size() == 0) {
                simplified = mergedFilters.get(0);
            } else if (mergedFilters.size() > 0) {
                List<Filter> full = new ArrayList<>();
                full.addAll(mergedFilters);
                full.addAll(otherFilters);
                simplified = FF.or(full);
            }
        }

        return simplified;
    }

