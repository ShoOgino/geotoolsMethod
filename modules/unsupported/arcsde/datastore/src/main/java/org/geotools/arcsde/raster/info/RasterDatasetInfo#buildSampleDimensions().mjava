    @SuppressWarnings({"unchecked", "rawtypes"})
    private List<GridSampleDimension> buildSampleDimensions() {

        final int numBands = getNumBands();
        List<GridSampleDimension> dimensions = new ArrayList<>(numBands);

        final Color transparent = new Color(0, 0, 0, 0);

        List<RasterBandInfo> bands = subRasterInfo.get(0).getBands();

        for (RasterBandInfo band : bands) {
            // use native cell type, in case no-data value has been computed to account for
            // sample depth promotion, we want to category to keep being the native range for
            // the values category
            final RasterCellType targetCellType = getNativeCellType();
            String bandName = band.getBandName();

            final double statsMin = band.getStatsMin();
            final double statsMax = band.getStatsMax();

            NumberRange<?> sampleValueRange;
            if (Double.isNaN(statsMin) || Double.isNaN(statsMax)) {
                sampleValueRange = targetCellType.getSampleValueRange();
            } else {
                sampleValueRange = NumberRange.create(statsMin, statsMax);
                Class elementClass = targetCellType.getSampleValueRange().getElementClass();
                sampleValueRange = sampleValueRange.castTo(elementClass);
            }

            final Color[] colorRange = null;

            final boolean geophysics = isGeoPhysics();

            Category valuesCat = new Category("values", colorRange, sampleValueRange);

            Category[] categories;
            if (geophysics) {
                double noDataValue = band.getNoDataValue().doubleValue();
                // same as Category.NODATA but for the actual nodata value instead of hardcoded to
                // zero
                Category nodataCat =
                        new Category(
                                Vocabulary.formatInternational(VocabularyKeys.NODATA),
                                transparent,
                                noDataValue);
                categories = new Category[] {valuesCat, nodataCat};
            } else {
                // do not build a nodata category. A nodata value that doesn't overlap the value
                // range couldn't be determined
                categories = new Category[] {valuesCat};
            }
            /*
             * if (band.isHasStats()) { //can't do this, get an exception telling categories
             * overlap.. so no real way to express the statistics, uh? Category catMin = new
             * Category("Min", null, band.getStatsMin()).geophysics(true); Category catMax = new
             * Category("Max", null, band.getStatsMin()).geophysics(true); Category catMean = new
             * Category("Mean", null, band.getStatsMin()).geophysics(true); Category catStdDev = new
             * Category("StdDev", null, band.getStatsMin()) .geophysics(true); categories = new
             * Category[] { valuesCat, nodataCat, catMin, catMax, catMean, catStdDev }; } else {
             * categories = new Category[] { valuesCat, nodataCat }; }
             */

            // .geophysics(false) because our sample model always corresponds to the packed view
            // (whether it matches the underlying sample depth or we're promoting in order to make
            // room for the nodata value).
            GridSampleDimension sampleDim = new GridSampleDimension(bandName, categories, null);

            dimensions.add(sampleDim);
        }
        return dimensions;
    }

