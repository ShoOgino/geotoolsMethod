    /**
     * Returns a color model based on {@code colorMap} that's guaranteed to have at least one
     * transparent pixel whose index can be used as no-data value for colormapped rasters, even if
     * the returned IndexColorModel needs to be of a higher sample depth (ie, 16 instead of 8 bit)
     * to satisfy that.
     *
     * @param colorMap the raster's native color map the returned one will be based on
     * @return the same {@code colorMap} if it has a transparent pixel, another, possibly of a
     *     higher depth one if not, containing all the colors from {@code colorMap} and a newly
     *     allocated cell for the transparent pixel if necessary
     */
    public static IndexColorModel ensureNoDataPixelIsAvailable(final IndexColorModel colorMap) {
        int transparentPixel = colorMap.getTransparentPixel();
        if (transparentPixel > -1) {
            return colorMap;
        }

        final int transferType = colorMap.getTransferType();
        final int mapSize = colorMap.getMapSize();
        final int maxSize = 65536; // true for either transfer type

        if (mapSize == maxSize) {
            LOGGER.fine(
                    "There's no room for a new transparent pixel, "
                            + "returning the original colorMap as is");
            return colorMap;
        }

        /*
         * The original map size is lower than the maximum allowed by a UShort color map, so expand
         * the colormap by one and make that new entry transparent
         */
        final int newMapSize = mapSize + 1;
        final int[] argb = new int[newMapSize];
        colorMap.getRGBs(argb);

        // set the last entry as transparent
        argb[newMapSize - 1] = ColorUtilities.getIntFromColor(0, 0, 0, 0);

        IndexColorModel targetColorModel;
        final int significantBits;
        final int newTransferType;

        {
            if (DataBuffer.TYPE_BYTE == transferType && newMapSize <= 256) {
                /*
                 * REVISIT: check if this needs to be promoted depending on whether I decide to
                 * treat 1 and 4 bit images as indexed with 1 and 4 significant bits respectively
                 */
                significantBits = colorMap.getPixelSize();
                newTransferType = DataBuffer.TYPE_BYTE;
            } else if (DataBuffer.TYPE_BYTE == transferType && newMapSize == 257) {
                // it's being promoted. significantBits = 9 makes for a 512 color model instead of a
                // 65535 one saving a good bit of memory, specially for color mapped raster catalogs
                // where the colormodel for each raster in the catalog is to be held in memory
                significantBits = 9;
                newTransferType = DataBuffer.TYPE_USHORT;
            } else {
                // already was 16-bit
                significantBits = 16;
                newTransferType = DataBuffer.TYPE_USHORT;
            }
        }

        final int transparentPixelIndex = newMapSize - 1;
        final boolean hasalpha = true;
        final int startIndex = 0;

        targetColorModel =
                new IndexColorModel(
                        significantBits,
                        newMapSize,
                        argb,
                        startIndex,
                        hasalpha,
                        transparentPixelIndex,
                        newTransferType);

        return targetColorModel;
    }

