    /**
     * Returns an {@link ArcSDEFeatureReader} for the given query that works against the given
     * connection.
     *
     * <p>Explicitly stating the connection to use allows for the feature reader to fetch the
     * differences (additions/modifications/deletions) made while a transaction is in progress.
     *
     * @param query the Query containing the request criteria
     * @param session the session to use to retrieve content.
     * @return
     * @throws IOException
     */
    private FeatureReader<SimpleFeatureType, SimpleFeature> getFeatureReader(
            final Query query,
            final SimpleFeatureType targetSchema,
            final ISession session,
            final ArcSdeVersionHandler versionHandler)
            throws IOException {

        final String typeName = query.getTypeName();

        final FeatureTypeInfo typeInfo = typeInfoCache.getFeatureTypeInfo(typeName, session);
        final SimpleFeatureType completeSchema = typeInfo.getFeatureType();

        final Filter queryFilter = query.getFilter();

        if (queryFilter == Filter.EXCLUDE || queryFilter.equals(Filter.EXCLUDE)) {
            return new EmptyFeatureReader<SimpleFeatureType, SimpleFeature>(targetSchema);
        }

        @SuppressWarnings("PMD.CloseResource") // wrapped and returned
        final ArcSDEQuery sdeQuery;
        if (typeInfo.isInProcessView()) {
            SeQueryInfo definitionQuery = typeInfo.getSdeDefinitionQuery();
            PlainSelect viewSelectStatement = typeInfo.getDefinitionQuery();
            sdeQuery =
                    ArcSDEQuery.createInprocessViewQuery(
                            session, completeSchema, query, definitionQuery, viewSelectStatement);
        } else {
            final FIDReader fidStrategy = typeInfo.getFidStrategy();
            sdeQuery =
                    ArcSDEQuery.createQuery(
                            session, completeSchema, query, fidStrategy, versionHandler);
        }

        final GeometryFactory geometryFactory = getGeometryFactory(query.getHints());

        // this is the one which's gonna close the connection when done
        final ArcSDEAttributeReader attReader;
        attReader = new ArcSDEAttributeReader(sdeQuery, geometryFactory, session);

        FeatureReader<SimpleFeatureType, SimpleFeature> reader;
        final Filter unsupportedFilter = sdeQuery.getFilters().getUnsupportedFilter();

        try {
            reader = new ArcSDEFeatureReader(attReader);
        } catch (SchemaException e) {
            throw new RuntimeException(
                    "Schema missmatch, should never happen!: " + e.getMessage(), e);
        }

        // SDE geometry filters are setup to be same or less restrictive than the JTS ones,
        // so we do post filtering in memory with the full filter (it's fast anyways)
        if (!unsupportedFilter.equals(Filter.INCLUDE)) {
            // use the full filter in this case, no sure how it was unpacked
            reader =
                    new FilteringFeatureReader<SimpleFeatureType, SimpleFeature>(
                            reader, queryFilter);
        } else if (!Filter.INCLUDE.equals(sdeQuery.getFilters().getGeometryFilter())) {
            // its ok to just use the geometry filter in-process
            reader =
                    new FilteringFeatureReader<SimpleFeatureType, SimpleFeature>(
                            reader, sdeQuery.getFilters().getGeometryFilter());
        }

        if (!targetSchema.equals(reader.getFeatureType())) {
            LOGGER.fine("Recasting feature type to subtype by using a ReTypeFeatureReader");
            reader = new ReTypeFeatureReader(reader, targetSchema, false);
        }

        if (query.getMaxFeatures() != Query.DEFAULT_MAX) {
            reader =
                    new MaxFeatureReader<SimpleFeatureType, SimpleFeature>(
                            reader, query.getMaxFeatures());
        }

        return reader;
    }

