    /** For each raster: crop->scale->translate->add to mosaic */
    private RenderedImage createMosaic(
            final List<RasterQueryInfo> queries,
            final GridEnvelope mosaicGeometry,
            final LoggingHelper log)
            throws IOException {

        List<RenderedImage> transformed = new ArrayList<RenderedImage>(queries.size());

        /*
         * Do we need to expand to RGB color space and then create a new colormapped image with the
         * whole mosaic?
         */
        boolean expandCM = queries.size() > 1 && rasterInfo.isColorMapped();
        if (expandCM) {
            LOGGER.fine(
                    "Creating mosaic out of "
                            + queries.size()
                            + " colormapped rasters. The mosaic tiles will be expanded to "
                            + "\nRGB space and the resulting mosaic reduced to a new IndexColorModel");
        }

        for (RasterQueryInfo query : queries) {
            RenderedImage image = query.getResultImage();
            ImageWorker worker = new ImageWorker(image);
            log.log(image, query.getRasterId(), "01_original");
            if (expandCM) {
                if (LOGGER.isLoggable(Level.FINER)) {
                    LOGGER.finer(
                            "Creating color expanded version of tile for raster #"
                                    + query.getRasterId());
                }

                /*
                 * reformat the image as a 4 band rgba backed by byte data
                 */
                image = worker.format(Integer.valueOf(DataBuffer.TYPE_BYTE)).getRenderedImage();
                log.log(image, query.getRasterId(), "04_1_colorExpanded");
            }

            cropToRequiredDimension(worker, query.getResultGridRange());
            image = worker.getRenderedImage();
            log.log(image, query.getRasterId(), "02_crop");

            if (queries.size() == 1) {
                return image;
            }
            final GridEnvelope mosaicLocation = query.getMosaicLocation();
            // scale
            Float scaleX = Float.valueOf(((float) mosaicLocation.getSpan(0) / image.getWidth()));
            Float scaleY = Float.valueOf(((float) mosaicLocation.getSpan(1) / image.getHeight()));
            Float translateX = Float.valueOf(0);
            Float translateY = Float.valueOf(0);

            if (!(Float.valueOf(1.0F).equals(scaleX) && Float.valueOf(1.0F).equals(scaleY))) {

                worker.scale(
                        scaleX,
                        scaleY,
                        translateX,
                        translateY,
                        Interpolation.getInstance(Interpolation.INTERP_NEAREST));

                image = worker.getRenderedImage();
                log.log(image, query.getRasterId(), "03_scale");

                int width = image.getWidth();
                int height = image.getHeight();

                assert mosaicLocation.getSpan(0) == width;
                assert mosaicLocation.getSpan(1) == height;
            }

            if (image.getMinX() != mosaicLocation.getLow(0)
                    || image.getMinY() != mosaicLocation.getLow(1)) {
                worker.translate(
                        Float.valueOf(mosaicLocation.getLow(0) - image.getMinX()),
                        Float.valueOf(mosaicLocation.getLow(1) - image.getMinY()),
                        null);
                image = worker.getRenderedImage();
                log.log(image, query.getRasterId(), "04_translate");

                assert image.getMinX() == mosaicLocation.getLow(0)
                        : image.getMinX() + " != " + mosaicLocation.getLow(0);
                assert image.getMinY() == mosaicLocation.getLow(1)
                        : image.getMinY() + " != " + mosaicLocation.getLow(1);
                assert image.getWidth() == mosaicLocation.getSpan(0)
                        : image.getWidth() + " != " + mosaicLocation.getSpan(0);
                assert image.getHeight() == mosaicLocation.getSpan(1)
                        : image.getHeight() + " != " + mosaicLocation.getSpan(1);
            }

            transformed.add(image);
        }

        final RenderedImage mosaic;
        if (queries.size() == 1) {
            /*
             * This is besides a very slight perf improvement needed because the JAI mosaic
             * operation truncates floating point raster values to 0 and 1. REVISIT: If there's no
             * workaround for that we should prevent raster catalogs made of floating point rasters
             * and throw an exception as we could not really support that.
             */
            mosaic = transformed.get(0);
        } else {
            /*
             * adapted from RasterLayerResponse.java in the imagemosaic module
             */
            ImageWorker w = new ImageWorker();

            // set background values to raster's no-data
            double[] backgroundValues;
            if (expandCM) {
                backgroundValues = new double[] {0, 0, 0, 0};
            } else {
                final int numBands = rasterInfo.getNumBands();
                backgroundValues = new double[numBands];
                final int rasterIndex = 0;
                Number noDataValue;
                for (int bn = 0; bn < numBands; bn++) {
                    noDataValue = rasterInfo.getNoDataValue(rasterIndex, bn);
                    backgroundValues[bn] = noDataValue.doubleValue();
                }
            }

            final ImageLayout layout =
                    new ImageLayout(
                            mosaicGeometry.getLow(0),
                            mosaicGeometry.getLow(1),
                            mosaicGeometry.getSpan(0),
                            mosaicGeometry.getSpan(1));
            final int tileWidth = rasterInfo.getTileDimension(0).width;
            final int tileHeight = rasterInfo.getTileDimension(0).height;
            layout.setTileWidth(tileWidth);
            layout.setTileHeight(tileHeight);

            final RenderingHints hints = new RenderingHints(JAI.KEY_IMAGE_LAYOUT, layout);

            RenderedImage[] images = new RenderedImage[transformed.size()];
            int i = 0;
            for (RenderedImage img : transformed) {
                images[i] = img;
                log.appendLoggingGeometries(LoggingHelper.MOSAIC_RESULT, img);
                i++;
            }
            log.log(LoggingHelper.MOSAIC_RESULT);

            LOGGER.fine("Creating mosaic out of " + queries.size() + " raster tiles");
            w.setRenderingHints(hints);
            w.setBackground(backgroundValues);
            mosaic =
                    w.mosaic(images, MosaicDescriptor.MOSAIC_TYPE_OVERLAY, null, null, null, null)
                            .getRenderedImage();
            log.log(mosaic, 0L, "05_mosaic_result");
        }
        return mosaic;
    }

