    /**
     * Retrieve the connection for the provided transaction.
     *
     * <p>The connection is held open until while the transaction is underway. A a Transaction.State
     * is registered for this SessionPool in order to hold the session.
     *
     * @param transaction
     * @return the session associated with the transaction
     */
    public ISession getSession(Transaction transaction) throws IOException {
        if (transaction == null) {
            throw new NullPointerException(
                    "transaction can't be null. Did you mean Transaction.AUTO_COMMIT?");
        }
        final ISession session;
        if (Transaction.AUTO_COMMIT.equals(transaction)) {
            try {
                session = connectionPool.getSession(false);
            } catch (UnavailableConnectionException e) {
                throw new RuntimeException("Session pool exhausted", e);
            }
        } else {
            SessionTransactionState state;
            state = SessionTransactionState.getState(transaction, this.connectionPool);
            session = state.getConnection();
        }
        return session;
    }

