    public List<ElasticAttribute> getElasticAttributes(Name layerName) throws IOException {
        final String localPart = layerName.getLocalPart();
        ElasticLayerConfiguration layerConfig = layerConfigurations.get(localPart);
        final List<ElasticAttribute> elasticAttributes;
        if (layerConfig == null || layerConfig.getAttributes().isEmpty()) {
            final String docType;
            if (docTypes.containsKey(layerName)) {
                docType = docTypes.get(layerName);
            } else {
                docType = localPart;
            }

            final ClusterStateRequest clusterStateRequest;
            clusterStateRequest = Requests.clusterStateRequest()
                    .routingTable(true)
                    .nodes(true)
                    .local(isLocal)
                    .indices(indexName);

            final ClusterState state;
            state = client.admin().cluster()
                    .state(clusterStateRequest).actionGet().getState();
            final MappingMetaData metadata;
            metadata = state.metaData().index(indexName)
                    .mapping(docType);

            final byte[] mappingSource = metadata.source().uncompressed();
            final XContentParser parser;
            parser = XContentFactory.xContent(mappingSource)
                    .createParser(mappingSource);

            Map<String, Object> mapping = parser.map();
            if (mapping.size() == 1 && mapping.containsKey(docType)) {
                // the type name is the root value, reduce it
                mapping = (Map<String, Object>) mapping.get(docType);
            }

            elasticAttributes = new ArrayList<ElasticAttribute>();
            add(elasticAttributes, "_id", "string", mapping, false);
            add(elasticAttributes, "_index", "string", mapping, false);
            add(elasticAttributes, "_type", "string", mapping, false);
            add(elasticAttributes, "_score", "float", mapping, false);
            add(elasticAttributes, "_relative_score", "float", mapping, false);

            walk(elasticAttributes, mapping, "", false, false);

            // add default geometry and short name and count duplicate short names
            final Map<String,Integer> counts = new HashMap<>();
            boolean foundGeometry = false;
            for (final ElasticAttribute attribute : elasticAttributes) {
                if (!foundGeometry && Geometry.class.isAssignableFrom(attribute.getType())) {
                    attribute.setDefaultGeometry(true);
                    foundGeometry = true;
                }
                final String[] parts = attribute.getName().split("\\.");
                attribute.setShortName(parts[parts.length-1]);
                final int count;
                if (counts.containsKey(attribute.getShortName())) {
                    count = counts.get(attribute.getShortName())+1;
                } else {
                    count = 1;
                }
                counts.put(attribute.getShortName(), count);
            }
            // use full name if short name has duplicates
            for (final ElasticAttribute attribute : elasticAttributes) {
                if (counts.get(attribute.getShortName()) > 1) {
                    attribute.setShortName(attribute.getName());
                }
            }
        } else {
            elasticAttributes = layerConfig.getAttributes();
        }
        return elasticAttributes;
    }

