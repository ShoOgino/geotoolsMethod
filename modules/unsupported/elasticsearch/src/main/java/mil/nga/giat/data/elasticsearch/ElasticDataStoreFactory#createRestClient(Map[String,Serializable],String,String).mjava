    private RestClient createRestClient(Map<String, Serializable> params, String user, String password) throws IOException {
        final String hostName = getValue(HOSTNAME, params);
        final String[] hosts = hostName.split(",");
        final Integer defaultPort = getValue(HOSTPORT, params);
        final Boolean sslRejectUnauthorized = getValue(SSL_REJECT_UNAUTHORIZED, params);
        final String adminUser = getValue(USER, params);
        final String type = user == null || adminUser == null || user.equals(adminUser) ? "ADMIN" : "PROXY_USER";

        final Pattern pattern = Pattern.compile("(?<scheme>https?)?(://)?(?<host>[^:]+):?(?<port>\\d+)?");
        final HttpHost[] httpHosts = new HttpHost[hosts.length];
        final AuthScope[] auths = new AuthScope[hosts.length];
        for (int index=0; index < hosts.length; index++) {
            final Matcher matcher = pattern.matcher(hosts[index].trim());
            if (matcher.find()) {
                final String scheme = matcher.group("scheme") != null ? matcher.group("scheme") : "http";
                final String host = matcher.group("host");
                final Integer port = matcher.group("port") != null ? Integer.valueOf(matcher.group("port")) : defaultPort;
                httpHosts[index] = new HttpHost(host, port, scheme);
                auths[index] = new AuthScope(host, port);
            } else {
                throw new IOException("Unable to parse host");
            }
        }

        final RestClientBuilder builder = createClientBuilder(httpHosts);

        if (user != null) {
            builder.setRequestConfigCallback((b) -> {
                LOGGER.finest(String.format("Calling %s setRequestConfigCallback", type));
                return b.setAuthenticationEnabled(true);
            });
        }

        builder.setHttpClientConfigCallback((httpClientBuilder) -> {
            LOGGER.finest(String.format("Calling %s customizeHttpClient", type));

            httpClientBuilder.setThreadFactory((run) -> {
                final Thread thread = new Thread(run);
                thread.setDaemon(true);
                thread.setName(String.format("esrest-asynchttp-%s-%d", type, httpThreads.getAndIncrement()));
                return thread;
            });

            httpClientBuilder.useSystemProperties();

            if (!sslRejectUnauthorized) {
                httpClientBuilder.setSSLHostnameVerifier((host,session) -> true);
                try {
                    httpClientBuilder.setSSLContext(SSLContextBuilder.create().loadTrustMaterial((chain,authType) ->true).build());
                } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException e) {
                    throw new UncheckedIOException(new IOException("Unable to create SSLContext", e));
                }
            }

            if (user != null) {
                final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
                final Credentials credentials = new org.apache.http.auth.UsernamePasswordCredentials(user, password);
                for (AuthScope scope : auths) {
                    credentialsProvider.setCredentials(scope, credentials);
                }

                httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider);
            }

            return httpClientBuilder;
        });

        LOGGER.fine(String.format("Building a %s RestClient for %s @ %s:%d", type, user, hostName, defaultPort));
        return builder.build();
    }

