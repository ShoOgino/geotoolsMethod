    protected RestClient createRestClient(Map<String, Serializable> params) throws IOException {
        final String[] hosts = ((String) getValue(HOSTNAME, params)).split(",");
        final Integer defaultPort = (Integer) getValue(HOSTPORT, params);
        Boolean sslEnabled = (Boolean) getValue(SSL_ENABLED, params);
        final Boolean sslRejectUnauthorized = (Boolean) getValue(SSL_REJECT_UNAUTHORIZED, params);

        final String defaultScheme = sslEnabled ? "https" : "http";
        final Pattern pattern = Pattern.compile("(?<scheme>https?)?(://)?(?<host>[^:]+):?(?<port>\\d+)?");
        final HttpHost[] httpHosts = new HttpHost[hosts.length];
        for (int index=0; index < hosts.length; index++) {
            final Matcher matcher = pattern.matcher(hosts[index].trim());
            if (matcher.find()) {
                final String scheme = matcher.group("scheme") != null ? matcher.group("scheme") : defaultScheme;
                final String host = matcher.group("host");
                final Integer port = matcher.group("port") != null ? Integer.valueOf(matcher.group("port")) : defaultPort;
                httpHosts[index] = new HttpHost(host, port, scheme);
                sslEnabled = sslEnabled || scheme != null && scheme.startsWith("https");
            } else {
                throw new IOException("Unable to parse host");
            }
        }

        final RestClientBuilder builder = RestClient.builder(httpHosts);

        if (sslEnabled) {
            builder.setHttpClientConfigCallback(new RestClientBuilder.HttpClientConfigCallback() {
                @Override
                public HttpAsyncClientBuilder customizeHttpClient(HttpAsyncClientBuilder httpClientBuilder) {
                    httpClientBuilder.useSystemProperties();
                    if (!sslRejectUnauthorized) {
                        httpClientBuilder.setSSLHostnameVerifier((host,session) -> true);
                        try {
                            httpClientBuilder.setSSLContext(SSLContextBuilder.create().loadTrustMaterial((chain,authType) -> true).build());
                        } catch (KeyManagementException | NoSuchAlgorithmException | KeyStoreException e) {
                            throw new UncheckedIOException(new IOException("Unable to create SSLContext", e));
                        }
                    }
                    return httpClientBuilder;
                }
            });
        }

        return builder.build();
    }

