    public ElasticDataStore(String searchHost, Integer hostPort, 
            String indexName, String searchIndices, String clusterName,
            boolean localNode, boolean storeData) {

        LOGGER.fine("initializing data store " + searchHost + ":" + hostPort + "/" + indexName);

        this.indexName = indexName;
        
        if (searchIndices != null) {
            this.searchIndices = searchIndices;
        } else {
            this.searchIndices = indexName;
        }

        if (localNode) {
            final NodeBuilder nodeBuilder;
            nodeBuilder = nodeBuilder().data(storeData)
                    .local(false)
                    .client(false)
                    .clusterName(clusterName);
            this.node = nodeBuilder.build();
            node.start();
            this.client = node.client();
        } else {
            this.node = null;
            final TransportAddress address;
            address = new InetSocketTransportAddress(searchHost, hostPort);
            Builder settings = ImmutableSettings.settingsBuilder()
                    .put("cluster.name", clusterName);
            this.client = new TransportClient(settings);
            ((TransportClient) client).addTransportAddress(address);
        }
        LOGGER.fine("client connection established");

        final ClusterStateRequest clusterStateRequest;
        clusterStateRequest = Requests.clusterStateRequest()
                .routingTable(true)
                .nodes(true)
                .indices(indexName);

        final ClusterState state;
        state = client.admin()
                .cluster()
                .state(clusterStateRequest)
                .actionGet().getState();
        LOGGER.fine("obtained cluster state");

        IndexMetaData metadata = state.metaData().index(indexName);
        if (metadata != null) {
            final ImmutableOpenMap<String, MappingMetaData> mappings;
            mappings = state.metaData().index(indexName).mappings();
            final Iterator<String> elasticTypes = mappings.keysIt();
            final Vector<Name> names = new Vector<Name>();
            while (elasticTypes.hasNext()) {
                names.add(new NameImpl(elasticTypes.next()));
            }
            cachedTypeNames = ImmutableList.copyOf(names);
        } else {
            cachedTypeNames = ImmutableList.copyOf(new ArrayList<Name>());
        }
    }

