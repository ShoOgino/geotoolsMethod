    /**
     * Common implementation for BinaryComparisonOperator filters.
     *
     * @param filter the comparison.
     *
     */
    protected void visitBinaryComparisonOperator(BinaryComparisonOperator filter, Object extraData) {
        LOGGER.finer("exporting FilterBuilder ComparisonFilter");

        Expression left = filter.getExpression1();
        Expression right = filter.getExpression2();
        if (isBinaryExpression(left) || isBinaryExpression(right)) {
            throw new UnsupportedOperationException("Binary expressions not supported");
        }

        AttributeDescriptor attType = null;
        Class leftContext = null, rightContext = null;
        if (left instanceof PropertyName) {
            // It's a propertyname, we should get the class and pass it in
            // as context to the tree walker.
            attType = (AttributeDescriptor)left.evaluate(featureType);
            if (attType != null) {
                rightContext = attType.getType().getBinding();
            }
        }
        
        if (right instanceof PropertyName) {
            attType = (AttributeDescriptor)right.evaluate(featureType);
            if (attType != null) {
                leftContext = attType.getType().getBinding();
            }
        }

        boolean nested = false;
        if (attType != null) {
            if (attType.getUserData().containsKey(NESTED)) {
                nested = (Boolean) attType.getUserData().get(NESTED);
            }
            if (Date.class.isAssignableFrom(attType.getType().getBinding())) {
                updateDateFormatter(attType);
            }
        }
        
        //case sensitivity
        if ( !filter.isMatchingCase() ) {
            //we only do for = and !=
            if ( filter instanceof PropertyIsEqualTo || 
                    filter instanceof PropertyIsNotEqualTo ) {
                //and only for strings
                if ( String.class.equals( leftContext ) 
                        || String.class.equals( rightContext ) ) {
                    //matchCase = false;
                    LOGGER.fine("Case insensitive filter not supported");
                }
            }
        }

        String type = (String) extraData;

        if ( matchCase ) {
            if (leftContext != null && isBinaryExpression(left)) {
                writeBinaryExpression(left, leftContext);
            }
            else {
                left.accept(this, leftContext);
            }
            final String key = (String) field;

            if (rightContext != null && isBinaryExpression(right)) {
                writeBinaryExpression(right, rightContext);
            }
            else {
                right.accept(this, rightContext);
            }

            if (type.equals("=")) {
                filterBuilder = QueryBuilders.termQuery(key, field);
//                filterBuilder = FilterBuilders.termFilter(key, field);
            } else if (type.equals("!=")) {
            	filterBuilder = QueryBuilders.boolQuery().mustNot(QueryBuilders.termQuery(key, field));
//                TermFilterBuilder equalsFilter;
//                equalsFilter = FilterBuilders.termFilter(key, field);
//                filterBuilder = FilterBuilders.notFilter(equalsFilter);
            } else if (type.equals(">")) {
                filterBuilder = QueryBuilders.rangeQuery(key).gt(field);
//                filterBuilder = FilterBuilders.rangeFilter(key).gt(field);
            } else if (type.equals(">=")) {
                filterBuilder = QueryBuilders.rangeQuery(key).gte(field);
//                filterBuilder = FilterBuilders.rangeFilter(key).gte(field);
            } else if (type.equals("<")) {
                filterBuilder = QueryBuilders.rangeQuery(key).lt(field);
//                filterBuilder = FilterBuilders.rangeFilter(key).lt(field);
            } else if (type.equals("<=")) {
                filterBuilder = QueryBuilders.rangeQuery(key).lte(field);
//                filterBuilder = FilterBuilders.rangeFilter(key).lte(field);
            }
        }
        else {
            // should never get here
            throw new FilterToElasticException("Case insensitive filter not supported");
        }

        if (type.equals("=")) {
            filterBuilder = FilterBuilders.termFilter(key, field);
        } else if (type.equals("!=")) {
            TermFilterBuilder equalsFilter;
            equalsFilter = FilterBuilders.termFilter(key, field);
            filterBuilder = FilterBuilders.notFilter(equalsFilter);
        } else if (type.equals(">")) {
            filterBuilder = FilterBuilders.rangeFilter(key).gt(field);
        } else if (type.equals(">=")) {
            filterBuilder = FilterBuilders.rangeFilter(key).gte(field);
        } else if (type.equals("<")) {
            filterBuilder = FilterBuilders.rangeFilter(key).lt(field);
        } else if (type.equals("<=")) {
            filterBuilder = FilterBuilders.rangeFilter(key).lte(field);
        }
        if (nested) {
            String path = extractNestedPath(key);
            filterBuilder = FilterBuilders.nestedFilter(path,filterBuilder);
        }
    }

