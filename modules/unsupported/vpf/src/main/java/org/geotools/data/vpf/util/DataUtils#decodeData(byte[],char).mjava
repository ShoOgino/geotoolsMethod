    /**
     * Describe <code>decodeData</code> method here.
     *
     * @param bytes a <code>byte[]</code> value
     * @param type a <code>char</code> value
     * @return an <code>Object</code> value
     */
    public static Object decodeData(byte[] bytes, char type) {
        Object result = null;

        switch (type) {
            case DATA_TEXT:
            case DATA_LEVEL1_TEXT:
            case DATA_LEVEL2_TEXT:
            case DATA_LEVEL3_TEXT:
                StringBuffer sb = new StringBuffer(bytes.length);

                for (int i = 0; i < bytes.length; i++) {
                    sb.append((char) bytes[i]);
                }

                boolean isNull = false;

                for (int i = 0; i < STRING_NULL_VALUES.length; i++) {
                    isNull |= sb.toString().trim().equalsIgnoreCase(STRING_NULL_VALUES[i]);
                }

                if (isNull) {
                    result = null;
                } else {
                    result = sb.toString().trim();
                }

                break;

            case DATA_SHORT_FLOAT:
                result = Float.valueOf(decodeFloat(bytes));

                break;

            case DATA_LONG_FLOAT:
                result = Double.valueOf(decodeDouble(bytes));

                break;

            case DATA_SHORT_INTEGER:
                result = Short.valueOf(decodeShort(bytes));

                break;

            case DATA_LONG_INTEGER:
                result = Integer.valueOf(decodeInt(bytes));

                break;

            case DATA_2_COORD_F:
                //        {
                //            // I doubt this is being used
                //          float[][] coords = new float[bytes.length / DATA_2_COORD_F_LEN][2];
                //          byte[] floatData = new byte[DATA_SHORT_FLOAT_LEN];
                //
                //          for (int i = 0; i < coords.length; i++) {
                //              copyArrays(floatData, bytes, i * DATA_2_COORD_F_LEN);
                //              coords[i][0] = decodeFloat(floatData);
                //              copyArrays(floatData, bytes, i * (DATA_2_COORD_F_LEN + 1));
                //              coords[i][1] = decodeFloat(floatData);
                //          }
                //          DirectPosition[] coords = new DirectPosition2D[bytes.length /
                // DATA_2_COORD_F_LEN];
                //          double xval, yval;
                //          byte[] floatData = new byte[DATA_SHORT_FLOAT_LEN];
                //
                //          for (int i = 0; i < coords.length; i++) {
                //              copyArrays(floatData, bytes, i * DATA_2_COORD_F_LEN);
                //              xval = decodeFloat(floatData);
                //              copyArrays(floatData, bytes, i * (DATA_2_COORD_F_LEN + 1));
                //              yval = decodeFloat(floatData);
                //              coords[i] = new DirectPosition2D(xval, yval);
                //          }

                //          result = coords;
                //            result = new Coordinate2DFloat(coords);
                //        }
                //
                //        break;

            case DATA_2_COORD_R:
                //        {
                // I doubt this is being used
                //            DirectPosition[] coords = new DirectPosition2D[bytes.length /
                // DATA_2_COORD_R_LEN];
                //            double xval, yval;
                //            byte[] doubleData = new byte[DATA_LONG_FLOAT_LEN];
                //
                //            for (int i = 0; i < coords.length; i++) {
                //                copyArrays(doubleData, bytes, i * DATA_2_COORD_R_LEN);
                //                xval = decodeDouble(doubleData);
                //                copyArrays(doubleData, bytes, i * (DATA_2_COORD_R_LEN + 1));
                //                yval = decodeDouble(doubleData);
                //                coords[i] = new DirectPosition2D(xval, yval);
                //            }
                //
                //            result = coords;
                //            double[][] coords = new double[bytes.length / DATA_2_COORD_R_LEN][2];
                //            byte[] doubleData = new byte[DATA_LONG_FLOAT_LEN];
                //
                //            for (int i = 0; i < coords.length; i++) {
                //                copyArrays(doubleData, bytes, i * DATA_2_COORD_R_LEN);
                //                coords[i][0] = decodeDouble(doubleData);
                //                copyArrays(doubleData, bytes, i * (DATA_2_COORD_R_LEN + 1));
                //                coords[i][1] = decodeDouble(doubleData);
                //            }
                //
                //            result = new Coordinate2DDouble(coords);
                //        }
                //
                //        break;
                //
            case DATA_3_COORD_F:
                //        {
                // I doubt this is being used
                //            DirectPosition[] coords = new DirectPosition2D[bytes.length /
                // DATA_2_COORD_R_LEN];
                //            double xval, yval, zval;
                //            byte[] floatData = new byte[DATA_SHORT_FLOAT_LEN];
                //
                //            for (int i = 0; i < coords.length; i++) {
                //                copyArrays(floatData, bytes, i * DATA_3_COORD_F_LEN);
                //                xval = decodeFloat(floatData);
                //                copyArrays(floatData, bytes, i * (DATA_3_COORD_F_LEN + 1));
                //                yval = decodeFloat(floatData);
                //                copyArrays(floatData, bytes, i * (DATA_3_COORD_F_LEN + 2));
                //                zval = decodeFloat(floatData);
                //                coords[i] = new GeneralDirectPosition(xval, yval, zval);
                //            }
                //
                //            result = coords;
                //            float[][] coords = new float[bytes.length / DATA_3_COORD_F_LEN][3];
                //            byte[] floatData = new byte[DATA_SHORT_FLOAT_LEN];
                //
                //            for (int i = 0; i < coords.length; i++) {
                //                copyArrays(floatData, bytes, i * DATA_3_COORD_F_LEN);
                //                coords[i][0] = decodeFloat(floatData);
                //                copyArrays(floatData, bytes, i * (DATA_3_COORD_F_LEN + 1));
                //                coords[i][1] = decodeFloat(floatData);
                //                copyArrays(floatData, bytes, i * (DATA_3_COORD_F_LEN + 2));
                //                coords[i][2] = decodeFloat(floatData);
                //            }
                //
                //            result = new Coordinate3DFloat(coords);
                //        }
                //
                //        break;
                //
            case DATA_3_COORD_R:
                //        {
                // I doubt this is being used
                //            DirectPosition[] coords = new DirectPosition2D[bytes.length /
                // DATA_2_COORD_R_LEN];
                //            double xval, yval, zval;
                //            byte[] doubleData = new byte[DATA_LONG_FLOAT_LEN];
                //
                //            for (int i = 0; i < coords.length; i++) {
                //                copyArrays(doubleData, bytes, i * DATA_3_COORD_R_LEN);
                //                xval = decodeDouble(doubleData);
                //                copyArrays(doubleData, bytes, i * (DATA_3_COORD_R_LEN + 1));
                //                yval = decodeDouble(doubleData);
                //                copyArrays(doubleData, bytes, i * (DATA_3_COORD_R_LEN + 2));
                //                zval = decodeDouble(doubleData);
                //                coords[i] = new GeneralDirectPosition(xval, yval, zval);
                //            }
                //
                //            result = coords;
                //            double[][] coords = new double[bytes.length / DATA_3_COORD_R_LEN][3];
                //            byte[] doubleData = new byte[DATA_LONG_FLOAT_LEN];
                //
                //            for (int i = 0; i < coords.length; i++) {
                //                copyArrays(doubleData, bytes, i * DATA_3_COORD_R_LEN);
                //                coords[i][0] = decodeDouble(doubleData);
                //                copyArrays(doubleData, bytes, i * (DATA_3_COORD_R_LEN + 1));
                //                coords[i][1] = decodeDouble(doubleData);
                //                copyArrays(doubleData, bytes, i * (DATA_3_COORD_R_LEN + 2));
                //                coords[i][2] = decodeDouble(doubleData);
                //            }
                //
                //            result = new Coordinate3DDouble(coords);
                //        }
                {
                    throw new RuntimeException(
                            "If this code is actually being used, replace it with equivalent code from VPFFile.");
                }
            case DATA_DATE_TIME:
                result = new VPFDate(bytes);

                break;

            case DATA_NULL_FIELD:
                break;

            case DATA_TRIPLET_ID:
            default:
                break;
        }

        return result;
    }

