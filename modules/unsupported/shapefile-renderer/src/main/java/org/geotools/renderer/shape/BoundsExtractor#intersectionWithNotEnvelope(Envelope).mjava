//    /*
//     * @see org.geotools.filter.FilterVisitor#visit(org.geotools.filter.LogicFilter)
//     */
//    public void visit(LogicFilter filter) {
//
//        if (filter != null) {
//            switch (filter.getFilterType()) {
//            case FilterType.LOGIC_OR: {
//                Iterator i = filter.getFilterIterator();
//                while (i.hasNext()) {
//                    Filter tmp = (Filter) i.next();
//                    tmp.accept(this);
//                }
//                Envelope bbox=new Envelope();
//                while( !envelopeStack.isEmpty() ){
//                    Envelope env = (Envelope) envelopeStack.pop();
//                    bbox.expandToInclude(env);
//                }
//                if( notEnvelope!=null ){
//                    if( bbox.contains(notEnvelope) ){
//                        // or contains all of notEnvelope so notEnvelope is meaningless
//                        notEnvelope=null;
//                    }else{
//                        // lets err on the side of caution and we can safely ignore the or... This will
//                        // be a little big but that's ok.
//                        bbox=new Envelope();
//                    }
//                }
//
//                if( !bbox.isNull() )
//                    envelopeStack.push(bbox);
//                break;
//            }
//            case FilterType.LOGIC_AND: {
//                Iterator i = filter.getFilterIterator();
//                while (i.hasNext()) {
//                    Filter tmp = (Filter) i.next();
//                    tmp.accept(this);
//                }
//                if( !envelopeStack.isEmpty() ){
//                    Envelope bbox = null;
//                    while( !envelopeStack.isEmpty() ){
//                        Envelope env = (Envelope) envelopeStack.pop();
//                        if( bbox==null ){
//                            bbox=env;
//                        }else{
//                            bbox=bbox.intersection(env);
//                        }
//                    }
//                    if( notEnvelope!=null && bbox!=null){
//                        if( notEnvelope.contains(bbox) ){
//                            // this mean that nothing valid since we are ANDING
//                            // and area with an area that is guaranteed to be empty
//                            // Erring on the side of caution for now
//                            notEnvelope=bbox;
//                            bbox=null;
//                        }else{
//                            bbox = intersectionWithNotEnvelope(bbox);
//                            notEnvelope=null;
//                        }
//                    }
//                    if( bbox!=null && !bbox.isNull() )
//                        envelopeStack.push(bbox);
//                }
//                
//                break;
//            }
//            case FilterType.LOGIC_NOT:
//                Iterator i = filter.getFilterIterator();
//                Filter tmp = (Filter) i.next();
//                tmp.accept(this);
//                if( !envelopeStack.isEmpty() ){
//                    notEnvelope=(Envelope) envelopeStack.pop();
//                    assert envelopeStack.isEmpty();
//                }else if( notEnvelope!=null || !notEnvelope.isNull()){
//                    envelopeStack.push(notEnvelope);
//                    notEnvelope=null;
//                }
//            default:
//                break;
//            }
//
//        }
//    }
//
    private Envelope intersectionWithNotEnvelope(Envelope bbox) {
        Geometry notGeom = factory.toGeometry(notEnvelope);
        Geometry andGeom = factory.toGeometry(bbox);
        
        Envelope envelopeInternal = andGeom.difference(notGeom).getEnvelopeInternal();
        bbox = envelopeInternal;
        return bbox;
    }
//    
//    public void visit(LiteralExpression expression) {
//        Object literal = expression.getLiteral();
//        if (literal instanceof Geometry) {
//            Geometry geom = (Geometry) literal;
//            envelopeStack.push(geom.getEnvelopeInternal());
//        }
//    }

