    public void paint( Graphics2D graphics, Rectangle paintArea, ReferencedEnvelope envelope,
            AffineTransform transform ) {
        if( transform == null ){
            throw new NullPointerException("Transform is required");
        }
        if (hints != null) {
            graphics.setRenderingHints(hints);
        }

        if ((graphics == null) || (paintArea == null)) {
            LOGGER.info("renderer passed null arguments");

            return;
        }

        // reset the abort flag
        renderingStopRequested = false;

        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Affine Transform is " + transform);
        }

        /*
         * If we are rendering to a component which has already set up some form of transformation
         * then we can concatenate our transformation to it. An example of this is the ZoomPane
         * component of the swinggui module.
         */
        if (concatTransforms) {
            AffineTransform atg = graphics.getTransform();

            // graphics.setTransform(new AffineTransform());
            atg.concatenate(transform);
            transform = atg;
        }

        try {
            setScaleDenominator(  
                    computeScale(
                            envelope,
                            context.getCoordinateReferenceSystem(),
                            paintArea, 
                            transform,
                            this.rendererHints));
        } catch (Exception e) // probably either (1) no CRS (2) error xforming
        {
            LOGGER.throwing("RendererUtilities", "calculateScale(envelope, coordinateReferenceSystem, imageWidth, imageHeight, hints)", e);
            setScaleDenominator(1 / transform.getScaleX()); // DJB old method - the best we can do            
        }

        MapLayer[] layers = context.getLayers();

        // get detstination CRS
        CoordinateReferenceSystem destinationCrs = context.getCoordinateReferenceSystem();
        labelCache.start();
        labelCache.clear();
        if(labelCache instanceof LabelCacheImpl) {
            ((LabelCacheImpl) labelCache).setLabelRenderingMode(LabelRenderingMode.valueOf(getTextRenderingMethod()));
        }
        for( int i = 0; i < layers.length; i++ ) {
            MapLayer currLayer = layers[i];

            if (!currLayer.isVisible()) {
                // Only render layer when layer is visible
                continue;
            }

            if (renderingStopRequested) {
                return;
            }
            
            if( layerIndexInfo[i]==STREAMING_RENDERER_INFO ){
            	renderWithStreamingRenderer(currLayer, graphics, paintArea, envelope, transform);
                continue;
            }
            labelCache.startLayer(""+i);

            ReferencedEnvelope bbox = envelope;

            try {
                FeatureSource featureSource = currLayer.getFeatureSource();
                if(featureSource instanceof DirectoryFeatureSource) {
                    featureSource = ((DirectoryFeatureSource) featureSource).unwrap();
                }
                
                GeometryDescriptor geom = featureSource.getSchema().getGeometryDescriptor();
                
                CoordinateReferenceSystem dataCRS;
                if (getForceCRSHint() == null) {
                    dataCRS = geom.getCoordinateReferenceSystem();
                } else {
                    dataCRS = getForceCRSHint();
                }
                MathTransform mt = null;
                CoordinateOperation op = null;
                if( dataCRS != null ){
                    try {
                        if( dataCRS != null ){
                            op = CRS.getCoordinateOperationFactory(true).createOperation(dataCRS, destinationCrs);
                            mt = op.getMathTransform();
                            bbox = bbox.transform(dataCRS, true, 10);
                        }
                        else {
                            LOGGER.log(Level.WARNING, "Could not reproject the bounding boxes as data CRS was null, proceeding in non reprojecting mode");
                            op = null;
                            mt = null;
                        }
                    } catch (Exception e) {
                        fireErrorEvent(e);
                        LOGGER.log(Level.WARNING, "Could not reproject the bounding boxes, proceeding in non reprojecting mode", e);
                        op = null;
                        mt = null;
                    }
                }
                else {
                    LOGGER.log(Level.WARNING, "Data CRS is unknown, proceeding in non reprojecting mode");
                }
                
                MathTransform at = ReferencingFactoryFinder.getMathTransformFactory(null)
                        .createAffineTransform(new GeneralMatrix(transform));

                if (mt == null) {
                    mt = at;
                } else {
                    mt = ReferencingFactoryFinder.getMathTransformFactory(null).createConcatenatedTransform(
                            mt, at);
                }

                // dbfheader must be set so that the attributes required for theming can be read in.
                ShapefileDataStore ds = (ShapefileDataStore) featureSource.getDataStore();

                // graphics.setTransform(transform);
                // extract the feature type stylers from the style object
                // and process them

                Transaction transaction = Transaction.AUTO_COMMIT;

                if (featureSource instanceof FeatureStore) {
                    transaction = ((SimpleFeatureStore) featureSource).getTransaction();
                }

                DefaultQuery query = new DefaultQuery(currLayer.getQuery());
                if( query.getFilter() !=null ){
                    // now reproject the geometries in filter because geoms are retrieved projected to screen space
                    FilterTransformer transformer= new  FilterTransformer(mt);
                    Filter transformedFilter = (Filter) query.getFilter().accept(transformer, null);
                    query.setFilter(transformedFilter);
                }
                
                // by processing the filter we can further restrict the maximum bounds that are
                // required.  For example if a filter 
                //BoundsExtractor extractor=new BoundsExtractor(bbox);
                //if( query.getFilter()!=null )
                //    query.getFilter().accept(extractor);
                //
                //processStylers(graphics, ds, query, extractor.getIntersection(), paintArea,
                //        mt, currLayer.getStyle(), layerIndexInfo[i], transaction);
                processStylers(graphics, ds, query, bbox, paintArea,
                        mt, currLayer.getStyle(), layerIndexInfo[i], transaction, ""+i);
            } catch (Exception exception) {
                Exception e = new Exception("Exception rendering layer " + currLayer, exception);
                fireErrorEvent(e);
            }

            labelCache.endLayer(""+i, graphics, paintArea);
        }

        labelCache.end(graphics, paintArea);
        if(LOGGER.isLoggable(Level.FINE))
            LOGGER.fine("Style cache hit ratio: " + styleFactory.getHitRatio() + " , hits "
                + styleFactory.getHits() + ", requests " + styleFactory.getRequests());
    }

