    private void processStylers( Graphics2D graphics, ShapefileDataStore datastore,
            Query query, Envelope bbox, Rectangle screenSize, MathTransform mt, Style style, IndexInfo info,
            Transaction transaction, String layerId) throws IOException {
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("processing " + style.getFeatureTypeStyles().length + " stylers");
        }

        FeatureTypeStyle[] featureStylers = style.getFeatureTypeStyles();
        SimpleFeatureType type;

        try {
            type = createFeatureType(query, style, datastore);
        } catch (Exception e) {
            fireErrorEvent(e);
            LOGGER.logp(Level.WARNING, "org.geotools.renderer.shape.ShapefileRenderer", "processStylers", "Could not prep style for rendering", e);
            return;
        }

        for( int i = 0; i < featureStylers.length; i++ ) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("processing style " + i);
            }

            FeatureTypeStyle fts = featureStylers[i];
            String typeName = datastore.getSchema().getTypeName();

            if ((typeName != null) &&
                    ( FeatureTypes.isDecendedFrom(datastore.getSchema(), null, fts.getFeatureTypeName()) 
                    || typeName .equalsIgnoreCase(fts.getFeatureTypeName()))) {
                // get applicable rules at the current scale
                Rule[] rules = fts.getRules();
                List<Rule> ruleList = new ArrayList<Rule>();
                List<Rule> elseRuleList = new ArrayList<Rule>();
                
                // TODO process filter for geometry expressions and restrict bbox further based on 
                // the result
                
                for( int j = 0; j < rules.length; j++ ) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine("processing rule " + j);
                    }

                    Rule r = rules[j];
                    Filter f = r.getFilter();
                    if(f != null) {
                    	GeometryFilterChecker checker = new GeometryFilterChecker();
                        f.accept(checker, null);
                        // geometry filters are quite unlikely in SLD, but if we have any,
                        // we need to reproject it to screen space since geometries are
                        // read directly in screen space
                        if(checker.isGeometryFilterPresent()) {
                        	// make copy so we don't modify the style
                        	DuplicatingStyleVisitor duplicator = new DuplicatingStyleVisitor();
                            r.accept(duplicator);
                            r=(Rule) duplicator.getCopy();
                            
                            FilterTransformer transformer= new  FilterTransformer(mt);
                            r.setFilter((Filter) r.getFilter().accept(transformer, null));
                        }
                    }
                    if (isWithInScale(r)) {
                        if (r.hasElseFilter()) {
                            elseRuleList.add(r);
                        } else {
                            ruleList.add(r);
                        }
                    }
                }

                // apply uom rescaling
                double pixelsPerMeters = RendererUtilities.calculatePixelsPerMeterRatio(scaleDenominator, rendererHints);
                UomRescaleStyleVisitor rescaleVisitor = new UomRescaleStyleVisitor(pixelsPerMeters);
                for (int j = 0; j < ruleList.size(); j++) {
                    rescaleVisitor.visit(ruleList.get(j));
                    ruleList.set(j, (Rule) rescaleVisitor.getCopy());
                }
                for (int j = 0; j < elseRuleList.size(); j++) {
                    rescaleVisitor.visit(elseRuleList.get(j));
                    elseRuleList.set(j, (Rule) rescaleVisitor.getCopy());
                }
                
                // apply dpi rescale
                double dpi = RendererUtilities.getDpi(getRendererHints());
                double standardDpi = RendererUtilities.getDpi(Collections.emptyMap());
                if(dpi != standardDpi) {
                    double scaleFactor = dpi / standardDpi;
                    RescaleStyleVisitor dpiVisitor = new RescaleStyleVisitor(scaleFactor);
                    for (int j = 0; j < ruleList.size(); j++) {
                        dpiVisitor.visit(ruleList.get(j));
                        ruleList.set(j, (Rule) dpiVisitor.getCopy());
                    }
                    for (int j = 0; j < elseRuleList.size(); j++) {
                        dpiVisitor.visit(elseRuleList.get(j));
                        elseRuleList.set(j, (Rule) dpiVisitor.getCopy());
                    }
                }

                // process the features according to the rules
                // TODO: find a better way to declare the scale ranges so that
                // we
                // get style caching also between multiple rendering runs
                NumberRange scaleRange = new NumberRange(scaleDenominator, scaleDenominator);

                Set modifiedFIDs = processTransaction(graphics, bbox, mt, datastore, transaction,
                        typeName, query, ruleList, elseRuleList, scaleRange, layerId);

                // don't try to read the shapefile if there is nothing to draw
                if(ruleList.size() > 0 || elseRuleList.size() > 0)
                	processShapefile(graphics, datastore, bbox,screenSize, mt, info, type, query, ruleList,
                        elseRuleList, modifiedFIDs, scaleRange, layerId);
            }
        }
    }

