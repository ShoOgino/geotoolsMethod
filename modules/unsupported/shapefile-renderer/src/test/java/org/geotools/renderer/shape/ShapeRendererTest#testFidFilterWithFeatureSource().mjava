    /**
     * What an ugly bug! It only happens if the DefaultMapLayer has been created with a
     * FeatureSource (not a FeatureCollection) in combination with ShapefileRenderer. With
     * StramingRenderer it works. Also works with ShapefileRenderer, if the MapLayer is created with
     * a FeatureCollection.
     * 
     * How does this test work: <br/>
     * 1. Using countries.shp which is not standard in this test package. But it's hard to show the
     * bug with lakes. <br/>
     * 2. Putting every third feature into a FidFilter 3. Creating a Style with two rules: First
     * rule paints red borders for all countries. Second rule is filtered by FidS and paints the
     * polygons with a red fill.<br/>
     * 3. Moving the BBOX 20 degree east, so the center is above a feature.<br/>
     * 4. Rendering the image once (this is the correct image!), and remembering the color of the
     * center point.<br/>
     * 5. Zooming in iteratively.. We expect the center point color not to change.<br/>
     * <br/>
     * But it changes with FeatureSource + ShapefileRenderer. Run the test interactively to see how
     * messy it is! <br/>
     * <br/>
     * It happens with lines, points and polygons. For questions contact alfonx on #geotools
     */
    public void testFidFilterWithFeatureSource() throws Exception {
        TestUtilites.INTERACTIVE = INTERACTIVE;

        // Sorry! Not part of this testing resources, but too hard to show it with lakes.
        ShapefileDataStore dataStore = TestUtilites.getDataStore("countries.shp");

        final SimpleFeatureSource featureSource = dataStore
                .getFeatureSource(dataStore.getTypeNames()[0]);
        SimpleFeatureCollection features = featureSource.getFeatures();

        // Preparing the Filter
        Set<FeatureId> selectedFids = new HashSet<FeatureId>();
        {
            Iterator<SimpleFeature> fIt = features.iterator();

            int count = 0;
            while (fIt.hasNext()) {
                SimpleFeature sf = fIt.next();

                // Add every third to the filter
                if (count++ % 3 != 0)
                    continue;

                selectedFids.add(sf.getIdentifier());
            }

            features.close(fIt);
        }
        assertEquals(84, selectedFids.size());
        Id filter = CommonFactoryFinder.getFilterFactory2(null).id(selectedFids);

        // Preparing the Style
        final StyleBuilder SB = new StyleBuilder();
        org.geotools.styling.Rule rule1 = SB.createRule(SB.createLineSymbolizer(Color.red));
        org.geotools.styling.Rule rule2 = SB.createRule(SB.createPolygonSymbolizer(Color.red));
        rule2.setFilter(filter);

        Style style = SB.createStyle();
        assertEquals(0, style.featureTypeStyles().size());

        style.featureTypeStyles().add(
                SB.createFeatureTypeStyle("Feature", new Rule[] { rule1, rule2 }));

        // One featuretypes, two rules
        assertEquals(1, style.featureTypeStyles().size());
        assertEquals(2, style.featureTypeStyles().get(0).rules().size());
        // second rule has a FID filter
        assertTrue(style.featureTypeStyles().get(0).rules().get(1).getFilter() instanceof Id);

        // WORKS: DefaultMapLayer layer = new DefaultMapLayer(featureSource.getFeatures(), style);
        DefaultMapLayer layer = new DefaultMapLayer(featureSource, style);
        MapContext mapContext = new DefaultMapContext();
        mapContext.addLayer(layer);

//        GTRenderer renderer = new StreamingRenderer();
        GTRenderer renderer = new ShapefileRenderer();
        renderer.setContext(mapContext);

        // Moving the bounds "over afrika".
        ReferencedEnvelope fullBounds = features.getBounds();
        fullBounds.translate(20, 0);
        fullBounds = zoomIn(fullBounds);

        BufferedImage correctImage = TestUtilites.showRender("full", renderer, 4000, fullBounds);
        int correctRgb = correctImage.getRGB(150, 150);
        assertEquals(-1, correctRgb);
        {
            ReferencedEnvelope zoomIn = fullBounds;
            for (int i = 1; i < 5; i++) {
                zoomIn = zoomIn(zoomIn);
                BufferedImage testImage = TestUtilites.showRender("zomming in step " + i, renderer,
                        4000, zoomIn);
                int testRgb = testImage.getRGB(150, 150);

                // Because we are zooming "into" the center, the color shouldn't change
                assertEquals(
                        "Just zooming into the mapContext, should not change the color of the center point in this test:",
                        correctRgb, testRgb);
            }
        }
    }

