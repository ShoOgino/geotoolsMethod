    /**
     * Looks up tessellation info for the schema/table.
     *
     * <p>The schema of the tessellation table is:
     *
     * <pre>
     * F_TABLE_SCHEMA VARCHAR(128) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
     * F_TABLE_NAME VARCHAR(128) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
     * F_GEOMETRY_COLUMN VARCHAR(128) CHARACTER SET UNICODE NOT CASESPECIFIC NOT NULL,
     * U_XMIN FLOAT,
     * U_YMIN FLOAT,
     * U_XMAX FLOAT,
     * U_YMAX FLOAT,
     * G_NX INTEGER,
     * G_NY INTEGER,
     * LEVELS INTEGER,
     * SCALE FLOAT,
     * SHIFT INTEGER)
     * </pre>
     */
    List<TessellationInfo> lookupTessellationInfos(
            Connection cx, String schemaName, String tableName, String columnName)
            throws SQLException {

        DatabaseMetaData metadata = cx.getMetaData();
        ResultSet tables =
                metadata.getTables(
                        null,
                        dataStore.escapeNamePattern(metadata, "sysspatial"),
                        dataStore.escapeNamePattern(metadata, TESSELLATION),
                        new String[] {"TABLE"});
        try {
            if (!tables.next()) {
                LOGGER.warning(
                        "sysspatial."
                                + TESSELLATION
                                + " does not exist. Unable to "
                                + " perform spatially index queries.");
                return Collections.emptyList();
            }
        } finally {
            dataStore.closeSafe(tables);
        }

        List<TessellationInfo> tinfos = new ArrayList();

        StringBuffer sql = new StringBuffer();
        sql.append("SELECT * FROM ");
        encodeTableName(SYSSPATIAL, TESSELLATION, sql);

        sql.append(" WHERE ");

        encodeColumnName(null, "F_TABLE_SCHEMA", sql);
        sql.append(" = ?").append(" AND ");

        encodeColumnName(null, "F_TABLE_NAME", sql);
        sql.append(" = ?");

        if (columnName != null) {
            sql.append(" AND ");
            encodeColumnName(null, "F_GEOMETRY_COLUMN", sql);
            sql.append(" = ?");
        }

        LOGGER.fine(sql.toString());
        PreparedStatement ps = cx.prepareStatement(sql.toString());
        try {
            ps.setString(1, schemaName);
            ps.setString(2, tableName);
            if (columnName != null) {
                ps.setString(3, columnName);
            }

            ResultSet rs = ps.executeQuery();
            try {
                if (rs.next()) {
                    TessellationInfo tinfo = new TessellationInfo();
                    tinfo.setUBounds(
                            new Envelope(
                                    rs.getDouble("U_XMIN"),
                                    rs.getDouble("U_XMAX"),
                                    rs.getDouble("U_YMIN"),
                                    rs.getDouble("U_YMAX")));
                    tinfo.setNx(rs.getInt("G_NX"));
                    tinfo.setNy(rs.getInt("G_NY"));
                    tinfo.setLevels(rs.getInt("LEVELS"));
                    tinfo.setScale(rs.getDouble("SCALE"));
                    tinfo.setShift(rs.getInt("SHIFT"));
                    tinfo.setColumName(rs.getString("F_GEOMETRY_COLUMN"));

                    tinfo.setSchemaName(schemaName);
                    tinfo.setTableName(tableName);

                    // look up the spatial index table
                    tables =
                            metadata.getTables(
                                    null,
                                    dataStore.escapeNamePattern(metadata, schemaName),
                                    dataStore.escapeNamePattern(
                                            metadata, tableName + "_" + columnName + "_idx"),
                                    new String[] {"TABLE", "VIEW"});
                    try {
                        if (tables.next()) {
                            tinfo.setIndexTableName(tables.getString("TABLE_NAME"));
                        }
                    } finally {
                        dataStore.closeSafe(tables);
                    }

                    tinfos.add(tinfo);
                }
            } finally {
                dataStore.closeSafe(rs);
            }
        } finally {
            dataStore.closeSafe(ps);
        }

        return tinfos;
    }

