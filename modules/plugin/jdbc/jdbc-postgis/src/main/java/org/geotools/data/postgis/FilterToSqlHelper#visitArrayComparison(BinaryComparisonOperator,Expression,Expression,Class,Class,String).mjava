    void visitArrayComparison(
            BinaryComparisonOperator filter,
            Expression left,
            Expression right,
            Class rightContext,
            Class leftContext,
            String type) {
        String leftCast = "";
        String rightCast = "";
        if (left instanceof PropertyName) {
            rightCast = getArrayTypeCast((PropertyName) left);
        }
        if (right instanceof PropertyName) {
            leftCast = getArrayTypeCast((PropertyName) right);
        }

        try {
            // match any against non array literals? we need custom logic
            MultiValuedFilter.MatchAction matchAction = filter.getMatchAction();
            if ((matchAction == MultiValuedFilter.MatchAction.ANY
                            || matchAction == MultiValuedFilter.MatchAction.ONE)
                    && (!isArray(left) && !isArray(right))) {
                // the only indexable search in this block
                if ("=".equalsIgnoreCase(type) && !isNull(left) && !isNull(right)) {
                    // if using a prepared statement dialect we need the native type info
                    // contained in the AttributeDescriptor to create a SQL array...
                    Object leftArrayContext = getArrayComparisonContext(left, right, leftContext);
                    writeBinaryExpressionMember(left, leftArrayContext);
                    out.write(leftCast);
                    // use the overlap operator to avoid deciding which side is the expression
                    out.write(" && ");
                    Object rightArrayContext = getArrayComparisonContext(right, left, rightContext);
                    writeBinaryExpressionMember(right, rightArrayContext);
                    out.write(rightCast);
                } else {
                    // need to un-nest and apply element by element, this is not indexable
                    if (left instanceof PropertyName) {
                        rightContext = rightContext.getComponentType();
                    }
                    if (right instanceof PropertyName) {
                        leftContext = leftContext.getComponentType();
                    }

                    boolean isPropertyLeft = left instanceof PropertyName;
                    boolean isPropertyRight = right instanceof PropertyName;
                    // un-nesting the array to do element by element comparisons... the
                    // generated "table" has "unnest" as the variable name
                    if (matchAction == MultiValuedFilter.MatchAction.ANY) {
                        out.write("EXISTS ( SELECT * from unnest(");
                    } else {
                        out.write("( SELECT count(*) from unnest(");
                    }
                    if (isPropertyLeft) {
                        left.accept(delegate, null);
                    } else {
                        right.accept(delegate, null);
                    }
                    out.write(") WHERE ");
                    // oh fun, if there are nulls we cannot write the same sql
                    if ((isPropertyLeft && isNull(right))
                            || (isPropertyRight && isNull(left))
                                    && ("=".equalsIgnoreCase(type)
                                            || "!=".equalsIgnoreCase(type))) {
                        if ("=".equalsIgnoreCase(type)) {
                            out.write("unnest is NULL");
                        } else if ("!=".equalsIgnoreCase(type)) {
                            out.write("unnest is NOT NULL");
                        }
                    } else {
                        // no nulls, but we still have to consider the comparison direction
                        if (isPropertyLeft) {
                            out.write("unnest");
                            out.write(" " + type + " ");
                            writeBinaryExpressionMember(right, rightContext);
                        } else {
                            writeBinaryExpressionMember(left, leftContext);
                            out.write(" " + type + " ");
                            out.write("unnest");
                        }
                    }
                    if (matchAction == MultiValuedFilter.MatchAction.ONE) {
                        out.write(") = 1");
                    } else {
                        out.write(")");
                    }
                }
            } else if (matchAction == MultiValuedFilter.MatchAction.ALL
                    || isArray(left)
                    || isArray(right)) {
                // for comparison against array literals we only support match-all style
                // for the user it would be really strange to ask for equality on an array
                // and get a positive match on a partial element overlap (filters build
                // without explicit match action default to "ANY")
                Object leftArrayContext = getArrayComparisonContext(left, right, leftContext);
                writeBinaryExpressionMember(left, leftArrayContext);
                out.write(leftCast);
                out.write(" " + type + " ");
                Object rightArrayContext = getArrayComparisonContext(right, left, rightContext);
                writeBinaryExpressionMember(right, rightArrayContext);
                out.write(rightCast);
            }

        } catch (IOException ioe) {
            throw new RuntimeException("Failed to write out SQL", ioe);
        }
    }

