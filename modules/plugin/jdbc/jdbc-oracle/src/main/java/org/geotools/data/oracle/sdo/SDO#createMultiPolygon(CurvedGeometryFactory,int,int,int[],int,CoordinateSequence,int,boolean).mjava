    /**
     * Create MultiPolygon as encoded by elemInfo.
     * 
     * <p>
     * Encoded as a series polygon triplets in elemInfo:
     * </p>
     * 
     * <ul>
     * <li>
     * STARTING_OFFSET: position in ordinal ordinate array
     * </li>
     * <li>
     * ETYPE: 2003 or 3 for Polygon
     * </li>
     * <li>
     * INTERPRETATION: 1 for straight edges, 3 for rectangle
     * </li>
     * </ul>
     * 
     * <p></p>
     *
     * @param gf Used to construct MultiLineString
     * @param GTYPE Encoding of <b>D</b>imension, <b>L</b>RS and <b>TT</b>ype
     * @param SRID Spatial Reference System
     * @param elemInfo Interpretation of coords
     * @param triplet Triplet in elemInfo to process as a Polygon
     * @param coords Coordinates to interpret using elemInfo
     * @param N Number of triplets (or -1 for rest)
     *
     */
    private static MultiPolygon createMultiPolygon(CurvedGeometryFactory gf,
        final int GTYPE, final int SRID, final int[] elemInfo,
        final int triplet, CoordinateSequence coords, final int N, boolean threeDimensional) {
        final int STARTING_OFFSET = STARTING_OFFSET(elemInfo, triplet);
        final int eTYPE = ETYPE(elemInfo, triplet);
        final int INTERPRETATION = INTERPRETATION(elemInfo, triplet);
        final int LENGTH = coords.size()*D(GTYPE);
        
        if (!(STARTING_OFFSET >= 1) || !(STARTING_OFFSET <= LENGTH))
            throw new IllegalArgumentException("ELEM_INFO STARTING_OFFSET "+STARTING_OFFSET+" inconsistent with ORDINATES length "+coords.size());
        if (!(eTYPE == ETYPE.POLYGON) && !(eTYPE == ETYPE.POLYGON_EXTERIOR)
                && !(eTYPE == ETYPE.FACE_EXTERIOR) && !(eTYPE == ETYPE.FACE_INTERIOR)
                && !(eTYPE == ETYPE.COMPOUND_POLYGON)
                && !(eTYPE == ETYPE.COMPOUND_POLYGON_EXTERIOR))
            throw new IllegalArgumentException("ETYPE "+eTYPE+" inconsistent with expected POLYGON or POLYGON_EXTERIOR");
        if (!(eTYPE == ETYPE.COMPOUND_POLYGON) && !(eTYPE == ETYPE.COMPOUND_POLYGON_EXTERIOR)
                && INTERPRETATION != 1 && INTERPRETATION != 3) {
            LOGGER.warning( "Could not create MultiPolygon with INTERPRETATION "+INTERPRETATION +" - we can only represent 1 for straight edges, or 3 for rectangle");
            return null;
        }
        final int endTriplet = (N != -1) ? (triplet + N)
                                         : ((elemInfo.length / 3) + 1);

        List list = new LinkedList();
        int etype;
POLYGONS: 
        for (int i = triplet;
                (i < endTriplet) && ((etype = ETYPE(elemInfo, i)) != -1);
                i++) {
            if ((etype == ETYPE.POLYGON) || (etype == ETYPE.POLYGON_EXTERIOR)
                    || (etype == ETYPE.FACE_EXTERIOR) || (etype == ETYPE.FACE_INTERIOR)) {
                Polygon poly = createPolygon(gf, GTYPE, SRID, elemInfo, i,
                        coords);
                i += poly.getNumInteriorRing(); // skip interior rings
                list.add(poly);
            } else if (etype == ETYPE.COMPOUND_POLYGON_EXTERIOR || etype == ETYPE.COMPOUND_POLYGON) {
                Polygon poly = createPolygon(gf, GTYPE, SRID, elemInfo, i, coords);
                int curvilinearElementsCount = getCurvilinearElementsCount(poly);
                i += curvilinearElementsCount - 1;
                list.add(poly);
            } else { // not a Polygon - get out here

                break POLYGONS;
            }
        }

        MultiPolygon polys = gf.createMultiPolygon(toPolygonArray(list));
        polys.setSRID(SRID);

        return polys;
    }

