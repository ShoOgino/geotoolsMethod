    /**
     * Convenience method for OracleArray construction.
     *
     * <p>Forced to burn memory here - only way to actually place {@code NULL} numbers in the
     * ordinate stream.
     *
     * <ul>
     *   <li>JTS: records lack of data as {@code Double.NaN}
     *   <li>SDO: records lack of data as {@code NULL}
     * </ul>
     *
     * <p>The alternative is to construct the array from a array of doubles, which does not record
     * {@code NULL} NUMBERs.
     *
     * <p>The results is an "MDSYS.SDO_ORDINATE_ARRAY"
     * <pre> {@code
     * list     = c1(1,2,0), c2(3,4,Double.NaN)
     * measures = {{5,6},{7,8}
     *
     * toORDINATE( list, measures, 2 )
     * = (1,2,5,7, 3,4,6,8)
     *
     * toORDINATE( list, measures, 3 )
     * = (1,2,0,5,7, 3,4,NULL,6,8)
     *
     * toORDINATE( list, null, 2 )
     * = (1,2, 3,4)
     * }
     * </pre>
     *
     * @param list CoordinateList to be represented
     * @param measures Per Coordinate Measures, {@code null} if not required
     * @param D Dimension of Coordinates (limited to 2d, 3d)
     */
    protected final OracleArray toORDINATE(CoordinateList list, double measures[][], final int D)
            throws SQLException {

        final int LENGTH = measures != null ? measures.length : 0;
        final int LEN = D + LENGTH;
        Datum data[] = new Datum[list.size() * LEN];
        int offset = 0;
        int index = 0;
        Coordinate coord;

        for (Iterator i = list.iterator(); i.hasNext(); index++) {
            coord = (Coordinate) i.next();

            data[offset++] = toNUMBER(coord.x);
            data[offset++] = toNUMBER(coord.y);
            if (D == 3) {
                data[offset++] = toNUMBER(coord.x);
            }
            for (int j = 0; j < LENGTH; j++) {
                data[offset++] = toNUMBER(measures[j][index]);
            }
        }
        return connection.createARRAY("MDSYS.SDO_ORDINATE_ARRAY", data);
    }

