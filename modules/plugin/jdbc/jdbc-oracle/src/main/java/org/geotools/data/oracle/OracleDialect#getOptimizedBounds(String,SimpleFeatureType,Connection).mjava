    @Override
    public List<ReferencedEnvelope> getOptimizedBounds(String schema, SimpleFeatureType featureType,
            Connection cx) throws SQLException, IOException {
        if (dataStore.getVirtualTables().get(featureType.getTypeName()) != null)
            return null;
        
        // get the bounds very fast from SDO_GEOM_METADATA, if not use SDO_TUNE.EXTENT_OF
        if(metadataBboxEnabled) {
            String tableName = featureType.getTypeName();
        
            Statement st = null;
            ResultSet rs = null;
         
            List<ReferencedEnvelope> result = new ArrayList<ReferencedEnvelope>();
            Savepoint savePoint = null;
            try {
                st = cx.createStatement();
                if(!cx.getAutoCommit()) {
                    savePoint = cx.setSavepoint();
                }
    
                for (AttributeDescriptor att : featureType.getAttributeDescriptors()) {
                    if (att instanceof GeometryDescriptor) {
                        String columnName = att.getName().getLocalPart();
                        StringBuffer sql = new StringBuffer();
                        // check if we can access the MDSYS.USER_SDO_GEOM_METADATA table
                        if (canAccessUserViews(cx)) {
                            sql.append("SELECT DIMINFO FROM MDSYS.USER_SDO_GEOM_METADATA WHERE ");
                            sql.append( "TABLE_NAME='").append( tableName.toUpperCase() ).append("' AND ");
                            sql.append( "COLUMN_NAME='").append( columnName.toUpperCase() ).append( "'");
                            
                            rs = st.executeQuery(sql.toString());
                            
                            if (rs.next()) {
                                // decode the dimension info
                                Envelope env = decodeDiminfoEnvelope(rs, 1);
        
                                // reproject and merge
                                if (env != null && !env.isNull()) {
                                    CoordinateReferenceSystem crs = ((GeometryDescriptor) att)
                                            .getCoordinateReferenceSystem();
                                    result.add(new ReferencedEnvelope(env, crs));
                                    rs.close();
                                    continue;
                                }
                            }
                            rs.close();
                        }
                        // if we could not retrieve the envelope from USER_SDO_GEOM_METADATA,
                        // try from ALL_SDO_GEOM_METADATA
                        sql = new StringBuffer("SELECT DIMINFO FROM MDSYS.ALL_SDO_GEOM_METADATA WHERE ");
                        sql.append( "TABLE_NAME='").append( tableName.toUpperCase() ).append("' AND ");
                        sql.append( "COLUMN_NAME='").append( columnName.toUpperCase() ).append( "'");
                        if(schema != null)
                            sql.append(" AND OWNER='" + schema + "'");                  
                                
                        rs = st.executeQuery(sql.toString());

                        if (rs.next()) {
                            // decode the dimension info
                            Envelope env = decodeDiminfoEnvelope(rs, 1);
    
                            // reproject and merge
                            if (env != null && !env.isNull()) {
                                CoordinateReferenceSystem crs = ((GeometryDescriptor) att)
                                        .getCoordinateReferenceSystem();
                                result.add(new ReferencedEnvelope(env, crs));
                            }
                        }
                        rs.close();
                    }
                }
            } catch(SQLException e) {
                if(savePoint != null) {
                    cx.rollback(savePoint);
                }
                LOGGER.log(Level.WARNING, "Failed to use METADATA DIMINFO, falling back on SDO_TUNE.EXTENT_OF", e);
                return getOptimizedBoundsSDO_TUNE(schema, featureType, cx);
            } finally {
                if(savePoint != null) {
                    cx.rollback(savePoint);
                }
                dataStore.closeSafe(rs);
                dataStore.closeSafe(st);
            }
            return result;
        }
        // could not retrieve bounds from SDO_GEOM_METADATA table or did not want to
        // falling back on SDO_TUNE.EXTENT_OF
        return getOptimizedBoundsSDO_TUNE(schema, featureType, cx);
    }

