	/**
	 * Creates a mosaic for the provided input parameters.
	 * 
	 * @param location
	 *            path to the directory where to gather the elements for the
	 *            mosaic.
	 * @param indexName
	 *            name to give to this mosaic
	 * @param wildcard
	 *            wildcard to use for walking through files. We are using
	 *            commonsIO for this task
	 * @param absolutePath
	 * 			  tells the catalogue builder to use absolute paths.
	 * @param hints hints to control reader instantiations
	 * @return <code>true</code> if everything is right, <code>false</code>if
	 *         something bad happens, in which case the reason should be logged
	 *         to the logger.
	 */
	static boolean createMosaic(
			final String location, 
			final String indexName,
			final String wildcard, 
			final boolean absolutePath, 
			final Hints hints) {

		// create a mosaic index builder and set the relevant elements
		final CatalogBuilderConfiguration configuration = new CatalogBuilderConfiguration();
		configuration.setAbsolute(absolutePath);
		configuration.setHints(hints);
		configuration.setRootMosaicDirectory(location);
		configuration.setIndexingDirectories(Arrays.asList(location));
		configuration.setIndexName(indexName);

		// look for and indexed.properties file
		final File parent = new File(location);
		final File indexerProperties = new File(parent, INDEXER_PROPERTIES);
		if (Utils.checkFileReadable(indexerProperties)) {
			// load it and parse it
			final Properties props = Utils.loadPropertiesFromURL(DataUtilities
					.fileToURL(indexerProperties));

			// name
			if (props.containsKey(Prop.NAME))
				configuration.setIndexName(props.getProperty(Prop.NAME));

			// absolute
			if (props.containsKey(Prop.ABSOLUTE))
				configuration.setAbsolute(Boolean.valueOf(props
						.getProperty(Prop.ABSOLUTE)));

			// recursive
			if (props.containsKey(Prop.RECURSIVE))
				configuration.setRecursive(Boolean.valueOf(props
						.getProperty(Prop.RECURSIVE)));

			// wildcard
			if (props.containsKey(Prop.WILDCARD))
				configuration.setWildcard(props.getProperty(Prop.WILDCARD));

			// schema
			if (props.containsKey(Prop.SCHEMA))
				configuration.setSchema(props.getProperty(Prop.SCHEMA));

			// time attr
			if (props.containsKey(Prop.TIME_ATTRIBUTE))
				configuration.setTimeAttribute(props.getProperty(Prop.TIME_ATTRIBUTE));
			
			// elevation attr
			if (props.containsKey(Prop.ELEVATION_ATTRIBUTE))
				configuration.setElevationAttribute(props.getProperty(Prop.ELEVATION_ATTRIBUTE));			
			
			// runtime attr
			if (props.containsKey(Prop.RUNTIME_ATTRIBUTE))
				configuration.setRuntimeAttribute(props.getProperty(Prop.RUNTIME_ATTRIBUTE));
			
			// imposed BBOX
			if (props.containsKey(Prop.ENVELOPE2D))
				configuration.setEnvelope2D(props.getProperty(Prop.ENVELOPE2D));	
			
			// imposed Pyramid Layout
			if (props.containsKey(Prop.RESOLUTION_LEVELS))
				configuration.setResolutionLevels(props.getProperty(Prop.RESOLUTION_LEVELS));			

			// collectors
			if (props.containsKey(Prop.PROPERTY_COLLECTORS))
				configuration.setPropertyCollectors(props.getProperty(Prop.PROPERTY_COLLECTORS));
			
			if (props.containsKey(Prop.CACHING))
				configuration.setCaching(Boolean.valueOf(props.getProperty(Prop.CACHING)));
		}

		// create the builder
		final CatalogBuilder catalogBuilder = new CatalogBuilder(configuration);
		// this is going to help us with catching exceptions and logging them
		final Queue<Throwable> exceptions = new LinkedList<Throwable>();
		try {

			final CatalogBuilder.ProcessingEventListener listener = new CatalogBuilder.ProcessingEventListener() {

				@Override
				public void exceptionOccurred(ExceptionEvent event) {
					final Throwable t = event.getException();
					exceptions.add(t);
					if (LOGGER.isLoggable(Level.SEVERE))
						LOGGER.log(Level.SEVERE, t.getLocalizedMessage(), t);

				}

				@Override
				public void getNotification(ProcessingEvent event) {
					if (LOGGER.isLoggable(Level.FINE))
						LOGGER.fine(event.getMessage());

				}

			};
			catalogBuilder.addProcessingEventListener(listener);
			catalogBuilder.run();
		} catch (Throwable e) {
			LOGGER.log(Level.SEVERE, "Unable to build mosaic", e);
			return false;
		} finally {
			catalogBuilder.dispose();
		}

		// check that nothing bad happened
		if (exceptions.size() > 0)
			return false;
		return true;
	}

