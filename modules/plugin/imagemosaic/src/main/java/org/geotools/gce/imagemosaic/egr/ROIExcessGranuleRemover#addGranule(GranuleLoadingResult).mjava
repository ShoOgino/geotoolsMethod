    public boolean addGranule(GranuleLoadingResult result) {
        // check we are working in the uniform CRS case
        CoordinateReferenceSystem granuleCRS =
                result.getGranuleDescriptor().getGranuleEnvelope().getCoordinateReferenceSystem();
        if (granuleCRS != null
                && targetCRS != null
                && !CRS.equalsIgnoreMetadata(granuleCRS, targetCRS)) {
            throw new UnsupportedOperationException(
                    "Excess granule removal not yet supported with heterogeneous CRS");
        }

        // early bail out if possible
        if (binarizator != null && binarizator.isComplete()) {
            return false;
        }

        // get the ROI
        ROI roi = result.getFootprint();
        if (roi == null) {
            // TODO: check if the image has some form transparency (alpha band, palette
            // with fully transparent pixels), binarize it and use it as a ROI?
            final RenderedImage raster = result.getRaster();
            Rectangle bounds =
                    new Rectangle(
                            raster.getMinX(),
                            raster.getMinY(),
                            raster.getWidth(),
                            raster.getHeight());
            roi = new ROIShape(bounds);
        }

        boolean essential;
        if (!roi.getBounds().intersects(rasterBounds)) {
            essential = false;
        } else {
            if (binarizator == null) {
                binarizator =
                        new Binarizator(
                                JTS.toPolygon(rasterBounds),
                                rasterBounds.width,
                                rasterBounds.height,
                                tileWidth,
                                tileHeight);
            }
            essential = binarizator.add(roi);
        }

        return essential;
    }

