    /**
     * Transforms the given resolution levels from a start CRS to a target one.
     *
     * @param resolutionLevels
     * @param fromCRS
     * @param toCRS
     * @param sourceEnvelope
     * @return
     * @throws FactoryException
     * @throws TransformException
     */
    private double[][] transformResolutionLevels(
            double[][] resolutionLevels,
            CoordinateReferenceSystem fromCRS,
            CoordinateReferenceSystem toCRS,
            GeneralEnvelope sourceEnvelope)
            throws FactoryException, TransformException {

        // prepare a set of points at middle of the envelope and their
        // corresponding offsets based on resolutions
        final int numLevels = resolutionLevels.length;
        double[] points = new double[numLevels * 8];
        double baseX = sourceEnvelope.getMedian(0);
        double baseY = sourceEnvelope.getMedian(1);
        for (int i = 0, j = 0; i < numLevels; i++) {
            // delta x point
            points[j++] = baseX;
            points[j++] = baseY;
            points[j++] = baseX + resolutionLevels[i][0];
            points[j++] = baseY;
            // delta y point
            points[j++] = baseX;
            points[j++] = baseY;
            points[j++] = baseX;
            points[j++] = baseY + resolutionLevels[i][1];
        }

        // transform to get offsets in the target CRS
        MathTransform mt = CRS.findMathTransform(fromCRS, toCRS);
        mt.transform(points, 0, points, 0, numLevels * 4);

        // compute back the offsets
        double[][] result = new double[numLevels][2];
        for (int i = 0; i < numLevels; i++) {
            result[i][0] = distance(points, i * 8);
            result[i][1] = distance(points, i * 8 + 4);
        }
        return result;
    }

