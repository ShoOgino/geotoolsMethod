    /**
     * Computes the requested resolution which is going to be used for selecting overviews and or deciding decimation factors on the target coverage.
     * 
     * <p>
     * In case the requested envelope is in the same {@link CoordinateReferenceSystem} of the coverage we compute the resolution using the requested
     * {@link MathTransform}. Notice that it must be a {@link LinearTransform} or else we fail.
     * 
     * <p>
     * In case the requested envelope is not in the same {@link CoordinateReferenceSystem} of the coverage we do an in place reprojection.
     * 
     */
    private void computeResolution() {

        try {

            //
            // the crs of the request and the one of the coverage are NOT the
            // same and the conversion is not , we can get the resolution from envelope + raster directly
            //
            GridGeometry2D gridGeometry;
            if (needsReprojection) {
                final GridToEnvelopeMapper geMapper = new GridToEnvelopeMapper(
                        new GridEnvelope2D(computedRasterArea), computedBBox);
                computedGridToWorld = geMapper.createAffineTransform();
                if (accurateResolution) {
                    gridGeometry = requestedGridGeometry;
                } else {
                    gridGeometry = new GridGeometry2D(new GridEnvelope2D(computedRasterArea),
                            computedBBox);
                }
            } else {
                gridGeometry = requestedGridGeometry;
                computedGridToWorld = requestedGridToWorld;
            }

            ReadResolutionCalculator calculator = new ReadResolutionCalculator(gridGeometry,
                    coverageProperties.crs2D, coverageProperties.fullResolution);
            calculator.setAccurateResolution(accurateResolution);
            computedResolution = calculator
                    .computeRequestedResolution(ReferencedEnvelope.reference(computedBBox));

            // leave
            return;
        } catch (Throwable e) {
            if (LOGGER.isLoggable(Level.INFO))
                LOGGER.log(Level.INFO, "Unable to compute requested resolution", e);
        }

        //
        // use the coverage resolution since we cannot compute the requested one, this can be problematic but at least keep us going
        //
        LOGGER.log(Level.WARNING,
                "Unable to compute requested resolution, using highest available");
        computedResolution = coverageProperties.fullResolution;

    }

