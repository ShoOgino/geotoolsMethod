        /**
         * This method accepts incming granules and dispatch them to the correct {@link GranuleCollector} depending on the internal {@link Filter} per
         * the dimension.
         * 
         * <p>
         * If not {@link MergeBehavior#STACK}ing is required, we collect them all together with an include filter.
         */
        public void visit(GranuleDescriptor granuleDescriptor, Object o) {

            //
            // load raster data
            //
            // create a granuleDescriptor loader
            final Geometry bb = JTS.toGeometry((BoundingBox) mosaicBBox);
            final Geometry inclusionGeometry = granuleDescriptor.getFootprint();
            if (!footprintBehavior.handleFootprints() || inclusionGeometry == null
                    || (footprintBehavior.handleFootprints() && inclusionGeometry.intersects(bb))) {

                // find the right filter for this granule
                boolean found = false;
                for (GranuleCollector collector : granuleCollectors) {
                    if (collector.accept(granuleDescriptor)) {
                        granulesNumber++;
                        found = true;
                        break;
                    }
                }

                // did we find a place for it?
                if (!found) {
                    throw new IllegalStateException("Unable to locate a filter for this granule:\n"
                            + granuleDescriptor.toString());
                }

            } else {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("We rejected for non ROI inclusion the granule "
                            + granuleDescriptor.toString());
                }
            }
        }

