    /**
     * Set proper fields from the specified input parameter.
     * 
     * @param param the input {@code ParamaterValue} object
     * @param name the name of the parameter
     */
    private void extractParameter(ParameterValue<?> param, Identifier name) {

        // //
        //
        // Requested GridGeometry2D parameter
        //
        // //
        if (name.equals(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            final GridGeometry2D gg = (GridGeometry2D) value;
            this.requestedBounds = gg.getEnvelope2D();
            
            if (rasterManager.getConfiguration().getCatalogConfigurationBean()
                    .isHeterogeneousCRS()) {
                GridEnvelope2D paddedRange = new GridEnvelope2D(gg.getGridRange2D());
                paddedRange.setBounds(paddedRange.x - DEFAULT_PADDING,
                        paddedRange.y - DEFAULT_PADDING, paddedRange.width + DEFAULT_PADDING * 2,
                        paddedRange.height + DEFAULT_PADDING * 2);

                GridGeometry2D padded = new GridGeometry2D(paddedRange, gg.getGridToCRS(),
                        gg.getCoordinateReferenceSystem());
                spatialRequestHelper.setRequestedGridGeometry(padded.toCanonical());
            } else {
                spatialRequestHelper.setRequestedGridGeometry(gg.toCanonical());
            }
            return;
        }

        // //
        //
        // Use JAI ImageRead parameter
        //
        // //
        if (name.equals(AbstractGridFormat.USE_JAI_IMAGEREAD.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            readType = param.booleanValue() ? ReadType.JAI_IMAGEREAD : ReadType.DIRECT_READ;
            return;
        }

        // //
        //
        // Sort clause
        //
        // //
        if (name.equals(ImageMosaicFormat.SORT_BY.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            sortClause = param.stringValue();
            return;
        }

        // //
        //
        // Merge Behavior
        //
        // //
        if (name.equals(ImageMosaicFormat.MERGE_BEHAVIOR.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            mergeBehavior = MergeBehavior.valueOf(param.stringValue().toUpperCase());
            return;
        }

        // //
        //
        // Overview Policy parameter
        //
        // //
        if (name.equals(AbstractGridFormat.OVERVIEW_POLICY.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            overviewPolicy = (OverviewPolicy) value;
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Requested OverviewPolicy: " + overviewPolicy);
            }
            return;
        }

        // //
        //
        // Decimation Policy parameter
        //
        // //
        if (name.equals(AbstractGridFormat.DECIMATION_POLICY.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            decimationPolicy = (DecimationPolicy) value;
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Requested DecimationPolicy: " + decimationPolicy);
            }
            return;
        }

        // //
        //
        // Interpolation parameter
        //
        // //
        if (name.equals(ImageMosaicFormat.INTERPOLATION.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            interpolation = (Interpolation) value;
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Requested interpolation: " + interpolation);
            }
            return;
        }

        if (name.equals(AbstractGridFormat.INPUT_TRANSPARENT_COLOR.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            inputTransparentColor = (Color) value;
            // paranoiac check on the provided transparent color
            inputTransparentColor = new Color(inputTransparentColor.getRed(),
                    inputTransparentColor.getGreen(), inputTransparentColor.getBlue());
            return;

        }

        if (name.equals(ImageMosaicFormat.FADING.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            blend = ((Boolean) value).booleanValue();
            return;

        }
        if (name.equals(ImageMosaicFormat.OUTPUT_TRANSPARENT_COLOR.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            outputTransparentColor = (Color) value;
            // paranoiac check on the provided transparent color
            outputTransparentColor = new Color(outputTransparentColor.getRed(),
                    outputTransparentColor.getGreen(), outputTransparentColor.getBlue());
            return;

        }

        if (name.equals(ImageMosaicFormat.BACKGROUND_VALUES.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            backgroundValues = (double[]) value;
            return;

        }

        if (name.equals(ImageMosaicFormat.MAX_ALLOWED_TILES.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            maximumNumberOfGranules = param.intValue();
            return;
        }

        if (name.equals(ImageMosaicFormat.DEFAULT_ARTIFACTS_FILTER_THRESHOLD.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            defaultArtifactsFilterThreshold = param.intValue();
            return;
        }

        if (name.equals(ImageMosaicFormat.ARTIFACTS_FILTER_PTILE_THRESHOLD.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            artifactsFilterPTileThreshold = param.doubleValue();
            return;
        }

        if (name.equals(ImageMosaicFormat.ALLOW_MULTITHREADING.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            multithreadingAllowed = ((Boolean) value).booleanValue();
            return;
        }

        if (name.equals(AbstractGridFormat.FOOTPRINT_BEHAVIOR.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            footprintBehavior = FootprintBehavior.valueOf((String) value);
            return;
        }

        if (name.equals(ImageMosaicFormat.ACCURATE_RESOLUTION.getName())) {
            final Object value = param.getValue();
            if (value == null) {
                return;
            }
            accurateResolution = ((Boolean) value).booleanValue();
            return;
        }

        // //
        //
        // Suggested tile size parameter. It must be specified with
        // the syntax: "TileWidth,TileHeight" (without quotes where TileWidth
        // and TileHeight are integer values)
        //
        // //
        if (name.equals(AbstractGridFormat.SUGGESTED_TILE_SIZE.getName())) {
            final String suggestedTileSize = (String) param.getValue();

            // Preliminary checks on parameter value
            if ((suggestedTileSize != null) && (suggestedTileSize.trim().length() > 0)) {

                if (suggestedTileSize.contains(AbstractGridFormat.TILE_SIZE_SEPARATOR)) {
                    final String[] tilesSize = suggestedTileSize
                            .split(AbstractGridFormat.TILE_SIZE_SEPARATOR);
                    if (tilesSize.length == 2) {
                        try {
                            // Getting suggested tile size
                            final int tileWidth = Integer.valueOf(tilesSize[0].trim());
                            final int tileHeight = Integer.valueOf(tilesSize[1].trim());
                            tileDimensions = new Dimension(tileWidth, tileHeight);
                        } catch (NumberFormatException nfe) {
                            if (LOGGER.isLoggable(Level.WARNING)) {
                                LOGGER.log(Level.WARNING,
                                        "Unable to parse " + "suggested tile size parameter");
                            }
                        }
                    }
                }
            }
        }

        // //
        //
        // Time parameter
        //
        // //
        if (name.equals(ImageMosaicFormat.TIME.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            final List<?> dates = (List<?>) value;
            if (dates == null || dates.size() <= 0) {
                return;
            }

            requestedTimes = dates;
            return;
        }

        //
        //
        // Elevation parameter
        //
        // //
        if (name.equals(ImageMosaicFormat.ELEVATION.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            elevation = (List<?>) value;
            return;
        }

        // //
        //
        // Runtime parameter
        //
        // //
        if (name.equals(ImageMosaicFormat.FILTER.getName())) {
            final Object value = param.getValue();
            if (value == null)
                return;
            filter = (Filter) value;
            return;
        }

        // //
        //
        // Additional dimension parameter check
        //
        // //
        String paramName = name.getCode();
        if (rasterManager.domainsManager != null
                && rasterManager.domainsManager.isParameterSupported(name)) {
            final Object value = param.getValue();
            if (value == null) {
                return;
            }
            if (value instanceof List) {
                List values = (List) value; // we are assuming it is a list !!!
                // remove last comma
                requestedAdditionalDomains.put(paramName, values);

            }
            return;
        }

        // setup the the bands parameter which defines the order and the bands that should be returned
        if (name.equals(ImageMosaicFormat.BANDS.getName())) {
            // if the parameter is NULL no problem
            bands = (int[]) param.getValue();
        }

        // see if we have to perform excess granule removal
        if (name.equals(ImageMosaicFormat.EXCESS_GRANULE_REMOVAL.getName())) {
            final Object value = param.getValue();
            if (value == null) {
                return;
            }
            excessGranuleRemovalPolicy = (ExcessGranulePolicy) value;
            return;
        }

    }

