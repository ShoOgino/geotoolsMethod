	private RenderedImage postProcessRaster(RenderedImage mosaic) {
		// alpha on the final mosaic
		if (finalTransparentColor != null) {
			if (LOGGER.isLoggable(Level.FINE))
				LOGGER.fine("Support for alpha on final mosaic");
			return ImageUtilities.maskColor(finalTransparentColor,mosaic);

		}
		if (!needsReprojection){
		    try {
		        
		        // creating source grid to world corrected to the pixel corner
                        final AffineTransform sourceGridToWorld = new AffineTransform((AffineTransform) finalGridToWorldCorner);
		        
		        // target world to grid at the corner
                        final AffineTransform targetGridToWorld = new AffineTransform(request.getRequestedGridToWorld());
                        targetGridToWorld.concatenate(CoverageUtilities.CENTER_TO_CORNER);
                        
                        // target world to grid at the corner
                        final AffineTransform targetWorldToGrid=targetGridToWorld.createInverse();
                        // final complete transformation
                        targetWorldToGrid.concatenate(sourceGridToWorld);
                        
                        //update final grid to world
                        finalGridToWorldCorner=new AffineTransform2D(targetGridToWorld);
		        
		        // create final image
		        // TODO this one could be optimized further depending on how the affine is created
		        //
                        // In case we are asked to use certain tile dimensions we tile
                        // also at this stage in case the read type is Direct since
                        // buffered images comes up untiled and this can affect the
                        // performances of the subsequent affine operation.
                        //
		        final Hints localHints= new Hints(hints);
                        if (hints != null && !hints.containsKey(JAI.KEY_BORDER_EXTENDER)) {
                            final Object extender = hints.get(JAI.KEY_BORDER_EXTENDER);
                            if (!(extender != null && extender instanceof BorderExtender)) {
                                localHints.add(ImageUtilities.BORDER_EXTENDER_HINTS);
                            }
                        }
	        
                        mosaic = AffineDescriptor.create(mosaic, targetWorldToGrid , interpolation, backgroundValues, localHints);
                    } catch (NoninvertibleTransformException e) {
                        if (LOGGER.isLoggable(Level.SEVERE)){
                            LOGGER.log(Level.SEVERE, "Unable to create the requested mosaic ", e );
                        }
                    }
		}
		return mosaic;
	}

