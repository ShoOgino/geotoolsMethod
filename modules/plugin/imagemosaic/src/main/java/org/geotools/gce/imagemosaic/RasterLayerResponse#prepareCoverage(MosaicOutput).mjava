    /**
     * This method is responsible for creating a coverage from the supplied {@link RenderedImage}.
     */
    private GridCoverage2D prepareCoverage(MosaicOutput mosaicOutput) throws IOException {

        // creating bands
        final RenderedImage image = mosaicOutput.image;
        final SampleModel sm = image.getSampleModel();
        final ColorModel cm = image.getColorModel();
        final int numBands = request.getBands() == null ? sm.getNumBands() : request.getBands().length;
        // quick check the possible provided bands names are equal the number of bands
        if (rasterManager.providedBandsNames != null && rasterManager.providedBandsNames.length != numBands) {
            // let's see if bands have been selected
            if (request.getBands() == null) {
                // no definitively there is something wrong
                throw new IllegalArgumentException("The number of provided bands names is different from the number of bands.");
            }
        }
        final GridSampleDimension[] bands = new GridSampleDimension[numBands];
        Set<String> bandNames = new HashSet<String>();
        // setting bands names.
        for (int i = 0; i < numBands; i++) {
            ColorInterpretation colorInterpretation = null;
            String bandName = null;

            // checking if bands names are provided, typical case for multiple bands dimensions
            if (rasterManager.providedBandsNames != null) {
                // we need to take in consideration if bands were selected
                if (request.getBands() == null) {
                    bandName = rasterManager.providedBandsNames[i];
                } else {
                    // using the selected band index to retrieve the correct provided name
                    bandName = rasterManager.providedBandsNames[request.getBands()[i]];
                }
            }

            if (cm != null) {
                // === color interpretation
                colorInterpretation = TypeMap.getColorInterpretation(cm, i);
                if (colorInterpretation == null) {
                    throw new IOException("Unrecognized sample dimension type");
                }

                if (bandName == null) {
                    bandName = colorInterpretation.name();
                    if (colorInterpretation == ColorInterpretation.UNDEFINED
                            || bandNames.contains(bandName)) {// make sure we create no duplicate band names
                        bandName = "Band" + (i + 1);
                    }
                }
            } else { // no color model
                if (bandName == null) {
                    bandName = "Band" + (i + 1);
                }
                colorInterpretation = ColorInterpretation.UNDEFINED;
            }

            // sample dimension type
            final SampleDimensionType st = TypeMap.getSampleDimensionType(sm, i);

            // set some no data values, as well as Min and Max values
            final double noData;
            double min = -Double.MAX_VALUE, max = Double.MAX_VALUE;
            Double noDataAsProperty = getNoDataProperty(image);
            if (noDataAsProperty != null) {
                noData = noDataAsProperty.doubleValue();
            } else if (backgroundValues != null) {
                // sometimes background values are not specified as 1 per each band, therefore we need to be careful
                noData = backgroundValues[backgroundValues.length > i ? i : 0];
            } else {
                if (st.compareTo(SampleDimensionType.REAL_32BITS) == 0)
                    noData = Float.NaN;
                else if (st.compareTo(SampleDimensionType.REAL_64BITS) == 0)
                    noData = Double.NaN;
                else if (st.compareTo(SampleDimensionType.SIGNED_16BITS) == 0) {
                    noData = Short.MIN_VALUE;
                    min = Short.MIN_VALUE;
                    max = Short.MAX_VALUE;
                } else if (st.compareTo(SampleDimensionType.SIGNED_32BITS) == 0) {
                    noData = Integer.MIN_VALUE;

                    min = Integer.MIN_VALUE;
                    max = Integer.MAX_VALUE;
                } else if (st.compareTo(SampleDimensionType.SIGNED_8BITS) == 0) {
                    noData = -128;
                    min = -128;
                    max = 127;
                } else {
                    // unsigned
                    noData = 0;
                    min = 0;

                    // compute max
                    if (st.compareTo(SampleDimensionType.UNSIGNED_1BIT) == 0)
                        max = 1;
                    else if (st.compareTo(SampleDimensionType.UNSIGNED_2BITS) == 0)
                        max = 3;
                    else if (st.compareTo(SampleDimensionType.UNSIGNED_4BITS) == 0)
                        max = 7;
                    else if (st.compareTo(SampleDimensionType.UNSIGNED_8BITS) == 0)
                        max = 255;
                    else if (st.compareTo(SampleDimensionType.UNSIGNED_16BITS) == 0)
                        max = 65535;
                    else if (st.compareTo(SampleDimensionType.UNSIGNED_32BITS) == 0)
                        max = Math.pow(2, 32) - 1;

                }

            }
            bands[i] = new SimplifiedGridSampleDimension(bandName, st, colorInterpretation, noData,
                    min, max, 1, // no scale
                    0, // no offset
                    null);
        }

        // creating the final coverage by keeping into account the fact that we
        Map<String, Object> properties = new HashMap<String, Object>();
        if (granulesPaths != null) {
            properties.put(GridCoverage2DReader.FILE_SOURCE_PROPERTY, granulesPaths);
        }
        if (sourceUrl != null) {
            properties.put(GridCoverage2DReader.SOURCE_URL_PROPERTY, sourceUrl);
        }
        if (mosaicOutput.pamDataset != null) {
            properties.put(Utils.PAM_DATASET, mosaicOutput.pamDataset);
        }
        // Setting NoData as the NoData for the first Band
        ImageWorker w = new ImageWorker(image);
        CoverageUtilities.setNoDataProperty(properties, w.getNoData());
        // Setting ROI property
        Object property = image.getProperty("ROI");
        if (property != null && property instanceof ROI) {
            CoverageUtilities.setROIProperty(properties, (ROI) property);
        }

        return coverageFactory.create(rasterManager.getCoverageIdentifier(), image,
                new GridGeometry2D(
                        new GridEnvelope2D(PlanarImage.wrapRenderedImage(image).getBounds()),
                        PixelInCell.CELL_CORNER, finalGridToWorldCorner,
                        this.mosaicBBox.getCoordinateReferenceSystem(), hints),
                bands, null, properties);
    }

