		@Override
		protected void handleFile(final File fileBeingProcessed, final int depth, final Collection results)
				throws IOException {
			
			// increment counter
			fileIndex++;

			//
			// Check that this file is actually good to go
			//
			if(!checkFile(fileBeingProcessed))
				return;

		
			// replacing chars on input path
			String validFileName;
			try {
				validFileName = fileBeingProcessed.getCanonicalPath();
				validFileName=FilenameUtils.normalize(validFileName);
			} catch (IOException e1) {
				fireException(e1);
				return;
			}
			validFileName=FilenameUtils.getName(validFileName);
			fireEvent(Level.INFO,"Now indexing file "+validFileName, ((fileIndex * 100.0) / numFiles));
			ImageInputStream inStream=null;
			ImageReader imageioReader = null;
			AbstractGridCoverage2DReader coverageReader=null;
			try {
				//
				// STEP 1
				// Getting an ImageIO reader for this coverage.
				//
				inStream = ImageIO.createImageInputStream(fileBeingProcessed);
				if(inStream==null) {
					fireEvent(Level.INFO,fileBeingProcessed+" has been skipped since we could not get a stream for it", ((fileIndex * 100.0) / numFiles));
					return;
				}
				inStream.mark();
				
				
				cachedSPITest: {
					// there is no cached reader spi, let's look for one
					if(cachedSPI==null){
						final Iterator<ImageReader> it = ImageIO.getImageReaders(inStream);
						if (it.hasNext()) {
							imageioReader = it.next();
							if(imageioReader!=null){
								//cache the SPI
								cachedSPI=imageioReader.getOriginatingProvider();
								imageioReader.setInput(inStream);
							}
						} else {
							imageioReader=null;
						}
					} else {
						// we have a cached SPI, let's try to use it
						if(!cachedSPI.canDecodeInput(inStream)){				
							// the SPI is no good for this input
							cachedSPI=null;
							//take me to the SPI search
							break cachedSPITest;
						}
						// the spi is good
						imageioReader=cachedSPI.createReaderInstance();
						imageioReader.setInput(inStream);
					}
				}
				// did we found a reader
				if (imageioReader == null) {
					// send a message
					fireEvent(Level.INFO,new StringBuilder("Skipped file ").append(fileBeingProcessed).append(":No ImageIO reader	s availaible.").toString(), ((fileIndex * 99.0) / numFiles));
					return;
				}


				//Append
				// STEP 2
				// Getting a coverage reader for this coverage.
				//
				final AbstractGridFormat format;
				if(cachedFormat == null) {
					format= (AbstractGridFormat) GridFormatFinder.findFormat(fileBeingProcessed);
				} else {
					if(cachedFormat.accepts(fileBeingProcessed)) {
						format=cachedFormat;
					} else {
						format=new UnknownFormat();
					}
				}
				if ((format instanceof UnknownFormat)||format == null) {
					fireEvent(Level.INFO,new StringBuilder("Skipped file ").append(fileBeingProcessed).append(": File format is not supported.").toString(), ((fileIndex * 99.0) / numFiles));
					return;
				}
				cachedFormat=format;
				coverageReader = (AbstractGridCoverage2DReader) format.getReader(fileBeingProcessed,runConfiguration.getHints());
				GeneralEnvelope envelope = (GeneralEnvelope) coverageReader.getOriginalEnvelope();
				CoordinateReferenceSystem actualCRS = coverageReader.getCrs();

				//
				// STEP 3
				// Get the type specifier for this image and the check that the
				// image has the correct sample model and color model.
				// If this is the first cycle of the loop we initialize everything.
				//
				final ImageTypeSpecifier its = ((ImageTypeSpecifier) imageioReader.getImageTypes(0).next());
				if (numberOfProcessedFiles==0) {
					// /////////////////////////////////////////////////////////////////////
					//
					// at the first step we initialize everything that we will
					// reuse afterwards starting with color models, sample
					// models, crs, etc....
					//
					// /////////////////////////////////////////////////////////////////////
					defaultCM = its.getColorModel();
					defaultSM = its.getSampleModel();
					if (defaultCM instanceof IndexColorModel) {
						IndexColorModel icm = (IndexColorModel) defaultCM;
						int numBands = defaultCM.getNumColorComponents();
						defaultPalette = new byte[3][icm.getMapSize()];
						icm.getReds(defaultPalette[0]);
						icm.getGreens(defaultPalette[0]);
						icm.getBlues(defaultPalette[0]);
						if (numBands == 4)
							icm.getAlphas(defaultPalette[0]);

					}
					defaultCRS = actualCRS;

					// /////////////////////////////////////////////////////////////////////
					//
					// getting information about resolution
					//
					// /////////////////////////////////////////////////////////////////////


					// get the dimension of the hr image and build the model
					// as well as computing the resolution
					// 
					// resetting reader and recreating stream, turnaround for a
					// strange imageio bug that sometimes pops up
					imageioReader.reset();
					try {
						inStream.reset();
					} catch (IOException e) {
						//close me and reopen me
						try {
							inStream.close();
						} catch (Throwable e1) {
							if(LOGGER.isLoggable(Level.FINE))
								LOGGER.log(Level.FINE,e1.getLocalizedMessage(),e1);
						}
						inStream= ImageIO.createImageInputStream(fileBeingProcessed);
					}
					
					//let's check if we got something now
					if(inStream==null) {
						//skip file
						fireEvent(Level.INFO,fileBeingProcessed+" has been skipped since we could not get a stream for it", ((fileIndex * 100.0) / numFiles));
						return;
					}
					imageioReader.setInput(inStream);
					int numberOfLevels = imageioReader.getNumImages(true);
					double[][] resolutionLevels = new double[2][numberOfLevels];
					setupResolutions(resolutionLevels, numberOfLevels, coverageReader, imageioReader, null);
					mosaicConfiguration.setLevelsNum(numberOfLevels);
					mosaicConfiguration.setLevels(resolutionLevels);

					// /////////////////////////////////////////////////////////////////////
					//
					// creating the schema
					//
					// /////////////////////////////////////////////////////////////////////
					final String schemaDef= runConfiguration.getSchema();
					if(schemaDef!=null){
						// get the schema
						try{
							indexSchema=DataUtilities.createType(mosaicConfiguration.getName(), runConfiguration.getSchema());
							//override the crs in case the provided one was wrong or absent
							indexSchema=DataUtilities.createSubType(indexSchema, DataUtilities.attributeNames(indexSchema), actualCRS);
						}
						catch (Throwable e) {
							if(LOGGER.isLoggable(Level.FINE))
								LOGGER.log(Level.FINE,e.getLocalizedMessage(),e);
							indexSchema=null;
						}
					}
					if(indexSchema==null){
						final SimpleFeatureTypeBuilder featureBuilder = new SimpleFeatureTypeBuilder();
						featureBuilder.setName(runConfiguration.getIndexName());
						featureBuilder.setNamespaceURI("http://www.geo-solutions.it/");
						featureBuilder.add(runConfiguration.getLocationAttribute(), String.class);
						featureBuilder.add("the_geom", Polygon.class,actualCRS);
						featureBuilder.setDefaultGeometry("the_geom");
						if(runConfiguration.getTimeAttribute()!=null)
							featureBuilder.add(runConfiguration.getTimeAttribute(), Date.class);
						indexSchema = featureBuilder.buildFeatureType();
					}
					// create the schema for the new shape file
					catalog.createType(indexSchema);
					
				} else {
				    if (!mosaicConfiguration.isHeterogeneous()){
				        // //
				        //
				        // There is no need to check resolutions if the mosaic
				        // has been already marked as heterogeneous
				        //
				        // //
				        int numberOfLevels = imageioReader.getNumImages(true);
                                        if (numberOfLevels != mosaicConfiguration.getLevelsNum()) {
                                            mosaicConfiguration.setHeterogeneous(true);
                                            if (numberOfLevels > mosaicConfiguration.getLevelsNum()){
                                                final double[][] resolutionLevels = new double[2][numberOfLevels];
                                                setupResolutions(resolutionLevels, numberOfLevels, coverageReader, imageioReader, null);
                                                mosaicConfiguration.setLevelsNum(numberOfLevels);
                                                mosaicConfiguration.setLevels(resolutionLevels);
                                            }
                                        } else {
                                            final double[][] mosaicLevels = mosaicConfiguration.getLevels();
                                            final double[][] resolutionLevels = new double[2][numberOfLevels];
                                            final boolean homogeneousLevels = setupResolutions(resolutionLevels, numberOfLevels, coverageReader, imageioReader, mosaicLevels);
                                            if (!homogeneousLevels){
                                                mosaicConfiguration.setHeterogeneous(true);
                                            }
                                        }
				    }
				    
				    
					// ////////////////////////////////////////////////////////
					// 
					// comparing ColorModel
					// comparing SampeModel
					// comparing CRSs
					// ////////////////////////////////////////////////////////
					ColorModel actualCM = its.getColorModel();
					if((fileIndex > 0 ? !(CRS.equalsIgnoreMetadata(defaultCRS, actualCRS)) : false)){
						fireEvent(
								Level.INFO,
								new StringBuilder("Skipping image ").append(fileBeingProcessed).append(" because CRSs do not match.").toString(),
								(((fileIndex + 1) * 99.0) / numFiles));
						return;
					}
					
					if(checkColorModels(defaultCM, defaultPalette,actualCM)){
						fireEvent(
								Level.INFO,
								new StringBuilder("Skipping image ").append(fileBeingProcessed).append(" because color models do not match.").toString(),
								(((fileIndex + 1) * 99.0) / numFiles));
						return;
					}							
				}

				// ////////////////////////////////////////////////////////
				//
				// STEP 4
				//
				// create and store features
				//
				// ////////////////////////////////////////////////////////
				final SimpleFeature feature = DataUtilities.template(indexSchema);
				feature.setAttribute(indexSchema.getGeometryDescriptor().getLocalName(), geomFactory.toGeometry(new ReferencedEnvelope((Envelope) envelope)));
				feature.setAttribute(runConfiguration.getLocationAttribute(), prepareLocation(fileBeingProcessed));
				
				// collect and dump properties
				if(propertiesCollectors!=null&&propertiesCollectors.size()>0)
					for(PropertiesCollector pc: propertiesCollectors)
					{
						pc.collect(fileBeingProcessed).collect(coverageReader).collect(imageioReader).setProperties(feature);
						pc.reset();
					}

				catalog.addGranule(feature,transaction);

				// fire event
				fireEvent(Level.FINE,"Done with file "+fileBeingProcessed, (((fileIndex + 1) * 99.0) / numFiles));
			

				// advance files
				numberOfProcessedFiles++;
			} catch (IOException e) {
				fireException(e);
				return;
			} catch (ArrayIndexOutOfBoundsException e) {
				fireException(e);
				return;
			} 
			finally{
				// ////////////////////////////////////////////////////////
				//
				// STEP 5
				//
				// release resources
				//
				// ////////////////////////////////////////////////////////
				try {
					if(inStream!=null)
						inStream.close();
				} catch (Throwable e) {
					// ignore exception
					if(LOGGER.isLoggable(Level.FINEST))
						LOGGER.log(Level.FINEST,e.getLocalizedMessage(),e);
				}
				try {
					if(imageioReader!=null)
						imageioReader.dispose();
				} catch (Throwable e) {
					// ignore exception
					if(LOGGER.isLoggable(Level.FINEST))
						LOGGER.log(Level.FINEST,e.getLocalizedMessage(),e);					
				}				
		
				
				try {
					if(coverageReader!=null)
						// release resources
						coverageReader.dispose();
				} catch (Throwable e) {
					// ignore exception
					if(LOGGER.isLoggable(Level.FINEST))
						LOGGER.log(Level.FINEST,e.getLocalizedMessage(),e);					
				}
			}
		
			
			super.handleFile(fileBeingProcessed, depth, results);
		}

