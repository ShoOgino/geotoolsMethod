        /**
         * This method is responsible for creating {@link Filter} that encompasses the provided
         * {@link List} of values for this {@link DomainManager}.
         *
         * @param values the {@link List} of values to use for building the containment {@link
         *     Filter}.
         * @return a {@link Filter} that encompasses the provided {@link List} of values for this
         *     {@link DomainManager}.
         */
        private Filter createFilter(List values) {

            // === create the filter
            // loop values and AND them
            final List<Filter> filters = new ArrayList<>();
            FilterFactory2 ff = FeatureUtilities.DEFAULT_FILTER_FACTORY;
            for (Object value : values) {
                // checks
                if (value == null) {
                    if (LOGGER.isLoggable(Level.INFO)) {
                        LOGGER.info("Ignoring null date for the filter:" + this.identifier);
                    }
                    continue;
                }
                if (domainType == DomainType.SINGLE_VALUE) {
                    // Domain made of single values
                    if (value instanceof Range) {
                        // RANGE
                        final Range range = (Range) value;
                        filters.add(
                                ff.and(
                                        ff.lessOrEqual(
                                                ff.property(propertyName),
                                                ff.literal(range.getMaxValue())),
                                        ff.greaterOrEqual(
                                                ff.property(propertyName),
                                                ff.literal(range.getMinValue()))));
                    } else {
                        // SINGLE value
                        filters.add(ff.equal(ff.property(propertyName), ff.literal(value), true));
                    }
                } else { // domainType == DomainType.RANGE
                    // Domain made of ranges such as (beginTime,endTime) ,
                    // (beginElevation,endElevation) , ...
                    if (value instanceof Range) {
                        // RANGE
                        final Range range = (Range) value;
                        final Comparable maxValue = range.getMaxValue();
                        final Comparable minValue = range.getMinValue();
                        if (maxValue.compareTo(minValue) != 0) {
                            // logic comes from Range.intersectsNC(Range)
                            // in summary, requestedMax > min && requestedMin < max
                            Filter maxCondition =
                                    ff.greaterOrEqual(
                                            ff.literal(maxValue), ff.property(propertyName));
                            Filter minCondition =
                                    ff.lessOrEqual(
                                            ff.literal(minValue),
                                            ff.property(additionalPropertyName));

                            filters.add(ff.and(Arrays.asList(maxCondition, minCondition)));
                            continue;
                        } else {
                            value = maxValue;
                        }
                    }
                    filters.add(
                            ff.and(
                                    ff.lessOrEqual(ff.property(propertyName), ff.literal(value)),
                                    ff.greaterOrEqual(
                                            ff.property(additionalPropertyName),
                                            ff.literal(value))));
                }
            }
            return ff.or(filters);
        }

