        /**
         * This method accepts incming granules and dispatch them to the correct {@link
         * DefaultSubmosaicProducer} depending on the internal {@link Filter} per the dimension.
         *
         * <p>
         *
         * <p>If not {@link MergeBehavior#STACK}ing is required, we collect them all together with
         * an include filter.
         */
        public void visit(GranuleDescriptor granuleDescriptor, SimpleFeature sf) {
            //
            // load raster data
            //
            // create a granuleDescriptor loader
            final Geometry bb = JTS.toGeometry((BoundingBox) mosaicBBox);
            Geometry inclusionGeometry = granuleDescriptor.getFootprint();
            boolean intersects = false;
            if (inclusionGeometry != null) {
                CoordinateReferenceSystem granuleCRS =
                        granuleDescriptor.getGranuleEnvelope().getCoordinateReferenceSystem();
                CoordinateReferenceSystem mosaicCRS = mosaicBBox.getCoordinateReferenceSystem();
                try {
                    if (!CRS.equalsIgnoreMetadata(granuleCRS, mosaicCRS)) {
                        ProjectionHandler handler =
                                ProjectionHandlerFinder.getHandler(mosaicBBox, granuleCRS, true);
                        MathTransform mt = CRS.findMathTransform(granuleCRS, mosaicCRS);
                        if (handler != null) {
                            Geometry preProcessed = handler.preProcess(inclusionGeometry);
                            if (preProcessed != null) {
                                Geometry transformed = JTS.transform(inclusionGeometry, mt);
                                inclusionGeometry = handler.postProcess(mt.inverse(), transformed);
                            }
                        } else {
                            inclusionGeometry = JTS.transform(inclusionGeometry, mt);
                        }
                    }
                    intersects = inclusionGeometry.intersects(bb);
                } catch (FactoryException | MismatchedDimensionException | TransformException e) {
                    // in case there was a reprojection issue assume intersection
                    intersects = true;
                }
                intersects = inclusionGeometry.intersects(bb);
            }
            if (!footprintBehavior.handleFootprints()
                    || inclusionGeometry == null
                    || (footprintBehavior.handleFootprints() && intersects)) {

                // find the right filter for this granule
                boolean found = false;
                for (SubmosaicProducer submosaicProducer : granuleCollectors) {
                    if (submosaicProducer.accept(granuleDescriptor)) {
                        granulesNumber++;
                        found = true;
                        break;
                    }
                }

                // did we find a place for it? If we are doing EGR then it's ok, if we are dealing
                // with an heterogenous CRS that also happens when zooming out a lot, otherwise not
                // so much
                if (!found && getExcessGranuleRemover() == null && !heterogeneousCRS) {
                    throw new IllegalStateException(
                            "Unable to locate a granule collector accepting this granule:\n"
                                    + granuleDescriptor.toString());
                }

            } else {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine(
                            "We rejected for non ROI inclusion the granule "
                                    + granuleDescriptor.toString());
                }
            }
        }

