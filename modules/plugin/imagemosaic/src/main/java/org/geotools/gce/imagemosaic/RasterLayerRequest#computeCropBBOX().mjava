    private void computeCropBBOX() throws DataSourceException  {

    	// get the crs for the requested bbox
        final CoordinateReferenceSystem requestCRS = CRS.getHorizontalCRS(requestedBBox.getCoordinateReferenceSystem());
        try {

        	//
			// If this approach succeeds, either the request crs is the same of
			// the coverage crs or the request bbox can be reprojected to that
			// crs
        	//
        	
        	
            // STEP 1: reproject requested BBox to native CRS if needed
            if (!CRS.equalsIgnoreMetadata(requestCRS,rasterManager.spatialDomainManager.coverageCRS2D))
                destinationToSourceTransform = CRS.findMathTransform(requestCRS,rasterManager.spatialDomainManager.coverageCRS2D, true);
            // now transform the requested envelope to source crs
            if (destinationToSourceTransform != null && !destinationToSourceTransform.isIdentity())
            {
            	final GeneralEnvelope temp = CRS.transform(destinationToSourceTransform,requestedBBox);
            	temp.setCoordinateReferenceSystem(rasterManager.spatialDomainManager.coverageCRS2D);
            	cropBBox= new ReferencedEnvelope(temp);
            	needsReprojection = true;
            	
            }
            else
            {
            	//we do not need to do anything, but we do this in order to aboid problems with the envelope checks
            	cropBBox=new ReferencedEnvelope(
            			requestedBBox.getMinX(),
            			requestedBBox.getMaxX(),
            			requestedBBox.getMinY(),
            			requestedBBox.getMaxY(),
            			rasterManager.spatialDomainManager.coverageCRS2D);
            	
            }            


            //
            // STEP 2: intersect requested BBox in native CRS with coverage native bbox to get the crop bbox
        	//
            // intersect the requested area with the bounds of this
            // layer in native crs
            if (!cropBBox.intersects((BoundingBox)rasterManager.spatialDomainManager.coverageBBox))
            {
                if (LOGGER.isLoggable(Level.FINE)){
                    LOGGER.fine(new StringBuilder("The computed CropBoundingBox ").append(cropBBox)
                            .append(" Doesn't intersect the coverage BoundingBox ").append(rasterManager.spatialDomainManager.coverageBBox)
                            .append(" resulting in an empty request").toString());
                }
                cropBBox = null;
                empty=true;
            	return;
            }
            // TODO XXX Optimize when referenced envelope has intersection method that actually retains the CRS, this is the JTS one
            cropBBox=new ReferencedEnvelope(((ReferencedEnvelope) cropBBox).intersection(rasterManager.spatialDomainManager.coverageBBox),rasterManager.spatialDomainManager.coverageCRS2D);   
            
            return;
        } catch (TransformException te) {
            // something bad happened while trying to transform this
            // envelope. let's try with wgs84
            if(LOGGER.isLoggable(Level.FINE))
            	LOGGER.log(Level.FINE,te.getLocalizedMessage(),te);
        } catch (FactoryException fe) {
            // something bad happened while trying to transform this
            // envelope. let's try with wgs84
            if(LOGGER.isLoggable(Level.FINE))
            	LOGGER.log(Level.FINE,fe.getLocalizedMessage(),fe);
        }
        

        try {
            
            // can we proceed? Do we have geo stuff to do all these operations?
            if(rasterManager.spatialDomainManager.coverageGeographicCRS2D!=null&&rasterManager.spatialDomainManager.coverageGeographicBBox!=null){
                
                
                
                
                //
                // If we can not reproject the requested envelope to the native CRS,
                // we go back to reproject in the geographic crs of the native
                // coverage since this usually happens for conversions between CRS
                // whose area of definition is different
                //
        	
        	// STEP 1 reproject the requested envelope to the coverage geographic bbox
    	        if(!CRS.equalsIgnoreMetadata(rasterManager.spatialDomainManager.coverageGeographicCRS2D, requestCRS)){
    	        	//try to convert the requested bbox to the coverage geocrs
    	        	requestCRSToCoverageGeographicCRS2D=CRS.findMathTransform(requestCRS, rasterManager.spatialDomainManager.coverageGeographicCRS2D,true);
    	        	if(!requestCRSToCoverageGeographicCRS2D.isIdentity())
    	        	{
    	        		requestedBBOXInCoverageGeographicCRS=CRS.transform(requestCRSToCoverageGeographicCRS2D,requestedBBox);
    	        		requestedBBOXInCoverageGeographicCRS.setCoordinateReferenceSystem(rasterManager.spatialDomainManager.coverageGeographicCRS2D);
    	        	}
    	        }
    	        if(requestedBBOXInCoverageGeographicCRS==null)
    	        	requestedBBOXInCoverageGeographicCRS= new GeneralEnvelope(requestCRS);
    	
    	
    	        // STEP 2 intersection with the geographic bbox for this coverage
    	        if (!requestedBBOXInCoverageGeographicCRS.intersects(rasterManager.spatialDomainManager.coverageGeographicBBox,true))
    	        {
    	            cropBBox=null;
    	            empty=true;
    	        	return;
    	        }
    	        // intersect with the coverage native geographic bbox
    	        // note that for the moment we got to use general envelope since there is no intersection otherwise
    	        requestedBBOXInCoverageGeographicCRS.intersect(rasterManager.spatialDomainManager.coverageGeographicBBox);
    	        requestedBBOXInCoverageGeographicCRS.setCoordinateReferenceSystem(rasterManager.spatialDomainManager.coverageGeographicCRS2D);
    	        
    	        // now go back to the coverage native CRS in order to compute an approximate requested resolution
    	        final MathTransform transform = CRS.findMathTransform(requestedBBOXInCoverageGeographicCRS.getCoordinateReferenceSystem(),rasterManager.spatialDomainManager.coverageCRS2D, true);
    	        approximateRequestedBBoInNativeCRS = CRS.transform(transform, requestedBBOXInCoverageGeographicCRS);
    	    	approximateRequestedBBoInNativeCRS.setCoordinateReferenceSystem(rasterManager.spatialDomainManager.coverageCRS2D);
    	    	cropBBox = new ReferencedEnvelope(approximateRequestedBBoInNativeCRS);     
    	    	return;
            }
	    	
        } catch (TransformException te) {
            // something bad happened while trying to transform this
            // envelope. let's try with wgs84
            if(LOGGER.isLoggable(Level.FINE))
            	LOGGER.log(Level.FINE,te.getLocalizedMessage(),te);
        } catch (FactoryException fe) {
            // something bad happened while trying to transform this
            // envelope. let's try with wgs84
            if(LOGGER.isLoggable(Level.FINE))
            	LOGGER.log(Level.FINE,fe.getLocalizedMessage(),fe);
        }

        LOGGER.log(Level.INFO,"We did not manage to crop the requested envelope, we fall back onto loading the whole coverage.");
        cropBBox=null;
    }

