        /**
         * This methods collects the granules from their eventual multithreaded processing
         * and turn them into a {@link MosaicInputs} object.
         * 
         * @return a {@link MosaicInputs} ready to be mosaicked.
         */
        private MosaicInputs collectGranules()throws IOException{
            // do we have anything to do?
            if (granulesNumber <= 0) {
                if (LOGGER.isLoggable(Level.FINE)){
                    LOGGER.log(Level.FINE, "granules number <= 0");
                }
                return null;
            }
            
           // execute them all
           final StringBuilder paths = new StringBuilder();
           final List<MosaicElement> returnValues= new ArrayList<RasterLayerResponse.MosaicElement>();
           // collect sources for the current dimension and then process them
           for (Future<GranuleLoadingResult> future :granulesFutures) {
                     
                try {
                    // get the resulting RenderedImage
                    final GranuleLoadingResult result = future.get();
                    if (result == null) {
                        if (LOGGER.isLoggable(Level.FINE)){
                            LOGGER.log(Level.FINE, "Unable to load the raster for granule with request " + request.toString());
                        }
                        continue;
                    }
                    final RenderedImage loadedImage = result.getRaster();
                    if (loadedImage == null) {
                        if (LOGGER.isLoggable(Level.FINE)) {
                           LOGGER.log(Level.FINE,
                                   "Unable to load the raster for granuleDescriptor " +result.granuleUrl+ " with request "+request.toString()
                           );
                       }
                       continue;
                   }
                   
                   // now process it
                    if (sourceThreshold == null) {
                            //
                            // We check here if the images have an alpha channel or some
                            // other sort of transparency. In case we have transparency
                            // I also save the index of the transparent channel.
                            //
                            // Specifically, I have to check if the loaded image have
                            // transparency, because if we do a ROI and/or we have a
                            // transparent color to set we have to remove it.
                            //
                            final ColorModel cm = loadedImage.getColorModel();
                            hasAlpha = cm.hasAlpha();
                            if (hasAlpha){
                                alphaIndex[0]= cm.getNumComponents() - 1 ;
                            }

                            //
                            // we set the input threshold accordingly to the input
                            // image data type. I find the default value (which is 0) very bad
                            // for data type other than byte and ushort. With float and double
                            // it can cut off a large par of the dynamic.
                            //
                            sourceThreshold = new double[][] { { CoverageUtilities.getMosaicThreshold(loadedImage.getSampleModel().getDataType()) } };                                                                  
                   }                                    

                   // moving on
                   if (LOGGER.isLoggable(Level.FINE)) {
                       LOGGER.fine("Adding to mosaic granule " +result.granuleUrl);
                   }

                   // path management
                   File inputFile = DataUtilities.urlToFile(result.granuleUrl);
                   String canonicalPath = inputFile.getCanonicalPath();
                   // Remove ovr extension if present
                   String fileCanonicalPath = canonicalPath;
                   if (canonicalPath.endsWith(".ovr")) {
                       fileCanonicalPath = canonicalPath.substring(0, canonicalPath.length() - 4);
                   }
                   paths.append(canonicalPath).append(",");
                   
                   // add to the mosaic collection, with preprocessing
                   // TODO pluggable mechanism for processing (artifacts,etc...)
                   MosaicElement input = preProcessGranuleRaster(
                                           loadedImage,
                                           result,
                                           fileCanonicalPath);  
                   returnValues.add(input);
                   
                } catch (Exception e) {
                    if (LOGGER.isLoggable(Level.INFO)){
                        LOGGER.info("Adding to mosaic failed, original request was " + request);
                    }
                    throw new IOException(e);
                }               
               

               // collect paths
                granulesPaths = paths.length() > 1 ? paths.substring(0, paths.length() - 1) : "";
           }
           if (returnValues == null || returnValues.isEmpty()) {
               if (LOGGER.isLoggable(Level.INFO)){
                   LOGGER.info("The MosaicElement list is null or empty");
               }
           }
           return new MosaicInputs(doInputTransparency, hasAlpha, returnValues, sourceThreshold);
        }

