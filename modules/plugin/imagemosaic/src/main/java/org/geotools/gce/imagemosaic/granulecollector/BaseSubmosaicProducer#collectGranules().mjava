    /**
     * This methods collects the granules from their eventual multithreaded processing and turn them into a {@link MosaicInputs} object.
     *
     * @return a {@link MosaicInputs} ready to be mosaicked.
     */
    protected MosaicInputs collectGranules() throws IOException {
        // do we have anything to do?
        if (granulesNumber <= 0) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log(Level.FINE, "granules number <= 0");
            }
            return null;
        }

        // execute them all
        final StringBuilder paths = new StringBuilder();
        final List<MosaicElement> returnValues = new ArrayList<>();
        // collect sources for the current dimension and then process them
        for (Future<GranuleDescriptor.GranuleLoadingResult> future : granulesFutures) {

            try {
                // get the resulting RenderedImage
                final GranuleDescriptor.GranuleLoadingResult result = future.get();
                if (result == null) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.log(Level.FINE, "Unable to load the raster for granule with request "
                                + rasterLayerResponse.getRequest().toString());
                    }
                    continue;
                }
                final RenderedImage loadedImage = result.getRaster();
                if (loadedImage == null) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.log(Level.FINE,
                                "Unable to load the raster for granuleDescriptor "
                                        + result.getGranuleUrl() + " with request "
                                        + rasterLayerResponse.getRequest().toString());
                    }
                    continue;
                }

                // now process it
                if (sourceThreshold == null) {
                    //
                    // We check here if the images have an alpha channel or some
                    // other sort of transparency. In case we have transparency
                    // I also save the index of the transparent channel.
                    //
                    // Specifically, I have to check if the loaded image have
                    // transparency, because if we do a ROI and/or we have a
                    // transparent color to set we have to remove it.
                    //
                    final ColorModel cm = loadedImage.getColorModel();
                    hasAlpha = cm.hasAlpha();
                    if (hasAlpha) {
                        alphaIndex[0] = cm.getNumComponents() - 1;
                    }

                    //
                    // we set the input threshold accordingly to the input
                    // image data type. I find the default value (which is 0) very bad
                    // for data type other than byte and ushort. With float and double
                    // it can cut off a large par of the dynamic.
                    //
                    sourceThreshold = new double[][] { { CoverageUtilities
                            .getMosaicThreshold(loadedImage.getSampleModel().getDataType()) } };
                }

                // moving on
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Adding to mosaic granule " + result.getGranuleUrl());
                }

                // path management
                File inputFile = DataUtilities.urlToFile(result.getGranuleUrl());
                String canonicalPath = inputFile.getCanonicalPath();
                // Remove ovr extension if present
                String fileCanonicalPath = canonicalPath;
                if (canonicalPath.endsWith(".ovr")) {
                    fileCanonicalPath = canonicalPath.substring(0, canonicalPath.length() - 4);
                }
                paths.append(canonicalPath).append(",");

                // add to the mosaic collection, with preprocessing
                // TODO pluggable mechanism for processing (artifacts,etc...)
                MosaicElement input = preProcessGranuleRaster(loadedImage, result,
                        fileCanonicalPath);
                returnValues.add(input);

            } catch (Exception e) {
                if (LOGGER.isLoggable(Level.INFO)) {
                    LOGGER.info("Adding to mosaic failed, original request was "
                            + rasterLayerResponse.getRequest());
                }
                throw new IOException(e);
            }

            // collect paths
            rasterLayerResponse.setGranulesPaths(
                    paths.length() > 1 ? paths.substring(0, paths.length() - 1) : "");
        }
        if (returnValues == null || returnValues.isEmpty()) {
            if (LOGGER.isLoggable(Level.INFO)) {
                LOGGER.info("The MosaicElement list is null or empty");
            }
        }
        return new MosaicInputs(doInputTransparency, hasAlpha, returnValues, sourceThreshold);
    }

