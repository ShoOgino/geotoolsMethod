    /**
     * This methods collects the granules from their eventual multithreaded processing and turn them
     * into a {@link MosaicInputs} object.
     *
     * @return a {@link MosaicInputs} ready to be mosaicked.
     */
    protected MosaicInputs collectGranules() throws IOException {
        // do we have anything to do?
        if (granulesNumber <= 0) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log(Level.FINE, "granules number <= 0");
            }
            return null;
        }

        // execute them all
        final StringBuilder paths = new StringBuilder();
        URL sourceUrl = null;
        final List<MosaicElement> returnValues = new ArrayList<>();
        // collect sources for the current dimension and then process them
        for (Future<GranuleDescriptor.GranuleLoadingResult> future : granulesFutures) {

            try {
                // get the resulting RenderedImage
                final GranuleDescriptor.GranuleLoadingResult result = future.get();
                if (result == null) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.log(
                                Level.FINE,
                                "Unable to load the raster for granule with request "
                                        + rasterLayerResponse.getRequest().toString());
                    }
                    continue;
                }
                final RenderedImage loadedImage = result.getRaster();
                if (loadedImage == null) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.log(
                                Level.FINE,
                                "Unable to load the raster for granuleDescriptor "
                                        + result.getGranuleUrl()
                                        + " with request "
                                        + rasterLayerResponse.getRequest().toString());
                    }
                    continue;
                }

                // perform excess granule removal in case multithreaded loading is enabled
                if (isMultithreadedLoadingEnabled()) {
                    ROIExcessGranuleRemover remover = rasterLayerResponse.getExcessGranuleRemover();
                    if (remover != null) {
                        if (remover.isRenderingAreaComplete()) {
                            break;
                        }
                        if (!remover.addGranule(result)) {
                            // skip this granule
                            continue;
                        }
                    }
                }

                // now process it
                if (sourceThreshold == null) {
                    //
                    // We check here if the images have an alpha channel or some
                    // other sort of transparency. In case we have transparency
                    // I also save the index of the transparent channel.
                    //
                    // Specifically, I have to check if the loaded image have
                    // transparency, because if we do a ROI and/or we have a
                    // transparent color to set we have to remove it.
                    //
                    final ColorModel cm = loadedImage.getColorModel();
                    hasAlpha |= cm.hasAlpha();

                    //
                    // we set the input threshold accordingly to the input
                    // image data type. I find the default value (which is 0) very bad
                    // for data type other than byte and ushort. With float and double
                    // it can cut off a large par of the dynamic.
                    //
                    sourceThreshold =
                            new double[][] {
                                {
                                    CoverageUtilities.getMosaicThreshold(
                                            loadedImage.getSampleModel().getDataType())
                                }
                            };
                }

                // moving on
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Adding to mosaic granule " + result.getGranuleUrl());
                }

                // path management
                String fileCanonicalPath = null;
                URL url = result.getGranuleUrl();
                File inputFile = URLs.urlToFile(url);
                if (inputFile != null) {
                    String canonicalPath = inputFile.getCanonicalPath();
                    // Remove ovr extension if present
                    fileCanonicalPath = canonicalPath;
                    if (canonicalPath.endsWith(".ovr")) {
                        fileCanonicalPath = canonicalPath.substring(0, canonicalPath.length() - 4);
                    }
                    paths.append(canonicalPath).append(",");
                } else {
                    // Let's go straight using the granuleUrl
                    paths.append(url.toString()).append(",");
                }
                // take only the first source URL found
                if (sourceUrl == null) {
                    sourceUrl = result.getGranuleUrl();
                }

                // add to the mosaic collection, with preprocessing
                // TODO pluggable mechanism for processing (artifacts,etc...)
                MosaicElement input =
                        preProcessGranuleRaster(loadedImage, result, fileCanonicalPath);
                returnValues.add(input);

            } catch (Exception e) {
                if (LOGGER.isLoggable(Level.INFO)) {
                    LOGGER.info(
                            "Adding to mosaic failed, original request was "
                                    + rasterLayerResponse.getRequest());
                }
                throw new IOException(e);
            }
        }

        // collect paths
        rasterLayerResponse.addGranulePaths(
                paths.length() > 1 ? paths.substring(0, paths.length() - 1) : "");
        rasterLayerResponse.setSourceUrl(sourceUrl);

        if (returnValues == null || returnValues.isEmpty()) {
            if (LOGGER.isLoggable(Level.INFO)) {
                LOGGER.info("The MosaicElement list is null or empty");
            }
        }
        return new MosaicInputs(doInputTransparency, hasAlpha, returnValues, sourceThreshold);
    }

