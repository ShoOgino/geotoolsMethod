    /**
     * Base constructor for a {@link PixelRestorationOpImage}
     * @param source the input {@link RenderedImage}
     * @param layout the optional {@link ImageLayout}
     * @param config 
     * @param sourceROI a {@link ROI} representing pixels to be restored.
     * @param backgroundValues the value of the background pixel values.
     */
    public ArtifactsFilterOpImage(
    		final RenderedImage source, 
    		final ImageLayout layout,
            final Map<?, ?> config, 
            final ROI sourceROI, 
            double[] backgroundValues,
            final int threshold,
            final int filterSize) {
        super(source, layout, config, true);
        
        RenderedImage inputRI = source;
        iter = RandomIterFactory.create(inputRI, null);
        final int tr= inputRI.getColorModel().getTransparency();
        // Set the band count.
        this.numBands = sampleModel.getNumBands();
        
        this.filterSize = filterSize;
        
        // Save the ROI array.
        ROI thresholdRoi = null;
        if (sourceROI != null){            
            RenderedImage image = inputRI;
            if (threshold != Integer.MAX_VALUE){
                if (numBands == 3) {
                    image = BandCombineDescriptor.create(image, RGB_TO_GRAY_MATRIX, null);
                } else {
                        //do we have transparency
                        //combination matrix
                        
                        final double fillValue = tr == Transparency.OPAQUE ? 1.0/numBands : 1.0/(numBands-1);
                        
                        final double[][] matrix = new double[1][numBands + 1];
                        for (int i=0; i < numBands; i++) {
                                matrix[0][i] = fillValue;
                        }
    
                        image = BandCombineDescriptor.create(image, matrix, null);
                }
                    thresholdRoi = new ROI(image, threshold);
                    thresholdRoi = thresholdRoi.intersect(sourceROI);
            }
        } 
        
        // Copy the background values per the specification.
        this.backgroundValues = new double[numBands];
        if (backgroundValues == null) {
            backgroundValues = new double[] { 0.0 };
        }

        if (backgroundValues.length < numBands) {
            Arrays.fill(this.backgroundValues, backgroundValues[0]);
        } else {
            System.arraycopy(backgroundValues, 0, this.backgroundValues, 0, numBands);
        }

        final int dataType = sampleModel.getDataType();

        // Determine constant value for source BORDER extension.
        double sourceExtensionConstant;
        switch (dataType) {
        case DataBuffer.TYPE_BYTE:
            sourceExtensionConstant = 0.0;
            break;
        case DataBuffer.TYPE_USHORT:
            sourceExtensionConstant = 0.0;
            break;
        case DataBuffer.TYPE_SHORT:
            sourceExtensionConstant = Short.MIN_VALUE;
            break;
        case DataBuffer.TYPE_INT:
            sourceExtensionConstant = Integer.MIN_VALUE;
            break;
        case DataBuffer.TYPE_FLOAT:
            sourceExtensionConstant = -Float.MAX_VALUE;
            break;
        case DataBuffer.TYPE_DOUBLE:
        default:
            sourceExtensionConstant = -Double.MAX_VALUE;
        }
        this.sourceExtender = sourceExtensionConstant == 0.0 ? BorderExtender
                .createInstance(BorderExtender.BORDER_ZERO)
                : new BorderExtenderConstant(new double[] { sourceExtensionConstant });

        roiAccessor = buildRoiAccessor(sourceROI);
        thresholdRoiAccessor = buildRoiAccessor(thresholdRoi);
    }

