    /**
     * Compute operation for the provided dest.
     * @param dest
     */
    private synchronized void computeRect(RasterAccessor dest) {
        int dwidth = dest.getWidth();
        int dheight = dest.getHeight();
        int dnumBands = dest.getNumBands();

        byte dstDataArrays[][] = dest.getByteDataArrays();
        int dstBandOffsets[] = dest.getBandOffsets();
        int dstPixelStride = dest.getPixelStride();
        int dstScanlineStride = dest.getScanlineStride();

        final int x = dest.getX();
        final int y = dest.getY();

        int valuess[][] = new int[filterSize*filterSize][dnumBands];
        int min = -(filterSize/2);
        int max = filterSize/2;
        int dstPixelOffset[] = new int[dnumBands];
        int dstScanlineOffset[] = new int[dnumBands];
        int val[]= new int[dnumBands];
        int valueCount = 0;
        boolean readOriginalValues = false;
        for (int k = 0; k < dnumBands; k++) {
            dstScanlineOffset[k] = dstBandOffsets[k];
        }
        for (int j = 0; j < dheight; j++) {
            for (int k = 0; k < dnumBands; k++) {
                dstPixelOffset[k] = dstScanlineOffset[k];
            }

            for (int i = 0; i < dwidth; i++) {
                valueCount = 0;
                readOriginalValues = false;
                for (int k = 0;k<dnumBands;k++){
                    val[k] = Integer.MIN_VALUE;
                }
                
                // //
                //
                // Pixels outside the ROI will be forced to background color
                //
                // //
                boolean insideRoi = contains(roiAccessor, x+i, y+j);
                
                if (insideRoi){
                    
                    // // 
                    //
                    // Artifact filtering is applied only on ROI BORDER 
                    //
                    // //
//                    boolean isBorder = isBorder(roiAccessor, x+i, y+j);
//                    if (isBorder) {
                        
                        // //
                        //
                        // If the actual pixel luminance is less then the threshold value,
                        // filter it
                        //
                        // //
                        if(!contains(thresholdRoiAccessor, x+i, y+j)){
                            
                            // //
                            //
                            // Checking sourrounding pixels
                            //
                            // //
                            for (int u = min; u <= max; u++) {
                                for (int v = min; v <= max; v++) {
                                    boolean set = false;
                                    
                                    // //
                                    // 
                                    // Neighbour pixel is in ROI and its luminance value is greater than
                                    // the threshold. Then use it for computation
                                    // 
                                    // //
                                    if (/*contains(roiAccessor, x+i+v, y+j+u) && */contains(thresholdRoiAccessor, x+i+v, y+j+u)){
                                        set = true;
                                    }
                                    if (set){
                                        iter.getPixel(x+i+v, y+j+u, valuess[valueCount++]);
                                    }
                                    
                                }
                            }
                            
                            if (valueCount == 0){
                                //Last attempt to get more valid pixels by looking at the borders
                                for (int u = min - 1; u <= max + 1; u += (filterSize+1) ) {
                                    for (int v = min-1 ; v <= max +1; v += (filterSize+1)) {
                                        boolean set = false;
                                        if (/*contains(roiAccessor, x+i+v, y+j+u) && */contains(thresholdRoiAccessor, x+i+v, y+j+u)){
                                            set = true;
                                        }
                                        if (set){
                                            iter.getPixel(x+i+v, y+j+u, valuess[valueCount++]);
                                        }
                                    }
                                }
                            }
                            // //
                            //
                            // Compute filter value from sourrounding pixel values
                            // 
                            // //
                            if (valueCount > 0) {
                                computeValueAtOnce(valuess, valueCount, val);
                            } else {
                                readOriginalValues = true;
                            }
                        } else {
                            readOriginalValues = true;
                        }
                    for (int k = 0; k < dnumBands; k++){
                        dstDataArrays[k][dstPixelOffset[k]] = (byte) val[k];
                    }    
                } else {
                    readOriginalValues = true;
                }
                if (readOriginalValues){
                    for (int k = 0; k < dnumBands; k++){
                        val[k] = (int) iter.getSample(x+i, y+j, k) & 0xff;
                        dstDataArrays[k][dstPixelOffset[k]] = (byte) val[k];
                    }
                }
                
                for (int k = 0; k < dnumBands; k++){
                    dstPixelOffset[k] += dstPixelStride;
                }    
            }
            for (int k = 0; k < dnumBands; k++){
                dstScanlineOffset[k] += dstScanlineStride;
            }
        }
    }

