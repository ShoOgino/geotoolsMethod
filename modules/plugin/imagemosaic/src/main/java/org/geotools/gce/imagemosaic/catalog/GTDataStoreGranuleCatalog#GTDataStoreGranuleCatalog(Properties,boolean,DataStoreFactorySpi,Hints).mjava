    public GTDataStoreGranuleCatalog(final Properties params, final boolean create,
            final DataStoreFactorySpi spi, final Hints hints) {
        super(hints);
        Utilities.ensureNonNull("params", params);
        Utilities.ensureNonNull("spi", spi);

        try {
            this.pathType = (PathType) params.get(Utils.Prop.PATH_TYPE);
            this.locationAttribute = (String) params.get(Utils.Prop.LOCATION_ATTRIBUTE);
            final String temp = (String) params.get(Utils.Prop.SUGGESTED_SPI);
            this.suggestedRasterSPI = temp != null ? (ImageReaderSpi) Class.forName(temp)
                    .newInstance() : null;
            this.parentLocation = (String) params.get(Utils.Prop.PARENT_LOCATION);
            if (params.containsKey(Utils.Prop.HETEROGENEOUS)) {
                this.heterogeneous = (Boolean) params.get(Utils.Prop.HETEROGENEOUS);
            }

            // creating a store, this might imply creating it for an existing underlying store or
            // creating a brand new one
            Map<String, Serializable> dastastoreParams = Utils.filterDataStoreParams(params, spi);

            // H2 workadound
            if (Utils.isH2Store(spi)) {
                Utils.fixH2DatabaseLocation(dastastoreParams, parentLocation);
                Utils.fixH2MVCCParam(dastastoreParams);
            }

            if (!create) {
                tileIndexStore = spi.createDataStore(dastastoreParams);
            } else {
                // this works only with the shapefile datastore, not with the others
                // therefore I try to catch the error to try and use themethdo without *New*
                try {
                    tileIndexStore = spi.createNewDataStore(dastastoreParams);
                } catch (UnsupportedOperationException e) {
                    tileIndexStore = spi.createDataStore(dastastoreParams);
                }
            }

            if(Utils.isOracleStore(spi)) {
                tileIndexStore = new OracleDatastoreWrapper(tileIndexStore,
                        FilenameUtils.getFullPath(parentLocation));
            }

            // is this a new store? If so we do not set any properties
            if (create) {
                return;
            }

            String typeName = null;
            boolean scanForTypeNames = false;

            if (params.containsKey(Utils.Prop.TYPENAME)) {
                typeName = (String) params.get(Utils.Prop.TYPENAME);
            }

            if (params.containsKey(Utils.SCAN_FOR_TYPENAMES)) {
                scanForTypeNames = Boolean.valueOf(params.get(Utils.SCAN_FOR_TYPENAMES).toString());
            }

            // if this is not a new store let's extract basic properties from it
            if (scanForTypeNames) {
                String[] typeNames = tileIndexStore.getTypeNames();
                if (typeNames != null) {
                    for (String tn : typeNames) {
                        this.typeNames.add(tn);
                    }
                }
            } else if (typeName != null) {
                addTypeName(typeName, false);
            }
            if (this.typeNames.size() > 0) {
                extractBasicProperties(typeNames.iterator().next());
            } else {
                extractBasicProperties(typeName);
            }
        } catch (Throwable e) {
            try {
                if (tileIndexStore != null)
                    tileIndexStore.dispose();
            } catch (Throwable e1) {
                if (LOGGER.isLoggable(Level.FINE))
                    LOGGER.log(Level.FINE, e1.getLocalizedMessage(), e1);
            } finally {
                tileIndexStore = null;
            }

            throw new IllegalArgumentException(e);
        }

    }

