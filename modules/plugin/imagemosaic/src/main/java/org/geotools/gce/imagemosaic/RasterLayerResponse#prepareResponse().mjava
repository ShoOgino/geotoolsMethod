	/**
	 * This method loads the granules which overlap the requested
	 * {@link GeneralEnvelope} using the provided values for alpha and input
	 * ROI.
	 * @return
	 * @throws DataSourceException
	 */
	private RenderedImage prepareResponse() throws DataSourceException {

		try {
			
			//
			// prepare the params for executing a mosaic operation.
			//
			// It might important to set the mosaic type to blend otherwise
			// sometimes strange results jump in.

			// select the relevant overview, notice that at this time we have
			// relaxed a bit the requirement to have the same exact resolution
			// for all the overviews, but still we do not allow for reading the
			// various grid to world transform directly from the input files,
			// therefore we are assuming that each granuleDescriptor has a scale and
			// translate only grid to world that can be deduced from its base
			// level dimension and envelope. The grid to world transforms for
			// the other levels can be computed accordingly knowing the scale
			// factors.
			if (request.getRequestedBBox() != null && request.getRequestedRasterArea() != null && !request.isHeterogeneousGranules())
				imageChoice = ReadParamsController.setReadParams(
				        request.getRequestedResolution(),
				        request.getOverviewPolicy(),
				        request.getDecimationPolicy(),
				        baseReadParameters,
				        request.rasterManager,
				        request.rasterManager.overviewsController); // use general overviews controller
			else
				imageChoice = 0;
			assert imageChoice>=0;
			if (LOGGER.isLoggable(Level.FINE))
				LOGGER.fine(new StringBuffer("Loading level ").append(
						imageChoice).append(" with subsampling factors ")
						.append(baseReadParameters.getSourceXSubsampling()).append(" ")
						.append(baseReadParameters.getSourceYSubsampling()).toString());			
			
			
			// ok we got something to return, let's load records from the index
			final BoundingBox cropBBOX = request.getCropBBox();
			if (cropBBOX != null)
				mosaicBBox = ReferencedEnvelope.reference(cropBBOX);
			else
				mosaicBBox = new ReferencedEnvelope(coverageEnvelope);
						
			//compute final world to grid
			// base grid to world for the center of pixels
			final AffineTransform g2w;
			final OverviewLevel baseLevel = rasterManager.overviewsController.resolutionsLevels
					.get(0);
			final OverviewLevel selectedLevel = rasterManager.overviewsController.resolutionsLevels.get(imageChoice);
			final double resX = baseLevel.resolutionX;
			final double resY = baseLevel.resolutionY;
			final double[] requestRes = request.getRequestedResolution();

                        g2w = new AffineTransform((AffineTransform) baseGridToWorld);
                        g2w.concatenate(CoverageUtilities.CENTER_TO_CORNER);
                        
			if ((requestRes[0] < resX || requestRes[1] < resY) ) {
			    // Using the best available resolution
			    oversampledRequest = true;
			} else {
				
			    // SG going back to working on a per level basis to do the composition
			    // g2w = new AffineTransform(request.getRequestedGridToWorld());
			    g2w.concatenate(AffineTransform.getScaleInstance(selectedLevel.scaleFactor,selectedLevel.scaleFactor));
			    g2w.concatenate(AffineTransform.getScaleInstance(baseReadParameters.getSourceXSubsampling(), baseReadParameters.getSourceYSubsampling()));
			}

			// move it to the corner
			finalGridToWorldCorner = new AffineTransform2D(g2w);
			finalWorldToGridCorner = finalGridToWorldCorner.inverse();// compute raster bounds
			final GeneralEnvelope tempRasterBounds = CRS.transform(finalWorldToGridCorner, mosaicBBox);
			rasterBounds=tempRasterBounds.toRectangle2D().getBounds();
			
			
//			 SG using the above may lead to problems since the reason is that  may be a little (1 px) bigger
//			 than what we need. The code below is a bit better since it uses a proper logic (see GridEnvelope
//			 Javadoc)
//			rasterBounds = new GridEnvelope2D(new Envelope2D(tempRasterBounds), PixelInCell.CELL_CORNER);
			if (rasterBounds.width == 0)
			    rasterBounds.width++;
			if (rasterBounds.height == 0)
			    rasterBounds.height++;
			if(oversampledRequest)
			    rasterBounds.grow(2, 2);
			
                        // make sure we do not go beyond the raster dimensions for this layer
                        final GeneralEnvelope levelRasterArea_ = CRS.transform(finalWorldToGridCorner, rasterManager.spatialDomainManager.coverageBBox);
                        final GridEnvelope2D levelRasterArea = new GridEnvelope2D(new Envelope2D(levelRasterArea_), PixelInCell.CELL_CORNER);
                        XRectangle2D.intersect(levelRasterArea, rasterBounds, rasterBounds);
			
			// create the index visitor and visit the feature
			final MosaicBuilder visitor = new MosaicBuilder();
			visitor.request = request;
			final List times = request.getRequestedTimes();
			final List elevations=request.getElevation();
			final Filter filter = request.getFilter();
			final boolean hasTime=(times!=null&&times.size()>0);
			final boolean hasElevation=(elevations!=null && elevations.size()>0);
			final boolean hasFilter = filter != null;

			final SimpleFeatureType type = rasterManager.granuleCatalog.getType();
			Query query = null;
			if (type != null){
			    query= new Query(rasterManager.granuleCatalog.getType().getTypeName());
			    final Filter bbox=FeatureUtilities.DEFAULT_FILTER_FACTORY.bbox(FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.granuleCatalog.getType().getGeometryDescriptor().getName()),mosaicBBox);
			    query.setFilter( bbox);
			}

                        if(hasTime||hasElevation||hasFilter )
                        {
                                //handle elevation indexing first since we then combine this with the max in case we are asking for current in time
                                if (hasElevation){
                                        // sort by
//                                        query.setSortBy(new SortBy[]{new SortByImpl(FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.elevationAttribute), SortOrder.ASCENDING)});
                                        final List<Filter> elevationF=new ArrayList<Filter>();
                                        for( Object elevation: elevations){
                                            if(elevation==null){
                                                if(LOGGER.isLoggable(Level.INFO))
                                                    LOGGER.info("Ignoring null elevation for the elevation filter");
                                                continue;
                                            }
                                            if(elevation instanceof Number){
                                                elevationF.add( FeatureUtilities.DEFAULT_FILTER_FACTORY.equal(
                                                    FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.elevationAttribute), 
                                                    FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(elevation),
                                                    true)); 
                                            } else {
                                                // convert to range and create a correct range filter
                                                @SuppressWarnings("rawtypes")
                                                final NumberRange range= (NumberRange)elevation;
                                                elevationF.add( 
                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.and(
                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.lessOrEqual(
                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.elevationAttribute), 
                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(range.getMaximum())),
                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.greaterOrEqual(
                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.elevationAttribute), 
                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(range.getMinimum()))
                                                        )); 
                                            }
                                            
                                        }
                                        final int elevationSize=elevationF.size();
                                        if(elevationSize>1)//should not happen
                                            query.setFilter(
                                                    FeatureUtilities.DEFAULT_FILTER_FACTORY.and(query.getFilter(),
                                                            FeatureUtilities.DEFAULT_FILTER_FACTORY.or(elevationF))
                                                            );  
                                        else
                                            if(elevationSize==1)
                                                query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.and(query.getFilter(), elevationF.get(0)));        
                                }

                                //handle generic filter since we then combine this with the max in case we are asking for current in time
                                if (hasFilter){
                                        query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.and(query.getFilter(), filter));        
                                }
                                
                                // fuse time query with the bbox query
                                if(hasTime){
//                                    final SortBy[] old= query.getSortBy();
//                                    if(old==null||old.length==0){
//                                        query.setSortBy(
//                                                new SortBy[]{
//                                                        new SortByImpl(
//                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), 
//                                                                SortOrder.DESCENDING)});
//                                    } else {
//                                        query.setSortBy(
//                                                new SortBy[]{
//                                                        old[0],
//                                                        new SortByImpl(
//                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), 
//                                                                SortOrder.DESCENDING)});
//                                    }
                                        final List<Filter> timeFilter=new ArrayList<Filter>();
                                        for( Object datetime: times){
                                            if(datetime==null){
                                                if(LOGGER.isLoggable(Level.INFO))
                                                    LOGGER.info("Ignoring null date for the time filter");
                                                continue;
                                            }
                                            if(datetime instanceof Date){
                                                timeFilter.add(
                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.equal(
                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), 
                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(datetime),true));
                                            }else {
                                                // convert to range and create a correct range filter
                                                final DateRange range= (DateRange)datetime;
                                                timeFilter.add( 
                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.and(
                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.lessOrEqual(
                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), 
                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(range.getMaxValue())),
                                                                FeatureUtilities.DEFAULT_FILTER_FACTORY.greaterOrEqual(
                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.timeAttribute), 
                                                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.literal(range.getMinValue()))
                                                        )); 
                                            }                                                

                                        }
                                        final int sizeTime=timeFilter.size();
                                        if(sizeTime>1)//should not happen
                                            query.setFilter(
                                                    FeatureUtilities.DEFAULT_FILTER_FACTORY.and(
                                                            query.getFilter(), FeatureUtilities.DEFAULT_FILTER_FACTORY.or(timeFilter)));
                                        else
                                            if(sizeTime==1)
                                                query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.and(query.getFilter(), timeFilter.get(0)));
                                }
                                
                                rasterManager.getGranules(query, visitor);

                        } else {
                            rasterManager.getGranules(mosaicBBox, visitor);    
                        }
			// get those granules
			visitor.produce();
			
			//
			// Did we actually load anything?? Notice that it might happen that
			// either we have holes inside the definition area for the mosaic
			// or we had some problem with missing tiles, therefore it might
			// happen that for some bboxes we don't have anything to load.
			//
			RenderedImage returnValue=null;
			if (visitor.granulesNumber>=1) {

				//
				// Create the mosaic image by doing a crop if necessary and also
				// managing the transparent color if applicable. Be aware that
				// management of the transparent color involves removing
				// transparency information from the input images.
				// 			
				returnValue= buildMosaic(visitor);
				if(returnValue!=null){
				    if (LOGGER.isLoggable(Level.FINE))
				        LOGGER.fine("Loaded bbox "+mosaicBBox.toString()+" while crop bbox "+request.getCropBBox().toString());
				    return returnValue;
				}
			
			}
                        if (LOGGER.isLoggable(Level.FINE))
                            LOGGER.fine("Creating constant image for area with no data");
                        
                        // if we get here that means that we do not have anything to load
                        // but still we are inside the definition area for the mosaic,
                        // therefore we create a fake coverage using the background values,
                        // if provided (defaulting to 0), as well as the compute raster
                        // bounds, envelope and grid to world.

                        final Number[] values = Utils.getBackgroundValues(rasterManager.defaultSM, backgroundValues);
                        // create a constant image with a proper layout
                        return ConstantDescriptor.create(
                                Float.valueOf(rasterBounds.width),
                                Float.valueOf(rasterBounds.height),
                                values,
                                rasterManager.defaultImageLayout!=null?new RenderingHints(JAI.KEY_IMAGE_LAYOUT,rasterManager.defaultImageLayout):null);
			

		} catch (IOException e) {
			throw new DataSourceException("Unable to create this mosaic", e);
		} catch (TransformException e) {
			throw new DataSourceException("Unable to create this mosaic", e);
		} 
	}

