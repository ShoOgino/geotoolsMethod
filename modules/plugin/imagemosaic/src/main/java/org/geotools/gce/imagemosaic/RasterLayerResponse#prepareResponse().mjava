    /**
     * This method loads the granules which overlap the requested {@link GeneralEnvelope} using the
     * provided values for alpha and input ROI.
     *
     * @return the mosaic output for the request
     */
    private MosaicOutput prepareResponse() throws DataSourceException {

        try {
            // === select overview
            chooseOverview();

            // === extract bbox
            initBBOX();

            // === init transformations
            initTransformations();

            // === init raster bounds
            initRasterBounds();

            // === init excess granule removal if needed
            initExcessGranuleRemover();

            // === create query and basic BBOX filtering
            MosaicQueryBuilder queryBuilder = new MosaicQueryBuilder(request, queryBBox);
            final Query query = queryBuilder.build();

            // === collect granules
            final MosaicProducer visitor =
                    new MosaicProducer(
                            submosaicProducerFactory.createProducers(
                                    this.getRequest(), this.getRasterManager(), this, false));
            rasterManager.getGranuleDescriptors(query, visitor);

            // get those granules and create the final mosaic
            heterogeneousCRS = visitor.heterogeneousCRS;
            MosaicOutput returnValue = visitor.produce();

            //
            // Did we actually load anything?? Notice that it might happen that
            // either we have holes inside the definition area for the mosaic
            // or we had some problem with missing tiles, therefore it might
            // happen that for some bboxes we don't have anything to load.
            //

            //
            // Create the mosaic image by doing a crop if necessary and also
            // managing the transparent color if applicable. Be aware that
            // management of the transparent color involves removing
            // transparency information from the input images.
            //
            if (returnValue != null) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine(
                            "Loaded bbox "
                                    + queryBBox.toString()
                                    + " while crop bbox "
                                    + request.spatialRequestHelper.getComputedBBox().toString());
                }
                return returnValue;
            }

            if (visitor.granulesNumber == 0) {
                // Redo the query without filter to check whether we got no granules due
                // to a filter. In that case we need to return null
                // Notice that we are using a dryRun visitor to make sure we don't
                // spawn any loading tasks, we also ensure we get only 1 feature at most
                // to make this blazing fast
                LOGGER.fine("We got no granules, let's do a dry run with no filters");
                List<SubmosaicProducer> collectors =
                        submosaicProducerFactory.createProducers(
                                this.getRequest(), this.getRasterManager(), this, true);
                final MosaicProducer dryRunVisitor = new MosaicProducer(true, collectors);
                final Utils.BBOXFilterExtractor bboxExtractor = new Utils.BBOXFilterExtractor();
                query.getFilter().accept(bboxExtractor, null);
                query.setFilter(
                        FeatureUtilities.DEFAULT_FILTER_FACTORY.bbox(
                                FeatureUtilities.DEFAULT_FILTER_FACTORY.property(
                                        rasterManager
                                                .getGranuleCatalog()
                                                .getType(rasterManager.getTypeName())
                                                .getGeometryDescriptor()
                                                .getName()),
                                bboxExtractor.getBBox()));
                query.setMaxFeatures(1);
                rasterManager.getGranuleDescriptors(query, dryRunVisitor);
                if (dryRunVisitor.granulesNumber > 0) {
                    LOGGER.fine(
                            "Dry run got a target granule, returning null as the additional filters did filter all the granules out");
                    // It means the previous lack of granule was due to a filter excluding all the
                    // results. Then we return null
                    return null;
                }
            }

            // do we return a null (outside of the coverage) or a blank? The choice is "hard" as we
            // might be in a hole of the coverage and not know it
            if (!queryBBox.intersects((BoundingBox) ReferencedEnvelope.reference(coverageEnvelope))
                    && !queryBBox.intersects(
                            (BoundingBox)
                                    ReferencedEnvelope.reference(
                                            rasterManager.spatialDomainManager.coverageBBox))) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine(
                            "Could not locate any granule in the requested bbox, returning null as it does not "
                                    + "match the cached bbox of the mosaic");
                }
                return null;
            } else {
                // prepare a blank response
                return createBlankResponse();
            }

        } catch (Exception e) {
            throw new DataSourceException("Unable to create this mosaic", e);
        }
    }

