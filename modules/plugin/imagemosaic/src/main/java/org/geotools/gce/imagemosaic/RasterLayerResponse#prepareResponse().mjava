    /**
     * This method loads the granules which overlap the requested {@link GeneralEnvelope} using the provided values for alpha and input ROI.
     * 
     * @return
     * @throws DataSourceException
     */
    private RenderedImage prepareResponse() throws DataSourceException {

        try {
            //=== select overview
            chooseOverview();	

            // === extract bbox
            initBBOX();

            // === init transformations
            initTransformations();

            // === init raster bounds
            initRasterBounds();

            // === create query and basic BBOX filtering
            final Query query = initQuery();

            // === manage additional filters
            handleAdditionalFilters(query);

            // === sort by clause
            handleSortByClause(query);

            // === collect granules
            final MosaicProducer visitor = new MosaicProducer();
            rasterManager.getGranules(query, visitor);            
            // get those granules and create the final mosaic
            RenderedImage returnValue = visitor.produce();

            //
            // Did we actually load anything?? Notice that it might happen that
            // either we have holes inside the definition area for the mosaic
            // or we had some problem with missing tiles, therefore it might
            // happen that for some bboxes we don't have anything to load.
            //

            //
            // Create the mosaic image by doing a crop if necessary and also
            // managing the transparent color if applicable. Be aware that
            // management of the transparent color involves removing
            // transparency information from the input images.
            //
            if (returnValue != null) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Loaded bbox " + mosaicBBox.toString() + " while crop bbox "
                            + request.spatialRequestHelper.getCropBBox().toString());
                }
                return returnValue;
            }

            // Redo the query without filter to check whether we got no granules due
            // to a filter. In that case we need to return null
            // Notice that we are using a dryRun visitor to make sure we don't
            // spawn any loading tasks, we also ensure we get only 1 feature at most
            // to make this blazing fast
            LOGGER.fine("We got no granules, let's do a dry run with no filters");
            final MosaicProducer dryRunVisitor = new MosaicProducer(true);
            final Utils.BBOXFilterExtractor bboxExtractor = new Utils.BBOXFilterExtractor();
            query.getFilter().accept(bboxExtractor, null);
            query.setFilter(FeatureUtilities.DEFAULT_FILTER_FACTORY.bbox(
                    FeatureUtilities.DEFAULT_FILTER_FACTORY.property(rasterManager.getGranuleCatalog().getType(rasterManager.getTypeName()).getGeometryDescriptor().getName()),
                    bboxExtractor.getBBox()));
            query.setMaxFeatures(1);
            rasterManager.getGranules(query, dryRunVisitor);
            if (dryRunVisitor.granulesNumber > 0) {
                LOGGER.fine("Dry run got a target granule, returning null as the additional filters did filter all the granules out");
                // It means the previous lack of granule was due to a filter excluding all the results. Then we return null
                return null;
            }

            // prepare a blank response
            return createBlankResponse();

        } catch (Exception e) {
            throw new DataSourceException("Unable to create this mosaic", e);
        }
    }

