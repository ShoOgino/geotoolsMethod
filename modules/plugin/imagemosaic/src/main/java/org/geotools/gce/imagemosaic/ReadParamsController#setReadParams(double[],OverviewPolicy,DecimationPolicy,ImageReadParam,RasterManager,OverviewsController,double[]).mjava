    /**
     * This method is responsible for preparing the read param for doing an {@link
     * ImageReader#read(int, ImageReadParam)}. It sets the passed {@link ImageReadParam} in terms of
     * decimation on reading using the provided requestedEnvelope and requestedDim to evaluate the
     * needed resolution. It also returns and {@link Integer} representing the index of the raster
     * to be read when dealing with multipage raster.
     *
     * @param overviewPolicy it can be one of {@link Hints#VALUE_OVERVIEW_POLICY_IGNORE}, {@link
     *     Hints#VALUE_OVERVIEW_POLICY_NEAREST}, {@link Hints#VALUE_OVERVIEW_POLICY_QUALITY} or
     *     {@link Hints#VALUE_OVERVIEW_POLICY_SPEED}. It specifies the policy to compute the
     *     overviews level upon request.
     * @param readParams an instance of {@link ImageReadParam} for setting the subsampling factors.
     * @return the index of the raster to read in the underlying data source.
     */
    static int setReadParams(
            final double[] requestedResolution,
            OverviewPolicy overviewPolicy,
            DecimationPolicy decimationPolicy,
            final ImageReadParam readParams,
            final RasterManager rasterManager,
            final OverviewsController overviewController,
            final double[] virtualNativeResolution)
            throws IOException, TransformException {

        Utilities.ensureNonNull("readParams", readParams);
        Utilities.ensureNonNull("RasterManager", rasterManager);
        Utilities.ensureNonNull("overviewsController", overviewController);

        if (overviewPolicy == null) {
            overviewPolicy = OverviewPolicy.getDefaultPolicy();
        }

        if (decimationPolicy == null) {
            decimationPolicy = DecimationPolicy.getDefaultPolicy();
        }

        // Default image index 0
        int imageChoice = 0;
        // default values for subsampling
        readParams.setSourceSubsampling(1, 1, 0, 0);

        // requested to ignore overviews
        if (overviewPolicy.equals(OverviewPolicy.IGNORE)
                && decimationPolicy.equals(DecimationPolicy.DISALLOW)
                && virtualNativeResolution == null) return imageChoice;

        if (!overviewPolicy.equals(OverviewPolicy.IGNORE)) {
            imageChoice =
                    overviewController.pickOverviewLevel(
                            overviewPolicy, requestedResolution, virtualNativeResolution);
            if (virtualNativeResolution != null
                    && !Double.isNaN(virtualNativeResolution[0])
                    && !Double.isNaN(virtualNativeResolution[1])) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine(
                            "Specified Resolution is: resX="
                                    + virtualNativeResolution[0]
                                    + " ; resY="
                                    + virtualNativeResolution[1]
                                    + " . Choosing imageIndex = "
                                    + imageChoice);
                }
            }
        }

        // DECIMATION ON READING
        if (!decimationPolicy.equals(DecimationPolicy.DISALLOW)) {
            ReadParamsController.performDecimation(
                    rasterManager.spatialDomainManager,
                    requestedResolution,
                    imageChoice,
                    readParams,
                    overviewController,
                    virtualNativeResolution);
        }
        return imageChoice;
    }

