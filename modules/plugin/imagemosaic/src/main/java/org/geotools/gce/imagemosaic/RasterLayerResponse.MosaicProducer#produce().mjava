        /**
         * This method is responsible for producing the final mosaic.
         *
         * <p>
         *
         * <p>Depending on whether or not a {@link MergeBehavior#STACK}ing is required, we perform 1
         * or 2 steps.
         *
         * <ol>
         *   <li>step 1 is for merging flat on each value for the dimension
         *   <li>step 2 is for merging stack on the resulting mosaics
         * </ol>
         */
        private MosaicOutput produce() throws IOException {
            // checks
            if (granulesNumber == 0) {
                LOGGER.log(Level.FINE, "Unable to load any granuleDescriptor");
                return null;
            }

            // STEP 1 collect all the mosaics from each single dimension
            LOGGER.fine("Producing the final mosaic, step 1, loop through granule collectors");
            final List<MosaicElement> mosaicInputs = new ArrayList<>();
            SubmosaicProducer first = null; // we take this apart to steal some val
            int size = 0;
            for (SubmosaicProducer collector : granuleCollectors) {
                if (LOGGER.isLoggable(Level.FINER)) {
                    LOGGER.fine("Submosaic producer being called: " + collector.toString());
                }
                final List<MosaicElement> preparedMosaic = collector.createMosaic();
                if (preparedMosaic.size() > 0
                        && !preparedMosaic.stream().allMatch(p -> p == null)) {
                    size += preparedMosaic.size();
                    mosaicInputs.addAll(preparedMosaic);
                    if (first == null) {
                        first = collector;
                    }
                }
            }
            LOGGER.fine("Producing the final mosaic, step 2, final mosaicking");
            // optimization
            if (size == 1) {
                // we don't need to mosaick again
                return new MosaicOutput(mosaicInputs.get(0));
            }
            // no mosaics produced, it might happen, see above
            if (size == 0) {
                return null;
            }

            MosaicInputs mosaickingInputs =
                    new MosaicInputs(
                            first.doInputTransparency(),
                            first.hasAlpha(),
                            mosaicInputs,
                            first.getSourceThreshold());
            // normal situation
            return new MosaicOutput(
                    new Mosaicker(RasterLayerResponse.this, mosaickingInputs, mergeBehavior)
                            .createMosaic());
        }

