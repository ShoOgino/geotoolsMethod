    /**
     * Return a crop region from a specified envelope, leveraging on the grid to world transformation.
     * 
     * @param refinedRequestedBBox the crop envelope
     * @return a {@code Rectangle} representing the crop region.
     * @throws TransformException in case a problem occurs when going back to raster space.
     * @throws DataSourceException
     */
    private void computeRasterArea() throws DataSourceException {

        // we have nothing to crop
        if (emptyRequest || computedBBox == null) {
            throw new IllegalStateException(
                    "IllegalState, unable to compute raster area for null bbox");
        }

        try {
            //
            // We need to invert the requested gridToWorld and then adjust the requested raster area are accordingly
            //

            // invert the requested grid to world keeping into account the fact that it is related to cell center
            // while the raster is related to cell corner
            MathTransform2D requestedWorldToGrid = (MathTransform2D) PixelTranslation
                    .translate(ProjectiveTransform.create(requestedGridToWorld),
                            PixelInCell.CELL_CENTER, PixelInCell.CELL_CORNER)
                    .inverse();

            if (!needsReprojection) {

                // now get the requested bbox which have been already adjusted and project it back
                // to raster space
                computedRasterArea = new GeneralGridEnvelope(
                        CRS.transform(requestedWorldToGrid, new GeneralEnvelope(computedBBox)),
                        PixelInCell.CELL_CORNER, false).toRectangle();

            } else {
                //
                // reproject the crop bbox back in the requested crs and then crop, notice that we
                // are imposing
                // the same raster area somehow
                //

                final GeneralEnvelope cropBBOXInRequestCRS = CRS.transform(computedBBox,
                        requestCRS);
                // make sure it falls within the requested envelope
                cropBBOXInRequestCRS.intersect(requestedBBox);

                // now go back to raster space
                computedRasterArea = new GeneralGridEnvelope(
                        CRS.transform(requestedWorldToGrid, cropBBOXInRequestCRS),
                        PixelInCell.CELL_CORNER, false).toRectangle();
                // intersect with the original requested raster space to be sure that we stay within
                // the requested raster area
                XRectangle2D.intersect(computedRasterArea, requestedRasterArea, computedRasterArea);

            }
        } catch (Exception e) {
            throw new DataSourceException(e);
        }

        // is it empty??
        if (computedRasterArea.isEmpty()) {

            // TODO: Future versions may define a 1x1 rectangle starting
            // from the lower coordinate
            emptyRequest = true;
            return;
        }

    }

