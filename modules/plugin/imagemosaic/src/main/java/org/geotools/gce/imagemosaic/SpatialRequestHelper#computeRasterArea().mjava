    /**
     * Return a crop region from a specified envelope, leveraging on the grid to world transformation.
     * 
     * @param refinedRequestedBBox the crop envelope
     * @return a {@code Rectangle} representing the crop region.
     * @throws TransformException in case a problem occurs when going back to raster space.
     * @throws DataSourceException
     */
    private void computeRasterArea() throws DataSourceException {

        // we have nothing to crop
        if (emptyRequest || computedBBox == null) {
            throw new IllegalStateException(
                    "IllegalState, unable to compute raster area for null bbox");
        }

        try {
            //
            // We need to invert the requested gridToWorld and then adjust the requested raster area are accordingly
            //

            // invert the requested grid to world keeping into account the fact that it is related to cell center
            // while the raster is related to cell corner
            MathTransform2D requestedWorldToGrid = (MathTransform2D) PixelTranslation
                    .translate(ProjectiveTransform.create(requestedGridToWorld),
                            PixelInCell.CELL_CENTER, PixelInCell.CELL_CORNER)
                    .inverse();

            if (!needsReprojection) {

                // now get the requested bbox which have been already adjusted and project it back
                // to raster space
                computedRasterArea = new GeneralGridEnvelope(
                        CRS.transform(requestedWorldToGrid, new GeneralEnvelope(computedBBox)),
                        PixelInCell.CELL_CORNER, false).toRectangle();

            } else {
                //
                // reproject the crop bbox back in the requested crs and then crop, notice that we
                // are imposing
                // the same raster area somehow
                //
                Rectangle computedRasterArea = computeRasterArea(computedBBox, requestedWorldToGrid);
                this.computedRasterArea = computedRasterArea;

            }
        } catch (Exception e) {
            throw new DataSourceException(e);
        }

        // is it empty??
        if (computedRasterArea.isEmpty()) {

            // TODO: Future versions may define a 1x1 rectangle starting
            // from the lower coordinate
            emptyRequest = true;
            return;
        }

    }

