	/**
	 * Once we reach this method it means that we have loaded all the images
	 * which were intersecting the requested envelope. Next step is to create
	 * the final mosaic image and cropping it to the exact requested envelope.
	 * @param visitor 
	 * 
	 * @return A {@link RenderedImage}}.
	 */
	private RenderedImage buildMosaic(final MosaicBuilder visitor) throws IOException  {

	    // build final layout and use it for cropping purposes
		final ImageLayout layout = new ImageLayout(
				rasterBounds.x,
				rasterBounds.y,
				rasterBounds.width,
				rasterBounds.height);
		
                //prepare hints
                final Dimension tileDimensions=request.getTileDimensions();
                if(tileDimensions!=null)
                        layout.setTileHeight(tileDimensions.width).setTileWidth(tileDimensions.height);
                final RenderingHints localHints = new RenderingHints(JAI.KEY_IMAGE_LAYOUT,layout);
                if (hints != null && !hints.isEmpty()){
                    if (hints.containsKey(JAI.KEY_TILE_CACHE)){
                        final Object tc = hints.get(JAI.KEY_TILE_CACHE);
                        if (tc != null && tc instanceof TileCache)
                            localHints.add(new RenderingHints(JAI.KEY_TILE_CACHE, (TileCache) tc));
                    }
                    boolean addBorderExtender = true;
                    if (hints != null && hints.containsKey(JAI.KEY_BORDER_EXTENDER)){
                        final Object extender = hints.get(JAI.KEY_BORDER_EXTENDER);
                        if (extender != null && extender instanceof BorderExtender) {
                            localHints.add(new RenderingHints(JAI.KEY_BORDER_EXTENDER, (BorderExtender) extender));
                            addBorderExtender = false;
                        }
                    }
                    if (addBorderExtender){
                        localHints.add(ImageUtilities.BORDER_EXTENDER_HINTS);
                    }
                    if (hints.containsKey(JAI.KEY_TILE_SCHEDULER)){
                        final Object ts = hints.get(JAI.KEY_TILE_SCHEDULER);
                        if (ts != null && ts instanceof TileScheduler)
                            localHints.add(new RenderingHints(JAI.KEY_TILE_SCHEDULER, (TileScheduler) ts));
                    }
                }	
                
		//
		// SPECIAL CASE
		// 1 single tile, we try not do a mosaic.
        final ROI[] sourceRoi = visitor.sourceRoi;
		if(visitor.granulesNumber==1 && Utils.OPTIMIZE_CROP){
		    // the roi is exactly equal to the 
		    final ROI roi = visitor.rois.get(0);
		    Rectangle bounds = Utils.toRectangle(roi.getAsShape());
	        if (bounds != null) {
	            RenderedImage image= visitor.getSourcesAsArray()[0];
	            Rectangle imageBounds= PlanarImage.wrapRenderedImage(image).getBounds();
	            if(imageBounds.equals(bounds)){
	                
	                // do we need to crop? (image is bigger than requested?)
	                if(!rasterBounds.contains(imageBounds)){
	                    // we have to crop
	                    XRectangle2D.intersect(imageBounds, rasterBounds, imageBounds);
	                    
	                    if(imageBounds.isEmpty()){
	                        // return back a constant image
	                        return null;
	                    }
	                    // crop
	                    ImageWorker iw = new ImageWorker(image);
	                    iw.setRenderingHints(localHints);
	                    iw.crop(imageBounds.x, imageBounds.y, imageBounds.width, imageBounds.height);
	                    
	                    image = iw.getRenderedImage();
	                    imageBounds = PlanarImage.wrapRenderedImage(image).getBounds();
	                }
	                
	                // and, do we need to add a border around the image?
	                if(!imageBounds.contains(rasterBounds)) {
	                    image = MosaicDescriptor.create(
	                            new RenderedImage[] {image}, 
	                            request.isBlend()? MosaicDescriptor.MOSAIC_TYPE_BLEND: MosaicDescriptor.MOSAIC_TYPE_OVERLAY, 
	                            (alphaIn || visitor.doInputTransparency) ? visitor.alphaChannels : null, sourceRoi, 
	                            visitor.sourceThreshold, 
	                            backgroundValues, 
	                            localHints);
	                }
	                
	                return image;
	            }
	        }
		}


		final RenderedImage mosaic = MosaicDescriptor.create(
		        visitor.getSourcesAsArray(), 
		        request.isBlend()? MosaicDescriptor.MOSAIC_TYPE_BLEND: MosaicDescriptor.MOSAIC_TYPE_OVERLAY, 
		        (alphaIn || visitor.doInputTransparency) ? visitor.alphaChannels : null, sourceRoi, 
		        visitor.sourceThreshold, 
		        backgroundValues, 
		        localHints);
		
		if (setRoiProperty) {
		    
    		    //Adding globalRoi to the output
    		    RenderedOp rop = (RenderedOp) mosaic;
                    ROI globalRoi = null;
                    ROI[] rois = sourceRoi;
                    for (int i=0; i<rois.length; i++){
                        if (globalRoi == null){
                              globalRoi = new ROIGeometry(((ROIGeometry)rois[i]).getAsGeometry());
                        } else {
                            globalRoi = globalRoi.add(rois[i]);
                        }
                    }
                    rop.setProperty("ROI", globalRoi);
		}

		if (LOGGER.isLoggable(Level.FINE))
			LOGGER.fine("Mosaic created ");


		// create the coverage
		return mosaic;

	}

