    /**
     * Extract the domain of a dimension (with Range) as a set of values.
     *
     * <p>It retrieves a comma separated list of values as a Set of {@link String}.
     *
     * @param domainType
     * @return a comma separated list of values as a Set of {@link String}.
     * @throws IOException
     */
    private Set extractDomain(
            final String attribute, final String secondAttribute, final DomainType domainType)
            throws IOException {
        final Query query = new Query(typeName);

        final PropertyName propertyName =
                FeatureUtilities.DEFAULT_FILTER_FACTORY.property(attribute);
        query.setPropertyNames(Arrays.asList(attribute, secondAttribute));

        final SortByImpl[] sb =
                new SortByImpl[] {new SortByImpl(propertyName, SortOrder.ASCENDING)};
        // Checking whether it supports sorting capabilities
        if (granuleCatalog.getQueryCapabilities(typeName).supportsSorting(sb)) {
            query.setSortBy(sb);
        } else {
            LOGGER.severe(
                    "Sorting parameter ignored, underlying datastore cannot sort on "
                            + Arrays.toString(sb));
        }

        final FeatureCalc visitor =
                domainType == DomainType.TIME_RANGE
                        ? new DateRangeVisitor(attribute, secondAttribute)
                        : new RangeVisitor(attribute, secondAttribute);
        granuleCatalog.computeAggregateFunction(query, visitor);
        return domainType == DomainType.TIME_RANGE
                ? ((DateRangeVisitor) visitor).getRange()
                : ((RangeVisitor) visitor).getRange();
    }

