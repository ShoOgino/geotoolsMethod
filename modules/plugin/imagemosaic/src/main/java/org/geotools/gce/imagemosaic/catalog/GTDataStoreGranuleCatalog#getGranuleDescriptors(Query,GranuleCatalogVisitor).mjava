    @Override
    public void getGranuleDescriptors(Query query, final GranuleCatalogVisitor visitor)
            throws IOException {
        Utilities.ensureNonNull("query", query);
        final Query q = mergeHints(query);
        String typeName = q.getTypeName();
        final Lock lock = rwLock.readLock();
        try {
            lock.lock();
            checkStore();

            //
            // Load tiles informations, especially the bounds, which will be
            // reused
            //
            final SimpleFeatureSource featureSource = tileIndexStore.getFeatureSource(typeName);
            if (featureSource == null) {
                throw new NullPointerException(
                        "The provided SimpleFeatureSource is null, it's impossible to create an index!");
            }

            final SimpleFeatureCollection features = featureSource.getFeatures(q);
            if (features == null)
                throw new NullPointerException(
                        "The provided SimpleFeatureCollection is null, it's impossible to create an index!");

            if (LOGGER.isLoggable(Level.FINE))
                LOGGER.fine("Index Loaded");

            // visiting the features from the underlying store
            final DefaultProgressListener listener = new DefaultProgressListener();
            features.accepts(new AbstractFeatureVisitor() {
                public void visit(Feature feature) {
                    if (feature instanceof SimpleFeature) {
                        // get the feature
                        final SimpleFeature sf = (SimpleFeature) feature;
                        MultiLevelROI footprint = getGranuleFootprint(sf);
                        if (footprint == null || !footprint.isEmpty()) {
                            try {
                                final GranuleDescriptor granule = new GranuleDescriptor(sf,
                                        suggestedRasterSPI, pathType, locationAttribute,
                                        parentLocation, footprint, heterogeneous, q.getHints());

                                visitor.visit(granule, null);
                            } catch (Exception e) {
                                LOGGER.log(Level.FINE, "Skipping invalid granule", e);
                            }
                        }

                        // check if something bad occurred
                        if (listener.isCanceled() || listener.hasExceptions()) {
                            if (listener.hasExceptions()) {
                                throw new RuntimeException(listener.getExceptions().peek());
                            } else {
                                throw new IllegalStateException(
                                        "Feature visitor for query " + q + " has been canceled");
                            }
                        }
                    }
                }
            }, listener);

        } catch (Throwable e) {
            final IOException ioe = new IOException();
            ioe.initCause(e);
            throw ioe;
        } finally {
            lock.unlock();

        }
    }

