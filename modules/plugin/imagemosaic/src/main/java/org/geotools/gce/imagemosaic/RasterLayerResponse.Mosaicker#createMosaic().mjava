        /**
         * Once we reach this method it means that we have loaded all the images
         * which were intersecting the requested envelope. Next step is to create
         * the final mosaic image and cropping it to the exact requested envelope.
         * 
         * @return A {@link MosaicElement}}.
         */
        private MosaicElement createMosaic() throws IOException  {
            
            // anything to do?
            final int size = inputs.size();
            if (size <= 0) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.log(Level.FINE, "Unable to load any granuleDescriptor ");
                }
                return null;
            }

            // === prepare hints
            final RenderingHints localHints = prepareHints();

            //
            // SPECIAL CASE
            // 1 single tile, we try not do a mosaic.
            if (size == 1 && Utils.OPTIMIZE_CROP) {
                // prepare input
                MosaicElement in = inputs.get(0);
                
                if (in == null) {
                    throw new NullPointerException("The list of MosaicElements contains one element but it's null");
                }
    
                // the roi is exactly equal to the image
                final ROI roi = in.roi;
                Rectangle bounds = Utils.toRectangle(roi.getAsShape());
                if (bounds != null) {
                    RenderedImage mosaic = in.source;
                    Rectangle imageBounds = PlanarImage.wrapRenderedImage(mosaic).getBounds();
                    if (imageBounds.equals(bounds)) {

                        // do we need to crop? (image is bigger than requested?)
                        if (!rasterBounds.contains(imageBounds)) {
                            // we have to crop
                            XRectangle2D.intersect(imageBounds, rasterBounds, imageBounds);

                            if (imageBounds.isEmpty()) {
                                // return back a constant image
                                return null;
                            }
                            // crop
                            ImageWorker iw = new ImageWorker(mosaic);
                            iw.setRenderingHints(localHints);
                            iw.crop(imageBounds.x, imageBounds.y, imageBounds.width, imageBounds.height);
                            mosaic = iw.getRenderedImage();
                            imageBounds = PlanarImage.wrapRenderedImage(mosaic).getBounds();
                        }

                        // and, do we need to add a border around the image?
                        if (!imageBounds.contains(rasterBounds)) {
                            mosaic = MergeBehavior.FLAT
                                    .process(
                                            new RenderedImage[] { mosaic },
                                            backgroundValues,
                                            sourceThreshold,
                                            (hasAlpha || doInputTransparency) ? new PlanarImage[] { in.alphaChannel }: new PlanarImage[] { null },
                                            new ROI[] { in.roi },
                                            request.isBlend() ? MosaicDescriptor.MOSAIC_TYPE_BLEND: MosaicDescriptor.MOSAIC_TYPE_OVERLAY,
                                            localHints);
                            if (setRoiProperty) {
                                // Adding globalRoi to the output
                                RenderedOp rop = (RenderedOp) mosaic;
                                rop.setProperty("ROI", in.roi);
                            }
                        }

                        // add to final list
                        return new MosaicElement(in.alphaChannel, roi, mosaic);
                    }
                }
            }

            // === do the mosaic as usual
            // prepare sources for the mosaic operation
            final RenderedImage[] sources = new RenderedImage[size];
            final PlanarImage[] alphas = new PlanarImage[size];
            final ROI[] rois = new ROI[size];
            ROI overallROI = null; // final ROI
            for (int i = 0; i < size; i++) {
                final MosaicElement mosaicElement = inputs.get(i);
                sources[i] = mosaicElement.source;
                alphas[i] = mosaicElement.alphaChannel;
                rois[i] = mosaicElement.roi;
                if (overallROI == null) {
                    overallROI = new ROIGeometry(((ROIGeometry) mosaicElement.roi).getAsGeometry());
                } else {
                    if (mosaicElement.roi != null) {
                        overallROI=overallROI.add(mosaicElement.roi);
                    }
                }                
            }

            // execute mosaic
            final RenderedImage mosaic = 
                mergeBehavior.process(
                        sources,
                        backgroundValues, 
                        sourceThreshold,
                        (hasAlpha || doInputTransparency) ? alphas : null,
                        rois, 
                        request.isBlend() ? MosaicDescriptor.MOSAIC_TYPE_BLEND: MosaicDescriptor.MOSAIC_TYPE_OVERLAY, 
                        localHints);
            
            if (setRoiProperty) {
                // Adding globalRoi to the output
                RenderedOp rop = (RenderedOp) mosaic;
                
                assert overallROI!=null;
                rop.setProperty("ROI", overallROI);
            }
    
            // prepare for next step
            if(hasAlpha || doInputTransparency){
                return new MosaicElement(new ImageWorker(mosaic).retainLastBand().getPlanarImage(), overallROI, mosaic);
             } else {
                return new MosaicElement(null, overallROI, mosaic);
             }            
            
        }

