    /**
     * Write a footprint summary file (".fpt") given an input <String,Geometry> map containing
     * granule location and related geometry, and the index shapefile store to associate footprints
     * to granules.
     *
     * @param footprintSummaryFile the output footprint summary file
     * @param footprintsLocationGeometryMap the map containing <granuleLocation,footprintGeometry>
     *     pairs
     * @throws MalformedURLException In case the url we create internally for the mosaic index is
     *     wrong (should never happen)
     */
    static void writeFootprintSummary(
            final File footprintSummaryFile,
            final File indexFile,
            final Map<String, Geometry> footprintsLocationGeometryMap)
            throws MalformedURLException {
        Utilities.ensureNonNull("footprintSummaryFile", footprintSummaryFile);
        Utilities.ensureNonNull("indexFile", indexFile);
        Utilities.ensureNonNull("footprintsLocationGeometryMap", footprintsLocationGeometryMap);
        if (footprintsLocationGeometryMap.isEmpty()) return;
        final ShapefileDataStore store = new ShapefileDataStore(URLs.fileToUrl(indexFile));

        if (footprintsLocationGeometryMap.isEmpty()) return;

        FeatureIterator<SimpleFeature> it = null;
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(footprintSummaryFile))) {
            final String[] typeNames = store.getTypeNames();
            if (typeNames.length <= 0) {
                throw new IllegalArgumentException(
                        "Problems when opening the shapefile, no typenames for the schema are defined");
            }
            final String typeName = typeNames[0];

            final FeatureSource<SimpleFeatureType, SimpleFeature> featureSource =
                    store.getFeatureSource(typeName);
            final FeatureCollection<SimpleFeatureType, SimpleFeature> features =
                    featureSource.getFeatures();

            if (features == null) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("No features found in the shapefile");
                }
                return;
            }

            // load the feature from the shapefile
            it = features.features();
            if (!it.hasNext())
                throw new IllegalArgumentException(
                        "The provided FeatureCollection<SimpleFeatureType, SimpleFeature>  or empty, it's impossible to create an index!");

            final WKTWriter geometryWriter = new WKTWriter();

            // Scan the index shapefile to get granules location
            while (it.hasNext()) {
                final SimpleFeature feature = it.next();
                final String location = (String) feature.getAttribute("location");
                if (location != null && location.trim().length() > 0) {
                    final String locationKey = location;

                    // Check if a footprint exist in the map for this granule
                    if (footprintsLocationGeometryMap.containsKey(locationKey)) {

                        // Build a featureID=Geometry pair and write it in
                        // the Footprint summary file
                        final String idGeometryPair =
                                FootprintUtils.buildIDGeometryPair(
                                        footprintsLocationGeometryMap,
                                        feature.getID(),
                                        locationKey,
                                        geometryWriter);
                        writer.write(idGeometryPair);
                    }
                }
            }
            writer.flush();
            writer.close();
        } catch (Throwable e) {
            // ignore exception
            if (LOGGER.isLoggable(Level.FINEST))
                LOGGER.log(Level.FINEST, e.getLocalizedMessage(), e);
        } finally {
            try {
                if (it != null) {
                    it.close();
                }
            } catch (Throwable e) {
                if (LOGGER.isLoggable(Level.FINEST))
                    LOGGER.log(Level.FINEST, e.getLocalizedMessage(), e);
            }

            try {
                store.dispose();
            } catch (Throwable e) {
                if (LOGGER.isLoggable(Level.FINEST))
                    LOGGER.log(Level.FINEST, e.getLocalizedMessage(), e);
            }
        }
    }

