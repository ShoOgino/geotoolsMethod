    private static MosaicConfigurationBean loadMosaicProperties(final URL sourceURL,
            final Set<String> ignorePropertiesSet) {

        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.log(Level.FINE, "Trying to load properties file from URL:" + sourceURL);
        }

        // ret value
        final MosaicConfigurationBean retValue = new MosaicConfigurationBean();
        final CatalogConfigurationBean catalogConfigurationBean = new CatalogConfigurationBean();
        retValue.setCatalogConfigurationBean(catalogConfigurationBean);
        final boolean ignoreSome = ignorePropertiesSet != null && !ignorePropertiesSet.isEmpty();

        //
        // load the properties file
        //
        URL propsURL = sourceURL;
        if (!sourceURL.toExternalForm().endsWith(".properties")) {
            propsURL = DataUtilities.changeUrlExt(sourceURL, "properties");
            if (propsURL.getProtocol().equals("file")) {
                final File sourceFile = URLs.urlToFile(propsURL);
                if (!sourceFile.exists()) {
                    if (LOGGER.isLoggable(Level.INFO)) {
                        LOGGER.info("properties file doesn't exist");
                    }
                    return null;
                }
            }
        }

        final Properties properties = CoverageUtilities.loadPropertiesFromURL(propsURL);
        if (properties == null) {
            if (LOGGER.isLoggable(Level.INFO))
                LOGGER.info("Unable to load mosaic properties file");
            return null;
        }

        String[] pairs = null;
        String pair[] = null;

        //
        // imposed bbox is optional
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.ENVELOPE2D)) {
            String bboxString = properties.getProperty(Prop.ENVELOPE2D, null);
            if (bboxString != null) {
                bboxString = bboxString.trim();
                try {
                    ReferencedEnvelope bbox = parseEnvelope(bboxString);
                    if (bbox != null)
                        retValue.setEnvelope(bbox);
                    else if (LOGGER.isLoggable(Level.INFO))
                        LOGGER.info("Cannot parse imposed bbox.");
                } catch (Exception e) {
                    if (LOGGER.isLoggable(Level.INFO))
                        LOGGER.log(Level.INFO, "Cannot parse imposed bbox.", e);
                }
            }

        }

        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.AUXILIARY_FILE)) {
            retValue.setAuxiliaryFilePath(properties.getProperty(Prop.AUXILIARY_FILE));
        }
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.AUXILIARY_DATASTORE_FILE)) {
            retValue.setAuxiliaryDatastorePath(
                    properties.getProperty(Prop.AUXILIARY_DATASTORE_FILE));
        }

        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.CHECK_AUXILIARY_METADATA)) {
            final boolean checkAuxiliaryMetadata = Boolean
                    .valueOf(properties.getProperty(Prop.CHECK_AUXILIARY_METADATA, "false").trim());
            retValue.setCheckAuxiliaryMetadata(checkAuxiliaryMetadata);
        }

        //
        // resolutions levels
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.LEVELS)) {
            int levelsNumber = Integer
                    .parseInt(properties.getProperty(Prop.LEVELS_NUM, "1").trim());
            retValue.setLevelsNum(levelsNumber);
            if (!properties.containsKey(Prop.LEVELS)) {
                if (LOGGER.isLoggable(Level.INFO))
                    LOGGER.info("Required key Levels not found.");
                return null;
            }
            final String levels = properties.getProperty(Prop.LEVELS).trim();
            pairs = levels.split(" ");
            if (pairs.length != levelsNumber) {
                if (LOGGER.isLoggable(Level.INFO))
                    LOGGER.info(
                            "Levels number is different from the provided number of levels resoltion.");
                return null;
            }
            final double[][] resolutions = new double[levelsNumber][2];
            for (int i = 0; i < levelsNumber; i++) {
                pair = pairs[i].split(",");
                if (pair == null || pair.length != 2) {
                    if (LOGGER.isLoggable(Level.INFO))
                        LOGGER.info(
                                "OverviewLevel number is different from the provided number of levels resoltion.");
                    return null;
                }
                resolutions[i][0] = Double.parseDouble(pair[0]);
                resolutions[i][1] = Double.parseDouble(pair[1]);
            }
            retValue.setLevels(resolutions);
        }

        //
        // typename, is mandatory when we don't use shapeiles
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.TYPENAME)) {
            String typeName = properties.getProperty(Prop.TYPENAME, null);
            catalogConfigurationBean.setTypeName(typeName);
        }

        //
        // suggested spi is optional
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.SUGGESTED_SPI)) {
            if (properties.containsKey(Prop.SUGGESTED_SPI)) {
                final String suggestedSPI = properties.getProperty(Prop.SUGGESTED_SPI).trim();
                catalogConfigurationBean.setSuggestedSPI(suggestedSPI);
            }
        }

        //
        // suggested format is optional
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.SUGGESTED_FORMAT)) {
            if (properties.containsKey(Prop.SUGGESTED_FORMAT)) {
                final String suggestedFormat = properties.getProperty(Prop.SUGGESTED_FORMAT).trim();
                catalogConfigurationBean.setSuggestedFormat(suggestedFormat);
            }
        }

        //
        // suggested IS Spi is optional
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.SUGGESTED_IS_SPI)) {
            if (properties.containsKey(Prop.SUGGESTED_IS_SPI)) {
                final String suggestedIsSpi = properties.getProperty(Prop.SUGGESTED_IS_SPI).trim();
                catalogConfigurationBean.setSuggestedIsSPI(suggestedIsSpi);
            }
        }

        //
        // time attribute is optional
        //
        if (properties.containsKey(Prop.TIME_ATTRIBUTE)) {
            final String timeAttribute = properties.getProperty("TimeAttribute").trim();
            retValue.setTimeAttribute(timeAttribute);
        }

        //
        // elevation attribute is optional
        //
        if (properties.containsKey(Prop.ELEVATION_ATTRIBUTE)) {
            final String elevationAttribute = properties.getProperty(Prop.ELEVATION_ATTRIBUTE)
                    .trim();
            retValue.setElevationAttribute(elevationAttribute);
        }
        
        //
        // crs attribute is optional
        //
        if (properties.containsKey(Prop.CRS_ATTRIBUTE)) {
            final String crsAttribute = properties.getProperty(Prop.CRS_ATTRIBUTE).trim();
            retValue.setCRSAttribute(crsAttribute);
        }

        //
        // resolution attributes are optional
        //
        if (properties.containsKey(Prop.RESOLUTION_ATTRIBUTE)) {
            final String attribute = properties.getProperty(Prop.RESOLUTION_ATTRIBUTE).trim();
            retValue.setResolutionAttribute(attribute);
        }
        if (properties.containsKey(Prop.RESOLUTION_X_ATTRIBUTE)) {
            final String attribute = properties.getProperty(Prop.RESOLUTION_X_ATTRIBUTE).trim();
            retValue.setResolutionXAttribute(attribute);
        }
        if (properties.containsKey(Prop.RESOLUTION_Y_ATTRIBUTE)) {
            final String attribute = properties.getProperty(Prop.RESOLUTION_Y_ATTRIBUTE).trim();
            retValue.setResolutionYAttribute(attribute);
        }

        //
        // additional domain attribute is optional
        //
        if (properties.containsKey(Prop.ADDITIONAL_DOMAIN_ATTRIBUTES)) {
            final String additionalDomainAttributes = properties
                    .getProperty(Prop.ADDITIONAL_DOMAIN_ATTRIBUTES).trim();
            retValue.setAdditionalDomainAttributes(additionalDomainAttributes);
        }

        //
        // caching
        //
        if (properties.containsKey(Prop.CACHING)) {
            String caching = properties.getProperty(Prop.CACHING).trim();
            try {
                catalogConfigurationBean.setCaching(Boolean.valueOf(caching));
            } catch (Throwable e) {
                catalogConfigurationBean
                        .setCaching(Boolean.valueOf(Utils.DEFAULT_CACHING_BEHAVIOR));
            }
        }

        //
        // name is not optional
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.NAME)) {
            if (!properties.containsKey(Prop.NAME)) {
                if (LOGGER.isLoggable(Level.SEVERE))
                    LOGGER.severe("Required key Name not found.");
                return null;
            }
            String coverageName = properties.getProperty(Prop.NAME).trim();
            retValue.setName(coverageName);
        }

        // need a color expansion?
        // this is a newly added property we have to be ready to the case where
        // we do not find it.
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.EXP_RGB)) {
            final boolean expandMe = Boolean
                    .valueOf(properties.getProperty(Prop.EXP_RGB, "false").trim());
            retValue.setExpandToRGB(expandMe);
        }

        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.WRAP_STORE)) {
            final boolean wrapStore = Boolean
                    .valueOf(properties.getProperty(Prop.WRAP_STORE, "false").trim());
            catalogConfigurationBean.setWrapStore(wrapStore);
        }

        //
        // Is heterogeneous granules mosaic
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.HETEROGENEOUS)) {
            final boolean heterogeneous = Boolean
                    .valueOf(properties.getProperty(Prop.HETEROGENEOUS, "false").trim());
            catalogConfigurationBean.setHeterogeneous(heterogeneous);
        }
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.HETEROGENEOUS_CRS)) {
            final boolean heterogeneousCRS = Boolean
                    .valueOf(properties.getProperty(Prop.HETEROGENEOUS_CRS, "false").trim());
            if (!catalogConfigurationBean.isHeterogeneous()) {
                catalogConfigurationBean.setHeterogeneous(heterogeneousCRS);
            }
            catalogConfigurationBean.setHeterogeneousCRS(heterogeneousCRS);
        }


        //
        // Absolute or relative path
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.ABSOLUTE_PATH)) {
            final boolean absolutePath = Boolean.valueOf(properties
                    .getProperty(Prop.ABSOLUTE_PATH, Boolean.toString(Utils.DEFAULT_PATH_BEHAVIOR))
                    .trim());
            catalogConfigurationBean.setAbsolutePath(absolutePath);
        }
        
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.PATH_TYPE)) {
            final String pathType = properties.getProperty(Prop.PATH_TYPE);
            if (pathType != null) {
                catalogConfigurationBean.setPathType(PathType.valueOf(pathType.trim()));
            }
        }

        //
        // Footprint management
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.FOOTPRINT_MANAGEMENT)) {
            final boolean footprintManagement = Boolean
                    .valueOf(properties.getProperty(Prop.FOOTPRINT_MANAGEMENT, "false").trim());
            retValue.setFootprintManagement(footprintManagement);
        }

        //
        // location
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.LOCATION_ATTRIBUTE)) {
            catalogConfigurationBean.setLocationAttribute(properties
                    .getProperty(Prop.LOCATION_ATTRIBUTE, Utils.DEFAULT_LOCATION_ATTRIBUTE).trim());
        }

        //
        // CoverageNameCollectorSpi
        //
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.COVERAGE_NAME_COLLECTOR_SPI)) {
            String coverageNameCollectorSpi = properties.getProperty(Prop.COVERAGE_NAME_COLLECTOR_SPI);
            if (coverageNameCollectorSpi != null && ((coverageNameCollectorSpi = coverageNameCollectorSpi.trim()) != null)) {
                retValue.setCoverageNameCollectorSpi(coverageNameCollectorSpi);
            }
        }

        // target CRS
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.MOSAIC_CRS)) {
            String crsCode = properties.getProperty(Prop.MOSAIC_CRS);
            if (crsCode != null && !crsCode.isEmpty()) {
                try {
                    retValue.setCrs(decodeSrs(crsCode));
                } catch (FactoryException e) {
                    LOGGER.log(Level.FINE,
                            "Unable to decode CRS of mosaic properties file. Configured CRS "
                                    + "code was: " + crsCode,
                            e);
                }
            }
        }

        // target NoData
        if (!ignoreSome || !ignorePropertiesSet.contains(Prop.NO_DATA)) {
            String noDataStr = properties.getProperty(Prop.NO_DATA);
            if (noDataStr != null && !noDataStr.isEmpty()) {
                try {
                    double noData = Double.parseDouble(noDataStr);
                    retValue.setNoData(noData);
                } catch (NumberFormatException e) {
                    LOGGER.log(Level.FINE,
                            "Unable to decode NoData of mosaic properties file. Configured NoData "
                                    + "code was: " + noDataStr,
                            e);
                }
            }
        }

        // Also initialize the indexer here, since it will be needed later on.
        File mosaicParentFolder = URLs.urlToFile(sourceURL).getParentFile();
        Indexer indexer = loadIndexer(mosaicParentFolder);

        if (indexer != null) {
            retValue.setIndexer(indexer);
            String granuleCollectorFactorySPI = IndexerUtils.getParameter(
                Prop.GRANULE_COLLECTOR_FACTORY, indexer);
            if (granuleCollectorFactorySPI == null || granuleCollectorFactorySPI.length() <= 0) {
                boolean isHeterogeneousCRS = Boolean
                    .parseBoolean(IndexerUtils.getParameter(Prop.HETEROGENEOUS_CRS, indexer));
                if (isHeterogeneousCRS) {
                    //in this case we know we need the reprojecting collector anyway, let's use it
                    IndexerUtils.setParam(indexer, Prop.GRANULE_COLLECTOR_FACTORY,
                        ReprojectingSubmosaicProducerFactory.class.getName());
                }
            }
        }

        // return value
        return retValue;
    }

