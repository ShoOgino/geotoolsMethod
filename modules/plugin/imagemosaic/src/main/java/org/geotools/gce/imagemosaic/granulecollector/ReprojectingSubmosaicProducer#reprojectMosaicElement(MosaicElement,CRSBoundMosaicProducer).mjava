    private MosaicElement reprojectMosaicElement(MosaicElement mosaicElement,
            CRSBoundMosaicProducer mosaicProducer) throws FactoryException, TransformException {

        final CoordinateReferenceSystem finalCrs = mosaicProducer.getCrs();
        if (!CRS.equalsIgnoreMetadata(targetCRS, finalCrs)) {
            GridCoverageFactory factory = new GridCoverageFactory(null);

            final MathTransform2D finalGridToWorld = mosaicProducer.rasterLayerResponse.getFinalGridToWorldCorner();
            ReferencedEnvelope submosaicBBOX = computeSubmosaicBoundingBox(finalGridToWorld, mosaicElement.getSource(), finalCrs);
            GridCoverage2D submosaicCoverage = createCoverageFromElement(mosaicElement, factory, submosaicBBOX);
            GridCoverage2D resampledCoverage = (GridCoverage2D) operations
                    .resample(submosaicCoverage, rasterLayerResponse.getMosaicBBox(), rasterLayerResponse.getRequest().getInterpolation());
            
            RenderedImage image = positionInOutputMosaic(resampledCoverage);
            
            // cropping is done after re-positining to avoid breaking warp/affine reduction. 
            // This is important not just for performance, but very much for output quality
            Geometry geometry = Utils.reprojectEnvelopeToGeometry(submosaicBBOX, targetCRS, rasterLayerResponse.getMosaicBBox());
            if(geometry != null && geometry.getNumGeometries() > 1) {
                // dateline crossing happend, clip on the reprojected vector geometry
                // as the reprojection math can do very "funny" stuff in the middle
                // due to numerical issues in reprojection math
                ReferencedEnvelope resampledImageEnvelope = computeSubmosaicBoundingBox(rasterLayerResponse.getFinalGridToWorldCorner(), image, finalCrs);
                GridCoverage2D repositionedCoverage = factory.create("repositioned", image, resampledImageEnvelope);
                GridCoverage2D croppedCoverage = (GridCoverage2D) operations.crop(repositionedCoverage, geometry);
                image = croppedCoverage.getRenderedImage();
            }
            

            PlanarImage alphaBand = image.getColorModel().hasAlpha()
                    ? new ImageWorker(image).retainLastBand().getPlanarImage() : null;

            Object property = image.getProperty("ROI");
            ROI overallROI = (property instanceof ROI) ? (ROI) property : null;
            return new MosaicElement(alphaBand, overallROI, image,
                    mosaicElement.getPamDataset());
        } else {
            return mosaicElement;
        }
    }

