        @Override
        protected void handleFile(final File fileBeingProcessed, final int depth,
                final Collection results) throws IOException {

            // increment counter
            fileIndex++;

            //
            // Check that this file is actually good to go
            //
            if (!checkFile(fileBeingProcessed))
                return;

            // replacing chars on input path
            String validFileName;
            SimpleFeatureType indexSchema = null;
            try {
                validFileName = fileBeingProcessed.getCanonicalPath();
                validFileName = FilenameUtils.normalize(validFileName);
            } catch (IOException e) {
                fireFileEvent(Level.FINER, fileBeingProcessed, false, 
                        "Exception occurred while processing file " + fileBeingProcessed + ": " + e.getMessage(), ((fileIndex * 100.0) / numFiles));
                fireException(e);
                return;
            }
            validFileName = FilenameUtils.getName(validFileName);
            fireEvent(Level.INFO, "Now indexing file " + validFileName,
                    ((fileIndex * 100.0) / numFiles));
            GridCoverage2DReader coverageReader = null;
            try {
                // STEP 1
                // Getting a coverage reader for this coverage.
                //
                final AbstractGridFormat format;
                final Hints configurationHints = runConfiguration.getHints();
                String indexName = runConfiguration.getParameter(Prop.INDEX_NAME);
                final Indexer indexer = runConfiguration.getIndexer();
                if (cachedFormat == null) {
                    // When looking for formats which may parse this file, make sure to exclude the ImageMosaicFormat as return
                    format = (AbstractGridFormat) GridFormatFinder.findFormat(fileBeingProcessed, excludeMosaicHints);
                } else {
                    if (cachedFormat.accepts(fileBeingProcessed)) {
                        format = cachedFormat;
                    } else {
                        format = new UnknownFormat();
                    }
                }
                if ((format instanceof UnknownFormat) || format == null) {
                    fireFileEvent(
                            Level.INFO,
                            fileBeingProcessed, false,
                            "Skipped file " + fileBeingProcessed + ": File format is not supported.",
                            ((fileIndex * 99.0) / numFiles));
                    return;
                }
                cachedFormat = format;
                coverageReader = (GridCoverage2DReader) format.getReader(fileBeingProcessed, configurationHints);
                
                // Getting available coverageNames from the reader
                String [] coverageNames = coverageReader.getGridCoverageNames();
                CatalogBuilderConfiguration catalogConfig;
                for (String cvName : coverageNames) {
                    
                    final String inputCoverageName = cvName;
                    String coverageName = coverageReader instanceof StructuredGridCoverage2DReader ? inputCoverageName
                            : indexName;

                    // checking whether the coverage already exists 
                    final boolean coverageExists = coverageExists(coverageName);
                    MosaicConfigurationBean mosaicConfiguration = null;
                    MosaicConfigurationBean currentConfigurationBean = null;
                    RasterManager rasterManager = null;
                    if (coverageExists) {
                        
                        // Get the manager for this coverage so it can be updated
                        rasterManager = parentReader.getRasterManager(coverageName);
                        mosaicConfiguration = rasterManager.getConfiguration();
                    }
                    
                    // STEP 2
                    // Collecting all Coverage properties to setup a MosaicConfigurationBean through
                    // the builder
                    final MosaicBeanBuilder configBuilder = new MosaicBeanBuilder();
                    
                    final GeneralEnvelope envelope = (GeneralEnvelope) coverageReader.getOriginalEnvelope(cvName);
                    final CoordinateReferenceSystem actualCRS = coverageReader.getCoordinateReferenceSystem(cvName);

                    SampleModel sm = null;
                    ColorModel cm = null;
                    int numberOfLevels = 1;
                    double[][] resolutionLevels = null;

                    if (mosaicConfiguration == null) {
                        catalogConfig = runConfiguration;
                        // We don't have a configuration for this configuration 
                        
                        // Get the type specifier for this image and the check that the
                        // image has the correct sample model and color model.
                        // If this is the first cycle of the loop we initialize everything.
                        //
                        ImageLayout layout = coverageReader.getImageLayout(inputCoverageName);
                        cm = layout.getColorModel(null);
                        sm = layout.getSampleModel(null);
                        numberOfLevels = coverageReader.getNumOverviews(inputCoverageName) + 1;
                        resolutionLevels = coverageReader.getResolutionLevels(inputCoverageName);

                        // at the first step we initialize everything that we will
                        // reuse afterwards starting with color models, sample
                        // models, crs, etc....

                        configBuilder.setSampleModel(sm);
                        configBuilder.setColorModel(cm);
                        ColorModel defaultCM = cm;

                        // Checking palette
                        if (defaultCM instanceof IndexColorModel) {
                            IndexColorModel icm = (IndexColorModel) defaultCM;
                            int numBands = defaultCM.getNumColorComponents();
                            byte[][] defaultPalette = new byte[3][icm.getMapSize()];
                            icm.getReds(defaultPalette[0]);
                            icm.getGreens(defaultPalette[0]);
                            icm.getBlues(defaultPalette[0]);
                            if (numBands == 4) {
                                icm.getAlphas(defaultPalette[0]);
                            }
                            configBuilder.setPalette(defaultPalette);
                        }

                        // STEP 2.A
                        // Preparing configuration 
                        configBuilder.setCrs(actualCRS);
                        configBuilder.setLevels(resolutionLevels);
                        configBuilder.setLevelsNum(numberOfLevels);
                        configBuilder.setName(coverageName);
                        configBuilder.setTimeAttribute(IndexerUtils.getAttribute(coverageName, Utils.TIME_DOMAIN, indexer));
                        configBuilder.setElevationAttribute(IndexerUtils.getAttribute(coverageName, Utils.ELEVATION_DOMAIN, indexer));
                        configBuilder.setAdditionalDomainAttributes(IndexerUtils.getAttribute(coverageName, Utils.ADDITIONAL_DOMAIN, indexer));
                        
                        final Hints runHints = runConfiguration.getHints();
                        if (runHints != null && runHints.containsKey(Utils.AUXILIARY_FILES_PATH)) {
                            String auxiliaryFilePath = (String) runHints.get(Utils.AUXILIARY_FILES_PATH);
                            if (auxiliaryFilePath != null && auxiliaryFilePath.trim().length() > 0) {
                                configBuilder.setAuxiliaryFilePath(auxiliaryFilePath);
                            }
                        }

                        final CatalogConfigurationBean catalogConfigurationBean = new CatalogConfigurationBean();
                        catalogConfigurationBean.setCaching(IndexerUtils.getParameterAsBoolean(Prop.CACHING, indexer));
                        catalogConfigurationBean.setAbsolutePath(IndexerUtils.getParameterAsBoolean(Prop.ABSOLUTE_PATH, indexer));
                        
                        catalogConfigurationBean.setLocationAttribute(IndexerUtils.getParameter(Prop.LOCATION_ATTRIBUTE, indexer));
                        configBuilder.setCatalogConfigurationBean(catalogConfigurationBean);

                        currentConfigurationBean = configBuilder.getMosaicConfigurationBean();

                        // creating the schema
                        indexSchema = CatalogManager.createSchema(runConfiguration, currentConfigurationBean.getName(), actualCRS);

                        // Creating a rasterManager which will be initialized after populating the catalog
                        rasterManager = parentReader.addRasterManager(currentConfigurationBean, false);

                        // Creating a granuleStore
                        parentReader.createCoverage(coverageName, indexSchema);
                        configurations.put(currentConfigurationBean.getName(), currentConfigurationBean);

                    } else {
                        catalogConfig = new CatalogBuilderConfiguration();
                        CatalogConfigurationBean bean = mosaicConfiguration.getCatalogConfigurationBean();
                        catalogConfig.setParameter(Prop.LOCATION_ATTRIBUTE, (bean.getLocationAttribute()));
                        catalogConfig.setParameter(Prop.ABSOLUTE_PATH, Boolean.toString(bean.isAbsolutePath()));
                        catalogConfig.setParameter(Prop.ROOT_MOSAIC_DIR/*setRootMosaicDirectory(*/, runConfiguration.getParameter(Prop.ROOT_MOSAIC_DIR));

                        // We already have a Configuration for this coverage.
                        // Check its properties are compatible with the existing coverage.
                        
                        CatalogConfigurationBean catalogConfigurationBean = bean;
                        if (!catalogConfigurationBean.isHeterogeneous()) {

                            // There is no need to check resolutions if the mosaic
                            // has been already marked as heterogeneous

                            numberOfLevels = coverageReader.getNumOverviews(inputCoverageName) + 1;
                            boolean needUpdate = false;

                            // 
                            // Heterogeneousity check
                            //
                            if (numberOfLevels != mosaicConfiguration.getLevelsNum()) {
                                catalogConfigurationBean.setHeterogeneous(true);
                                if (numberOfLevels > mosaicConfiguration.getLevelsNum()) {
                                    resolutionLevels = coverageReader.getResolutionLevels(inputCoverageName);
                                    mosaicConfiguration.setLevels(resolutionLevels);
                                    mosaicConfiguration.setLevelsNum(numberOfLevels);
                                    needUpdate = true;
                                }
                            } else {
                                final double[][] mosaicLevels = mosaicConfiguration.getLevels();
                                resolutionLevels = coverageReader.getResolutionLevels(inputCoverageName);
                                final boolean homogeneousLevels = Utils.homogeneousCheck(numberOfLevels, resolutionLevels, mosaicLevels);
                                if (!homogeneousLevels) {
                                    catalogConfigurationBean.setHeterogeneous(true);
                                    needUpdate = true;
                                }
                            }
                            // configuration need to be updated
                            if (needUpdate) {
                                configurations.put(mosaicConfiguration.getName(), mosaicConfiguration);
                            }
                        }
                        ImageLayout layout = coverageReader.getImageLayout(inputCoverageName);
                        cm = layout.getColorModel(null);
                        sm = layout.getSampleModel(null);

                        // comparing ColorModel
                        // comparing SampeModel
                        // comparing CRSs
                        ColorModel actualCM = cm;
                        CoordinateReferenceSystem expectedCRS; 
                        if(mosaicConfiguration.getCrs() != null) {
                            expectedCRS = mosaicConfiguration.getCrs();
                        } else {
                            expectedCRS = rasterManager.spatialDomainManager.coverageCRS;
                        }
                        if (!(CRS.equalsIgnoreMetadata(expectedCRS, actualCRS))) {
                            // if ((fileIndex > 0 ? !(CRS.equalsIgnoreMetadata(defaultCRS, actualCRS)) : false)) {
                            fireFileEvent(Level.INFO, fileBeingProcessed, false,
                                    "Skipping image " + fileBeingProcessed + " because CRSs do not match.",
                                    (((fileIndex + 1) * 99.0) / numFiles));
                            return;
                        }

                        byte[][] palette = mosaicConfiguration.getPalette();
                        ColorModel colorModel = mosaicConfiguration.getColorModel();
                        if(colorModel == null) {
                            palette = rasterManager.getConfiguration().getPalette();
                            colorModel = rasterManager.defaultCM;
                        }
                        if (checkColorModels(colorModel, palette, mosaicConfiguration, actualCM)) {
                            // if (checkColorModels(defaultCM, defaultPalette, actualCM)) {
                            fireFileEvent(Level.INFO, fileBeingProcessed, false,
                                    "Skipping image " + fileBeingProcessed + " because color models do not match.",
                                    (((fileIndex + 1) * 99.0) / numFiles));
                            return;
                        }
                    }

                    // STEP 3
                    // create and store features
                    CatalogManager.updateCatalog(coverageName, fileBeingProcessed, coverageReader,
                            parentReader, catalogConfig, envelope, transaction,
                            propertiesCollectors);
                    // fire event
                    fireFileEvent(Level.FINE, fileBeingProcessed, true, "Done with file " + fileBeingProcessed,
                            (((fileIndex + 1) * 99.0) / numFiles));

                }
            } catch (IOException e) {
                fireException(e);
                return;
            } catch (ArrayIndexOutOfBoundsException e) {
                fireException(e);
                return;
            } finally {
                // ////////////////////////////////////////////////////////
                //
                // STEP 5
                //
                // release resources
                //
                // ////////////////////////////////////////////////////////
                try {
                    if (coverageReader != null)
                        // release resources
                        coverageReader.dispose();
                } catch (Throwable e) {
                    // ignore exception
                    if (LOGGER.isLoggable(Level.FINEST))
                        LOGGER.log(Level.FINEST, e.getLocalizedMessage(), e);
                }
            }

            super.handleFile(fileBeingProcessed, depth, results);
        }

