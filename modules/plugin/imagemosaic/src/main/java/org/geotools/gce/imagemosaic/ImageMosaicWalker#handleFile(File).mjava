    protected void handleFile(final File fileBeingProcessed) throws IOException {

        // increment counter
        fileIndex++;

        //
        // Check that this file is actually good to go
        //
        if (!checkFile(fileBeingProcessed))
            return;

        // replacing chars on input path
        String validFileName;
        String extension;
        try {
            validFileName = fileBeingProcessed.getCanonicalPath();
            validFileName = FilenameUtils.normalize(validFileName);
            extension = FilenameUtils.getExtension(validFileName);
        } catch (IOException e) {
            eventHandler.fireFileEvent(Level.FINER,
                    fileBeingProcessed, false, "Exception occurred while processing file "
                            + fileBeingProcessed + ": " + e.getMessage(),
                    ((fileIndex * 100.0) / numFiles));
            eventHandler.fireException(e);
            return;
        }
        validFileName = FilenameUtils.getName(validFileName);
        eventHandler.fireEvent(Level.INFO, "Now indexing file " + validFileName,
                ((fileIndex * 100.0) / numFiles));
        GridCoverage2DReader coverageReader = null;
        try {
            // STEP 1
            // Getting a coverage reader for this coverage.
            //
            final AbstractGridFormat format;
            if (cachedFormat == null) {
                // When looking for formats which may parse this file, make sure to exclude the ImageMosaicFormat as return
                format = (AbstractGridFormat) GridFormatFinder.findFormat(fileBeingProcessed,
                        excludeMosaicHints);
            } else {
                if (cachedFormat.accepts(fileBeingProcessed)) {
                    format = cachedFormat;
                } else {
                    format = new UnknownFormat();
                }
            }
            if ((format instanceof UnknownFormat) || format == null) {
                if (!logExcludes.contains(extension)) {
                    eventHandler.fireFileEvent(Level.INFO, fileBeingProcessed, false,
                            "Skipped file " + fileBeingProcessed
                                    + ": File format is not supported.",
                            ((fileIndex * 99.0) / numFiles));
                }
                return;
            }
            cachedFormat = format;

            final Hints configurationHints = configHandler.getRunConfiguration().getHints();
            coverageReader = (GridCoverage2DReader) format.getReader(fileBeingProcessed,
                    configurationHints);

            // Setting of the ReaderSPI to use
            if (configHandler.getCachedReaderSPI() == null) {
                // Get the URL associated to the file
                URL granuleUrl = URLs.fileToUrl(fileBeingProcessed);
                // Get the ImageInputStreamSPI associated to the URL
                ImageInputStreamSpi inStreamSpi = Utils.getInputStreamSPIFromURL(granuleUrl);
                // Ensure that the ImageInputStreamSPI is available
                if (inStreamSpi == null) {
                    throw new IllegalArgumentException("no inputStreamSPI available!");
                }
                ImageInputStream inStream = null;
                try {
                    // Get the ImageInputStream from the SPI
                    inStream = inStreamSpi.createInputStreamInstance(granuleUrl,
                            ImageIO.getUseCache(), ImageIO.getCacheDirectory());
                    // Throws an Exception if the ImageInputStream is not present
                    if (inStream == null) {
                        if (LOGGER.isLoggable(Level.WARNING)) {
                            LOGGER.log(Level.WARNING, Utils.getFileInfo(fileBeingProcessed));
                        }
                        throw new IllegalArgumentException(
                                "Unable to get an input stream for the provided file "
                                        + granuleUrl.toString());
                    }
                    // Selection of the ImageReaderSpi from the Stream
                    ImageReaderSpi spi = Utils.getReaderSpiFromStream(null, inStream);
                    // Setting of the ImageReaderSpi to the ImageMosaicConfigHandler in order to set it inside the indexer properties
                    configHandler.setCachedReaderSPI(spi);
                } finally {
                    if (inStream != null) {
                        inStream.close();
                    }
                }

            }

            // Getting available coverageNames from the reader
            String[] coverageNames = coverageReader.getGridCoverageNames();

            for (String cvName : coverageNames) {
                boolean shouldAccept = true;
                for (GranuleAcceptor acceptor : this.configHandler.getGranuleAcceptors()) {
                    if (!acceptor.accepts(coverageReader, cvName, fileBeingProcessed,
                            configHandler)) {
                        shouldAccept = false;
                        eventHandler.fireFileEvent(Level.FINE, fileBeingProcessed, true,
                                "Granule acceptor  " + acceptor.getClass().getName()
                                        + " rejected the granule being processed"
                                        + fileBeingProcessed,
                                ((fileIndex + 1) * 99.0) / numFiles);
                        break;
                    }
                }

                if (shouldAccept) {
                    configHandler.updateConfiguration(coverageReader, cvName, fileBeingProcessed,
                            fileIndex, numFiles, transaction);
                }

                // fire event
                eventHandler.fireFileEvent(Level.FINE, fileBeingProcessed, true,
                        "Done with file " + fileBeingProcessed,
                        (((fileIndex + 1) * 99.0) / numFiles));

            }
        } catch (Exception e) {
            // we got an exception, we should stop the walk
            eventHandler.fireException(e);

            this.stop();
            return;
        } finally {
            //
            // STEP 5
            //
            // release resources
            //
            try {
                if (coverageReader != null)
                    // release resources
                    coverageReader.dispose();
            } catch (Throwable e) {
                // ignore exception
                if (LOGGER.isLoggable(Level.FINEST))
                    LOGGER.log(Level.FINEST, e.getLocalizedMessage(), e);
            }
        }

    }

