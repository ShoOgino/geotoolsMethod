        @Override
        public void handleElement(URL url, ImageMosaicWalker walker) throws IOException {

            // increment counter
            int elementIndex = walker.getElementIndex() + 1;
            walker.setElementIndex(elementIndex);

            int numElements = walker.getNumElements();
            ImageMosaicEventHandlers eventHandler = walker.getEventHandler();
            ImageMosaicConfigHandler configHandler = walker.getConfigHandler();

            eventHandler.fireEvent(
                    Level.INFO, "Now indexing url " + url, ((elementIndex * 100.0) / numElements));
            GridCoverage2DReader coverageReader = null;
            try {
                // STEP 1
                // Getting a coverage reader for this coverage.
                //
                final AbstractGridFormat format;
                final AbstractGridFormat cachedFormat = configHandler.getCachedFormat();

                SourceSPIProvider readerInputObject = sourceSPIProvider.getSourceSPIProvider(url);
                if (cachedFormat == null) {
                    // When looking for formats which may parse this file, make sure to exclude the
                    // ImageMosaicFormat as return
                    format =
                            GridFormatFinder.findFormat(
                                    readerInputObject, Utils.EXCLUDE_MOSAIC_HINTS);
                } else {
                    if (cachedFormat.accepts(readerInputObject)) {
                        format = cachedFormat;
                    } else {
                        format =
                                GridFormatFinder.findFormat(
                                        readerInputObject, Utils.EXCLUDE_MOSAIC_HINTS);
                    }
                }
                if ((format instanceof UnknownFormat) || format == null) {

                    eventHandler.fireUrlEvent(
                            Level.INFO,
                            url,
                            false,
                            "Skipped granule " + url + ": format is not supported.",
                            ((elementIndex * 99.0) / numElements));

                    return;
                }

                final Hints configurationHints = configHandler.getRunConfiguration().getHints();
                coverageReader =
                        (GridCoverage2DReader)
                                format.getReader(readerInputObject, configurationHints);

                // Setting of the ReaderSPI to use
                if (configHandler.getCachedReaderSPI() == null) {
                    ImageInputStreamSpi inStreamSpi = readerInputObject.getStreamSpi();
                    // Ensure that the ImageInputStreamSPI is available
                    if (inStreamSpi == null) {
                        throw new IllegalArgumentException("no inputStreamSPI available!");
                    }
                    ImageInputStream inStream = null;
                    try {
                        // Get the ImageInputStream from the SPI

                        inStream = ((SourceSPIProvider) readerInputObject).getStream();
                        // Throws an Exception if the ImageInputStream is not present
                        if (inStream == null) {
                            if (LOGGER.isLoggable(Level.WARNING)) {
                                LOGGER.log(Level.WARNING, "Unable to open a stream on " + url);
                            }
                            throw new IllegalArgumentException(
                                    "Unable to get an input stream for the provided file granule"
                                            + url);
                        }
                        // Selection of the ImageReaderSpi from the Stream
                        ImageReaderSpi spi = readerInputObject.getReaderSpi();
                        // Setting of the ImageReaderSpi to the ImageMosaicConfigHandler in order to
                        // set
                        // it inside the indexer properties
                        configHandler.setCachedReaderSPI(spi);
                    } finally {
                        if (inStream != null) {
                            inStream.close();
                        }
                    }
                }

                // Getting available coverageNames from the reader
                String[] coverageNames = coverageReader.getGridCoverageNames();

                for (String cvName : coverageNames) {
                    try {

                        //  Assume that all the granules already put on the datastore are valid
                        configHandler.setCachedFormat(format);
                    } catch (Exception e) {
                        LOGGER.log(
                                Level.FINE,
                                "Failure during potential granule evaluation, skipping it: " + url,
                                e);
                    }

                    ImageMosaicSourceElement element = new ImageMosaicSourceElement.URLElement(url);
                    configHandler.updateConfiguration(
                            coverageReader,
                            cvName,
                            new ImageMosaicSourceElement.URLElement(url),
                            elementIndex,
                            numElements,
                            walker.getTransaction());

                    // fire event
                    element.fireHarvestingEvent(
                            eventHandler, elementIndex, numElements, "Done with granule " + url);
                }
            } catch (Exception e) {
                // we got an exception, we should stop the walk
                eventHandler.fireException(e);
                walker.stop();
                return;
            } finally {

                try {
                    if (coverageReader != null)
                        // release resources
                        coverageReader.dispose();
                } catch (Throwable e) {
                    // ignore exception
                    if (LOGGER.isLoggable(Level.FINEST))
                        LOGGER.log(Level.FINEST, e.getLocalizedMessage(), e);
                }
            }
        }

