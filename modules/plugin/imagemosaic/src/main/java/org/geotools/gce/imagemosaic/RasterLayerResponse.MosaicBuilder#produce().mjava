		public void produce(){
			
			// reusable parameters
			alphaChannels = new PlanarImage[granulesNumber];
			int granuleIndex=0;
			inputTransparentColor = request.getInputTransparentColor();
			doInputTransparency = inputTransparentColor != null&&!footprintManagement;
			// execute them all
			boolean firstGranule=true;
			int[] alphaIndex=null;
			StringBuilder paths = new StringBuilder();
			
			for (Future<GranuleLoadingResult> future :tasks) {
				
				
				final RenderedImage loadedImage;
				final GranuleLoadingResult result;
				final URL url;
				final File inputFile;
				final String canonicalPath;
				boolean doFiltering;
				try {
					if(!multithreadingAllowed || rasterManager.parent.multiThreadedLoader == null)
					{
						//run the loading in this thread
					    final FutureTask<GranuleLoadingResult> task=(FutureTask<GranuleLoadingResult>) future;
                                            task.run();
					}
					result = future.get();
                                        if (result == null) {
                                            if (LOGGER.isLoggable(Level.FINE))
                                                LOGGER.log(Level.FINE, "Unable to load the raster for granule " 
                                                        + granuleIndex + " with request " + request.toString());
                                            continue;
                                        }
					loadedImage = result.getRaster();
					doFiltering = result.isDoFiltering();
					url = result.granuleUrl;
					inputFile = DataUtilities.urlToFile(url);
					canonicalPath = inputFile.getCanonicalPath();
					if(loadedImage==null)
					{
						if(LOGGER.isLoggable(Level.FINE))
							LOGGER.log(Level.FINE,"Unable to load the raster for granuleDescriptor " +granuleIndex+ " with request "+request.toString());
						continue;
					}
					if(firstGranule){
						//
						// We check here if the images have an alpha channel or some
						// other sort of transparency. In case we have transparency
						// I also save the index of the transparent channel.
						//
						// Specifically, I have to check if the loaded image have
						// transparency, because if we do a ROI and/or we have a
						// transparent color to set we have to remove it.
						//
						final ColorModel cm = loadedImage.getColorModel();
						alphaIn = cm.hasAlpha();
						if (alphaIn||doInputTransparency)
							alphaIndex = new int[] { cm.getNumComponents() - 1 };


						//
						// we set the input threshold accordingly to the input
						// image data type. I find the default value (which is 0) very bad
						// for data type other than byte and ushort. With float and double
						// it can cut off a large par of the dynamic.
						//
						sourceThreshold = new double[][] { { CoverageUtilities.getMosaicThreshold(loadedImage.getSampleModel().getDataType()) } };
						
						
						firstGranule=false;
										
					}					
					
				} catch (Exception e) {
				            if (LOGGER.isLoggable(Level.FINE))
				                LOGGER.fine("Adding to mosaic image number " + granuleIndex + " failed, original request was " + request);
				            continue;
				}


				if (LOGGER.isLoggable(Level.FINER)) {
					LOGGER.finer("Adding to mosaic image number " + granuleIndex);
				}
				
				//
				// add to the mosaic collection, with preprocessing
				//
				RenderedImage raster = processGranuleRaster(
						loadedImage,
						granuleIndex, 
						alphaIndex,
						alphaIn, 
						alphaChannels, 
						doInputTransparency,
						inputTransparentColor);
				
				// we need to add its roi in order to avoid problems with the mosaic overlapping
				Rectangle bounds = PlanarImage.wrapRenderedImage(raster).getBounds();
				Geometry mask = JTS.toGeometry(new Envelope(bounds.getMinX(), bounds.getMaxX(), bounds.getMinY(), bounds.getMaxY()));
				ROI imageBounds = new ROIGeometry(mask);
                                if (footprintManagement){
                                    final ROI footprint = result.getFootprint();
                                    if (footprint != null) {
                                        if (imageBounds.contains(footprint.getBounds2D().getBounds())) {
                                            imageBounds = footprint;
                                        } else {
                                            imageBounds = imageBounds.intersect(footprint);
                                        }
                                    }
                                    
                                    //Artifacts filtering processing
                                if (defaultArtifactsFilterThreshold != Integer.MIN_VALUE && doFiltering){
                                    int artifactThreshold = defaultArtifactsFilterThreshold; 
                                    if (artifactsFilterPTileThreshold != -1){
                                        
                                        //Looking for a histogram for that granule in order to 
                                        //setup dynamic threshold 
                                        if (url != null){
                                            final String path = FilenameUtils.getFullPath(canonicalPath);
                                            final String baseName = FilenameUtils.getBaseName(canonicalPath);
                                            final String histogramPath = path + baseName + "." + "histogram";
                                            final Histogram histogram = Utils.getHistogram(histogramPath);
                                            if (histogram != null) {
                                                final double[]p = histogram.getPTileThreshold(artifactsFilterPTileThreshold);
                                                artifactThreshold = (int)p[0];
                                            }
                                        }
                                    }
                                    if (LOGGER.isLoggable(Level.FINE)){
                                        LOGGER.log(Level.FINE, "Filtering granules artifacts");
                                    }
                                    raster = ArtifactsFilterDescriptor.create(raster, imageBounds, new double[]{0}, artifactThreshold, 3, hints);
                                    }
                                }
                                rois.add(imageBounds);

				// add to mosaic
                                sources.add(raster);
                                paths.append(granuleIndex > 0 ? "," : "").append(canonicalPath);
			
				//increment index 
				granuleIndex++;
			}

			granulesNumber=granuleIndex;
			if(granulesNumber==0)
			{
				if(LOGGER.isLoggable(Level.FINE))
					LOGGER.log(Level.FINE,"Unable to load any granuleDescriptor ");
				return;
			}
			granulesPaths = paths.toString();
	                sourceRoi = rois.toArray(new ROI[rois.size()]);
		}

