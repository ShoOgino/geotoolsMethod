    /**
     * Use the passed coverageReader to create or update the all the needed configurations<br>
     * It not responsible of the passed coverageReader which should be disposed outside (in the
     * caller).
     *
     * @param coverageReader
     * @param inputCoverageName
     * @param fileBeingProcessed
     * @param fileIndex
     * @param numFiles
     * @param transaction
     * @throws IOException
     * @throws FactoryException
     * @throws NoSuchAuthorityCodeException
     * @throws TransformException
     */
    public void updateConfiguration(
            GridCoverage2DReader coverageReader,
            final String inputCoverageName,
            File fileBeingProcessed,
            int fileIndex,
            double numFiles,
            DefaultTransaction transaction)
            throws IOException, GranuleHandlingException, NoSuchAuthorityCodeException,
                    FactoryException, TransformException {

        final String targetCoverageName = getTargetCoverageName(coverageReader, inputCoverageName);

        final Indexer indexer = getRunConfiguration().getIndexer();

        // checking whether the coverage already exists
        final boolean coverageExists = coverageExists(targetCoverageName);
        MosaicConfigurationBean mosaicConfiguration = null;
        MosaicConfigurationBean currentConfigurationBean = null;
        RasterManager rasterManager = null;
        if (coverageExists) {
            // Get the manager for this coverage so it can be updated
            rasterManager = getParentReader().getRasterManager(targetCoverageName);
            mosaicConfiguration = rasterManager.getConfiguration();
            this.configurations.put(mosaicConfiguration.getName(), mosaicConfiguration);
        }

        // STEP 2
        // Collecting all Coverage properties to setup a MosaicConfigurationBean through
        // the builder
        final MosaicBeanBuilder configBuilder = new MosaicBeanBuilder();

        final GeneralEnvelope envelope = coverageReader.getOriginalEnvelope(inputCoverageName);
        final CoordinateReferenceSystem actualCRS =
                coverageReader.getCoordinateReferenceSystem(inputCoverageName);

        SampleModel sm = null;
        ColorModel cm = null;
        int numberOfLevels = 1;
        double[][] resolutionLevels = null;
        CatalogBuilderConfiguration catalogConfig;
        Boolean heterogeneousCRS =
                Boolean.valueOf(IndexerUtils.getParameter(Prop.HETEROGENEOUS_CRS, indexer));
        if (mosaicConfiguration == null) {
            catalogConfig = getRunConfiguration();
            // We don't have a configuration for this configuration

            // Get the type specifier for this image and the check that the
            // image has the correct sample model and color model.
            // If this is the first cycle of the loop we initialize everything.
            //
            ImageLayout layout = coverageReader.getImageLayout(inputCoverageName);
            cm = layout.getColorModel(null);
            sm = layout.getSampleModel(null);

            // at the first step we initialize everything that we will
            // reuse afterwards starting with color models, sample
            // models, crs, etc....

            configBuilder.setSampleModel(sm);
            configBuilder.setColorModel(cm);
            ColorModel defaultCM = cm;

            // Checking palette
            if (defaultCM instanceof IndexColorModel) {
                IndexColorModel icm = (IndexColorModel) defaultCM;
                byte[][] defaultPalette = Utils.extractPalette(icm);
                configBuilder.setPalette(defaultPalette);
            }

            // STEP 2.A
            // Preparing configuration
            String mosaicCrs = IndexerUtils.getParameter(Utils.Prop.MOSAIC_CRS, indexer);
            if (mosaicCrs != null) {
                configBuilder.setCrs(CRS.decode(mosaicCrs, true));
            } else {
                configBuilder.setCrs(actualCRS);
            }

            String noData = IndexerUtils.getParameter(Prop.NO_DATA, indexer);
            if (noData != null && !noData.isEmpty()) {
                try {
                    double noDataValue = Double.parseDouble(noData);
                    configBuilder.setNoData(noDataValue);
                } catch (NumberFormatException e) {
                    String error =
                            "Invalid NoData specification " + noData + ", was expecting a number";
                    LOGGER.log(Level.WARNING, error);
                    throw new RuntimeException(error, e);
                }
            }

            // get/compute the resolution levels
            resolutionLevels =
                    getResolutionLevels(coverageReader, inputCoverageName, configBuilder.getCrs());
            numberOfLevels = resolutionLevels.length;
            configBuilder.setLevels(resolutionLevels);
            configBuilder.setLevelsNum(numberOfLevels);
            configBuilder.setName(targetCoverageName);
            configBuilder.setTimeAttribute(
                    IndexerUtils.getAttribute(targetCoverageName, Utils.TIME_DOMAIN, indexer));
            configBuilder.setCrsAttribute(
                    IndexerUtils.getAttribute(targetCoverageName, Prop.CRS_ATTRIBUTE, indexer));
            configBuilder.setElevationAttribute(
                    IndexerUtils.getAttribute(targetCoverageName, Utils.ELEVATION_DOMAIN, indexer));
            configBuilder.setAdditionalDomainAttributes(
                    IndexerUtils.getAttribute(
                            targetCoverageName, Utils.ADDITIONAL_DOMAIN, indexer));

            final Hints runHints = getRunConfiguration().getHints();
            if (runHints != null) {
                if (runHints.containsKey(Utils.AUXILIARY_FILES_PATH)) {
                    String auxiliaryFilePath = (String) runHints.get(Utils.AUXILIARY_FILES_PATH);
                    if (auxiliaryFilePath != null && auxiliaryFilePath.trim().length() > 0) {
                        configBuilder.setAuxiliaryFilePath(auxiliaryFilePath);
                    }
                }
                if (runHints.containsKey(Utils.AUXILIARY_DATASTORE_PATH)) {
                    String auxiliaryDatastorePath =
                            (String) runHints.get(Utils.AUXILIARY_DATASTORE_PATH);
                    if (auxiliaryDatastorePath != null
                            && auxiliaryDatastorePath.trim().length() > 0) {
                        configBuilder.setAuxiliaryDatastorePath(auxiliaryDatastorePath);
                    }
                }
            }

            final CatalogConfigurationBean catalogConfigurationBean =
                    new CatalogConfigurationBean();
            catalogConfigurationBean.setCaching(
                    IndexerUtils.getParameterAsBoolean(Prop.CACHING, indexer));
            catalogConfigurationBean.setAbsolutePath(
                    IndexerUtils.getParameterAsBoolean(Prop.ABSOLUTE_PATH, indexer));

            catalogConfigurationBean.setLocationAttribute(
                    IndexerUtils.getParameter(Prop.LOCATION_ATTRIBUTE, indexer));
            catalogConfigurationBean.setWrapStore(
                    IndexerUtils.getParameterAsBoolean(Prop.WRAP_STORE, indexer));

            String configuredTypeName = IndexerUtils.getParameter(Prop.TYPENAME, indexer);
            if (configuredTypeName != null) {
                catalogConfigurationBean.setTypeName(configuredTypeName);
            } else {
                catalogConfigurationBean.setTypeName(targetCoverageName);
            }
            configBuilder.setCatalogConfigurationBean(catalogConfigurationBean);
            configBuilder.setCheckAuxiliaryMetadata(
                    IndexerUtils.getParameterAsBoolean(Prop.CHECK_AUXILIARY_METADATA, indexer));

            currentConfigurationBean = configBuilder.getMosaicConfigurationBean();
            if (heterogeneousCRS) {
                currentConfigurationBean.getCatalogConfigurationBean().setHeterogeneous(true);
                currentConfigurationBean.getCatalogConfigurationBean().setHeterogeneousCRS(true);
            }

            // Creating a rasterManager which will be initialized after populating the catalog
            getParentReader().addRasterManager(currentConfigurationBean, false);

            // Creating a granuleStore
            if (!useExistingSchema) {
                // creating the schema
                SimpleFeatureType indexSchema =
                        createSchema(
                                getRunConfiguration(),
                                currentConfigurationBean.getName(),
                                configBuilder.getCrs());
                getParentReader().createCoverage(targetCoverageName, indexSchema);
            }
            getConfigurations().put(currentConfigurationBean.getName(), currentConfigurationBean);

        } else {
            catalogConfig = new CatalogBuilderConfiguration();
            CatalogConfigurationBean bean = mosaicConfiguration.getCatalogConfigurationBean();
            catalogConfig.setParameter(Prop.LOCATION_ATTRIBUTE, (bean.getLocationAttribute()));
            catalogConfig.setParameter(Prop.ABSOLUTE_PATH, Boolean.toString(bean.isAbsolutePath()));
            catalogConfig.setParameter(Prop.PATH_TYPE, bean.getPathType().toString());
            catalogConfig.setParameter(
                    Prop.ROOT_MOSAIC_DIR /* setRootMosaicDirectory( */,
                    getRunConfiguration().getParameter(Prop.ROOT_MOSAIC_DIR));

            // We already have a Configuration for this coverage.
            // Check its properties are compatible with the existing coverage.

            CatalogConfigurationBean catalogConfigurationBean = bean;

            // make sure we pick the same resolution irrespective of order of harvest
            resolutionLevels =
                    getResolutionLevels(
                            coverageReader, inputCoverageName, mosaicConfiguration.getCrs());
            numberOfLevels = resolutionLevels.length;

            int originalNumberOfLevels = mosaicConfiguration.getLevelsNum();
            boolean needUpdate = false;
            if (Utils.homogeneousCheck(
                    Math.min(numberOfLevels, originalNumberOfLevels),
                    resolutionLevels,
                    mosaicConfiguration.getLevels())) {
                if (numberOfLevels != originalNumberOfLevels) {
                    catalogConfigurationBean.setHeterogeneous(true);
                    if (numberOfLevels > originalNumberOfLevels) {
                        needUpdate = true; // pick the one with highest number of levels
                    }
                }
            } else {
                catalogConfigurationBean.setHeterogeneous(true);
                if (isHigherResolution(resolutionLevels, mosaicConfiguration.getLevels())) {
                    needUpdate = true; // pick the one with the highest resolution
                }
            }

            // configuration need to be updated
            if (needUpdate) {
                mosaicConfiguration.setLevels(resolutionLevels);
                mosaicConfiguration.setLevelsNum(numberOfLevels);
                getConfigurations().put(mosaicConfiguration.getName(), mosaicConfiguration);
            }
        }
        // STEP 3
        if (!useExistingSchema) {
            // create and store features
            updateCatalog(
                    targetCoverageName,
                    fileBeingProcessed,
                    coverageReader,
                    getParentReader(),
                    catalogConfig,
                    envelope,
                    transaction,
                    getPropertiesCollectors());
        }
    }

