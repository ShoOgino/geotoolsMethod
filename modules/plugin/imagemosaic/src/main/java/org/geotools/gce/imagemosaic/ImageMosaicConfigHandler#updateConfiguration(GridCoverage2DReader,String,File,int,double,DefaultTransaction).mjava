    /**
     * Use the passed coverageReader to create or update the all the needed configurations<br/>
     * It not responsible of the passed coverageReader which should be disposed outside (in the caller).
     * 
     * @param coverageReader
     * @param inputCoverageName
     * @param fileBeingProcessed
     * @param fileIndex
     * @param numFiles
     * @param transaction
     * @throws IOException
     */
    public void updateConfiguration(GridCoverage2DReader coverageReader,
            final String inputCoverageName, File fileBeingProcessed, int fileIndex,
            double numFiles, DefaultTransaction transaction) throws IOException {

        final String indexName = getRunConfiguration().getParameter(Prop.INDEX_NAME);
        final String coverageName = coverageReader instanceof StructuredGridCoverage2DReader ? inputCoverageName
                : indexName;

        final Indexer indexer = getRunConfiguration().getIndexer();

        // checking whether the coverage already exists
        final boolean coverageExists = coverageExists(coverageName);
        MosaicConfigurationBean mosaicConfiguration = null;
        MosaicConfigurationBean currentConfigurationBean = null;
        RasterManager rasterManager = null;
        if (coverageExists) {

            // Get the manager for this coverage so it can be updated
            rasterManager = getParentReader().getRasterManager(coverageName);
            mosaicConfiguration = rasterManager.getConfiguration();
        }

        // STEP 2
        // Collecting all Coverage properties to setup a MosaicConfigurationBean through
        // the builder
        final MosaicBeanBuilder configBuilder = new MosaicBeanBuilder();

        final GeneralEnvelope envelope = (GeneralEnvelope) coverageReader
                .getOriginalEnvelope(inputCoverageName);
        final CoordinateReferenceSystem actualCRS = coverageReader
                .getCoordinateReferenceSystem(inputCoverageName);

        SampleModel sm = null;
        ColorModel cm = null;
        int numberOfLevels = 1;
        double[][] resolutionLevels = null;
        CatalogBuilderConfiguration catalogConfig;
        if (mosaicConfiguration == null) {
            catalogConfig = getRunConfiguration();
            // We don't have a configuration for this configuration

            // Get the type specifier for this image and the check that the
            // image has the correct sample model and color model.
            // If this is the first cycle of the loop we initialize everything.
            //
            ImageLayout layout = coverageReader.getImageLayout(inputCoverageName);
            cm = layout.getColorModel(null);
            sm = layout.getSampleModel(null);
            numberOfLevels = coverageReader.getNumOverviews(inputCoverageName) + 1;
            resolutionLevels = coverageReader.getResolutionLevels(inputCoverageName);

            // at the first step we initialize everything that we will
            // reuse afterwards starting with color models, sample
            // models, crs, etc....

            configBuilder.setSampleModel(sm);
            configBuilder.setColorModel(cm);
            ColorModel defaultCM = cm;

            // Checking palette
            if (defaultCM instanceof IndexColorModel) {
                IndexColorModel icm = (IndexColorModel) defaultCM;
                int numBands = defaultCM.getNumColorComponents();
                byte[][] defaultPalette = new byte[3][icm.getMapSize()];
                icm.getReds(defaultPalette[0]);
                icm.getGreens(defaultPalette[0]);
                icm.getBlues(defaultPalette[0]);
                if (numBands == 4) {
                    icm.getAlphas(defaultPalette[0]);
                }
                configBuilder.setPalette(defaultPalette);
            }

            // STEP 2.A
            // Preparing configuration
            configBuilder.setCrs(actualCRS);
            configBuilder.setLevels(resolutionLevels);
            configBuilder.setLevelsNum(numberOfLevels);
            configBuilder.setName(coverageName);
            configBuilder.setTimeAttribute(IndexerUtils.getAttribute(coverageName,
                    Utils.TIME_DOMAIN, indexer));
            configBuilder.setElevationAttribute(IndexerUtils.getAttribute(coverageName,
                    Utils.ELEVATION_DOMAIN, indexer));
            configBuilder.setAdditionalDomainAttributes(IndexerUtils.getAttribute(coverageName,
                    Utils.ADDITIONAL_DOMAIN, indexer));

            final Hints runHints = getRunConfiguration().getHints();
            if (runHints != null && runHints.containsKey(Utils.AUXILIARY_FILES_PATH)) {
                String auxiliaryFilePath = (String) runHints.get(Utils.AUXILIARY_FILES_PATH);
                if (auxiliaryFilePath != null && auxiliaryFilePath.trim().length() > 0) {
                    configBuilder.setAuxiliaryFilePath(auxiliaryFilePath);
                }
            }

            final CatalogConfigurationBean catalogConfigurationBean = new CatalogConfigurationBean();
            catalogConfigurationBean.setCaching(IndexerUtils.getParameterAsBoolean(Prop.CACHING,
                    indexer));
            catalogConfigurationBean.setAbsolutePath(IndexerUtils.getParameterAsBoolean(
                    Prop.ABSOLUTE_PATH, indexer));

            catalogConfigurationBean.setLocationAttribute(IndexerUtils.getParameter(
                    Prop.LOCATION_ATTRIBUTE, indexer));
            
            catalogConfigurationBean.setTypeName(coverageName);
            
            configBuilder.setCatalogConfigurationBean(catalogConfigurationBean);
            configBuilder.setCheckAuxiliaryMetadata(IndexerUtils.getParameterAsBoolean(Prop.CHECK_AUXILIARY_METADATA, indexer));

            currentConfigurationBean = configBuilder.getMosaicConfigurationBean();

            // Creating a rasterManager which will be initialized after populating the catalog
            rasterManager = getParentReader().addRasterManager(currentConfigurationBean, false);

            // Creating a granuleStore
            if (!useExistingSchema) {
                // creating the schema
                SimpleFeatureType indexSchema = CatalogManager.createSchema(getRunConfiguration(),
                        currentConfigurationBean.getName(), actualCRS);
                getParentReader().createCoverage(coverageName, indexSchema);
//            } else {
//                rasterManager.typeName = coverageName;
            }
            getConfigurations().put(currentConfigurationBean.getName(), currentConfigurationBean);

        } else {
            catalogConfig = new CatalogBuilderConfiguration();
            CatalogConfigurationBean bean = mosaicConfiguration.getCatalogConfigurationBean();
            catalogConfig.setParameter(Prop.LOCATION_ATTRIBUTE, (bean.getLocationAttribute()));
            catalogConfig.setParameter(Prop.ABSOLUTE_PATH, Boolean.toString(bean.isAbsolutePath()));
            catalogConfig.setParameter(Prop.ROOT_MOSAIC_DIR/* setRootMosaicDirectory( */,
                    getRunConfiguration().getParameter(Prop.ROOT_MOSAIC_DIR));

            // We already have a Configuration for this coverage.
            // Check its properties are compatible with the existing coverage.

            CatalogConfigurationBean catalogConfigurationBean = bean;
            if (!catalogConfigurationBean.isHeterogeneous()) {

                // There is no need to check resolutions if the mosaic
                // has been already marked as heterogeneous

                numberOfLevels = coverageReader.getNumOverviews(inputCoverageName) + 1;
                boolean needUpdate = false;

                //
                // Heterogeneousity check
                //
                if (numberOfLevels != mosaicConfiguration.getLevelsNum()) {
                    catalogConfigurationBean.setHeterogeneous(true);
                    if (numberOfLevels > mosaicConfiguration.getLevelsNum()) {
                        resolutionLevels = coverageReader.getResolutionLevels(inputCoverageName);
                        mosaicConfiguration.setLevels(resolutionLevels);
                        mosaicConfiguration.setLevelsNum(numberOfLevels);
                        needUpdate = true;
                    }
                } else {
                    final double[][] mosaicLevels = mosaicConfiguration.getLevels();
                    resolutionLevels = coverageReader.getResolutionLevels(inputCoverageName);
                    final boolean homogeneousLevels = Utils.homogeneousCheck(numberOfLevels,
                            resolutionLevels, mosaicLevels);
                    if (!homogeneousLevels) {
                        catalogConfigurationBean.setHeterogeneous(true);
                        needUpdate = true;
                    }
                }
                // configuration need to be updated
                if (needUpdate) {
                    getConfigurations().put(mosaicConfiguration.getName(), mosaicConfiguration);
                }
            }
            ImageLayout layout = coverageReader.getImageLayout(inputCoverageName);
            cm = layout.getColorModel(null);
            sm = layout.getSampleModel(null);

            // comparing ColorModel
            // comparing SampeModel
            // comparing CRSs
            ColorModel actualCM = cm;
            CoordinateReferenceSystem expectedCRS;
            if (mosaicConfiguration.getCrs() != null) {
                expectedCRS = mosaicConfiguration.getCrs();
            } else {
                expectedCRS = rasterManager.spatialDomainManager.coverageCRS;
            }
            if (!(CRS.equalsIgnoreMetadata(expectedCRS, actualCRS))) {
                // if ((fileIndex > 0 ? !(CRS.equalsIgnoreMetadata(defaultCRS, actualCRS)) : false)) {
                eventHandler.fireFileEvent(Level.INFO, fileBeingProcessed, false, "Skipping image "
                        + fileBeingProcessed + " because CRSs do not match.",
                        (((fileIndex + 1) * 99.0) / numFiles));
                return;
            }

            byte[][] palette = mosaicConfiguration.getPalette();
            ColorModel colorModel = mosaicConfiguration.getColorModel();
            if (colorModel == null) {
                palette = rasterManager.getConfiguration().getPalette();
                colorModel = rasterManager.defaultCM;
            }
            if (Utils.checkColorModels(colorModel, palette, mosaicConfiguration, actualCM)) {
                // if (checkColorModels(defaultCM, defaultPalette, actualCM)) {
                eventHandler.fireFileEvent(Level.INFO, fileBeingProcessed, false, "Skipping image "
                        + fileBeingProcessed + " because color models do not match.",
                        (((fileIndex + 1) * 99.0) / numFiles));
                return;
            }

        }
        // STEP 3
        if (!useExistingSchema) {
            // create and store features
            CatalogManager.updateCatalog(coverageName, fileBeingProcessed, coverageReader,
                    getParentReader(), catalogConfig, envelope, transaction,
                    getPropertiesCollectors());
        }
    }

