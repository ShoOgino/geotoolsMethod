    /**
     * This method is responsible for creating a blank image as a reponse to the query as it seems
     * we got a no data area.
     * 
     * @return a blank {@link RenderedImage} initialized using the background values
     */
    private MosaicOutput createBlankResponse() {
        // if we get here that means that we do not have anything to load
        // but still we are inside the definition area for the mosaic,
        // therefore we create a fake coverage using the background values,
        // if provided (defaulting to 0), as well as the compute raster
        // bounds, envelope and grid to world.
        LOGGER.fine("Creating constant image for area with no data");
        
        final ImageLayout2 il= new ImageLayout2();
        il.setColorModel(rasterManager.defaultCM);
        Dimension tileSize= request.getTileDimensions();
        if(tileSize==null){
            tileSize=JAI.getDefaultTileSize();
        } 

        il.setTileGridXOffset(0).setTileGridYOffset(0).setTileWidth((int)tileSize.getWidth()).setTileHeight((int)tileSize.getHeight());
        final RenderingHints renderingHints = new RenderingHints(JAI.KEY_IMAGE_LAYOUT,il);
        
        
        final Number[] values = ImageUtilities.getBackgroundValues(rasterManager.defaultSM,
                backgroundValues);
        RenderedImage finalImage;
        if (ImageUtilities.isMediaLibAvailable()) {
            // create a constant image with a proper layout
            finalImage = ConstantDescriptor.create(Float.valueOf(rasterBounds.width),
                    Float.valueOf(rasterBounds.height), values, renderingHints);
            if (rasterBounds.x != 0 || rasterBounds.y != 0) {
                ImageWorker w = new ImageWorker(finalImage);
                w.translate(Float.valueOf(rasterBounds.x), 
                        Float.valueOf(rasterBounds.y), 
                        Interpolation.getInstance(Interpolation.INTERP_NEAREST));
                finalImage = w.getRenderedImage();
                
                //finalImage = TranslateDescriptor.create(finalImage, Float.valueOf(rasterBounds.x),
                        //Float.valueOf(rasterBounds.y),
                        //Interpolation.getInstance(Interpolation.INTERP_NEAREST), null);
            }

            // impose the color model and samplemodel as the constant operation does not take them
            // into account!
            if (rasterManager.defaultCM != null) {
                il.setColorModel(rasterManager.defaultCM);
                il.setSampleModel(rasterManager.defaultCM.createCompatibleSampleModel(
                        tileSize.width, tileSize.height));
                finalImage = new ImageWorker(finalImage).setRenderingHints(renderingHints).
                        format(il.getSampleModel(null).getDataType()).getRenderedImage();
            }
        } else {
            il.setWidth(rasterBounds.width).setHeight(rasterBounds.height);
            if (rasterBounds.x != 0 || rasterBounds.y != 0) {
                il.setMinX(rasterBounds.x).setMinY(rasterBounds.y);
            }
            // impose the color model and samplemodel as the constant operation does not take them
            // into account!
            if (rasterManager.defaultCM != null) {
                il.setColorModel(rasterManager.defaultCM);
                il.setSampleModel(rasterManager.defaultCM.createCompatibleSampleModel(
                        tileSize.width, tileSize.height));

            }
            final double[] bkgValues = new double[values.length];
            for (int i = 0; i < values.length; i++) {
                bkgValues[i] = values[i].doubleValue();
            }
            Assert.isTrue(il.isValid(ImageLayout.WIDTH_MASK | ImageLayout.HEIGHT_MASK
                    | ImageLayout.SAMPLE_MODEL_MASK));
            ImageWorker w = new ImageWorker(renderingHints);
            w.setBackground(bkgValues);
            w.mosaic(new RenderedImage[0], MosaicDescriptor.MOSAIC_TYPE_OVERLAY, 
                    null, null, 
                    new double[][] { { CoverageUtilities.
                        getMosaicThreshold(il.getSampleModel(null).getDataType()) } },
                        new Range[]{RangeFactory.create(0, 0)});
            finalImage = w.getRenderedImage();
            //finalImage = MosaicDescriptor.create(new RenderedImage[0],
                    //MosaicDescriptor.MOSAIC_TYPE_OVERLAY, null, null,
                    //new double[][] { { CoverageUtilities.getMosaicThreshold(il.getSampleModel(null)
                            //.getDataType()) } }, bkgValues, renderingHints);
        }
        if (footprintBehavior != null) {
            finalImage = footprintBehavior.postProcessBlankResponse(finalImage, renderingHints);
        }
        
        return new MosaicOutput(finalImage, null);
    }

