    /**
     * This method is responsible for creating a blank image as a reponse to the query as it seems we got a no data area.
     *
     * @return a blank {@link RenderedImage} initialized using the background values
     */
    private MosaicOutput createBlankResponse() {
        // if we get here that means that we do not have anything to load
        // but still we are inside the definition area for the mosaic,
        // therefore we create a fake coverage using the background values,
        // if provided (defaulting to 0), as well as the compute raster
        // bounds, envelope and grid to world.
        LOGGER.fine("Creating constant image for area with no data");

        final ImageLayout2 il = new ImageLayout2();
        ColorModel cm = rasterManager.defaultCM;
        SampleModel sm = rasterManager.defaultSM;
        int[] bands = baseReadParameters.getBands();

        if (bands != null && cm != null && bands.length != cm.getNumComponents()) {
            final int nBands = bands.length;
            ColorSpace cs = null;
            switch (nBands) {
            case 1:
                cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);
                break;
            case 3:
                cs = ColorSpace.getInstance(ColorSpace.CS_sRGB);
                break;
            default:
                cs = new BogusColorSpace(nBands);
            }
            cm = new ComponentColorModel(cs, cm.hasAlpha(), cm.isAlphaPremultiplied(),
                    cm.getTransparency(), cm.getTransferType());
            sm = cm.createCompatibleSampleModel(sm.getWidth(), sm.getHeight());
        }

        il.setColorModel(cm);
        Dimension tileSize = request.getTileDimensions();
        if (tileSize == null) {
            tileSize = JAI.getDefaultTileSize();
        }

        il.setTileGridXOffset(0).setTileGridYOffset(0).setTileWidth((int) tileSize.getWidth())
                .setTileHeight((int) tileSize.getHeight());
        final RenderingHints renderingHints = new RenderingHints(JAI.KEY_IMAGE_LAYOUT, il);

        final Number[] values = ImageUtilities.getBackgroundValues(rasterManager.defaultSM,
                backgroundValues);
        RenderedImage finalImage;
        if (ImageUtilities.isMediaLibAvailable()) {
            // create a constant image with a proper layout
            finalImage = ConstantDescriptor.create((float) rasterBounds.width,
                    (float) rasterBounds.height, values, renderingHints);
            if (rasterBounds.x != 0 || rasterBounds.y != 0) {
                ImageWorker w = new ImageWorker(finalImage);
                w.translate((float) rasterBounds.x, (float) rasterBounds.y,
                        Interpolation.getInstance(Interpolation.INTERP_NEAREST));
                finalImage = w.getRenderedImage();
            }

            // impose the color model and samplemodel as the constant operation does not take them
            // into account!
            if (cm != null) {
                il.setColorModel(cm);
                il.setSampleModel(cm.createCompatibleSampleModel(tileSize.width, tileSize.height));
                finalImage = new ImageWorker(finalImage).setRenderingHints(renderingHints)
                        .format(il.getSampleModel(null).getDataType()).getRenderedImage();
            }
        } else {
            il.setWidth(rasterBounds.width).setHeight(rasterBounds.height);
            if (rasterBounds.x != 0 || rasterBounds.y != 0) {
                il.setMinX(rasterBounds.x).setMinY(rasterBounds.y);
            }
            // impose the color model and samplemodel as the constant operation does not take them
            // into account!
            if (cm == null) {
                byte[] arr = { (byte) 0, (byte) 0xff };
                cm = new IndexColorModel(1, 2, arr, arr, arr);
            }
            il.setColorModel(cm);
            il.setSampleModel(cm.createCompatibleSampleModel(tileSize.width, tileSize.height));

            final double[] bkgValues;
            if (bands != null && bands.length != 0) {
                // Extract the background values
                bkgValues = new double[bands.length];
                for (int k = 0; k < bands.length; k++) {
                    int index = k > values.length ? 0 : bands[k];
                    bkgValues[k] = values[index].doubleValue();
                }
            } else {
                bkgValues = new double[values.length];
                for (int i = 0; i < values.length; i++) {
                    bkgValues[i] = values[i].doubleValue();
                }
            }
            Assert.isTrue(il.isValid(ImageLayout.WIDTH_MASK | ImageLayout.HEIGHT_MASK
                    | ImageLayout.SAMPLE_MODEL_MASK));
            ImageWorker w = new ImageWorker(renderingHints);
            w.setBackground(bkgValues);
            w.mosaic(new RenderedImage[0], MosaicDescriptor.MOSAIC_TYPE_OVERLAY, null, null,
                    new double[][] { { CoverageUtilities
                            .getMosaicThreshold(il.getSampleModel(null).getDataType()) } },
                    new Range[] { RangeFactory.create(0, 0) });
            // there was really nothing here, so make sure this comes out in the output
            Double noData = rasterManager.getConfiguration().getNoData();
            if (noData != null) {
                w.setNoData(RangeFactory.create(noData, noData));
            }
            finalImage = w.getRenderedImage();
        }
        //
        // TRANSPARENT COLOR MANAGEMENT
        //
        Color inputTransparentColor = request.getInputTransparentColor();
        boolean hasAlpha;
        if (inputTransparentColor != null
                && (footprintBehavior == null || !footprintBehavior.handleFootprints())) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Support for alpha on blank image");
            }
            finalImage = new ImageWorker(finalImage).makeColorTransparent(inputTransparentColor)
                    .getRenderedImage();
            hasAlpha = finalImage.getColorModel().hasAlpha();
            if (!hasAlpha) {
                // if the resulting image has no transparency (can happen with IndexColorModel then we need to try component
                // color model
                finalImage = new ImageWorker(finalImage).forceComponentColorModel(true)
                        .makeColorTransparent(inputTransparentColor).getRenderedImage();
                hasAlpha = finalImage.getColorModel().hasAlpha();
            }
            assert hasAlpha;

        } else if (footprintBehavior != null) {
            finalImage = footprintBehavior.postProcessBlankResponse(finalImage, renderingHints);
        }

        return new MosaicOutput(finalImage, null);
    }

