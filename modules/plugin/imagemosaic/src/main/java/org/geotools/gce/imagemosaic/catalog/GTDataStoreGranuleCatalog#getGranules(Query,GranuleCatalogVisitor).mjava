	public void  getGranules(final Query q, final GranuleCatalogVisitor visitor)
	throws IOException {
		Utilities.ensureNonNull("query",q);

		final Lock lock=rwLock.readLock();
		try{
			lock.lock();		
			checkStore();
			
			//
			// Load tiles informations, especially the bounds, which will be
			// reused
			//
			final SimpleFeatureSource featureSource = tileIndexStore.getFeatureSource(this.typeName);
			if (featureSource == null){
				throw new NullPointerException(
						"The provided SimpleFeatureSource is null, it's impossible to create an index!");	
			}
			final SimpleFeatureCollection features = featureSource.getFeatures( q );
			if (features == null) 
				throw new NullPointerException(
						"The provided SimpleFeatureCollection is null, it's impossible to create an index!");
	
			if (LOGGER.isLoggable(Level.FINE))
				LOGGER.fine("Index Loaded");
						
			
			//load the feature from the underlying datastore as needed
			final SimpleFeatureIterator it = features.features();
			try{
				if (!it.hasNext()) {
					if(LOGGER.isLoggable(Level.FINE))
						LOGGER.fine("The provided SimpleFeatureCollection  or empty, it's impossible to create an index!");
					return ;
						
				}	
			}finally{
				it.close();
			}
			
			// visiting the features from the underlying store
			final DefaultProgressListener listener= new DefaultProgressListener();
			features.accepts( new AbstractFeatureVisitor(){
			    public void visit( Feature feature ) {
			        if(feature instanceof SimpleFeature)
			        {
			        	// get the feature
			        	final SimpleFeature sf= (SimpleFeature) feature;
			        	final GranuleDescriptor granule;
			        	
			        	// caching by granule's location
			        	synchronized (granuleDescriptorsCache) {
			        	    String granuleLocation = (String) sf.getAttribute(locationAttribute);
                                            if(granuleDescriptorsCache.containsKey(granuleLocation)){
                                                granule=granuleDescriptorsCache.get(granuleLocation);
                                            } else{
                                                // create the granule descriptor
                                                granule= new GranuleDescriptor(
                                                                sf,
                                                                suggestedRasterSPI,
                                                                pathType,
                                                                locationAttribute,
                                                                parentLocation,
                                                                heterogeneous);
                                                granuleDescriptorsCache.put(granuleLocation, granule);
                                            }
  
			        	    
			        	    
                                        }
			        	visitor.visit(granule, null);
			        	
			        	// check if something bad occurred
			        	if(listener.isCanceled()||listener.hasExceptions()){
			        	    if(listener.hasExceptions())
			        	        throw new RuntimeException(listener.getExceptions().peek());
			        	    else
			        	        throw new IllegalStateException("Feature visitor for query "+q+" has been canceled");
			        	}
			        }
			    }            
			}, listener);

		}
		catch (Throwable e) {
			final IOException ioe= new  IOException();
			ioe.initCause(e);
			throw ioe;
		}
		finally{
			lock.unlock();

		}
	}

