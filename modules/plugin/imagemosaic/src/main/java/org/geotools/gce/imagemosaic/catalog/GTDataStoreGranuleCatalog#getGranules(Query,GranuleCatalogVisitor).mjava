	public void  getGranules(final Query q, final GranuleCatalogVisitor visitor)
	throws IOException {
		Utilities.ensureNonNull("q",q);

		final Lock lock=rwLock.readLock();
		try{
			lock.lock();		
			checkStore();
			
			//
			// Load tiles informations, especially the bounds, which will be
			// reused
			//

			final SimpleFeatureSource featureSource = tileIndexStore.getFeatureSource(this.typeName);
			if (featureSource == null) 
				throw new NullPointerException(
						"The provided SimpleFeatureSource is null, it's impossible to create an index!");			
			final SimpleFeatureCollection features = featureSource.getFeatures( q );
			if (features == null) 
				throw new NullPointerException(
						"The provided SimpleFeatureCollection is null, it's impossible to create an index!");
	
			if (LOGGER.isLoggable(Level.FINE))
				LOGGER.fine("Index Loaded");
						
			
			//load the feature from the underlying datastore as needed
			final SimpleFeatureIterator it = features.features();
			try{
				if (!it.hasNext()) {
					if(LOGGER.isLoggable(Level.FINE))
						LOGGER.fine("The provided SimpleFeatureCollection  or empty, it's impossible to create an index!");
					return ;
						
				}	
			}finally{
				it.close();
			}
			
			final DefaultProgressListener listener= new DefaultProgressListener();
			features.accepts( new AbstractFeatureVisitor(){
			    public void visit( Feature feature ) {
			        if(feature instanceof SimpleFeature)
			        {
			        	final SimpleFeature sf= (SimpleFeature) feature;
						// create the granule descriptor
						final GranuleDescriptor granule= new GranuleDescriptor(
								sf,
								suggestedSPI,
								pathType,
								locationAttribute,
								parentLocation,
								heterogeneous);
			        	visitor.visit(granule, null);
			        	
			        	// check if something bad occurred
			        	if(listener.isCanceled()||listener.hasExceptions()){
			        	    if(listener.hasExceptions())
			        	        throw new RuntimeException(listener.getExceptions().peek());
			        	    else
			        	        throw new IllegalStateException("Feature visitor for query "+q+" has been canceled");
			        	}
			        }
			    }            
			}, listener);

		}
		catch (Throwable e) {
			final IOException ioe= new  IOException();
			ioe.initCause(e);
			throw ioe;
		}
		finally{
			lock.unlock();

		}
	}

