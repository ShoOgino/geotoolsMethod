	public void  getGranules(final Query q, final GranuleCatalogVisitor visitor)
	throws IOException {
		Utilities.ensureNonNull("q",q);

		final Lock lock=rwLock.readLock();
		try{
			lock.lock();		
			checkStore();
			
			//
			// Load tiles informations, especially the bounds, which will be
			// reused
			//

			final SimpleFeatureSource featureSource = tileIndexStore.getFeatureSource(this.typeName);
			if (featureSource == null) 
				throw new NullPointerException(
						"The provided SimpleFeatureSource is null, it's impossible to create an index!");			
			final SimpleFeatureCollection features = featureSource.getFeatures( q );
			if (features == null) 
				throw new NullPointerException(
						"The provided SimpleFeatureCollection is null, it's impossible to create an index!");
	
			if (LOGGER.isLoggable(Level.FINE))
				LOGGER.fine("Index Loaded");
						
			
			//load the feature from the underlying datastore as needed
			final SimpleFeatureIterator it = features.features();
			try{
				if (!it.hasNext()) {
					if(LOGGER.isLoggable(Level.FINE))
						LOGGER.fine("The provided SimpleFeatureCollection  or empty, it's impossible to create an index!");
					return ;
						
				}	
			}finally{
				it.close();
			}
			
			features.accepts( new AbstractFeatureVisitor(){
			    public void visit( Feature feature ) {
			        if(feature instanceof SimpleFeature)
			        {
			        	final SimpleFeature sf= (SimpleFeature) feature;
						// create the granule descriptor
						final GranuleDescriptor granule= new GranuleDescriptor(
								sf,
								suggestedSPI,
								pathType,
								locationAttribute,
								parentLocation,
								heterogeneous);
			        	visitor.visit(granule, null);
			        }
			    }            
			}, new NullProgressListener() );

		}
		catch (Throwable e) {
			throw new  IllegalArgumentException(e);
		}
		finally{
			lock.unlock();

		}
	}

