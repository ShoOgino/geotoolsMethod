    /**
     * Get a {@link GranuleSource} related to a specific coverageName from an inputReader
     * and put the related granules into a {@link GranuleStore} related to the same coverageName
     * of the mosaicReader.
     *
     * @param coverageName the name of the coverage to be managed
     * @param fileBeingProcessed the reference input file
     * @param inputReader the reader source of granules
     * @param mosaicReader the reader where to store source granules
     * @param configuration the configuration
     * @param envelope envelope of the granule being added
     * @param transaction transaction in progress
     * @param propertiesCollectors list of properties collectors to use
     * @throws IOException
     */
    private void updateCatalog(
            final String coverageName,
            final File fileBeingProcessed,
            final GridCoverage2DReader inputReader,
            final ImageMosaicReader mosaicReader,
            final CatalogBuilderConfiguration configuration,
            final GeneralEnvelope envelope,
            final DefaultTransaction transaction,
            final List<PropertiesCollector> propertiesCollectors) throws IOException {

        // Retrieving the store and the destination schema
        final GranuleStore store = (GranuleStore) mosaicReader.getGranules(coverageName, false);
        if (store == null) {
            throw new IllegalArgumentException("No valid granule store has been found for: " + coverageName);
        }
        final SimpleFeatureType indexSchema = store.getSchema();
        final SimpleFeature feature = new ShapefileCompatibleFeature(DataUtilities.template(indexSchema));
        store.setTransaction(transaction);

        final ListFeatureCollection collection = new ListFeatureCollection(indexSchema);
        final String fileLocation = prepareLocation(configuration, fileBeingProcessed);
        final String locationAttribute = configuration.getParameter(Prop.LOCATION_ATTRIBUTE);

        // getting input granules
        if (inputReader instanceof StructuredGridCoverage2DReader) {

            //
            // Case A: input reader is a StructuredGridCoverage2DReader. We can get granules from a source
            //
            // Getting granule source and its input granules
            final GranuleSource source = ((StructuredGridCoverage2DReader) inputReader).getGranules(coverageName, true);
            final SimpleFeatureCollection originCollection = source.getGranules(null);
            final DefaultProgressListener listener = new DefaultProgressListener();

            // Getting attributes structure to be filled
            final Collection<Property> destProps = feature.getProperties();
            final Set<Name> destAttributes = new HashSet<>();
            for (Property prop: destProps) {
                destAttributes.add(prop.getName());
            }

            // Collecting granules
            originCollection.accepts( new AbstractFeatureVisitor(){
                public void visit( Feature feature ) {
                    if(feature instanceof SimpleFeature)
                    {
                            // get the feature
                            final SimpleFeature sourceFeature = (SimpleFeature) feature;
                            final SimpleFeature destFeature = DataUtilities.template(indexSchema);
                            Collection<Property> props = sourceFeature.getProperties();
                            Name propName = null;
                            Object propValue = null;

                            // Assigning value to dest feature for matching attributes
                            for (Property prop: props) {
                                propName = prop.getName();
                                propValue = prop.getValue();

                                // Matching attributes are set
                                if (destAttributes.contains(propName)) {
                                    destFeature.setAttribute(propName, propValue);
                                }
                            }

                            // Set location
                            destFeature.setAttribute(locationAttribute, fileLocation);

                            // delegate remaining attributes set to properties collector
                            updateAttributesFromCollectors(destFeature, fileBeingProcessed, inputReader, propertiesCollectors);
                            collection.add(destFeature);

                            // check if something bad occurred
                            if(listener.isCanceled()||listener.hasExceptions()){
                                if(listener.hasExceptions())
                                    throw new RuntimeException(listener.getExceptions().peek());
                                else
                                    throw new IllegalStateException("Feature visitor has been canceled");
                            }
                    }
                }
            }, listener);
        } else {
            //
            // Case B: old style reader, proceed with classic way, using properties collectors
            //
            feature.setAttribute(indexSchema.getGeometryDescriptor().getLocalName(),
                    GEOM_FACTORY.toGeometry(new ReferencedEnvelope(envelope)));
            feature.setAttribute(locationAttribute, fileLocation);

            updateAttributesFromCollectors(feature, fileBeingProcessed, inputReader, propertiesCollectors);
            collection.add(feature);
        }

        // drop all the granules associated to the same
        Filter filter = Utils.FF.equal(Utils.FF.property(locationAttribute), Utils.FF.literal(fileLocation),
                !isCaseSensitiveFileSystem(fileBeingProcessed));
        store.removeGranules(filter);

        // Add the granules collection to the store
        store.addGranules(collection);
    }

