    /** Builds an alternate view of request/response/manager based on a template descriptor */
    public RasterLayerResponse reprojectTo(GranuleDescriptor templateDescriptor) throws Exception {
        // optimization in case the granule CRS and the mosaic CRS correspond
        CoordinateReferenceSystem granuleCRS =
                templateDescriptor.getGranuleEnvelope().getCoordinateReferenceSystem();
        RasterLayerRequest originalRequest = this.getRequest();
        CoordinateReferenceSystem referenceCRS =
                originalRequest.spatialRequestHelper.getReferenceCRS(true);
        if (CRS.equalsIgnoreMetadata(referenceCRS, granuleCRS)) {
            return this;
        }

        // rebuild
        RasterManager originalRasterManager = originalRequest.getRasterManager();
        RasterManager manager =
                originalRasterManager.getForGranuleCRS(
                        templateDescriptor,
                        this.mosaicBBox,
                        originalRequest.spatialRequestHelper.isSupportingAlternativeCRSOutput()
                                ? this.queryBBox
                                : this.mosaicBBox);
        RasterLayerRequest request =
                new RasterLayerRequest(originalRequest.getParams(), manager) {
                    @Override
                    protected ReferencedEnvelope computeCoverageBoundingBox(
                            RasterManager rasterManager) throws IOException {
                        // in case of filtering we are re-computing the bbox from the data, it gets
                        // back in the mosaic CRS instead of the desired one. Force it to use the
                        // whole
                        // thing, we already used the filter
                        // TODO: add projection handler support
                        if (filter != null && !Filter.INCLUDE.equals(filter)) {
                            // limit it to the filtered granules bounding box by full enumeration,
                            // to avoid
                            // imprecise datastore optimizations (e.g., loose bounds)
                            GranuleSource granules = rasterManager.getGranuleSource(true, null);
                            String crsAttribute = manager.getCrsAttribute();
                            String granuleCRSCode =
                                    (String)
                                            templateDescriptor
                                                    .getOriginator()
                                                    .getAttribute(crsAttribute);
                            FilterFactory2 ff = FeatureUtilities.DEFAULT_FILTER_FACTORY;
                            PropertyIsEqualTo crsFilter =
                                    ff.equal(
                                            ff.property(crsAttribute),
                                            ff.literal(granuleCRSCode),
                                            false);
                            Filter composite = ff.and(crsFilter, filter);

                            Query query = new Query(granules.getSchema().getTypeName(), composite);
                            // ... load only the default geometry if possible
                            final GeometryDescriptor gd =
                                    granules.getSchema().getGeometryDescriptor();
                            if (gd != null) {
                                query.setPropertyNames(gd.getLocalName());
                            }
                            SimpleFeatureCollection features = granules.getGranules(query);
                            ReferencedEnvelope envelope = DataUtilities.bounds(features);
                            if (envelope != null && !envelope.isEmpty()) {
                                try {
                                    return envelope.transform(granuleCRS, true);
                                } catch (TransformException | FactoryException e) {
                                    LOGGER.log(
                                            Level.FINE,
                                            "Could not transform filtered envelope into target granule CRS, falling back on mosaic");
                                }
                            }
                        }

                        // fallback
                        return rasterManager.spatialDomainManager.coverageBBox;
                    }
                };
        // if the output needs to have transparent footprint behavior, we need to preserve the
        // various sub-mosaic ROIs until the final mosaicking
        if (request.getFootprintBehavior() == FootprintBehavior.Transparent) {
            request.setFootprintBehavior(FootprintBehavior.Cut);
        }
        if (request.spatialRequestHelper.isEmpty()) {
            return null;
        }
        RasterLayerResponse response =
                new RasterLayerResponse(request, manager, this.submosaicProducerFactory);
        // initialize enough info without actually running the output computation
        response.chooseOverview();
        response.initBBOX();
        response.initTransformations();
        response.initRasterBounds();

        return response;
    }

