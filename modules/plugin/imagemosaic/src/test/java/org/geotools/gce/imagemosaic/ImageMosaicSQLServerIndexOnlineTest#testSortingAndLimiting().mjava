    /** Complex test for SQLServer indexing on db. */
    @Test
    public void testSortingAndLimiting() throws Exception {
        ImageMosaicReader reader = null;
        try {
            createMetadataTable();
            final File workDir = new File(TestData.file(this, "."), tempFolderName2);
            assertTrue(workDir.mkdir());
            FileUtils.copyFile(
                    TestData.file(this, "watertemp.zip"), new File(workDir, "watertemp.zip"));
            TestData.unzipFile(this, tempFolderName2 + "/watertemp.zip");
            final URL timeElevURL = TestData.url(this, tempFolderName2);

            setupDataStoreProperties(tempFolderName2);

            // now start the test
            final AbstractGridFormat format = TestUtils.getFormat(timeElevURL);
            assertNotNull(format);
            reader = TestUtils.getReader(timeElevURL, format);
            assertNotNull(reader);

            final String[] metadataNames = reader.getMetadataNames();
            assertNotNull(metadataNames);
            assertEquals(13, metadataNames.length);

            assertEquals("true", reader.getMetadataValue("HAS_TIME_DOMAIN"));
            assertEquals("true", reader.getMetadataValue("HAS_ELEVATION_DOMAIN"));

            // dispose and create new reader
            reader.dispose();
            reader = new MyImageMosaicReader(timeElevURL);
            final RasterManager rasterManager =
                    reader.getRasterManager(reader.getGridCoverageNames()[0]);

            // query
            final SimpleFeatureType type = rasterManager.granuleCatalog.getType("waterTempPG2");
            Query query = null;
            if (type != null) {
                // creating query
                query = new Query(type.getTypeName());

                // sorting and limiting
                // max number of elements
                query.setMaxFeatures(1);

                // sorting
                final SortBy[] clauses =
                        new SortBy[] {
                            new SortByImpl(
                                    FeatureUtilities.DEFAULT_FILTER_FACTORY.property("ingestion"),
                                    SortOrder.DESCENDING),
                            new SortByImpl(
                                    FeatureUtilities.DEFAULT_FILTER_FACTORY.property("elevation"),
                                    SortOrder.ASCENDING),
                        };
                query.setSortBy(clauses);
            }

            // checking that we get a single feature and that feature is correct
            final Collection<GranuleDescriptor> features = new ArrayList<GranuleDescriptor>();
            rasterManager.getGranuleDescriptors(
                    query,
                    new GranuleCatalogVisitor() {

                        @Override
                        public void visit(GranuleDescriptor granule, SimpleFeature o) {
                            features.add(granule);
                        }
                    });
            assertEquals(features.size(), 1);
            GranuleDescriptor granule = features.iterator().next();
            SimpleFeature sf = granule.getOriginator();
            assertNotNull(sf);
            Object ingestion = sf.getAttribute("ingestion");
            assertTrue(ingestion instanceof Timestamp);
            final GregorianCalendar gc = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
            gc.setTimeInMillis(1225497600000l);
            assertEquals(0, (((Timestamp) ingestion).compareTo(gc.getTime())));
            Object elevation = sf.getAttribute("elevation");
            assertTrue(elevation instanceof Integer);
            assertEquals(((Integer) elevation).intValue(), 0);

            // Reverting order (the previous timestamp shouldn't match anymore)
            final SortBy[] clauses =
                    new SortBy[] {
                        new SortByImpl(
                                FeatureUtilities.DEFAULT_FILTER_FACTORY.property("ingestion"),
                                SortOrder.ASCENDING),
                        new SortByImpl(
                                FeatureUtilities.DEFAULT_FILTER_FACTORY.property("elevation"),
                                SortOrder.DESCENDING),
                    };
            query.setSortBy(clauses);

            // checking that we get a single feature and that feature is correct
            features.clear();
            rasterManager.getGranuleDescriptors(
                    query,
                    new GranuleCatalogVisitor() {

                        @Override
                        public void visit(GranuleDescriptor granule, SimpleFeature o) {
                            features.add(granule);
                        }
                    });
            assertEquals(features.size(), 1);
            granule = features.iterator().next();
            sf = granule.getOriginator();
            assertNotNull(sf);
            ingestion = sf.getAttribute("ingestion");
            assertTrue(ingestion instanceof Timestamp);
            assertNotSame(0, (((Timestamp) ingestion).compareTo(gc.getTime())));
            elevation = sf.getAttribute("elevation");
            assertTrue(elevation instanceof Integer);
            assertNotSame(((Integer) elevation).intValue(), 0);
        } finally {
            if (reader != null) reader.dispose();
        }
    }

