    @Test
    public void testHarvestCurrentTime() throws Exception {
        File source = URLs.urlToFile(org.geotools.test.TestData.url(this, "rgba/"));
        File config = URLs.urlToFile(org.geotools.test.TestData.url(this, "currentdate/"));
        File testDataDir = org.geotools.test.TestData.file(this, ".");
        File directory1 = new File(testDataDir, "currTimeHarvest1");
        File directory2 = new File(testDataDir, "currTimeHarvest2");
        if (directory1.exists()) {
            FileUtils.deleteDirectory(directory1);
        }
        FileUtils.copyDirectory(source, directory1);
        FileUtils.copyDirectory(config, directory1);
        if (directory2.exists()) {
            FileUtils.deleteDirectory(directory2);
        }
        FileUtils.copyDirectory(source, directory2);
        // remove all files but one from the source dir
        for (File file :
                directory1.listFiles(
                        f ->
                                !f.getName().startsWith("passA2006128193711.")
                                        && !f.getName().endsWith(".properties"))) {
            assertTrue(file.delete());
        }

        // ok, let's create a mosaic with a single granule and check its times
        URL harvestSingleURL = fileToUrl(directory1);
        final AbstractGridFormat format = TestUtils.getFormat(harvestSingleURL);
        ImageMosaicReader reader = TestUtils.getReader(harvestSingleURL, format);
        try {
            // wait a bit
            Thread.sleep(100);

            // harvest a file
            File harvestSourceOne = new File(directory2, "passA2006128194218.png");
            List<HarvestedSource> summary = reader.harvest(null, harvestSourceOne, null);
            assertEquals(1, summary.size());
            HarvestedSource hf = summary.get(0);
            assertTrue(hf.success());

            // wait a bit again

            Thread.sleep(100);

            // harvest another
            File harvestSourceTwo = new File(directory2, "passA2006128211927.png");
            summary = reader.harvest(null, harvestSourceTwo, null);
            assertEquals(1, summary.size());
            hf = summary.get(0);
            assertTrue(hf.success());

            // now collect the granules and make sure the times are in sequential order (not all
            // same)
            Map<String, Date> mappedDates = new HashMap<>();
            reader.getGranules(null, true)
                    .getGranules(Query.ALL)
                    .accepts(
                            feature -> {
                                String location =
                                        (String) feature.getProperty("location").getValue();
                                int idxSlash = location.lastIndexOf('\\');
                                int idxBackslash = location.lastIndexOf('/');
                                String name = location;
                                if (idxSlash > -1 || idxBackslash > -1) {
                                    name = location.substring(Math.max(idxSlash, idxBackslash) + 1);
                                }
                                Date ingest = (Date) feature.getProperty("ingestion").getValue();
                                mappedDates.put(name, ingest);
                            },
                            null);

            // check they are not all the same (the collector was re-created every time)
            assertThat(
                    mappedDates.get("passA2006128193711.png"),
                    Matchers.lessThan(mappedDates.get("passA2006128194218.png")));
            assertThat(
                    mappedDates.get("passA2006128194218.png"),
                    Matchers.lessThan(mappedDates.get("passA2006128211927.png")));

            // check they are reasonable (say within an hour from the current time, if not the
            // test execution went really wrong)
            long now = System.currentTimeMillis();
            long oneHour = 1000 * 60 * 60;
            for (Date d : mappedDates.values()) {
                assertThat(
                        d + " vs " + new Date(),
                        now - d.getTime(),
                        Matchers.lessThanOrEqualTo(oneHour));
            }
        } finally {
            reader.dispose();
        }
    }

