    private void runConcurrentHeteroUTMH2(
            Function<ImageMosaicReader, GeneralParameterValue[]> parameters)
            throws URISyntaxException, IOException, InterruptedException,
                    java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException {
        String testLocation = "hetero_utm";
        URL storeUrl = TestData.url(this, testLocation);

        File testDataFolder = new File(storeUrl.toURI());
        File testDirectory = crsMosaicFolder.newFolder(testLocation);
        FileUtils.copyDirectory(testDataFolder, testDirectory);

        // to similate the deadlock we need a connection pool with just one connection,
        // a single request will cause the deadlock in this case (but we try with a pool
        // nevertheless, to be extra sure)
        File datastoreProperties = new File(testDirectory, "datastore.properties");
        try (FileWriter out = new FileWriter(datastoreProperties)) {
            out.write("database=hetero_concurrent\n");
            out.write(
                    "SPI=org.geotools.data.h2.H2DataStoreFactory\n"
                            + "dbtype=h2\n"
                            + "user=gs\n"
                            + "passwd=gs\n"
                            + "Connection\\ timeout=3600\n"
                            + "max \\connections=1"
                            + "min \\connections=1");
            out.flush();
        }

        final ExecutorService executors = Executors.newFixedThreadPool(4);
        ImageMosaicReader reader = new ImageMosaicReader(testDirectory, null);
        try {
            List<Future> futures = new ArrayList<>();
            for (int i = 0; i < 20; i++) {
                Future<GridCoverage2D> future =
                        executors.submit(() -> reader.read(parameters.apply(reader)));
                futures.add(future);
            }
            for (Future future : futures) {
                // just to make sure it cannot get stuck forever, but allow execution on
                // very slow runtimes
                future.get(120, TimeUnit.SECONDS);
            }
        } finally {
            reader.dispose();
        }
    }

