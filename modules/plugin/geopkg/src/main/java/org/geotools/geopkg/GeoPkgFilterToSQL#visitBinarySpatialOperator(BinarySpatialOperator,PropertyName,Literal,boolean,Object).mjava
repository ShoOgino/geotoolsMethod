    @Override
    protected Object visitBinarySpatialOperator(
            BinarySpatialOperator filter,
            PropertyName property,
            Literal geometry,
            boolean swapped,
            Object extraData) {

        // get the attribute, it will expand the default geom name if necessary and give access to
        // the user data
        AttributeDescriptor attribute = property.evaluate(featureType, AttributeDescriptor.class);
        // should be ever called only with a bbox filter
        Geometry reference = geometry.evaluate(null, Geometry.class);
        Envelope envelope = reference.getEnvelopeInternal();
        if (envelope == null) {
            throw new IllegalArgumentException(
                    "Invalid BBOX filter specification, it's defined against a NULL envelope");
        }
        envelope.expandBy(1e-11);

        // can we use the spatial index?
        try {
            if (primaryKey != null
                    && attribute != null
                    && Boolean.TRUE.equals(
                            attribute.getUserData().get(GeoPkgDialect.HAS_SPATIAL_INDEX))) {
                // encode the primary key
                PrimaryKeyColumn pk = primaryKey.getColumns().get(0);
                String pkName = pk.getName();
                filterFactory.property(pkName).accept(this, null);
                // Make Sure the table name is escaped - GEOT-5852
                StringBuffer sb = new StringBuffer();
                dialect.encodeTableName(
                        "rtree_" + featureType.getTypeName() + "_" + attribute.getLocalName(), sb);
                String spatial_index = sb.toString();

                out.write(" IN (SELECT id FROM " + spatial_index + " r WHERE");
                out.write(" r.maxx >= " + envelope.getMinX());
                out.write(" AND r.minx <= " + envelope.getMaxX());
                out.write(" AND r.maxy >= " + envelope.getMinY());
                out.write(" AND r.miny <= " + envelope.getMaxY());
                out.write(")");
            } else {
                // fall back on direct BBOX tests, it's still faster than loading the whole geometry
                // and to do BBOX in memory
                StringBuffer sb = new StringBuffer();
                dialect.encodeColumnName(null, attribute.getLocalName(), sb);
                String encodedPropertyName = sb.toString();
                out.write(
                        "(ST_MaxX("
                                + encodedPropertyName
                                + ") >= "
                                + envelope.getMinX()
                                + " AND\n");
                out.write(
                        "ST_MinX(" + encodedPropertyName + ") <= " + envelope.getMaxX() + " AND\n");
                out.write(
                        "ST_MaxY(" + encodedPropertyName + ") >= " + envelope.getMinY() + " AND\n");
                out.write("ST_MinY(" + encodedPropertyName + ") <= " + envelope.getMaxY() + ")\n");
            }
        } catch (IOException e) {
            throw new RuntimeException(
                    "Failure encoding the SQL equivalent for a spatial filter", e);
        }

        return extraData;
    }

