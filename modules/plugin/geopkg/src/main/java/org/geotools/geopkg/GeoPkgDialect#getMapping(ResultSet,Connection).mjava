    @Override
    public Class<?> getMapping(ResultSet columns, Connection cx) throws SQLException {
        String tbl = columns.getString("TABLE_NAME");
        String col = columns.getString("COLUMN_NAME");
        String typeName = columns.getString("TYPE_NAME");

        String sql =
                format(
                        "SELECT b.geometry_type_name"
                                + " FROM %s a, %s b"
                                + " WHERE a.table_name = b.table_name"
                                + " AND b.table_name = ?"
                                + " AND b.column_name = ?",
                        GEOPACKAGE_CONTENTS, GEOMETRY_COLUMNS);

        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine(String.format("%s; 1=%s, 2=%s", sql, tbl, col));
        }

        try (PreparedStatement ps = cx.prepareStatement(sql)) {
            ps.setString(1, tbl);
            ps.setString(2, col);

            ResultSet rs = ps.executeQuery();
            try {
                if (rs.next()) {
                    String t = rs.getString(1);
                    Geometries g = Geometries.getForName(t);
                    if (g != null) {
                        return g.getBinding();
                    }
                }
            } finally {
                dataStore.closeSafe(rs);
            }
        }

        // if it's an enumeration, switch data type to string
        @SuppressWarnings("PMD.CloseResource") // using the pool of the store, no need to close
        GeoPackage geoPackage = geopkg();
        try {
            GeoPkgSchemaExtension extension = geoPackage.getExtension(GeoPkgSchemaExtension.class);
            List<DataColumn> dataColumns = extension.getDataColumns(tbl, cx);
            for (DataColumn dataColumn : dataColumns) {
                if (col.equals(dataColumn.getColumnName())) {
                    DataColumnConstraint constraint = dataColumn.getConstraint();
                    // array?
                    if ("application/json".equals(dataColumn.getMimeType())) {
                        return String[].class;
                    }
                    // otherwise consider the conversion
                    if (constraint instanceof DataColumnConstraint.Enum) {
                        return String.class;
                    }
                }
            }
        } catch (IOException e) {
            throwSQLException(e);
        }

        // handle GeoPackage integer type expectations
        if ("TINYINT".equals(typeName)) return Byte.class;
        else if ("SMALLINT".equals(typeName)) return Short.class;
        else if ("MEDIUMINT".equals(typeName)) return Integer.class;
        else if ("INT".equals(typeName) || "INTEGER".equals(typeName)) return Long.class;
        // support for overview tables
        else if ("POINT".equalsIgnoreCase(typeName)) return Point.class;
        else if ("MULTIPOINT".equalsIgnoreCase(typeName)) return MultiPoint.class;
        else if ("LINESTRING".equalsIgnoreCase(typeName)) return LineString.class;
        else if ("MULTILINESTRING".equalsIgnoreCase(typeName)) return MultiLineString.class;
        else if ("POLYGON".equalsIgnoreCase(typeName)) return Polygon.class;
        else if ("MULTIPOLYGON".equalsIgnoreCase(typeName)) return MultiPolygon.class;
        else if ("GEOMETRY".equalsIgnoreCase(typeName)) return Geometry.class;
        else if ("GEOMETRYCOLLECTION".equalsIgnoreCase(typeName)) return GeometryCollection.class;

        return null;
    }

