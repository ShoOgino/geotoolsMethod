    @Override
    public GridCoverage2D read(String coverageName, GeneralParameterValue[] parameters)
            throws IllegalArgumentException, IOException {
        TileEntry entry = tiles.get(coverageName);
        RenderedImage image = null;
        ReferencedEnvelope resultEnvelope = null;

        CoordinateReferenceSystem crs = getCoordinateReferenceSystem(coverageName);

        ReferencedEnvelope requestedEnvelope = null;
        Rectangle dim = null;

        if (parameters != null) {
            for (int i = 0; i < parameters.length; i++) {
                final ParameterValue param = (ParameterValue) parameters[i];
                final ReferenceIdentifier name = param.getDescriptor().getName();
                if (name.equals(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName())) {
                    final GridGeometry2D gg = (GridGeometry2D) param.getValue();
                    try {
                        requestedEnvelope =
                                ReferencedEnvelope.create(
                                                gg.getEnvelope(), gg.getCoordinateReferenceSystem())
                                        .transform(crs, true);
                        ;
                    } catch (Exception e) {
                        requestedEnvelope = null;
                    }

                    dim = gg.getGridRange2D().getBounds();
                    continue;
                }
            }
        }

        // find the closest zoom based on horizontal resolution
        TileMatrix bestMatrix = null;
        if (requestedEnvelope != null && dim != null) {
            // requested res
            double horRes =
                    requestedEnvelope.getSpan(0)
                            / dim.getWidth(); // proportion of total width that is being
            // requested

            // loop over matrices
            double difference = Double.MAX_VALUE;
            for (TileMatrix matrix : entry.getTileMatricies()) {
                if (!matrix.hasTiles()) {
                    continue;
                }
                double newRes = matrix.getXPixelSize();
                double newDifference = Math.abs(horRes - newRes);
                if (newDifference < difference) {
                    difference = newDifference;
                    bestMatrix = matrix;
                }
            }
        }
        if (bestMatrix == null) {
            // pick the highest resolution, like in a geotiff with overviews
            double resolution = Double.POSITIVE_INFINITY;
            for (TileMatrix matrix : entry.getTileMatricies()) {
                if (!matrix.hasTiles()) {
                    continue;
                }
                double newRes = matrix.getXPixelSize();
                if (newRes < resolution) {
                    resolution = newRes;
                    bestMatrix = matrix;
                }
            }
        }

        if (bestMatrix == null) {
            // it means no level has tiles, return null, it's ok to do so
            return null;
        }

        Envelope entryBounds = entry.getTileMatrixSetBounds();
        double resX = bestMatrix.getXPixelSize() * bestMatrix.getTileWidth();
        double resY = bestMatrix.getYPixelSize() * bestMatrix.getTileHeight();
        /*
         * From the specification: "The tile coordinate (0,0) always refers to the tile in the upper left corner of the tile matrix at any zoom
         * level, regardless of the actual availability of that tile."
         * So remember the y axis goes from top to bottom, not the other way around
         */
        double offsetX = entryBounds.getMinX();
        double offsetY = entryBounds.getMaxY();

        // crop tiles to requested envelope if necessary
        int leftTile, bottomTile, rightTile, topTile;
        if (requestedEnvelope != null) {
            TileBoundsCalculator tileBoundsCalculator =
                    new TileBoundsCalculator(requestedEnvelope, resX, resY, offsetX, offsetY)
                            .invoke();
            leftTile = tileBoundsCalculator.getLeftTile();
            bottomTile = tileBoundsCalculator.getBottomTile();
            rightTile = tileBoundsCalculator.getRightTile();
            topTile = tileBoundsCalculator.getTopTile();
        } else {
            TileBoundsCalculator tileBoundsCalculator =
                    new TileBoundsCalculator(entryBounds, resX, resY, offsetX, offsetY).invoke();
            leftTile = tileBoundsCalculator.getLeftTile();
            bottomTile = tileBoundsCalculator.getBottomTile();
            rightTile = tileBoundsCalculator.getRightTile();
            topTile = tileBoundsCalculator.getTopTile();

            final double minX = entryBounds.getMinX();
            final double maxX = entryBounds.getMaxX();
            final double minY = entryBounds.getMinY();
            final double maxY = entryBounds.getMaxY();

            // cannot "round" here or half a tile in the requested area might be missing
            // TODO: the code could consider if the eventual extra tile introduced by
            // floor/ceil actually contributes at least one full pixel to the output, or
            // a significant part of it
            leftTile = (int) Math.floor((minX - offsetX) / resX);
            topTile = (int) Math.floor((offsetY - maxY) / resY);
            rightTile = (int) Math.ceil((maxX - offsetX) / resX);
            bottomTile = (int) Math.ceil((offsetY - minY) / resY);
        }

        try (TileReader it =
                file.reader(
                        entry,
                        bestMatrix.getZoomLevel(),
                        bestMatrix.getZoomLevel(),
                        leftTile,
                        rightTile,
                        topTile,
                        bottomTile)) {
            /**
             * Composing the output is harder than it seems, GeoPackage does not mandate any
             * uniformity in tiles, they can be in different formats (a mix of PNG and JPEG) and can
             * have different color models, thus a mix of (possibly different) palettes, gray, RGB,
             * RGBA. GDAL in particular defaults to generate a mix of PNG and JPEG to generate the
             * slow and large PNG format only when transparency is actually needed
             */
            List<RenderedImage> sources = new ArrayList<>();
            ImageWorker iw = new ImageWorker();
            TileImageReader tileReader = new TileImageReader();

            while (it.hasNext()) {
                Tile tile = it.next();
                // recalculate the envelope we are actually returning (remember y axis is flipped)
                ReferencedEnvelope tileEnvelope =
                        new ReferencedEnvelope( //
                                offsetX + tile.getColumn() * resX, //
                                offsetX + (tile.getColumn() + 1) * resX, //
                                offsetY - (tile.getRow() + 1) * resY, //
                                offsetY - tile.getRow() * resY,
                                crs);
                if (resultEnvelope == null) {
                    resultEnvelope = tileEnvelope;
                } else {
                    resultEnvelope.expandToInclude(tileEnvelope);
                }

                BufferedImage tileImage = tileReader.read(tile.getData());

                iw.setImage(tileImage);
                int posx = (tile.getColumn() - leftTile) * DEFAULT_TILE_SIZE;
                int posy = (tile.getRow() - topTile) * DEFAULT_TILE_SIZE;
                if (posx != 0 || posy != 0) {
                    iw.translate(
                            posx, posy, Interpolation.getInstance(Interpolation.INTERP_NEAREST));
                    RenderedImage translated = iw.getRenderedImage();
                    sources.add(translated);
                } else {
                    sources.add(tileImage);
                }
            }
            it.close();

            if (sources.isEmpty()) {
                // no tiles
                return null;
            } else if (sources.size() == 1) {
                // one tile
                image = sources.get(0);
            } else {
                // at the time of writing, only JAI-EXT mosaic can handle a mix of different
                // color models, we need to use it explicitly
                final ParameterBlockJAI pb =
                        new ParameterBlockJAI(new it.geosolutions.jaiext.mosaic.MosaicDescriptor());
                sources.forEach(s -> pb.addSource(s));
                pb.setParameter("mosaicType", MosaicDescriptor.MOSAIC_TYPE_OVERLAY);
                pb.setParameter("sourceAlpha", null);
                pb.setParameter("sourceROI", null);
                pb.setParameter("sourceThreshold", null);
                pb.setParameter("backgroundValues", new double[] {0});
                pb.setParameter("nodata", null);

                RenderingHints hints = new Hints(JAI.getDefaultInstance().getRenderingHints());
                hints.putAll(GeoTools.getDefaultHints());
                image = new MosaicRIF().create(pb, hints);
            }
        }
        return coverageFactory.create(entry.getTableName(), image, resultEnvelope);
    }

