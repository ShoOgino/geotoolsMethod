    @Override
    public GridCoverage2D read(String coverageName, GeneralParameterValue[] parameters) throws IllegalArgumentException, IOException {
        TileEntry entry = tiles.get(coverageName);
        RenderedImage image = null;
        ReferencedEnvelope resultEnvelope = null;
        GeoPackage file = new GeoPackage(sourceFile);
        try {
            CoordinateReferenceSystem crs = getCoordinateReferenceSystem(coverageName);

            ReferencedEnvelope requestedEnvelope = null;
            Rectangle dim = null;

            if (parameters != null) {
                for (int i = 0; i < parameters.length; i++) {
                    final ParameterValue param = (ParameterValue) parameters[i];
                    final ReferenceIdentifier name = param.getDescriptor().getName();
                    if (name.equals(AbstractGridFormat.READ_GRIDGEOMETRY2D.getName())) {
                        final GridGeometry2D gg = (GridGeometry2D) param.getValue();
                        try {                        
                            requestedEnvelope = ReferencedEnvelope.create(gg.getEnvelope(), gg.getCoordinateReferenceSystem()).transform(crs, true);;
                        } catch (Exception e) {
                            requestedEnvelope = null;
                        }

                        dim = gg.getGridRange2D().getBounds();
                        continue;
                    }
                }
            }

            int boundsLeftTile, boundsBottomTile, boundsRightTile, boundsTopTile;

            //find the closest zoom based on horizontal resolution
            TileMatrix bestMatrix = null;
            if (requestedEnvelope != null && dim != null) {
                // requested res
                double horRes = requestedEnvelope.getSpan(0) / dim.getWidth(); //proportion of total width that is being requested

                //loop over matrices            
                double difference = Double.MAX_VALUE;
                for (TileMatrix matrix : entry.getTileMatricies()) {
                    double newRes = matrix.getXPixelSize();
                    double newDifference = Math.abs(horRes - newRes);
                    if (newDifference < difference) {
                        difference = newDifference;
                        bestMatrix = matrix;
                    }
                }
            }
            if (bestMatrix == null) {
                // pick the highest resolution, like in a geotiff with overviews
                double resolution = Double.POSITIVE_INFINITY;
                for (TileMatrix matrix : entry.getTileMatricies()) {
                    double newRes = matrix.getXPixelSize();
                    if (newRes < resolution) {
                        resolution = newRes;
                        bestMatrix = matrix;
                    }
                }
            }

            //take available tiles from database
            boundsLeftTile = file.getTileBound(entry, bestMatrix.getZoomLevel(), false, false);
            boundsRightTile = file.getTileBound(entry, bestMatrix.getZoomLevel(), true, false);
            boundsTopTile = file.getTileBound(entry, bestMatrix.getZoomLevel(), false, true);
            boundsBottomTile = file.getTileBound(entry, bestMatrix.getZoomLevel(), true, true);

            Envelope entryBounds = entry.getTileMatrixSetBounds();
            double resX = bestMatrix.getXPixelSize() * bestMatrix.getTileWidth();
            double resY = bestMatrix.getYPixelSize() * bestMatrix.getTileHeight();
            /*
             * From the specification: "The tile coordinate (0,0) always refers to the tile in the upper left corner of the tile matrix at any zoom
             * level, regardless of the actual availability of that tile."
             * So remember the y axis goes from top to bottom, not the other way around
             */
            double offsetX = entryBounds.getMinX();
            double offsetY = entryBounds.getMaxY();

            // crop tiles to requested envelope if necessary
            int leftTile, bottomTile, rightTile, topTile;
            if (requestedEnvelope != null) { 
                // the requested bounds
                final double minX = requestedEnvelope.getMinimum(0);
                final double maxX = requestedEnvelope.getMaximum(0);
                final double minY = requestedEnvelope.getMinimum(1);
                final double maxY = requestedEnvelope.getMaximum(1);

                // cannot "round" here or half a tile in the requested area might be missing
                // TODO: the code could consider if the eventual extra tile introduced by
                // floor/ceil actually contributes at least one full pixel to the output, or 
                // a significant part of it
                leftTile = (int) Math.floor((minX - offsetX) / resX);
                topTile = (int) Math.floor((offsetY - maxY) / resY);
                rightTile = (int) Math.ceil((maxX - offsetX) / resX);
                bottomTile = (int) Math.ceil((offsetY - minY) / resY);
                
                leftTile = normalizeTile(leftTile, boundsLeftTile, boundsRightTile);
                rightTile = normalizeTile(rightTile, boundsLeftTile, boundsRightTile);
                topTile = normalizeTile(topTile, boundsTopTile, boundsBottomTile);
                bottomTile = normalizeTile(bottomTile, boundsTopTile, boundsBottomTile);
            } else {
                // use the full extent of the selected tile matrix
                leftTile = boundsLeftTile;
                rightTile = boundsRightTile;
                topTile = boundsTopTile;
                bottomTile = boundsBottomTile;
            }

            int width = (int) (rightTile - leftTile + 1) * DEFAULT_TILE_SIZE;
            int height = (int) (bottomTile - topTile + 1) * DEFAULT_TILE_SIZE;

            // recalculate the envelope we are actually returning (remeber y axis is flipped)
            resultEnvelope = new ReferencedEnvelope( //
                    offsetX + leftTile * resX, // 
                    offsetX + (rightTile + 1) * resX, // 
                    offsetY - (bottomTile + 1) * resY, //
                    offsetY - topTile * resY, crs);

            try(TileReader it = file.reader(entry, bestMatrix.getZoomLevel(), bestMatrix.getZoomLevel(), leftTile, rightTile, topTile, bottomTile)) {
                /**
                 * Composing the output is harder than it seems, GeoPackage does not mandate any uniformity in tiles,
                 * they can be in different formats (a mix of PNG and JPEG) and can have different color models,
                 * thus a mix of (possibly different) palettes, gray, RGB, RGBA. GDAL in particular defaults
                 * to generate a mix of PNG and JPEG to generate the slow and large PNG format only when 
                 * transparency is actually needed 
                 */
                List<RenderedImage> sources = new ArrayList<>();
                List<RenderedImage> alphas = new ArrayList<>();
                ImageWorker iw = new ImageWorker();
                while (it.hasNext()) {                
                    Tile tile = it.next();
    
                    BufferedImage tileImage = readImage(tile.getData());
                    
                    iw.setImage(tileImage);
                    int posx = (int) (tile.getColumn() - leftTile) * DEFAULT_TILE_SIZE;
                    int posy = (int) (tile.getRow() - topTile) * DEFAULT_TILE_SIZE;
                    if(posx != 0 || posy != 0) {
                        iw.translate(posx, posy, Interpolation.getInstance(Interpolation.INTERP_NEAREST));
                        RenderedImage translated = iw.getRenderedImage();
                        sources.add(translated);
                    } else {
                        sources.add(tileImage);
                    }
                }
                
                if (sources.isEmpty()) {
                    // no tiles
                    image = getStartImage(width, height);
                } else if(sources.size() == 1) {
                    // one tile
                    image = sources.get(0);
                } else {
                    // at the time of writing, only JAI-EXT mosaic can handle a mix of different 
                    // color models, we need to use it explicitly
                    final ParameterBlockJAI pb = new ParameterBlockJAI(
                            new it.geosolutions.jaiext.mosaic.MosaicDescriptor());
                    sources.forEach(s -> pb.addSource(s));
                    pb.setParameter("mosaicType", MosaicDescriptor.MOSAIC_TYPE_OVERLAY);
                    pb.setParameter("sourceAlpha", null);
                    pb.setParameter("sourceROI", null);
                    pb.setParameter("sourceThreshold", null);
                    pb.setParameter("backgroundValues", new double[] {0});
                    pb.setParameter("nodata", null);

                    image = PlanarImage.wrapRenderedImage(
                            // explicit reference here too
                            new MosaicRIF().create(pb, GeoTools.getDefaultHints()));
                }
            }
        }
        finally {
            file.close();
        }
        return coverageFactory.create(entry.getTableName(), image, resultEnvelope);
    }

