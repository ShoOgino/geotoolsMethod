	/**
	 * Reads an image from a source stream. Loads an image from a source stream,
	 * then loads the values from the world file and constructs a new
	 * GridCoverage from this information. When reading from a remote stream we
	 * do not look for a world fiel but we suppose those information comes from
	 * a different way (xml, gml, pigeon?)
	 * 
	 * @param params
	 *            WorldImageReader supports no parameters, it just ignores them.
	 * 
	 * @return a new GridCoverage read from the source.
	 * 
	 * @throws IllegalArgumentException
	 *             DOCUMENT ME!
	 * @throws IOException
	 *             DOCUMENT ME!
	 */
	public GridCoverage2D read(GeneralParameterValue[] params)
			throws IllegalArgumentException, IOException {

		// /////////////////////////////////////////////////////////////////////
		//
		// do we have parameters to use for reading from the specified source
		//
		// /////////////////////////////////////////////////////////////////////
		GeneralEnvelope requestedEnvelope = null;
		Rectangle dim = null;
		OverviewPolicy overviewPolicy=null;
		if (params != null) {
			// /////////////////////////////////////////////////////////////////////
			//
			// Checking params
			//
			// /////////////////////////////////////////////////////////////////////
			if (params != null) {
				for (int i = 0; i < params.length; i++) {
					final ParameterValue param = (ParameterValue) params[i];
					final String name = param.getDescriptor().getName().getCode();
					if (name.equals(
							AbstractGridFormat.READ_GRIDGEOMETRY2D.getName()
									.toString())) {
						final GridGeometry2D gg = (GridGeometry2D) param
								.getValue();
						requestedEnvelope = new GeneralEnvelope((Envelope) gg
								.getEnvelope2D());
						dim = gg.getGridRange2D().getBounds();
						continue;
					}
					if (name.equals(AbstractGridFormat.OVERVIEW_POLICY
							.getName().toString())) {
						overviewPolicy=(OverviewPolicy) param.getValue();
						continue;
					}					
				}
			}
		}
		// /////////////////////////////////////////////////////////////////////
		//
		// set params
		//
		// /////////////////////////////////////////////////////////////////////
		Integer imageChoice = new Integer(0);
		final ImageReadParam readP = new ImageReadParam();
		if (!wmsRequest) {
			try {
				imageChoice = setReadParams(overviewPolicy,readP, requestedEnvelope, dim);
			} catch (TransformException e) {
				new DataSourceException(e);
			}
		}
		// /////////////////////////////////////////////////////////////////////
		//
		// Reading the source layer
		//
		// /////////////////////////////////////////////////////////////////////
//		final ImageReader reader = readerSPI.createReaderInstance();
//		final ImageInputStream inStream = wmsRequest ? ImageIO
//				.createImageInputStream(((URL) source).openStream()) : ImageIO
//				.createImageInputStream(source);
//		
		final Hints newHints = (Hints) hints.clone();
//		if (!wmsRequest) {
//			reader.setInput(inStream);
//			if (!reader.isImageTiled(imageChoice.intValue())) {
//				final Dimension tileSize = ImageUtilities
//						.toTileSize(new Dimension(reader.getWidth(imageChoice
//								.intValue()), reader.getHeight(imageChoice
//								.intValue())));
//				final ImageLayout layout = new ImageLayout();
//				layout.setTileGridXOffset(0);
//				layout.setTileGridYOffset(0);
//				layout.setTileHeight(tileSize.height);
//				layout.setTileWidth(tileSize.width);
//				newHints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT, layout));
//			}
//		}
//		inStream.close();
		final ParameterBlock pbjRead = new ParameterBlock();
		pbjRead.add(inStreamSPI!=null?inStreamSPI.createInputStreamInstance(source, ImageIO.getUseCache(), ImageIO.getCacheDirectory()):ImageIO.createImageInputStream(source));		
//		pbjRead.add(wmsRequest ? ImageIO
//				.createImageInputStream(((URL) source).openStream()) : ImageIO
//				.createImageInputStream(source));
		pbjRead.add(imageChoice);
		pbjRead.add(Boolean.FALSE);
		pbjRead.add(Boolean.FALSE);
		pbjRead.add(Boolean.FALSE);
		pbjRead.add(null);
		pbjRead.add(null);
		pbjRead.add(readP);
		pbjRead.add(readerSPI.createReaderInstance());
		final RenderedOp coverageRaster=JAI.create("ImageRead", pbjRead,
                        (RenderingHints) newHints);

		// /////////////////////////////////////////////////////////////////////
                //
                // BUILDING COVERAGE
                //
                // /////////////////////////////////////////////////////////////////////
                // I need to calculate a new transformation (raster2Model)
                // between the cropped image and the required
                // adjustedRequestEnvelope
                final int ssWidth = coverageRaster.getWidth();
                final int ssHeight = coverageRaster.getHeight();
                if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.log(Level.FINE, "Coverage read: width = " + ssWidth
                                        + " height = " + ssHeight);
                }
        
                // //
                //
                // setting new coefficients to define a new affineTransformation
                // to be applied to the grid to world transformation
                // -----------------------------------------------------------------------------------
                //
                // With respect to the original envelope, the obtained planarImage
                // needs to be rescaled. The scaling factors are computed as the
                // ratio between the cropped source region sizes and the read
                // image sizes.
                //
                // //
                final double scaleX = originalGridRange.getSpan(0) / (1.0 * ssWidth);
                final double scaleY = originalGridRange.getSpan(1) / (1.0 * ssHeight);
                final AffineTransform tempRaster2Model = new AffineTransform((AffineTransform) raster2Model);
                tempRaster2Model.concatenate(new AffineTransform(scaleX, 0, 0, scaleY, 0, 0));
                return createImageCoverage(coverageRaster, ProjectiveTransform.create((AffineTransform) tempRaster2Model));


	}

