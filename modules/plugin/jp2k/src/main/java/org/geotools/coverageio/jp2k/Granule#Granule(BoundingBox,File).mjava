	public Granule(BoundingBox granuleBBOX, File granuleFile) {
		super();
		this.granuleBBOX = ReferencedEnvelope.reference(granuleBBOX);
		this.granuleFile = granuleFile;
		
		// create the base grid to world transformation
		ImageInputStream inStream = null;
		ImageReader reader = null;
		try {
			//
			//get info about the raster we have to read
			//
			
			// get a stream
			inStream = Utils.getInputStream(granuleFile);
			if(inStream == null)
				throw new IllegalArgumentException("Unable to get an input stream for the provided file "+granuleFile.getAbsolutePath());
			
			// get a reader and try to cache the relevant SPI
			if (cachedSPI == null){
				reader = Utils.getReader( inStream);
				if (reader != null)
					cachedSPI = reader.getOriginatingProvider();
			}
			else
				reader = cachedSPI.createReaderInstance();
			if(reader == null)
				throw new IllegalArgumentException("Unable to get an ImageReader for the provided file "+granuleFile.getAbsolutePath());
			
			//get selected level and base level dimensions
			final Rectangle originalDimension = Utils.getDimension(0,inStream, reader);
			
			// build the g2W for this tile, in principle we should get it
			// somehow from the tile itself or from the index, but at the moment
			// we do not have such info, hence we assume that it is a simple
			// scale and translate
			final GridToEnvelopeMapper geMapper= new GridToEnvelopeMapper(
					new GridEnvelope2D(originalDimension), granuleBBOX);
			geMapper.setPixelAnchor(PixelInCell.CELL_CENTER);//this is the default behavior but it is nice to write it down anyway
			this.baseGridToWorld = geMapper.createAffineTransform();
			
			// add the base level
			this.granuleLevels.put(Integer.valueOf(0), new Level(1, 1, originalDimension.width, originalDimension.height));

		} catch (IllegalStateException e) {
			throw new IllegalArgumentException(e);
			
		} catch (IOException e) {
			throw new IllegalArgumentException(e);
		} 
		finally{
			try{
				if(inStream != null)
					inStream.close();
			}
			catch (Throwable e) {
				throw new IllegalArgumentException(e);
			}
			finally{
				if(reader != null)
					reader.dispose();
			}
		}	
	}

