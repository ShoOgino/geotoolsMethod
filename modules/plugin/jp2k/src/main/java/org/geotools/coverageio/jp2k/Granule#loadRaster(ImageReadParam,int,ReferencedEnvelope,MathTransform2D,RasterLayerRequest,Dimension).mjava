	public RenderedImage loadRaster(
			final ImageReadParam readParameters,
			final int imageIndex, 
			final ReferencedEnvelope cropBBox,
			final MathTransform2D worldToGrid,
			final RasterLayerRequest request,
			final Dimension tileDimension) throws IOException {
		
		if (LOGGER.isLoggable(java.util.logging.Level.FINE))
			LOGGER.fine("Loading raster data for granule "+this.toString());

		final ReferencedEnvelope bbox= new ReferencedEnvelope(granuleBBOX);
		// intersection of this tile bound with the current crop bbox
		final ReferencedEnvelope intersection = new ReferencedEnvelope(bbox.intersection(cropBBox), cropBBox.getCoordinateReferenceSystem());

		ImageInputStream inStream=null;
		ImageReader reader=null;
		try {
			//
			//get info about the raster we have to read
			//
			
			// get a stream
			inStream = Utils.getInputStream(granuleFile);
			if(inStream==null)
				return null;
	
			// get a reader and try to cache the relevant SPI
			if(cachedSPI==null){
				reader = Utils.getReader( inStream);
				if(reader!=null)
					cachedSPI=reader.getOriginatingProvider();
			}
			else
				reader=cachedSPI.createReaderInstance();
			if(reader==null)
			{
				if (LOGGER.isLoggable(java.util.logging.Level.WARNING))
					LOGGER.warning("Unable to get reader for granule "+this.toString()+ " with request "+request.toString());
				return null;
			}
			
			//get selected level and base level dimensions
			final Level selectedlevel= getLevel(imageIndex);
	
			
			// now create the crop grid to world which can be used to decide
			// which source area we need to crop in the selected level taking
			// into account the scale factors imposed by the selection of this
			// level together with the base level grid to world transformation
			MathTransform2D cropWorldToGrid=(MathTransform2D) PixelTranslation.translate(ProjectiveTransform.create(selectedlevel.gridToWorldTransform), PixelInCell.CELL_CENTER, PixelInCell.CELL_CORNER).inverse();		
			
			// computing the crop source area which leaves straight into the
			// selected level raster space, NOTICE that at the end we need to
			// take into account the fact that we might also decimate therefore
			// we cannot just use the crop grid to world but we need to correct
			// it.
			final Rectangle sourceArea = CRS.transform(cropWorldToGrid, new GeneralEnvelope(intersection)).toRectangle2D().getBounds();
			XRectangle2D.intersect(sourceArea, selectedlevel.rasterDimensions, sourceArea);//make sure roundings don't bother us
			// is it empty??
			if (sourceArea.isEmpty()) {
				if (LOGGER.isLoggable(java.util.logging.Level.FINE))
					LOGGER.fine("Got empty area for granule "+this.toString()+ " with request "+request.toString());
				return null;

			} else if (LOGGER.isLoggable(java.util.logging.Level.FINE))
				LOGGER.fine((new StringBuffer("Loading level ").append(
						imageIndex).append(" with source region ").append(
						sourceArea).toString()));
			final int ssx = readParameters.getSourceXSubsampling();
			final int ssy = readParameters.getSourceYSubsampling();
			final int newSubSamplingFactor = ImageIOUtilities.getSubSamplingFactor2(ssx,ssy);
			if (newSubSamplingFactor != 0){
				readParameters.setSourceSubsampling(newSubSamplingFactor, newSubSamplingFactor,0,0);
			}
			
			// set the source region
			readParameters.setSourceRegion(sourceArea);
			final RenderedImage raster;
			try{
				// read
				raster= request.getReadType().read(readParameters,imageIndex, granuleFile, selectedlevel.rasterDimensions,tileDimension,cachedSPI);
				if (raster == null)
					return null;
			}
			catch (Throwable e) {
				if(LOGGER.isLoggable(java.util.logging.Level.FINE))
					LOGGER.log(java.util.logging.Level.FINE,"Unable to load raster for granule "+this.toString()+ " with request "+request.toString(),e);
				return null;
			}

			// use fixed source area
			sourceArea.setRect(readParameters.getSourceRegion());

			//
			// setting new coefficients to define a new affineTransformation
			// to be applied to the grid to world transformation
			// -----------------------------------------------------------------------------------
			// With respect to the original envelope, the obtained planarImage
			// needs to be rescaled. The scaling factors are computed as the
			// ratio between the cropped source region sizes and the read
			// image sizes.
			//
			// place it in the dest image using the coords created above;
			double decimationScaleX = ((1.0 * sourceArea.width) / raster.getWidth());
			double decimationScaleY = ((1.0 * sourceArea.height) / raster.getHeight());
			final AffineTransform decimationScaleTranform = XAffineTransform.getScaleInstance(decimationScaleX, decimationScaleY);

			// keep into account translation  to work into the selected level raster space
			final AffineTransform afterDecimationTranslateTranform = XAffineTransform.getTranslateInstance(sourceArea.x, sourceArea.y);

			// now we need to go back to the base level raster space
			final AffineTransform backToBaseLevelScaleTransform = selectedlevel.baseToLevelTransform;
			
			// now create the overall transform
			final AffineTransform finalRaster2Model = new AffineTransform(baseGridToWorld);
			finalRaster2Model.concatenate(CoverageUtilities.CENTER_TO_CORNER);
			if(!XAffineTransform.isIdentity(backToBaseLevelScaleTransform,EPS))
				finalRaster2Model.concatenate(backToBaseLevelScaleTransform);
			if(!XAffineTransform.isIdentity(afterDecimationTranslateTranform,EPS))
				finalRaster2Model.concatenate(afterDecimationTranslateTranform);
			if(!XAffineTransform.isIdentity(decimationScaleTranform,EPS))
				finalRaster2Model.concatenate(decimationScaleTranform);

			// keep into account translation factors to place this tile
			finalRaster2Model.preConcatenate((AffineTransform) worldToGrid);
			
			final InterpolationNearest nearest = new InterpolationNearest();
			//paranoiac check to avoid that JAI freaks out when computing its internal layouT on images that are too small
			Rectangle2D finalLayout= ImageUtilities.layoutHelper(
					raster, 
					(float)finalRaster2Model.getScaleX(), 
					(float)finalRaster2Model.getScaleY(), 
					(float)finalRaster2Model.getTranslateX(), 
					(float)finalRaster2Model.getTranslateY(), 
					nearest);
			if(finalLayout.isEmpty()){
				if(LOGGER.isLoggable(java.util.logging.Level.FINE))
					LOGGER.fine("Unable to create a granule " + this.toString()+ " due to jai scale bug");
				return null;
			}

			// apply the affine transform  conserving indexed color model
			final RenderingHints localHints = new RenderingHints(JAI.KEY_REPLACE_INDEX_COLOR_MODEL, Boolean.FALSE);
			if(XAffineTransform.isIdentity(finalRaster2Model,10E-6))
				return raster;
			else
			{
				//
				// In case we are asked to use certain tile dimensions we tile
				// also at this stage in case the read type is Direct since
				// buffered images comes up untiled and this can affect the
				// performances of the subsequent affine operation.
				//
				final Dimension tileDimensions=request.getTileDimensions();
				if(tileDimensions!=null&&request.getReadType().equals(ReadType.DIRECT_READ))
				{
					final ImageLayout layout = new ImageLayout();
					layout.setTileHeight(tileDimensions.width).setTileWidth(tileDimensions.height);
					localHints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT,layout));
				}
				return AffineDescriptor.create(raster, finalRaster2Model, nearest, null, localHints);
			}
		
		} catch (IllegalStateException e) {
			if (LOGGER.isLoggable(java.util.logging.Level.WARNING))
				LOGGER.log(java.util.logging.Level.WARNING, "Unable to load raster for granule "+this.toString()+ " with request "+request.toString(), e);
			return null;
		} 
		catch (org.opengis.referencing.operation.NoninvertibleTransformException e) {
			if (LOGGER.isLoggable(java.util.logging.Level.WARNING))
				LOGGER.log(java.util.logging.Level.WARNING, "Unable to load raster for granule "+this.toString()+ " with request "+request.toString(), e);
			return null;
		} catch (TransformException e) {
			if (LOGGER.isLoggable(java.util.logging.Level.WARNING))
				LOGGER.log(java.util.logging.Level.WARNING, "Unable to load raster for granule "+this.toString()+ " with request "+request.toString(), e);
			return null;
		} 
		finally{
			try{
				if(inStream!=null)
					inStream.close();
			}
			finally{
				if(reader!=null)
					reader.dispose();
			}
		}
	}

