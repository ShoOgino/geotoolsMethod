    @SuppressWarnings("PMD.UseTryWithResources") // the image input stream might be null
    public RenderedImage loadRaster(
            final ImageReadParam readParameters,
            final int imageIndex,
            final ReferencedEnvelope cropBBox,
            final MathTransform2D worldToGrid,
            final RasterLayerRequest request,
            final Dimension tileDimension)
            throws IOException {

        if (LOGGER.isLoggable(java.util.logging.Level.FINE))
            LOGGER.fine("Loading raster data for granule " + this.toString());

        final ReferencedEnvelope bbox = new ReferencedEnvelope(granuleBBOX);
        // intersection of this tile bound with the current crop bbox
        final ReferencedEnvelope intersection =
                new ReferencedEnvelope(
                        bbox.intersection(cropBBox), cropBBox.getCoordinateReferenceSystem());

        ImageInputStream inStream = null;
        ImageReader reader = null;
        try {
            //
            // get info about the raster we have to read
            //

            // get a stream
            inStream = Utils.getInputStream(granuleFile);
            if (inStream == null) return null;

            // get a reader and try to cache the relevant SPI
            if (cachedSPI == null) {
                reader = Utils.getReader(inStream);
                if (reader != null) cachedSPI = reader.getOriginatingProvider();
            } else reader = cachedSPI.createReaderInstance();
            if (reader == null) {
                if (LOGGER.isLoggable(java.util.logging.Level.WARNING))
                    LOGGER.warning(
                            "Unable to get reader for granule "
                                    + this.toString()
                                    + " with request "
                                    + request.toString());
                return null;
            }

            // get selected level and base level dimensions
            final Level selectedlevel = getLevel(imageIndex);

            // now create the crop grid to world which can be used to decide
            // which source area we need to crop in the selected level taking
            // into account the scale factors imposed by the selection of this
            // level together with the base level grid to world transformation
            MathTransform2D cropWorldToGrid =
                    (MathTransform2D)
                            PixelTranslation.translate(
                                            ProjectiveTransform.create(
                                                    selectedlevel.gridToWorldTransform),
                                            PixelInCell.CELL_CENTER,
                                            PixelInCell.CELL_CORNER)
                                    .inverse();

            // computing the crop source area which leaves straight into the
            // selected level raster space, NOTICE that at the end we need to
            // take into account the fact that we might also decimate therefore
            // we cannot just use the crop grid to world but we need to correct
            // it.
            final Rectangle sourceArea =
                    CRS.transform(cropWorldToGrid, new GeneralEnvelope(intersection))
                            .toRectangle2D()
                            .getBounds();
            XRectangle2D.intersect(
                    sourceArea,
                    selectedlevel.rasterDimensions,
                    sourceArea); // make sure roundings don't bother us
            // is it empty??
            if (sourceArea.isEmpty()) {
                if (LOGGER.isLoggable(java.util.logging.Level.FINE))
                    LOGGER.fine(
                            "Got empty area for granule "
                                    + this.toString()
                                    + " with request "
                                    + request.toString());
                return null;

            } else if (LOGGER.isLoggable(java.util.logging.Level.FINE))
                LOGGER.fine(
                        (new StringBuffer("Loading level ")
                                .append(imageIndex)
                                .append(" with source region ")
                                .append(sourceArea)
                                .toString()));
            final int ssx = readParameters.getSourceXSubsampling();
            final int ssy = readParameters.getSourceYSubsampling();
            final int newSubSamplingFactor = ImageIOUtilities.getSubSamplingFactor2(ssx, ssy);
            if (newSubSamplingFactor != 0) {
                readParameters.setSourceSubsampling(
                        newSubSamplingFactor, newSubSamplingFactor, 0, 0);
            }

            // set the source region
            readParameters.setSourceRegion(sourceArea);
            final RenderedImage raster;
            try {
                // read
                raster =
                        request.getReadType()
                                .read(
                                        readParameters,
                                        imageIndex,
                                        granuleFile,
                                        selectedlevel.rasterDimensions,
                                        tileDimension,
                                        cachedSPI);
                if (raster == null) return null;
            } catch (Throwable e) {
                if (LOGGER.isLoggable(java.util.logging.Level.FINE))
                    LOGGER.log(
                            java.util.logging.Level.FINE,
                            "Unable to load raster for granule "
                                    + this.toString()
                                    + " with request "
                                    + request.toString(),
                            e);
                return null;
            }

            // use fixed source area
            sourceArea.setRect(readParameters.getSourceRegion());

            //
            // setting new coefficients to define a new affineTransformation
            // to be applied to the grid to world transformation
            // -----------------------------------------------------------------------------------
            // With respect to the original envelope, the obtained planarImage
            // needs to be rescaled. The scaling factors are computed as the
            // ratio between the cropped source region sizes and the read
            // image sizes.
            //
            // place it in the dest image using the coords created above;
            double decimationScaleX = ((1.0 * sourceArea.width) / raster.getWidth());
            double decimationScaleY = ((1.0 * sourceArea.height) / raster.getHeight());
            final AffineTransform decimationScaleTranform =
                    XAffineTransform.getScaleInstance(decimationScaleX, decimationScaleY);

            // keep into account translation  to work into the selected level raster space
            final AffineTransform afterDecimationTranslateTranform =
                    XAffineTransform.getTranslateInstance(sourceArea.x, sourceArea.y);

            // now we need to go back to the base level raster space
            final AffineTransform backToBaseLevelScaleTransform =
                    selectedlevel.baseToLevelTransform;

            // now create the overall transform
            final AffineTransform finalRaster2Model = new AffineTransform(baseGridToWorld);
            finalRaster2Model.concatenate(CoverageUtilities.CENTER_TO_CORNER);
            if (!XAffineTransform.isIdentity(backToBaseLevelScaleTransform, EPS))
                finalRaster2Model.concatenate(backToBaseLevelScaleTransform);
            if (!XAffineTransform.isIdentity(afterDecimationTranslateTranform, EPS))
                finalRaster2Model.concatenate(afterDecimationTranslateTranform);
            if (!XAffineTransform.isIdentity(decimationScaleTranform, EPS))
                finalRaster2Model.concatenate(decimationScaleTranform);

            // keep into account translation factors to place this tile
            finalRaster2Model.preConcatenate((AffineTransform) worldToGrid);

            final InterpolationNearest nearest = new InterpolationNearest();
            // paranoiac check to avoid that JAI freaks out when computing its internal layouT on
            // images that are too small
            Rectangle2D finalLayout =
                    ImageUtilities.layoutHelper(
                            raster,
                            (float) finalRaster2Model.getScaleX(),
                            (float) finalRaster2Model.getScaleY(),
                            (float) finalRaster2Model.getTranslateX(),
                            (float) finalRaster2Model.getTranslateY(),
                            nearest);
            if (finalLayout.isEmpty()) {
                if (LOGGER.isLoggable(java.util.logging.Level.FINE))
                    LOGGER.fine(
                            "Unable to create a granule "
                                    + this.toString()
                                    + " due to jai scale bug");
                return null;
            }

            // apply the affine transform  conserving indexed color model
            final RenderingHints localHints =
                    new RenderingHints(JAI.KEY_REPLACE_INDEX_COLOR_MODEL, Boolean.FALSE);
            if (XAffineTransform.isIdentity(finalRaster2Model, 10E-6)) return raster;
            else {
                //
                // In case we are asked to use certain tile dimensions we tile
                // also at this stage in case the read type is Direct since
                // buffered images comes up untiled and this can affect the
                // performances of the subsequent affine operation.
                //
                final Dimension tileDimensions = request.getTileDimensions();
                if (tileDimensions != null && request.getReadType().equals(ReadType.DIRECT_READ)) {
                    final ImageLayout layout = new ImageLayout();
                    layout.setTileHeight(tileDimensions.width).setTileWidth(tileDimensions.height);
                    localHints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT, layout));
                }
                ImageWorker worker = new ImageWorker(raster).setRenderingHints(localHints);
                worker.affine(finalRaster2Model, nearest, null);
                return worker.getRenderedImage();
            }
        } catch (IllegalStateException | TransformException e) {
            if (LOGGER.isLoggable(java.util.logging.Level.WARNING))
                LOGGER.log(
                        java.util.logging.Level.WARNING,
                        "Unable to load raster for granule "
                                + this.toString()
                                + " with request "
                                + request.toString(),
                        e);
            return null;
        } finally {
            try {
                if (inStream != null) inStream.close();
            } finally {
                if (reader != null) reader.dispose();
            }
        }
    }

