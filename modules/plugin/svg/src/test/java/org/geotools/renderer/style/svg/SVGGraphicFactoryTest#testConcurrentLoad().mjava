    @Test
    public void testConcurrentLoad() throws Exception {
        URL url = SVGGraphicFactory.class.getResource("gradient.svg");
        Assert.assertNotNull(url);
        Literal expression = ff.literal(url);

        // create N threads and have them load the same SVG over a graphic factory. Do it a number
        // of times with a new factory and a clear cache, trying to make sure the run was not just
        // a lucky one
        int THREADS = Runtime.getRuntime().availableProcessors();
        ExecutorService executorService = Executors.newFixedThreadPool(THREADS);
        for (int i = 0; i < 50; i++) {
            // check that we are going to load the same path just once
            AtomicInteger counter = new AtomicInteger();
            SVGGraphicFactory svg =
                    new SVGGraphicFactory() {
                        @Override
                        protected RenderableSVG toRenderableSVG(String svgfile, URL svgUrl)
                                throws SAXException, IOException {
                            int value = counter.incrementAndGet();
                            Assert.assertEquals(1, value);
                            return super.toRenderableSVG(svgfile, svgUrl);
                        }
                    };

            // if all goes well, only one thread will actually load the SVG
            List<Future<Void>> futures = new ArrayList<>();
            for (int j = 0; j < THREADS * 4; j++) {
                executorService.submit(
                        () -> {
                            Icon icon = svg.getIcon(null, expression, "image/svg", 20);
                            Assert.assertNotNull(icon);
                            Assert.assertEquals(20, icon.getIconHeight());
                            Assert.assertTrue(
                                    RenderableSVGCache.glyphCache.containsKey(url.toString()));
                            return null;
                        });
            }
            // get all
            for (Future<Void> future : futures) {
                future.get();
            }
            // clear the cache
            RenderableSVGCache.glyphCache.clear();
        }
    }

