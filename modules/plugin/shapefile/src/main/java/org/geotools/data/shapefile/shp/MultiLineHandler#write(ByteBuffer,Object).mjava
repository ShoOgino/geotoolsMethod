    public void write(ByteBuffer buffer, Object geometry) {
        MultiLineString multi = (MultiLineString) geometry;

        Envelope box = multi.getEnvelopeInternal();
        buffer.putDouble(box.getMinX());
        buffer.putDouble(box.getMinY());
        buffer.putDouble(box.getMaxX());
        buffer.putDouble(box.getMaxY());

        final int numParts = multi.getNumGeometries();
        final CoordinateSequence[] lines = new CoordinateSequence[numParts];
        final double[] zExtreame = {Double.NaN, Double.NaN};
        final int npoints = multi.getNumPoints();

        buffer.putInt(numParts);
        buffer.putInt(npoints);

        {
            int idx = 0;
            for (int i = 0; i < numParts; i++) {
                lines[i] = ((LineString) multi.getGeometryN(i)).getCoordinateSequence();
                buffer.putInt(idx);
                idx = idx + lines[i].size();
            }
        }

        for (CoordinateSequence coords : lines) {
            if (shapeType == ShapeType.ARCZ) {
                JTSUtilities.zMinMax(coords, zExtreame);
            }
            final int ncoords = coords.size();

            for (int t = 0; t < ncoords; t++) {
                buffer.putDouble(coords.getX(t));
                buffer.putDouble(coords.getY(t));
            }
        }

        if (shapeType == ShapeType.ARCZ) {
            if (Double.isNaN(zExtreame[0])) {
                buffer.putDouble(0.0);
                buffer.putDouble(0.0);
            } else {
                buffer.putDouble(zExtreame[0]);
                buffer.putDouble(zExtreame[1]);
            }

            for (final CoordinateSequence coords : lines) {
                final int ncoords = coords.size();
                double z;
                for (int t = 0; t < ncoords; t++) {
                    z = coords.getOrdinate(t, 2);
                    if (Double.isNaN(z)) {
                        buffer.putDouble(0.0);
                    } else {
                        buffer.putDouble(z);
                    }
                }
            }
        }

        // if there are M coordinates
        if (shapeType == ShapeType.ARCZ || shapeType == ShapeType.ARCM) {
            // get M values list
            List<Double> mvalues = new ArrayList<>();
            for (int t = 0, tt = multi.getNumGeometries(); t < tt; t++) {
                LineString line = (LineString) multi.getGeometryN(t);
                CoordinateSequence seq = line.getCoordinateSequence();
                for (int i = 0; i < seq.size(); i++) {
                    mvalues.add(line.getCoordinateSequence().getM(i));
                }
            }

            // min, max
            buffer.putDouble(mvalues.stream().min(Double::compare).get());
            buffer.putDouble(mvalues.stream().max(Double::compare).get());
            // encode all M values
            mvalues.forEach(
                    x -> {
                        buffer.putDouble(x);
                    });
        }
    }

