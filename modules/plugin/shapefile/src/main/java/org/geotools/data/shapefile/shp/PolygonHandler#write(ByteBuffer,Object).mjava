    @Override
    public void write(ByteBuffer buffer, Object geometry) {
        MultiPolygon multi;

        if (geometry instanceof MultiPolygon) {
            multi = (MultiPolygon) geometry;
        } else {
            multi = geometryFactory.createMultiPolygon(new Polygon[] {(Polygon) geometry});
        }

        Envelope box = multi.getEnvelopeInternal();
        buffer.putDouble(box.getMinX());
        buffer.putDouble(box.getMinY());
        buffer.putDouble(box.getMaxX());
        buffer.putDouble(box.getMaxY());

        // need to find the total number of rings and points
        final int nrings;
        final CoordinateSequence[] coordinates;
        {
            List<CoordinateSequence> allCoords = new ArrayList<>();
            for (int t = 0; t < multi.getNumGeometries(); t++) {
                Polygon p = (Polygon) multi.getGeometryN(t);
                allCoords.add(p.getExteriorRing().getCoordinateSequence());
                for (int ringN = 0; ringN < p.getNumInteriorRing(); ringN++) {
                    allCoords.add(p.getInteriorRingN(ringN).getCoordinateSequence());
                }
            }
            coordinates = allCoords.toArray(new CoordinateSequence[allCoords.size()]);
            nrings = coordinates.length;
        }

        final int npoints = multi.getNumPoints();

        buffer.putInt(nrings);
        buffer.putInt(npoints);

        int count = 0;
        for (int t = 0; t < nrings; t++) {
            buffer.putInt(count);
            count = count + coordinates[t].size();
        }

        final double[] zExtreame = {Double.NaN, Double.NaN};

        // write out points here!.. and gather up min and max z values
        for (int ringN = 0; ringN < nrings; ringN++) {
            CoordinateSequence coords = coordinates[ringN];

            JTSUtilities.zMinMax(coords, zExtreame);

            final int seqSize = coords.size();
            for (int coordN = 0; coordN < seqSize; coordN++) {
                buffer.putDouble(coords.getOrdinate(coordN, 0));
                buffer.putDouble(coords.getOrdinate(coordN, 1));
            }
        }

        if (shapeType == ShapeType.POLYGONZ) {
            // z
            if (Double.isNaN(zExtreame[0])) {
                buffer.putDouble(0.0);
                buffer.putDouble(0.0);
            } else {
                buffer.putDouble(zExtreame[0]);
                buffer.putDouble(zExtreame[1]);
            }

            for (int ringN = 0; ringN < nrings; ringN++) {
                CoordinateSequence coords = coordinates[ringN];

                final int seqSize = coords.size();
                double z;
                for (int coordN = 0; coordN < seqSize; coordN++) {
                    z = coords.getOrdinate(coordN, 2);
                    if (Double.isNaN(z)) {
                        buffer.putDouble(0.0);
                    } else {
                        buffer.putDouble(z);
                    }
                }
            }
        }

        if (shapeType == ShapeType.POLYGONM || shapeType == ShapeType.POLYGONZ) {
            // obtain all M values
            List<Double> values = new ArrayList<>();
            for (int ringN = 0; ringN < nrings; ringN++) {
                CoordinateSequence coords = coordinates[ringN];
                final int seqSize = coords.size();
                double m;
                for (int coordN = 0; coordN < seqSize; coordN++) {
                    m = coords.getM(coordN);
                    values.add(m);
                }
            }

            // m min
            double edge = values.stream().min(Double::compare).get();
            buffer.putDouble(!Double.isNaN(edge) ? edge : -10E40);
            // m max
            edge = values.stream().max(Double::compare).get();
            buffer.putDouble(!Double.isNaN(edge) ? edge : -10E40);

            // m values
            values.forEach(
                    x -> {
                        buffer.putDouble(Double.isNaN(x) ? -10E40 : x);
                    });
        }
    }

