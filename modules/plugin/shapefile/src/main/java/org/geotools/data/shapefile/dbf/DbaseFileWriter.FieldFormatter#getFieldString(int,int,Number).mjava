        public String getFieldString(int size, int decimalPlaces, Number n) {
            buffer.delete(0, buffer.length());

            if (n != null) {
                double dval = n.doubleValue();

                /* DecimalFormat documentation:
                 * NaN is formatted as a string, which typically has a single character \uFFFD.
                 * This string is determined by the DecimalFormatSymbols object.
                 * This is the only value for which the prefixes and suffixes are not used.
                 *
                 * Infinity is formatted as a string, which typically has a single character \u221E,
                 * with the positive or negative prefixes and suffixes applied.
                 * The infinity string is determined by the DecimalFormatSymbols object.
                 */
                /* However, the Double.toString method returns an ascii string, which is more ESRI-friendly */
                if (Double.isNaN(dval) || Double.isInfinite(dval)) {
                    buffer.append(n.toString());
                    /* Should we use toString for integral numbers as well? */
                } else {

                    numFormat.setMaximumFractionDigits(decimalPlaces);
                    numFormat.setMinimumFractionDigits(decimalPlaces);
                    FieldPosition fp = new FieldPosition(NumberFormat.FRACTION_FIELD);
                    numFormat.format(n, buffer, fp);

                    // large-magnitude numbers may overflow the field size in non-exponent notation,
                    // so do a safety check and fall back to native representation to preserve value
                    if (fp.getBeginIndex() >= size) {
                        buffer.delete(0, buffer.length());
                        buffer.append(n.toString());
                        if (buffer.length() > size) {
                            // we have a grevious problem -- the value does not fit in the required
                            // size.
                            logger.logp(
                                    Level.WARNING,
                                    this.getClass().getName(),
                                    "getFieldString",
                                    "Writing DBF data, value {0} cannot be represented in size {1,number}",
                                    new Object[] {n, size});
                            if (!swallowFieldSizeErrors) {
                                // rather than truncate, and corrupt the data, we throw a Runtime
                                throw new IllegalArgumentException(
                                        "Value " + n + " cannot be represented in size " + size);
                            }
                        }
                    }
                }
            }

            int diff = size - buffer.length();
            if (diff > 0) {
                buffer.insert(0, emptyString.substring(0, diff));
            } else if (diff < 0) {
                buffer.setLength(size);
            }
            return buffer.toString();
        }

