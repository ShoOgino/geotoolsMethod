    public Object read(ByteBuffer buffer, ShapeType type, boolean flatFeature) {
        if (type == ShapeType.NULL) {
            return createNull();
        }
        // bounds
        ((Buffer) buffer).position(buffer.position() + 4 * 8);

        int[] partOffsets;

        int numParts = buffer.getInt();
        int numPoints = buffer.getInt();
        int dimensions = (shapeType == ShapeType.POLYGONZ) && !flatFeature ? 3 : 2;

        partOffsets = new int[numParts];

        for (int i = 0; i < numParts; i++) {
            partOffsets[i] = buffer.getInt();
        }

        ArrayList<LinearRing> shells = new ArrayList<>();
        ArrayList<LinearRing> holes = new ArrayList<>();
        CoordinateSequence coords = readCoordinates(buffer, numPoints, dimensions, flatFeature);

        int offset = 0;
        int start;
        int finish;
        int length;

        for (int part = 0; part < numParts; part++) {
            start = partOffsets[part];

            if (part == (numParts - 1)) {
                finish = numPoints;
            } else {
                finish = partOffsets[part + 1];
            }

            length = finish - start;
            int close = 0; // '1' if the ring must be closed, '0' otherwise
            if ((coords.getOrdinate(start, CoordinateSequence.X)
                            != coords.getOrdinate(finish - 1, CoordinateSequence.X))
                    || (coords.getOrdinate(start, CoordinateSequence.Y)
                            != coords.getOrdinate(finish - 1, CoordinateSequence.Y))) {
                close = 1;
            }
            if (dimensions == 3 && !coords.hasM()) {
                if (coords.getOrdinate(start, CoordinateSequence.Z)
                        != coords.getOrdinate(finish - 1, CoordinateSequence.Z)) {
                    close = 1;
                }
            }

            CoordinateSequence csRing;

            if (coords.hasZ() && !flatFeature) {
                csRing =
                        JTS.createCS(
                                geometryFactory.getCoordinateSequenceFactory(),
                                length + close,
                                4,
                                1);
            } else if (coords.hasM() && !flatFeature) {
                csRing =
                        JTS.createCS(
                                geometryFactory.getCoordinateSequenceFactory(),
                                length + close,
                                3,
                                1);

            } else {
                csRing =
                        JTS.createCS(
                                geometryFactory.getCoordinateSequenceFactory(), length + close, 2);
            }

            // double area = 0;
            // int sx = offset;
            for (int i = 0; i < length; i++) {
                csRing.setOrdinate(
                        i, CoordinateSequence.X, coords.getOrdinate(offset, CoordinateSequence.X));
                csRing.setOrdinate(
                        i, CoordinateSequence.Y, coords.getOrdinate(offset, CoordinateSequence.Y));
                if (coords.hasZ() && !flatFeature) {
                    csRing.setOrdinate(
                            i,
                            CoordinateSequence.Z,
                            coords.getOrdinate(offset, CoordinateSequence.Z));
                }
                if (coords.hasM() && !flatFeature) {
                    csRing.setOrdinate(
                            i,
                            CoordinateSequence.M,
                            coords.getOrdinate(offset, CoordinateSequence.M));
                }
                offset++;
            }
            if (close == 1) {
                csRing.setOrdinate(
                        length,
                        CoordinateSequence.X,
                        coords.getOrdinate(start, CoordinateSequence.X));
                csRing.setOrdinate(
                        length,
                        CoordinateSequence.Y,
                        coords.getOrdinate(start, CoordinateSequence.Y));
                if (coords.hasZ() && !flatFeature) {
                    csRing.setOrdinate(
                            length,
                            CoordinateSequence.Z,
                            coords.getOrdinate(start, CoordinateSequence.Z));
                }
                if (coords.hasM() && !flatFeature) {
                    csRing.setOrdinate(
                            length,
                            CoordinateSequence.M,
                            coords.getOrdinate(start, CoordinateSequence.M));
                }
            }
            // REVISIT: polygons with only 1 or 2 points are not polygons -
            // geometryFactory will bomb so we skip if we find one.
            if (csRing.size() == 0 || csRing.size() > 3) {
                LinearRing ring = geometryFactory.createLinearRing(csRing);

                if (CoordinateSequences.isCCW(csRing)) {
                    // counter-clockwise
                    holes.add(ring);
                } else {
                    // clockwise
                    shells.add(ring);
                }
            }
        }

        // quick optimization: if there's only one shell no need to check
        // for holes inclusion
        if (shells.size() == 1) {
            return createMulti(shells.get(0), holes);
        }
        // if for some reason, there is only one hole, we just reverse it and
        // carry on.
        else if (holes.size() == 1 && shells.size() == 0) {
            return createMulti(holes.get(0));
        } else {

            // build an association between shells and holes
            final List<List<LinearRing>> holesForShells = assignHolesToShells(shells, holes);

            Geometry g = buildGeometries(shells, holes, holesForShells);

            return g;
        }
    }

