    private void fillCache() {
        indices.clear();
        ArrayList<Data> dataList = null;
        try {
            while (indices.size() < MAX_INDICES && current != null) {
                if (idIndex < current.getNumShapeIds()
                        && !current.isVisited()
                        && current.getBounds().intersects(bounds)) {
                    indices.add(current.getShapeId(idIndex));
                    idIndex++;
                } else {
                    // free the shapes id array of the current node and prepare to move to the next
                    current.setShapesId(new int[0]);
                    idIndex = 0;

                    boolean foundUnvisited = false;
                    for (int i = 0; i < current.getNumSubNodes(); i++) {
                        Node node = current.getSubNode(i);
                        if (!node.isVisited() && node.getBounds().intersects(bounds)) {
                            foundUnvisited = true;
                            parents.add(current);
                            current = node;
                            break;
                        }
                    }
                    if (!foundUnvisited) {
                        // mark as visited and free the subnodes
                        current.setVisited(true);
                        current.clean();

                        // move up to parent
                        if (parents.isEmpty()) current = null;
                        else current = parents.remove(parents.size() - 1);
                    }
                }
            }

            // sort so offset lookup is faster
            indices.sort();
            int size = indices.size();
            dataList = new ArrayList<>(size);
            for (int i = 0; i < size; i++) {
                int recno = indices.get(i);
                Data data = new Data(DATA_DEFINITION);
                data.addValue(recno + 1);
                data.addValue(Long.valueOf(indexfile.getOffsetInBytes(recno)));
                dataList.add(data);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        data = dataList.iterator();
    }

