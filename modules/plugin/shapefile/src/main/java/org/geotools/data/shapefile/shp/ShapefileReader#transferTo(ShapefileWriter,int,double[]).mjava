    /**
     * Transfer (by bytes) the data at the current record to the ShapefileWriter.
     *
     * @param bounds double array of length four for transfering the bounds into
     * @return The length of the record transfered in bytes
     */
    public int transferTo(ShapefileWriter writer, int recordNum, double[] bounds)
            throws IOException {

        ((Buffer) buffer).position(this.toBufferOffset(record.end));
        buffer.order(ByteOrder.BIG_ENDIAN);

        buffer.getInt(); // record number
        int rl = buffer.getInt();
        int mark = ((Buffer) buffer).position();
        int len = rl * 2;

        buffer.order(ByteOrder.LITTLE_ENDIAN);
        ShapeType recordType = ShapeType.forID(buffer.getInt());

        if (recordType.isMultiPoint()) {
            for (int i = 0; i < 4; i++) {
                bounds[i] = buffer.getDouble();
            }
        } else if (recordType != ShapeType.NULL) {
            bounds[0] = bounds[1] = buffer.getDouble();
            bounds[2] = bounds[3] = buffer.getDouble();
        }

        // write header to shp and shx
        headerTransfer.position(0);
        headerTransfer.putInt(recordNum).putInt(rl).position(0);
        writer.shpChannel.write(headerTransfer);
        headerTransfer.putInt(0, writer.offset).position(0);
        writer.offset += rl + 4;
        writer.shxChannel.write(headerTransfer);

        // reset to mark and limit at end of record, then write
        int oldLimit = ((Buffer) buffer).limit();
        ((Buffer) buffer).position(mark).limit(mark + len);
        writer.shpChannel.write(buffer);
        ((Buffer) buffer).limit(oldLimit);

        record.end = this.toFileOffset(((Buffer) buffer).position());
        record.number++;

        return len;
    }

