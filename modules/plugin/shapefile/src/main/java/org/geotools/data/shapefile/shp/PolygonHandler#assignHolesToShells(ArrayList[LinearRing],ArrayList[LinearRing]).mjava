    /** <b>Package private for testing</b> */
    List<List<LinearRing>> assignHolesToShells(
            final ArrayList<LinearRing> shells, final ArrayList<LinearRing> holes) {
        List<List<LinearRing>> holesForShells = getListOfLists(shells.size());

        // find homes
        for (LinearRing testRing : holes) {
            LinearRing minShell = null;
            Envelope minEnv = null;
            Envelope testEnv = testRing.getEnvelopeInternal();
            Coordinate testPt = testRing.getCoordinateN(0);
            LinearRing tryRing;

            for (LinearRing shell : shells) {
                tryRing = shell;

                Envelope tryEnv = tryRing.getEnvelopeInternal();
                if (minShell != null) {
                    minEnv = minShell.getEnvelopeInternal();
                }

                boolean isContained = false;
                Coordinate[] coordList = tryRing.getCoordinates();

                if (tryEnv.contains(testEnv)
                        && (RayCrossingCounter.locatePointInRing(testPt, coordList) != 2
                                || (pointInList(testPt, coordList)))) {
                    isContained = true;
                }

                // check if this new containing ring is smaller than the current
                // minimum ring
                if (isContained) {
                    if ((minShell == null) || minEnv.contains(tryEnv)) {
                        minShell = tryRing;
                    }
                }
            }

            if (minShell == null) {
                // now reverse this bad "hole" and turn it into a shell
                shells.add(testRing);
                holesForShells.add(new ArrayList<>());
            } else {
                holesForShells.get(shells.indexOf(minShell)).add(testRing);
            }
        }

        return holesForShells;
    }

