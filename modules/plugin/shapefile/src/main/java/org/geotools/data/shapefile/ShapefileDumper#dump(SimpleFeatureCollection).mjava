    /**
     * Dumps the collection into one or more shapefiles. Multiple files will be geneated when
     * the input collection contains multiple geometry types, or as the size limit for output files
     * get reached
     * 
     * @param fc The input feature collection
     * @return True if at least one feature got written, false otherwise
     * @throws IOException
     */
    public boolean dump(SimpleFeatureCollection fc) throws IOException {
        // make sure we are not trying to write out a geometryless data set
        if (fc.getSchema().getGeometryDescriptor() == null) {
            throw new DataSourceException("Cannot write geometryless shapefiles, yet "
                    + fc.getSchema() + " has no geometry field");
        }
        
        // Takes a feature collection with a generic schema and remaps it to one whose schema respects the limitations of the shapefile format
        fc = RemappingFeatureCollection.getShapefileCompatibleCollection(fc);
        SimpleFeatureType schema = fc.getSchema();

        Map<Class, StoreWriter> writers = new HashMap<Class, StoreWriter>();
        boolean featuresWritten = false;
        Class geomType = schema.getGeometryDescriptor().getType().getBinding();
        boolean multiWriter = GeometryCollection.class.equals(geomType)
                || Geometry.class.equals(geomType);
        try (SimpleFeatureIterator it = fc.features()) {
            while (it.hasNext()) {
                SimpleFeature f = it.next();

                StoreWriter storeWriter = getStoreWriter(f, writers, multiWriter);
                // try to write, the shapefile size limits could be reached
                try {
                    writeToShapefile(f, storeWriter.writer);
                } catch(ShapefileSizeException e) {
                    // make one attempt to move to the next file (just one, since
                    // we could be trying to write a feature that won't fit the size limits)
                    storeWriter.nextWriter();
                    writeToShapefile(f, storeWriter.writer);
                }
                featuresWritten = true;
            }
            
            // force writing out a empty shapefile if required
            if(!featuresWritten && emptyShapefileAllowed) {
                if(multiWriter) {
                    // force the dump of a point file
                    getStoreWriter(fc.getSchema(), writers, true, Point.class, null);
                } else {
                    getStoreWriter(fc.getSchema(), writers, false, geomType, null);
                }
            }
            
        } catch (ShapefileSizeException e) {
            throw e;
        } catch (IOException ioe) {
            LOGGER.log(Level.WARNING,
                    "Error while writing featuretype '" + schema.getTypeName() + "' to shapefile.",
                    ioe);
            throw new IOException(ioe);
        } finally {
            // close all writers, dispose all datastores, even if an exception occurs
            // during closeup (shapefile datastore will have to copy the shapefiles, that migh
            // fail in many ways)
            IOException stored = null;
            for (StoreWriter sw : writers.values()) {
                try {
                    SimpleFeatureType writerSchema = sw.dstore.getSchema();
                    sw.writer.close();
                    sw.dstore.dispose();
                    // notify subclasses that the file has been completed
                    shapefileDumped(writerSchema.getTypeName(), writerSchema);
                } catch (IOException e) {
                    stored = e;
                }
            }
            // if an exception occurred make the world aware of it
            if (stored != null) {
                throw new IOException(stored);
            }
        }
        
        

        return featuresWritten;
    }

