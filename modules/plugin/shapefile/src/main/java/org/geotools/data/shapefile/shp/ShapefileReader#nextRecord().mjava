    /**
     * Fetch the next record information.
     *
     * @return The record instance associated with this reader.
     */
    public Record nextRecord() throws IOException {

        // need to update position
        positionBufferForOffset(buffer, getNextOffset());
        if (currentShape != UNKNOWN) currentShape++;

        // record header is big endian
        buffer.order(ByteOrder.BIG_ENDIAN);

        // read shape record header
        int recordNumber = buffer.getInt();
        // silly ESRI say contentLength is in 2-byte words
        // and ByteByffer uses bytes.
        // track the record location
        int recordLength = buffer.getInt() * 2;

        if (!buffer.isReadOnly() && !useMemoryMappedBuffer) {
            // capacity is less than required for the record
            // copy the old into the newly allocated
            if (((Buffer) buffer).capacity() < recordLength + 8) {
                this.currentOffset += ((Buffer) buffer).position();
                ByteBuffer old = buffer;
                // ensure enough capacity for one more record header
                buffer = ensureCapacity(buffer, recordLength + 8, useMemoryMappedBuffer);
                buffer.put(old);
                NIOUtilities.clean(old, useMemoryMappedBuffer);
                fill(buffer, channel);
                ((Buffer) buffer).position(0);
            } else
            // remaining is less than record length
            // compact the remaining data and read again,
            // allowing enough room for one more record header
            if (((Buffer) buffer).remaining() < recordLength + 8) {
                this.currentOffset += ((Buffer) buffer).position();
                buffer.compact();
                fill(buffer, channel);
                ((Buffer) buffer).position(0);
            }
        }

        // shape record is all little endian
        buffer.order(ByteOrder.LITTLE_ENDIAN);

        // read the type, handlers don't need it
        ShapeType recordType = ShapeType.forID(buffer.getInt());

        // this usually happens if the handler logic is bunk,
        // but bad files could exist as well...
        if (recordType != ShapeType.NULL && recordType != fileShapeType) {
            throw new IllegalStateException(
                    "ShapeType changed illegally from " + fileShapeType + " to " + recordType);
        }

        // peek at bounds, then reset for handler
        // many handler's may ignore bounds reading, but we don't want to
        // second guess them...
        ((Buffer) buffer).mark();
        if (recordType.isMultiPoint()) {
            record.minX = buffer.getDouble();
            record.minY = buffer.getDouble();
            record.maxX = buffer.getDouble();
            record.maxY = buffer.getDouble();
        } else if (recordType != ShapeType.NULL) {
            record.minX = record.maxX = buffer.getDouble();
            record.minY = record.maxY = buffer.getDouble();
        }
        ((Buffer) buffer).reset();

        record.offset = record.end;
        // update all the record info.
        record.length = recordLength;
        record.type = recordType;
        record.number = recordNumber;
        // remember, we read one int already...
        record.end = this.toFileOffset(((Buffer) buffer).position()) + recordLength - 4;
        // mark this position for the reader
        record.start = ((Buffer) buffer).position();
        // clear any cached shape
        record.shape = null;

        return record;
    }

