    /**
     * Called to convert the given object to bytes.
     * 
     * @param obj
     *            The value to convert; never null.
     * @param col
     *            The column this object will be encoded into.
     * @return The bytes of a string representation of the given object in the
     *         current character encoding.
     * @throws UnsupportedEncodingException Thrown if the current charset is unsupported. 
     */
    private byte[] fieldBytes(Object obj, final int col)
            throws UnsupportedEncodingException {
        String o;
        final int fieldLen = header.getFieldLength(col);
        switch (header.getFieldType(col)) {
        case 'C':
        case 'c':
            o = formatter.getFieldString(fieldLen, obj.toString());
            break;
        case 'L':
        case 'l':
            if (obj instanceof Boolean) {
                o = ((Boolean)obj).booleanValue() ? "T" : "F";
            } else {
                o = "?";
            }
            break;
        case 'M':
        case 'G':
            o = formatter.getFieldString(fieldLen, obj.toString());
            break;
        case 'N':
        case 'n':
            // int?
            if (header.getFieldDecimalCount(col) == 0) {
                o = formatter.getFieldString(fieldLen, 0, (Number)obj);
                break;
            }
        case 'F':
        case 'f':
            o = formatter.getFieldString(fieldLen,
                    header.getFieldDecimalCount(col),
                    (Number)obj);
            break;
        case 'D':
        case 'd':
            o = formatter.getFieldString((Date)obj);
            break;
        case '@':
            o = formatter.getFieldStringDateTime((Date)obj);
            if (Boolean.getBoolean("org.geotools.shapefile.datetime")) {
                // Adding the charset to getBytes causes the output to
                // get altered for the '@: Timestamp' field.
                // And using String.getBytes returns a different array
                // in 64-bit platforms so we get chars and cast to byte
                // one element at a time.
                char[] carr = o.toCharArray();
                byte[] barr = new byte[carr.length];
                for (int i = 0; i < carr.length; i++) {
                    barr[i] = (byte)carr[i];
                }                            
                return barr;
            }
            break;   
        default:
            throw new RuntimeException("Unknown type "
                    + header.getFieldType(col));
        }

        // convert the string to bytes with the given charset.
        return o.getBytes(charset.name());
    }

