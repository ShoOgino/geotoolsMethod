    /**
     * Collect georeferencing information about this geotiff.
     * 
     * @param hints
     * @throws DataSourceException
     */
    private void getHRInfo(Hints hints) throws DataSourceException {
        ImageReader reader = null;
        ImageReader ovrReader = null;
        ImageInputStream ovrStream = null;
        try {
            // //
            //
            // Get a reader for this format
            //
            // //
            reader = READER_SPI.createReaderInstance();

            // //
            //
            // get the METADATA
            //
            // //
            inStream.mark();
            reader.setInput(inStream);
            final IIOMetadata iioMetadata = reader.getImageMetadata(0);
            final GeoTiffIIOMetadataDecoder metadata = new GeoTiffIIOMetadataDecoder(iioMetadata);
            gtcs = new GeoTiffMetadata2CRSAdapter(hints);
            
            // //
            //
            // get the CRS INFO
            //
            // //
            final Object tempCRS = this.hints.get(Hints.DEFAULT_COORDINATE_REFERENCE_SYSTEM);
            if (tempCRS != null) {
                this.crs = (CoordinateReferenceSystem) tempCRS;
                if (LOGGER.isLoggable(Level.FINE))
                    LOGGER.log(Level.FINE, "Using forced coordinate reference system");
            } else {
            	
            	// check external prj first
            	crs = getCRS(source);
                                
            	// now, if we did not want to override the inner CRS or we did not have any external PRJ at hand
            	// let's look inside the geotiff
                if (!OVERRIDE_INNER_CRS || crs==null){
                	if(metadata.hasGeoKey()&& gtcs != null){
                	    crs = gtcs.createCoordinateSystem(metadata);
                	}
                }


            }

            // 
            // No data
            //
            if (metadata.hasNoData()){
                noData = metadata.getNoData();
            }
            
            // 
            // parse and set layout
            // 
            setLayout(reader);
            
            // //
            //
            // get the dimension of the hr image and build the model as well as
            // computing the resolution
            // //
            numOverviews = reader.getNumImages(true) - 1;
            int hrWidth = reader.getWidth(0);
            int hrHeight = reader.getHeight(0);
            final Rectangle actualDim = new Rectangle(0, 0, hrWidth, hrHeight);
            originalGridRange = new GridEnvelope2D(actualDim);

            if (gtcs != null&& metadata!=null&& (metadata.hasModelTrasformation()||(metadata.hasPixelScales()&&metadata.hasTiePoints()))) {
                this.raster2Model = GeoTiffMetadata2CRSAdapter.getRasterToModel(metadata);
            } else {
                this.raster2Model = parseWorldFile(source);
                if (raster2Model == null) {
                    MapInfoFileReader mifReader = parseMapInfoFile(source);
                    raster2Model = mifReader.getTransform();
                    crs = mifReader.getCRS();
                }
            }
            
            if (crs == null){
                if(LOGGER.isLoggable(Level.WARNING)){
                    LOGGER.warning("Coordinate Reference System is not available");
                }
                crs = AbstractGridFormat.getDefaultCRS();
            }

            if (this.raster2Model == null) {
                throw new DataSourceException("Raster to Model Transformation is not available");
            }

            // create envelope using corner transformation
            final AffineTransform tempTransform = new AffineTransform(
                    (AffineTransform) raster2Model);
            tempTransform.concatenate(CoverageUtilities.CENTER_TO_CORNER);
            originalEnvelope = CRS.transform(ProjectiveTransform.create(tempTransform),
                    new GeneralEnvelope(actualDim));
            originalEnvelope.setCoordinateReferenceSystem(crs);

            // ///
            // 
            // setting the higher resolution available for this coverage
            //
            // ///
            highestRes = new double[2];
            highestRes[0] = XAffineTransform.getScaleX0(tempTransform);
            highestRes[1] = XAffineTransform.getScaleY0(tempTransform);

            if (ovrInStreamSPI != null) {
                ovrReader = READER_SPI.createReaderInstance();
                ovrStream = ovrInStreamSPI.createInputStreamInstance(ovrSource,
                        ImageIO.getUseCache(), ImageIO.getCacheDirectory());
                ovrReader.setInput(ovrStream);
                // this includes the real image as this is a image index, we need to add one.
                extOvrImgChoice = numOverviews + 1;
                numOverviews = numOverviews + ovrReader.getNumImages(true);
                if (numOverviews < extOvrImgChoice)
                    extOvrImgChoice = -1;
            }
            
            
            // //
            //
            // get information for the successive images
            //
            // //
            if (numOverviews >= 1) {
                overViewResolutions = new double[numOverviews][2];
                // Internal overviews start at 1, so lastInternalOverview matches numOverviews if no
                // external.
                int firstExternalOverview = extOvrImgChoice == -1 ? numOverviews : extOvrImgChoice - 1;
                double spanRes0 = highestRes[0] * this.originalGridRange.getSpan(0);
                double spanRes1 = highestRes[1] * this.originalGridRange.getSpan(1);
                for (int i = 0; i < firstExternalOverview; i++) {
                    overViewResolutions[i][0] = spanRes0 / reader.getWidth(i + 1);
                    overViewResolutions[i][1] = spanRes1 / reader.getHeight(i + 1);
                }
                for (int i = firstExternalOverview; i < numOverviews; i++) {
                    overViewResolutions[i][0] = spanRes0 / ovrReader.getWidth(i - firstExternalOverview);
                    overViewResolutions[i][1] = spanRes1 / ovrReader.getHeight(i - firstExternalOverview);
                }
               
            } else
                overViewResolutions = null;
        } catch (Throwable e) {
            throw new DataSourceException(e);
        } finally {
            if (reader != null)
                try {
                    reader.dispose();
                } catch (Throwable t) {
                }
                
            if (ovrReader != null)
                try {
                    ovrReader.dispose();
                } catch (Throwable t) {
                }

            if (ovrStream != null)
                try {
                    ovrStream.close();
                } catch (Throwable t) {
                }

            if (inStream != null)
                try {
                    inStream.reset();
                } catch (Throwable t) {
                }

        }
    }

