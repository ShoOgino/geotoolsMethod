    /**
     * Currently, we only accept files, and we open the file to verify that it has a GeoKeyDirectory
     * tag. If anything more subtle is wrong with the file, we deal with that when we try and read
     * it.
     *
     * @param o the source object to test for compatibility with this format.
     * @return true if "o" is a File or a URL that points to a GeoTiff with a GeoTiff file as a
     *     resource.
     */
    @Override
    @SuppressWarnings("PMD.CloseResource") // might need to close, or not, conditional
    public boolean accepts(Object o, Hints hints) {

        if (o == null) {
            return false;
        }
        ImageReader reader = null;
        ImageInputStream inputStream = null;
        boolean closeMe = true;
        try {
            if (o instanceof URL) {
                // /////////////////////////////////////////////////////////////
                //
                // URL management
                // In case the URL points to a file we need to get to the fie
                // directly and avoid caching. In case it points to http or ftp
                // or it is an opnen stream we have very small to do and we need
                // to enable caching.
                //
                // /////////////////////////////////////////////////////////////
                final URL url = (URL) o;
                o = URLs.urlToFile(url);
            } else if (o instanceof ImageInputStream) {
                closeMe = false;
            }
            // get a stream
            inputStream =
                    (ImageInputStream)
                            ((o instanceof ImageInputStream)
                                    ? o
                                    : ImageIO.createImageInputStream(o));
            if (inputStream == null) {
                if (LOGGER.isLoggable(Level.FINE)) LOGGER.fine("Unable to get an ImageInputStream");
                return false;
            }

            // get a reader
            if (!IMAGEIO_READER_FACTORY.canDecodeInput(inputStream)) return false;
            reader = IMAGEIO_READER_FACTORY.createReaderInstance();

            inputStream.mark();
            reader.setInput(inputStream);
            final IIOMetadata metadata = reader.getImageMetadata(0);
            if (metadata == null) return false;
            //
            // parse metadata and be resilient with CRS
            //
            final GeoTiffIIOMetadataDecoder metadataAdapter =
                    new GeoTiffIIOMetadataDecoder(metadata);
            if (!metadataAdapter.hasGeoKey() && LOGGER.isLoggable(Level.FINE))
                LOGGER.fine("Unable to find geokey directory for this tif file");

            //
            // analyze georeferencing
            //
            // do we have verything as geotiff?
            if (metadataAdapter.hasModelTrasformation()
                    || (metadataAdapter.hasPixelScales() && metadataAdapter.hasTiePoints()))
                return true;

            // now look for info into a WLD file or TAB file
            MathTransform raster2Model = GeoTiffReader.parseWorldFile(o);
            if (raster2Model == null) {
                MapInfoFileReader mif = GeoTiffReader.parseMapInfoFile(o);
                if (mif != null) {
                    raster2Model = mif.getTransform();
                }
            }
            if (raster2Model != null) {
                return true;
            } else {
                // see if we have GCPs at least
                TiePoint[] modelTiePoints = metadataAdapter.getModelTiePoints();
                if (modelTiePoints != null && modelTiePoints.length > 1) {
                    return true;
                }

                if (LOGGER.isLoggable(Level.FINE))
                    LOGGER.fine("Unable to find georeferencing for this tif file");
                return false;
            }

        } catch (Throwable e) {
            if (LOGGER.isLoggable(Level.FINE)) LOGGER.log(Level.FINE, e.getLocalizedMessage(), e);
            return false;
        } finally {
            if (reader != null) {
                try {
                    reader.dispose();
                } catch (Exception e) {

                }
            }
            if (closeMe && inputStream != null) {
                try {
                    inputStream.close();
                } catch (Throwable t) {

                }
            }
        }
    }

