    /*
     * (non-Javadoc)
     *
     * @see org.opengis.coverage.grid.GridCoverageWriter#write(org.opengis.coverage.grid.GridCoverage,
     *      org.opengis.parameter.GeneralParameterValue[])
     */
    @SuppressWarnings("rawtypes")
    public void write(final GridCoverage gc, final GeneralParameterValue[] params)
            throws IllegalArgumentException, IOException, IndexOutOfBoundsException {

        GeoToolsWriteParams gtParams = null;
        boolean writeTfw = GeoTiffFormat.WRITE_TFW.getDefaultValue();
        ProgressListener listener = null;
        boolean retainAxesOrder = false;
        boolean writeNodata = GeoTiffFormat.WRITE_NODATA.getDefaultValue();
        if (params != null) {
            // /////////////////////////////////////////////////////////////////////
            //
            // Checking params
            //
            // /////////////////////////////////////////////////////////////////////
            if (params != null) {
                Parameter<?> param;
                final int length = params.length;
                for (int i = 0; i < length; i++) {
                    param = (Parameter) params[i];
                    final ReferenceIdentifier name = param.getDescriptor().getName();
                    if (name.equals(AbstractGridFormat.GEOTOOLS_WRITE_PARAMS.getName())) {
                        gtParams = (GeoToolsWriteParams) param.getValue();
                        continue;
                    }
                    if (name.equals(GeoTiffFormat.WRITE_TFW.getName())) {
                        writeTfw = (Boolean) param.getValue();
                        continue;
                    }
                    if (name.equals(GeoTiffFormat.PROGRESS_LISTENER.getName())) {
                        listener = (ProgressListener) param.getValue();
                        continue;
                    }
                    if (name.equals(GeoTiffFormat.RETAIN_AXES_ORDER.getName())) {
                        retainAxesOrder = (Boolean) param.getValue();
                        continue;
                    }
                    if (name.equals(GeoTiffFormat.WRITE_NODATA.getName())) {
                        writeNodata = (Boolean) param.getValue();
                        continue;
                    }
                }
            }
        }
        if (gtParams == null) gtParams = new GeoTiffWriteParams();

        //
        // getting the coordinate reference system
        //
        final GridGeometry2D gg = (GridGeometry2D) gc.getGridGeometry();
        GridEnvelope2D range = gg.getGridRange2D();
        final Rectangle sourceRegion = gtParams.getSourceRegion();
        if (sourceRegion != null) {
            range = new GridEnvelope2D(sourceRegion);
        }
        final AffineTransform tr = (AffineTransform) gg.getGridToCRS2D();
        final CoordinateReferenceSystem crs = gg.getCoordinateReferenceSystem2D();

        //
        // we handle just projected and geographic crs
        //
        if (!(crs instanceof ProjectedCRS || crs instanceof GeographicCRS)) {
            throw new GeoTiffException(
                    null,
                    "The supplied grid coverage uses an unsupported crs! You are allowed to use only projected and geographic coordinate reference systems",
                    null);
        }

        // creating geotiff metadata
        final CRS2GeoTiffMetadataAdapter adapter = new CRS2GeoTiffMetadataAdapter(crs);
        final GeoTiffIIOMetadataEncoder metadata = adapter.parseCoordinateReferenceSystem();

        // setting georeferencing
        setGeoReference(crs, metadata, tr, range, retainAxesOrder);

        // handling noData
        final double inNoData = CoverageUtilities.getBackgroundValues((GridCoverage2D) gc)[0];
        if (!Double.isNaN(inNoData) && writeNodata) {
            metadata.setNoData(inNoData);
        }
        if (metadataKeyValue != null && !metadataKeyValue.isEmpty()) {
            metadata.setTiffTagsMetadata(metadataKeyValue);
        }

        //
        // write image
        //
        writeImage(
                ((GridCoverage2D) gc).getRenderedImage(),
                this.outStream,
                metadata,
                gtParams,
                listener);

        //
        // write tfw
        //
        if (writeTfw && (destination instanceof File)) {
            handleTFW(gc, tr);
        }
    }

