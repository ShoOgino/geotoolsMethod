	/**
	 * Testing {@link GeoTiffWriter} capabilities to write a cropped coverage.
	 * 
	 * @throws IllegalArgumentException
	 * @throws IOException
	 * @throws UnsupportedOperationException
	 * @throws ParseException
	 * @throws FactoryException
	 * @throws TransformException
	 */
	@Test
//	    @Ignore
	public void testWriteCroppedCoverage() throws IllegalArgumentException,
			IOException, UnsupportedOperationException, ParseException,
			FactoryException, TransformException {


		// /////////////////////////////////////////////////////////////////////
		//
		// Look for the original coverage that we want to crop.
		//
		// /////////////////////////////////////////////////////////////////////
		final File readdir = TestData.file(GeoTiffWriterTest.class, "");
		final File writedir = new File(new StringBuilder(readdir.getAbsolutePath()).append("/testWriter/").toString());
		writedir.mkdir();
		final File tiff = new File(readdir, "latlon.tiff");
		assert tiff.exists() && tiff.canRead() && tiff.isFile();
		if (TestData.isInteractiveTest())
			LOGGER.info(tiff.getAbsolutePath());

		// /////////////////////////////////////////////////////////////////////
		//
		// Create format and reader
		//
		// /////////////////////////////////////////////////////////////////////
		final GeoTiffFormat format = new GeoTiffFormat();
		// getting a reader
		GridCoverageReader reader = format.getReader(tiff);
		assertNotNull(reader);

		// /////////////////////////////////////////////////////////////////////
		//
		// Play with metadata
		//
		// /////////////////////////////////////////////////////////////////////
		IIOMetadataDumper metadataDumper = new IIOMetadataDumper(((GeoTiffReader) reader).getMetadata().getRootNode());
		if (TestData.isInteractiveTest()) {
			LOGGER.info(metadataDumper.getMetadata());
		} else
			metadataDumper.getMetadata();

		// /////////////////////////////////////////////////////////////////////
		//
		// Read the original coverage.
		//
		// /////////////////////////////////////////////////////////////////////
		GridCoverage2D gc = (GridCoverage2D) reader.read(null);
		if (TestData.isInteractiveTest()) {
			LOGGER.info(new StringBuilder("Coverage before: ").append("\n")
					.append(gc.getCoordinateReferenceSystem().toWKT()).append(
							gc.getEnvelope().toString()).toString());
		}
		final CoordinateReferenceSystem sourceCRS = gc.getCoordinateReferenceSystem2D();
		final GeneralEnvelope sourceEnvelope = (GeneralEnvelope) gc.getEnvelope();
		final GridGeometry2D sourcedGG = (GridGeometry2D) gc.getGridGeometry();
		final MathTransform sourceG2W = sourcedGG.getGridToCRS(PixelInCell.CELL_CENTER);

		// /////////////////////////////////////////////////////////////////////
		//
		//
		// CROP
		//
		//
		// /////////////////////////////////////////////////////////////////////

		// /////////////////////////////////////////////////////////////////////
		//
		// Crop the original coverage.
		//
		// /////////////////////////////////////////////////////////////////////
		double xc = sourceEnvelope.getMedian(0);
		double yc = sourceEnvelope.getMedian(1);
		double xl = sourceEnvelope.getSpan(0);
		double yl = sourceEnvelope.getSpan(1);
		final GeneralEnvelope cropEnvelope = new GeneralEnvelope(new double[] {
				xc - xl / 4.0, yc - yl / 4.0 }, new double[] { xc + xl / 4.0,
				yc + yl / 4.0 });
		final CoverageProcessor processor = CoverageProcessor.getInstance();
		final ParameterValueGroup param = processor
				.getOperation("CoverageCrop").getParameters();
		param.parameter("Source").setValue(gc);
		param.parameter("Envelope").setValue(cropEnvelope);
		final GridCoverage2D cropped = (GridCoverage2D) processor.doOperation(param);

		// /////////////////////////////////////////////////////////////////////
		//
		// Check that we got everything correctly after the crop.
		//
		// /////////////////////////////////////////////////////////////////////
		// checking the ranges of the output image.
		final GridGeometry2D croppedGG = (GridGeometry2D) cropped.getGridGeometry();
		final GridEnvelope croppedGR = croppedGG.getGridRange();
		final MathTransform croppedG2W = croppedGG.getGridToCRS(PixelInCell.CELL_CENTER);
		final GeneralEnvelope croppedEnvelope = (GeneralEnvelope) cropped.getEnvelope();
		assertTrue("min x do not match after crop", 29 == croppedGR.getLow(0));
		assertTrue("min y do not match after crop", 30 == croppedGR.getLow(1));
		assertTrue("max x do not match after crop", 90 == croppedGR.getHigh(0)+1);
		assertTrue("max y do not match after crop", 91 == croppedGR.getHigh(1)+1);
		// check that the affine transform are the same thing
		assertTrue(
				"The Grdi2World tranformations of the original and the cropped covearage do not match",
				sourceG2W.equals(croppedG2W));
		// check that the envelope is correct
		final GeneralEnvelope expectedEnvelope = new GeneralEnvelope(croppedGR,PixelInCell.CELL_CENTER, croppedG2W, cropped.getCoordinateReferenceSystem2D());
		assertTrue("Expected envelope is different from the computed one",expectedEnvelope.equals(croppedEnvelope, XAffineTransform.getScale((AffineTransform) croppedG2W) / 2.0, false));

		//release things
		cropped.dispose(true);
		gc.dispose(true);
		try{
			if(reader!=null)
				reader.dispose();
		}catch (Throwable e) {
		}
		// /////////////////////////////////////////////////////////////////////
		//
		//
		// WRITING AND TESTING
		//
		//
		// /////////////////////////////////////////////////////////////////////
		final File writeFile = new File(new StringBuilder(writedir.getAbsolutePath()).append(File.separatorChar).append(cropped.getName().toString()).append(".tiff").toString());
		final GridCoverageWriter writer = format.getWriter(writeFile);
		
		try{
			writer.write(cropped, null);
		}catch (IOException e) {
		}
		finally{
			try{
				writer.dispose();
			}catch (Throwable e) {
			}
		}
		try{
			reader = new GeoTiffReader(writeFile, null);
			assertNotNull(reader);
			gc = (GridCoverage2D) reader.read(null);
			assertNotNull(gc);
			final CoordinateReferenceSystem targetCRS = gc.getCoordinateReferenceSystem2D();
			assertTrue(
					"Source and Target coordinate reference systems do not match",
					CRS.equalsIgnoreMetadata(sourceCRS, targetCRS));
			assertEquals("Read-back and Cropped envelopes do not match", cropped
					.getEnvelope(), croppedEnvelope);
	
			if (TestData.isInteractiveTest()) {
				LOGGER.info(new StringBuilder("Coverage after: ").append("\n")
						.append(gc.getCoordinateReferenceSystem().toWKT()).append(
								gc.getEnvelope().toString()).toString());
				if (TestData.isInteractiveTest())
					gc.show();
				else
					PlanarImage.wrapRenderedImage(gc.getRenderedImage()).getTiles();
	
			}
		}finally{
			try{
				if(reader!=null)
					reader.dispose();
			}catch (Throwable e) {
			}
			
			if(!TestData.isInteractiveTest())
				gc.dispose(true);
		}
	}

