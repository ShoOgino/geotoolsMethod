    /**
     * This method creates the GridCoverage2D from the underlying file.
     *
     * @param requestedDim
     * @param readEnvelope
     * @return a GridCoverage
     * @throws java.io.IOException
     */
    private GridCoverage2D createCoverage(
            GeneralEnvelope requestedEnvelope,
            Rectangle requestedDim,
            OverviewPolicy overviewPolicy)
            throws IOException {

        if (!closeMe) {

            inStream.reset();
            inStream.mark();
        }
        // /////////////////////////////////////////////////////////////////////
        //
        // Doing an image read for reading the coverage.
        //
        // /////////////////////////////////////////////////////////////////////

        // //
        //
        // Setting subsampling factors with some checkings
        // 1) the subsampling factors cannot be zero
        // 2) the subsampling factors cannot be such that the w or h are zero
        //
        // //
        final ImageReadParam readP = new ImageReadParam();
        final Integer imageChoice;
        try {
            imageChoice = setReadParams(overviewPolicy, readP, requestedEnvelope, requestedDim);
        } catch (IOException e) {
            if (LOGGER.isLoggable(Level.SEVERE))
                LOGGER.log(Level.SEVERE, e.getLocalizedMessage(), e);
            return null;
        } catch (TransformException e) {
            if (LOGGER.isLoggable(Level.SEVERE))
                LOGGER.log(Level.SEVERE, e.getLocalizedMessage(), e);
            return null;
        }

        // //
        //
        // image and metadata
        //
        // //
        final ParameterBlock pbjImageRead = new ParameterBlock();
        // prepare input to handle possible parallelism between different
        // readers
        if (source instanceof File) {
            if (!gzipped) {
                if (inStreamSPI != null)
                    pbjImageRead.add(
                            inStreamSPI.createInputStreamInstance(
                                    source, ImageIO.getUseCache(), ImageIO.getCacheDirectory()));
                else pbjImageRead.add(ImageIO.createImageInputStream(source));
            } else
                pbjImageRead.add(
                        ImageIO.createImageInputStream(
                                new GZIPInputStream(new FileInputStream((File) source))));
        } else if (source instanceof ImageInputStream || source instanceof InputStream)
            pbjImageRead.add(inStream);
        else if (source instanceof URL) {
            if (gzipped)
                ImageIO.createImageInputStream(
                        new GZIPInputStream(((URL) source).openConnection().getInputStream()));
            else
                pbjImageRead.add(
                        ImageIO.createImageInputStream(
                                ((URL) source).openConnection().getInputStream()));
        }
        pbjImageRead.add(imageChoice);
        pbjImageRead.add(Boolean.FALSE);
        pbjImageRead.add(Boolean.FALSE);
        pbjImageRead.add(Boolean.FALSE);
        pbjImageRead.add(null);
        pbjImageRead.add(null);
        pbjImageRead.add(readP);
        pbjImageRead.add(readerSPI.createReaderInstance());
        final RenderedOp asciiCoverage = JAI.create("ImageRead", pbjImageRead, hints);

        // //
        //
        // Creating the coverage
        //
        // //
        try {

            // //
            //
            // Categories
            //
            //
            // //
            Unit<?> uom = null;
            final Category nan;
            if (Double.isNaN(inNoData)) {
                nan =
                        new Category(
                                Vocabulary.formatInternational(VocabularyKeys.NODATA),
                                new Color(0, 0, 0, 0),
                                Double.NaN);

            } else {
                nan =
                        new Category(
                                Vocabulary.formatInternational(VocabularyKeys.NODATA),
                                new Color[] {new Color(0, 0, 0, 0)},
                                NumberRange.create(inNoData, inNoData));
            }

            //
            // Sample dimension
            //
            final SampleModel sm = asciiCoverage.getSampleModel();
            final ColorModel cm = asciiCoverage.getColorModel();
            final ColorInterpretation colorInterpretation = TypeMap.getColorInterpretation(cm, 0);
            if (colorInterpretation == null)
                throw new IOException("Unrecognized sample dimension type");

            final GridSampleDimension band =
                    new GridSampleDimension(coverageName, new Category[] {nan}, uom);
            final Map<String, Object> properties = new HashMap<String, Object>();
            CoverageUtilities.setNoDataProperty(properties, new Double(inNoData));

            //
            // Coverage
            //
            return coverageFactory.create(
                    coverageName,
                    asciiCoverage,
                    originalEnvelope,
                    new GridSampleDimension[] {band},
                    null,
                    properties);

        } catch (NoSuchElementException e) {
            if (LOGGER.isLoggable(Level.SEVERE))
                LOGGER.log(Level.SEVERE, e.getLocalizedMessage(), e);
            throw new DataSourceException(e);
        }
    }

