    /**
     * Performs the reading of the coverage.
     *
     * <p>This method read the grass file with a special image I/O class. If the image support the
     * tiling read the data with a special operation which are written for this case. The step are:
     * <li>set the region in the world
     * <li>set the region to read in the JAI coordinate
     * <li>read the data directly with driver or, if isTiling is true, with the operation.
     * <li>verify if the image cover whole the region, if not fill the rows and columns with padding
     *     (with the Border operation)
     * <li>scale the image to return an image with the number of columns and rows equal to the
     *     requestedRegion
     * <li>set the coverage (with the transformation from the JAI coordinate to the real world
     *     coordinate.
     *
     *     <p>
     *
     * @param region the {@link JGrassRegion region}to read. If null, the map is read in its
     *     original boundary and resolution.
     * @return the {@link GridCoverage2D read coverage}.
     * @throws IOException
     */
    public GridCoverage2D readRaster(JGrassRegion region) throws IOException {
        /*
         * retrieve original map region and crs
         */
        HashMap<String, String> metaDataTable =
                ((GrassBinaryImageMetadata) imageReader.getImageMetadata(0)).toHashMap();
        double fileNorth = Double.parseDouble(metaDataTable.get(GrassBinaryImageMetadata.NORTH));
        double fileSouth = Double.parseDouble(metaDataTable.get(GrassBinaryImageMetadata.SOUTH));
        double fileEast = Double.parseDouble(metaDataTable.get(GrassBinaryImageMetadata.EAST));
        double fileWest = Double.parseDouble(metaDataTable.get(GrassBinaryImageMetadata.WEST));
        int fileRows = Integer.parseInt(metaDataTable.get(GrassBinaryImageMetadata.NROWS));
        int fileCols = Integer.parseInt(metaDataTable.get(GrassBinaryImageMetadata.NCOLS));

        CoordinateReferenceSystem crs = DefaultGeographicCRS.WGS84;
        try {
            crs = CRS.parseWKT(metaDataTable.get(GrassBinaryImageMetadata.CRS));
        } catch (FactoryException e) {
            throw new IOException(e.getLocalizedMessage());
        }
        // where to put the region to read and if use subSampling
        ImageReadParam imageReadParam = new ImageReadParam();

        /*
         * the envelope that was requested, i.e. what has to be given back in
         * terms of bounds and resolution.
         */
        Envelope requestedRegionEnvelope = null;
        /*
         * the read region, i.e. the requested region without the parts east and
         * south of the file region. (since they would produce negative origin)
         */
        Rectangle sourceRegion = null;

        int requestedRows = 0;
        int requestedCols = 0;
        double requestedWest = -1;
        double requestedEast = -1;
        double requestedSouth = -1;
        double requestedNorth = -1;
        double requestedXres = -1;
        double requestedYres = -1;

        int subSamplingX = 1;
        int subSamplingY = 1;
        // These variable are difference,in N-E coordinate, between the
        // requested region and the
        // image region.
        double xDeltaW = 0;
        double xDeltaE = 0;
        double yDeltaN = 0;
        double yDeltaS = 0;
        // this is a difference used to compute the exact region in the world in
        // order to transform
        // the SR.
        double tmpDxW = 0.0;
        double tmpDyS = 0.0;
        double tmpDyN = 0.0;
        double tmpDxE = 0.0;
        int xPaddingSx = 0;
        int yPaddingTop = 0;

        if (region != null) {
            /*
             * the user requested a particular read region. and that is exactly
             * the region we have to give back.
             */
            requestedRows = region.getRows();
            requestedCols = region.getCols();
            requestedWest = region.getWest();
            requestedEast = region.getEast();
            requestedSouth = region.getSouth();
            requestedNorth = region.getNorth();
            requestedXres = region.getWEResolution();
            requestedYres = region.getNSResolution();
            /*
             * define the raster space region
             */
            double scaleX = fileCols / (fileEast - fileWest);
            double scaleY = fileRows / (fileNorth - fileSouth);
            double EPS = 1E-7;

            // awt space seen in the world view (north is ymax)
            int xmin = (int) Math.floor((requestedWest - fileWest) * scaleX + EPS);
            int xmax = (int) Math.ceil((requestedEast - fileWest) * scaleX - EPS);
            int ymin = (int) Math.floor((fileNorth - requestedNorth) * scaleY + EPS);
            int ymax = (int) Math.ceil((fileNorth - requestedSouth) * scaleY - EPS);

            /*
             * clip away region that is west and south of the image bounds. This
             * is important because the imageio source region can't be < 0.
             * Later the clipped parts will be resolved by translation of the
             * image.
             */
            if (xmin < 0) {
                xPaddingSx = xmin;
                xmin = 0;
            }
            if (ymin < 0) {
                yPaddingTop = ymin;
                ymin = 0;
            }

            /*
             * the pixel space region that will be extracted. Since the origin
             * is always 0,0, we can continue to see this in world view.
             */
            sourceRegion = new Rectangle(xmin, ymin, (xmax - xmin), ymax - ymin);
            requestedRegionEnvelope =
                    new Envelope2D(
                            crs,
                            requestedWest,
                            requestedSouth,
                            requestedEast - requestedWest,
                            requestedNorth - requestedSouth);

            /*
             * the real world deltas
             */
            xDeltaW = requestedWest - fileWest;
            yDeltaS = requestedSouth - fileSouth;
            xDeltaE = requestedEast - fileEast;
            yDeltaN = requestedNorth - fileNorth;
            // yDelta = requestedNorth - north;

            /*
             * the real world envelope covering the read map part.
             */
            tmpDxW = xDeltaW > 0.0 ? 0.0 : xDeltaW;
            tmpDyS = yDeltaS > 0.0 ? 0.0 : yDeltaS;
            tmpDyN = yDeltaN < 0.0 ? 0.0 : yDeltaN;
            tmpDxE = xDeltaE < 0.0 ? 0.0 : xDeltaE;
            // set the region to the requestedRegion, this value is passed to
            // the coverage to
            // transform the JAI space into the real space.

            /*
             * define the subsampling values. This done starting from the
             * original's image resolution.
             */
            if (!useSubSamplingAsRequestedColsRows) {
                /*
                 * in this case we respect the original subsampling contract.
                 */
                JGrassRegion tmpRegion = new JGrassRegion(region);
                tmpRegion.setWEResolution((fileEast - fileWest) / (double) fileCols);
                tmpRegion.setNSResolution((fileNorth - fileSouth) / (double) fileRows);
                subSamplingX =
                        (int) Math.floor((double) tmpRegion.getCols() / (double) requestedCols);
                subSamplingY =
                        (int) Math.floor((double) tmpRegion.getRows() / (double) requestedRows);
                if (subSamplingX == 0) subSamplingX = 1;
                if (subSamplingY == 0) subSamplingY = 1;
                if (subSamplingX != subSamplingY) {
                    if (subSamplingX < subSamplingY) {
                        subSamplingY = subSamplingX;
                    } else {
                        subSamplingX = subSamplingY;
                    }
                }
            } else {
                /*
                 * in this case the subsampling values are interpreted as
                 * columns and row numbers to be used to calculate the
                 * resolution from the given boundaries.
                 */

                double sourceCols =
                        (requestedEast - requestedWest)
                                / (1 + (xPaddingSx / (xmax - xmin)))
                                / requestedXres;
                double sourceRows =
                        (requestedNorth - requestedSouth)
                                / (1 + (yPaddingTop / (ymax - ymin)))
                                / requestedYres;
                /*
                 * the padding has to be removed since inside the reader
                 * the padding is ignored and non present in the sourceRegion that
                 * is passed.
                 */
                sourceCols = sourceCols + xPaddingSx;
                sourceRows = sourceRows + yPaddingTop;
                subSamplingX = (int) Math.round(sourceCols);
                subSamplingY = (int) Math.round(sourceRows);

                if (subSamplingX < 1) {
                    subSamplingX = 1;
                }
                if (subSamplingY < 1) {
                    subSamplingY = 1;
                }
            }

        } else {
            /*
             * if no region has been requested, the source and requested region
             * are the same, i.e. the whole raster is read and passed.
             */
            requestedRows = fileRows;
            requestedCols = fileCols;
            requestedWest = fileWest;
            requestedEast = fileEast;
            requestedSouth = fileSouth;
            requestedNorth = fileNorth;
            double scaleX = fileCols / (fileEast - fileWest);
            double scaleY = fileRows / (fileNorth - fileSouth);
            double EPS = 1E-6;
            int xmin = (int) Math.floor((requestedWest - fileWest) * scaleX + EPS);
            int xmax = (int) Math.ceil((requestedEast - fileWest) * scaleX - EPS);
            int ymin = (int) Math.floor((fileNorth - requestedNorth) * scaleY + EPS);
            int ymax = (int) Math.ceil((fileNorth - requestedSouth) * scaleY - EPS);
            sourceRegion = new Rectangle(xmin, ymin, (xmax - xmin), ymax - ymin);
            requestedRegionEnvelope =
                    new Envelope2D(
                            crs,
                            requestedWest,
                            requestedSouth,
                            requestedEast - requestedWest,
                            requestedNorth - requestedSouth);

            /*
             * define the subsampling values. This done starting from the
             * original's image resolution.
             */
            if (!useSubSamplingAsRequestedColsRows) {
                /*
                 * in this case we respect the original subsampling contract.
                 */
                subSamplingX = 1;
                subSamplingY = 1;
            } else {
                subSamplingX = fileCols;
                subSamplingY = fileRows;
            }
        }
        if (sourceRegion.getWidth() <= 0 || sourceRegion.getHeight() <= 0) {
            return null;
        }

        // now we have enough info to create the ImageReadParam
        imageReadParam.setSourceRegion(sourceRegion);
        imageReadParam.setSourceSubsampling(subSamplingX, subSamplingY, 0, 0);
        RenderedImage finalImage = null;

        BufferedImage image =
                imageReader.read(
                        0,
                        imageReadParam,
                        useSubSamplingAsRequestedColsRows,
                        castDoubleToFloating,
                        monitor);
        imageReader.dispose();

        int imageWidth = image.getWidth();
        int imageHeight = image.getHeight();
        if (requestedSouth < fileSouth
                || requestedWest < fileWest
                || requestedEast > fileEast
                || requestedNorth > fileNorth) {
            double totalHeigth = (requestedNorth - tmpDyN) - (requestedSouth - tmpDyS);

            int xPaddingDx = 0;
            if (xDeltaE > 0) {
                xPaddingDx =
                        (int)
                                Math.round(
                                        xDeltaE
                                                * (double) imageWidth
                                                / ((requestedEast - tmpDxE)
                                                        - (requestedWest - tmpDxW)));
            }
            int yPaddingBottom = 0;
            if (yDeltaS < 0) {
                yPaddingBottom = (int) Math.round(yDeltaS * (double) imageHeight / (totalHeigth));
            }
            RenderedImage translatedImage =
                    setPadding(xPaddingSx, xPaddingDx, yPaddingTop, yPaddingBottom, image);

            if (requestedRows != imageHeight || requestedCols != imageWidth) {
                finalImage =
                        JGrassUtilities.scaleJAIImage(
                                requestedCols, requestedRows, translatedImage, interpolation);
            } else {
                finalImage = translatedImage;
            }
        } else if (requestedRows != imageHeight || requestedCols != imageWidth) {
            finalImage =
                    JGrassUtilities.scaleJAIImage(
                            requestedCols, requestedRows, image, interpolation);
        } else {
            finalImage = image;
        }

        if (finalImage instanceof RenderedOp) {
            RenderedOp rOp = (RenderedOp) finalImage;
            finalImage = rOp.getAsBufferedImage();
        }

        // set the minimum and the maximum default value in order to obtain a
        // color table.
        double min = JGrassMapEnvironment.defaultMapMin;
        double max = JGrassMapEnvironment.defaultMapMax;

        File rangeFile = jgMapEnvironment.getCELLMISC_RANGE();
        // if the file exists, read the range.
        if (rangeFile.exists()) {
            InputStream is = new FileInputStream(rangeFile);
            byte[] numbers = new byte[16];
            int testread = is.read(numbers);
            is.close();
            if (testread == 16) {
                ByteBuffer rangeBuffer = ByteBuffer.wrap(numbers);
                min = rangeBuffer.getDouble();
                max = rangeBuffer.getDouble();
            }
        }
        range = new double[] {min, max};
        // range = imageReader.getRasterReader().getRange();

        /*
         * create the categories from the color rules
         */
        GridSampleDimension band = createGridSampleDimension(metaDataTable, range);

        // create a relationship between the real region in the world and the
        // jai space. N.B. the
        // image dimension is only the real dimension which can be extract to a
        // file.
        GridToEnvelopeMapper g2eMapper = new GridToEnvelopeMapper();
        g2eMapper.setEnvelope(requestedRegionEnvelope);
        g2eMapper.setGridRange(new GridEnvelope2D(0, 0, requestedCols, requestedRows));

        g2eMapper.setPixelAnchor(cellAnchor);
        MathTransform gridToEnvelopeTransform = g2eMapper.createTransform();
        GridCoverageFactory factory =
                CoverageFactoryFinder.getGridCoverageFactory(GeoTools.getDefaultHints());

        GridCoverage2D coverage2D =
                factory.create(
                        name,
                        finalImage,
                        crs,
                        gridToEnvelopeTransform,
                        new GridSampleDimension[] {band},
                        null,
                        null);
        return coverage2D;
    }

