    /**
     * Load a specified a raster as a portion of the granule describe by this {@link DefaultGranuleDescriptor}.
     * 
     * @param imageReadParameters the {@link ImageReadParam} to use for reading.
     * @param index the index to use for the {@link ImageReader}.
     * @param cropBBox the bbox to use for cropping.
     * @param mosaicWorldToGrid the cropping grid to world transform.
     * @param request the incoming request to satisfy.
     * @param hints {@link Hints} to be used for creating this raster.
     * @return a specified a raster as a portion of the granule describe by this {@link DefaultGranuleDescriptor}.
     * @throws IOException in case an error occurs.
     */
    private RenderedImage loadRaster(final ImageReadParam imageReadParameters, final int index,
            final ReferencedEnvelope cropBBox, final MathTransform2D mosaicWorldToGrid,
            final Hints hints) throws IOException {

        if (LOGGER.isLoggable(java.util.logging.Level.FINER)) {
            final String name = Thread.currentThread().getName();
            LOGGER.finer("Thread:" + name + " Loading raster data for granuleDescriptor "
                    + this.toString());
        }
        ImageReadParam readParameters = null;
        int imageIndex;
        final ReferencedEnvelope bbox = request.spatialRequestHelper.getCoverageProperties().getBbox();

        // intersection of this tile bound with the current crop bbox
        final ReferencedEnvelope intersection = new ReferencedEnvelope(bbox.intersection(cropBBox),
                cropBBox.getCoordinateReferenceSystem());
        if (intersection.isEmpty()) {
            if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
                LOGGER.fine(new StringBuilder("Got empty intersection for granule ")
                        .append(this.toString()).append(" with request ")
                        .append(request.toString())
                        .append(" Resulting in no granule loaded: Empty result").toString());
            }
            return null;
        }
        try {

            // What about thread safety?
            
            imageIndex = index;
            readParameters = imageReadParameters;

            // now create the crop grid to world which can be used to decide
            // which source area we need to crop in the selected level taking
            // into account the scale factors imposed by the selection of this
            // level together with the base level grid to world transformation

            final AffineTransform gridToWorldTransform_ = new AffineTransform();
            gridToWorldTransform_.preConcatenate(CoverageUtilities.CENTER_TO_CORNER);
            gridToWorldTransform_.preConcatenate(baseGridToWorld);
            AffineTransform2D cropWorldToGrid = new AffineTransform2D(gridToWorldTransform_);
            cropWorldToGrid = (AffineTransform2D) cropWorldToGrid.inverse();
            // computing the crop source area which lives into the
            // selected level raster space, NOTICE that at the end we need to
            // take into account the fact that we might also decimate therefore
            // we cannot just use the crop grid to world but we need to correct
            // it.
            Rectangle sourceArea = CRS.transform(cropWorldToGrid, intersection)
                    .toRectangle2D().getBounds();
            // Selection of the source original area for cropping the computed source area 
            // (may have negative values for the approximation)
            final Rectangle initialArea = request.source.getSpatialDomain()
                    .getRasterElements(true, null).iterator().next().toRectangle();
            sourceArea = sourceArea.intersection(initialArea);

            if (sourceArea.isEmpty()) {
                if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
                    LOGGER.fine("Got empty area for granuleDescriptor " + this.toString()
                            + " with request " + request.toString()
                            + " Resulting in no granule loaded: Empty result");

                }
                return null;

            } else if (LOGGER.isLoggable(java.util.logging.Level.FINER)) {
                LOGGER.finer("Loading level " + imageIndex + " with source region: " + sourceArea
                        + " subsampling: " + readParameters.getSourceXSubsampling() + ","
                        + readParameters.getSourceYSubsampling() + " for granule:" + datasetURL);
            }

            // set the source region
            readParameters.setSourceRegion(sourceArea);
            final RenderedImage raster;
            try {
                // read
                raster = request.readType.read(readParameters, imageIndex, datasetURL,
                        request.spatialRequestHelper.getCoverageProperties().getRasterArea(),
                        request.source.reader, hints, false);

            } catch (Throwable e) {
                if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
                    LOGGER.log(java.util.logging.Level.FINE,
                            "Unable to load raster for granuleDescriptor " + this.toString()
                                    + " with request " + request.toString()
                                    + " Resulting in no granule loaded: Empty result", e);
                }
                return null;
            }

            // use fixed source area
            sourceArea.setRect(readParameters.getSourceRegion());

            //
            // setting new coefficients to define a new affineTransformation
            // to be applied to the grid to world transformation
            // -----------------------------------------------------------------------------------
            //
            // With respect to the original envelope, the obtained planarImage
            // needs to be rescaled. The scaling factors are computed as the
            // ratio between the cropped source region sizes and the read
            // image sizes.
            //
            // place it in the mosaic using the coords created above;
            double decimationScaleX = ((1.0 * sourceArea.width) / raster.getWidth());
            double decimationScaleY = ((1.0 * sourceArea.height) / raster.getHeight());
            final AffineTransform decimationScaleTranform = XAffineTransform.getScaleInstance(
                    decimationScaleX, decimationScaleY);

            // keep into account translation to work into the selected level raster space
            final AffineTransform afterDecimationTranslateTranform = XAffineTransform
                    .getTranslateInstance(sourceArea.x, sourceArea.y);

            // // now we need to go back to the base level raster space
            // final AffineTransform backToBaseLevelScaleTransform =selectedlevel.baseToLevelTransform;
            //
            // now create the overall transform
            final AffineTransform finalRaster2Model = new AffineTransform(baseGridToWorld);
            finalRaster2Model.concatenate(CoverageUtilities.CENTER_TO_CORNER);

            if (!XAffineTransform.isIdentity(afterDecimationTranslateTranform, EPS))
                finalRaster2Model.concatenate(afterDecimationTranslateTranform);
            if (!XAffineTransform.isIdentity(decimationScaleTranform, EPS))
                finalRaster2Model.concatenate(decimationScaleTranform);

            // keep into account translation factors to place this tile
            finalRaster2Model.preConcatenate((AffineTransform) mosaicWorldToGrid);

            final Interpolation interpolation = request.getInterpolation();
            // paranoiac check to avoid that JAI freaks out when computing its internal layouT on images that are too small
            Rectangle2D finalLayout = ImageUtilities.layoutHelper(raster,
                    (float) finalRaster2Model.getScaleX(), (float) finalRaster2Model.getScaleY(),
                    (float) finalRaster2Model.getTranslateX(),
                    (float) finalRaster2Model.getTranslateY(), interpolation);
            if (finalLayout.isEmpty()) {
                if (LOGGER.isLoggable(java.util.logging.Level.INFO))
                    LOGGER.info("Unable to create a granuleDescriptor " + this.toString()
                            + " due to jai scale bug creating a null source area");
                return null;
            }
            // apply the affine transform conserving indexed color model
            final RenderingHints localHints = new RenderingHints(JAI.KEY_REPLACE_INDEX_COLOR_MODEL,
                    interpolation instanceof InterpolationNearest ? Boolean.FALSE : Boolean.TRUE);
            //
            // In case we are asked to use certain tile dimensions we tile
            // also at this stage in case the read type is Direct since
            // buffered images comes up untiled and this can affect the
            // performances of the subsequent affine operation.
            //
            // final Dimension tileDimensions=request.getTileDimensions();
            // if(tileDimensions!=null&&request.getReadType().equals(ReadType.DIRECT_READ)) {
            // final ImageLayout layout = new ImageLayout();
            // layout.setTileHeight(tileDimensions.width).setTileWidth(tileDimensions.height);
            // localHints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT,layout));
            // } else {
            // if (hints != null && hints.containsKey(JAI.KEY_IMAGE_LAYOUT)) {
            // final Object layout = hints.get(JAI.KEY_IMAGE_LAYOUT);
            // if (layout != null && layout instanceof ImageLayout) {
            // localHints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT, ((ImageLayout) layout).clone()));
            // }
            // }
            // }
            if (hints != null && hints.containsKey(JAI.KEY_TILE_CACHE)) {
                final Object cache = hints.get(JAI.KEY_TILE_CACHE);
                if (cache != null && cache instanceof TileCache)
                    localHints.add(new RenderingHints(JAI.KEY_TILE_CACHE, (TileCache) cache));
            }
            if (hints != null && hints.containsKey(JAI.KEY_TILE_SCHEDULER)) {
                final Object scheduler = hints.get(JAI.KEY_TILE_SCHEDULER);
                if (scheduler != null && scheduler instanceof TileScheduler)
                    localHints.add(new RenderingHints(JAI.KEY_TILE_SCHEDULER,
                            (TileScheduler) scheduler));
            }
            boolean addBorderExtender = true;
            if (hints != null && hints.containsKey(JAI.KEY_BORDER_EXTENDER)) {
                final Object extender = hints.get(JAI.KEY_BORDER_EXTENDER);
                if (extender != null && extender instanceof BorderExtender) {
                    localHints.add(new RenderingHints(JAI.KEY_BORDER_EXTENDER,
                            (BorderExtender) extender));
                    addBorderExtender = false;
                }
            }
            // border extender
            if (addBorderExtender) {
                localHints.add(ImageUtilities.BORDER_EXTENDER_HINTS);
            }

            ImageWorker iw = new ImageWorker(raster);
            iw.setRenderingHints(localHints);
            iw.affine(finalRaster2Model, interpolation, DEFAULT_BACKGROUND_VALUES);
            return iw.getRenderedImage();

        } catch (IllegalStateException e) {
            if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                LOGGER.log(java.util.logging.Level.WARNING,
                        new StringBuilder("Unable to load raster for granuleDescriptor ")
                                .append(this.toString()).append(" with request ")
                                .append(request.toString())
                                .append(" Resulting in no granule loaded: Empty result").toString(),
                        e);
            }
            return null;
        } catch (org.opengis.referencing.operation.NoninvertibleTransformException e) {
            if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                LOGGER.log(java.util.logging.Level.WARNING,
                        new StringBuilder("Unable to load raster for granuleDescriptor ")
                                .append(this.toString()).append(" with request ")
                                .append(request.toString())
                                .append(" Resulting in no granule loaded: Empty result").toString(),
                        e);
            }
            return null;
        } catch (TransformException e) {
            if (LOGGER.isLoggable(java.util.logging.Level.WARNING)) {
                LOGGER.log(java.util.logging.Level.WARNING,
                        new StringBuilder("Unable to load raster for granuleDescriptor ")
                                .append(this.toString()).append(" with request ")
                                .append(request.toString())
                                .append(" Resulting in no granule loaded: Empty result").toString(),
                        e);
            }
            return null;

        } finally {
//            try {
//                if (request.getReadType() != ReadType.JAI_IMAGEREAD && inStream != null) {
//                    inStream.close();
//                }
//            } finally {
//                if (request.getReadType() != ReadType.JAI_IMAGEREAD && reader != null) {
//                    reader.dispose();
//                }
//            }
        }
    }

