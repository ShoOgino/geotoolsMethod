    /** @see javax.imageio.ImageReader#read(int, javax.imageio.ImageReadParam) */
    @Override
    public BufferedImage read(int imageIndex, ImageReadParam param) throws IOException {
        clearAbortRequest();

        final Slice2DIndex slice2DIndex = getSlice2DIndex(imageIndex);
        final String variableName = slice2DIndex.getVariableName();
        final VariableAdapter wrapper = getCoverageDescriptor(new NameImpl(variableName));

        // let's see if we have some extra parameters
        int[] bands = null;
        if (param instanceof EnhancedImageReadParam) {
            bands = ((EnhancedImageReadParam) param).getBands();
        }

        /*
         * Fetches the parameters that are not already processed by utility
         * methods like 'getDestination' or 'computeRegions' (invoked below).
         */
        final int strideX, strideY;
        final int[] dstBands;
        if (param != null) {
            strideX = param.getSourceXSubsampling();
            strideY = param.getSourceYSubsampling();
            dstBands = param.getDestinationBands();
        } else {
            strideX = 1;
            strideY = 1;
            dstBands = null;
        }

        /*
         * Gets the destination image of appropriate size. We create it now
         * since it is a convenient way to get the number of destination bands.
         */
        final int width = wrapper.getWidth();
        final int height = wrapper.getHeight();
        /*
         * Computes the source region (in the NetCDF file) and the destination
         * region (in the buffered image). Copies those informations into UCAR
         * Range structure.
         */
        final Rectangle srcRegion = new Rectangle();
        final Rectangle destRegion = new Rectangle();
        computeRegions(param, width, height, null, srcRegion, destRegion);

        // Flipping is needed only when the input latitude coordinate is ordered
        // from min to max
        if (georeferencing.isNeedsFlipping()) {
            flipVertically(param, height, srcRegion);
        }
        int destWidth = destRegion.x + destRegion.width;
        int destHeight = destRegion.y + destRegion.height;

        /*
         * build the ranges that need to be read from each
         * dimension based on the source region
         */
        final List<Range> ranges = new LinkedList<>();
        try {

            // Eventual ignored dimensions are at the beginning (lower index)
            // (Based on COARDS convention)
            if (!wrapper.ignoredDimensions.isEmpty()) {
                for (int i = 0; i < wrapper.ignoredDimensions.size(); i++) {
                    // Setting up range to specify ignored dimension
                    ranges.add(new Range(0, 0, 1));
                }
            }

            // add the ranges the COARDS way: (additional dims), T, Z, Y, X
            int first, index;

            // Populate (additional), T, Z in COARDS order by default
            for (int i = 0; i < slice2DIndex.getNCount(); i++) {
                first = slice2DIndex.getNIndex(i);
                if (first != -1) {
                    ranges.add(new Range(first, first, 1));
                }
            }
            // use the nDimensionindex to reorder the T, Z, additional ranges as appropriate
            // nDimensionIndex(i) corresponds to the position of the ith dimension in ranges
            for (int i = 0; i < slice2DIndex.getNCount(); i++) {
                first = slice2DIndex.getNIndex(i);
                index = wrapper.getNDimensionIndex(i);
                if (first != -1 && index != -1) {
                    ranges.set(index, new Range(first, first, 1));
                }
            }
            // Y
            first = srcRegion.y;
            int length = srcRegion.height;
            int stride = strideY;
            ranges.add(new Range(first, first + length - 1, stride));
            // X
            first = srcRegion.x;
            length = srcRegion.width;
            stride = strideX;
            ranges.add(new Range(first, first + length - 1, stride));
        } catch (InvalidRangeException e) {
            throw netcdfFailure(e);
        }

        /*
         * create the section of multidimensional array indices
         * that defines the exact data that need to be read
         * for this image index and parameters
         */
        final Section section = new Section(ranges);

        // computing the number of bands, according to COARDS convention ignored dimension are at
        // the beginning
        int numDstBands = 1;
        String candidateDimension = wrapper.variableDS.getDimensions().get(0).getFullName();
        MultipleBandsDimensionInfo multipleBands =
                ancillaryFileManager.getMultipleBandsDimensionInfo(candidateDimension);
        if (multipleBands != null) {
            // multiple bands are defined for the ignored dimension
            numDstBands = multipleBands.getNumberOfBands();
            // we need to take in account the bands parameter
            if (bands != null) {
                // let's do a quick check to see if the bands parameter values make sense
                int maxSourceBand = Arrays.stream(bands).max().getAsInt();
                if (maxSourceBand > numDstBands) {
                    throw new IllegalArgumentException(
                            "The provided source bands parameter is invalid.");
                }
                // the source bands parameter seems ok
                numDstBands = bands.length;
            }
        }

        // Setting SampleModel and ColorModel.
        SampleModel sampleModel =
                new BandedSampleModel(
                        wrapper.getSampleModel().getDataType(), destWidth, destHeight, numDstBands);
        final ColorModel colorModel = ImageIOUtilities.createColorModel(sampleModel);

        final WritableRaster raster = Raster.createWritableRaster(sampleModel, new Point(0, 0));
        Hashtable<String, Object> properties = getNoDataProperties(wrapper);
        final BufferedImage image =
                new BufferedImage(
                        colorModel, raster, colorModel.isAlphaPremultiplied(), properties);

        CoordinateSystem cs = wrapper.variableDS.getCoordinateSystems().get(0);
        CoordinateAxis axis = georeferencing.isLonLat() ? cs.getLatAxis() : cs.getYaxis();
        boolean flipYAxis = needFlipYAxis(axis);
        // Reads the requested sub-region only.
        processImageStarted(imageIndex);

        final float toPercent = 100f / numDstBands;
        final int type = raster.getSampleModel().getDataType();
        final int xmin = destRegion.x;
        final int ymin = destRegion.y;
        final int xmax = destRegion.width + xmin;
        final int ymax = destRegion.height + ymin;

        for (int zi = 0; zi < numDstBands; zi++) {
            // final int srcBand = (srcBands == null) ? zi : srcBands[zi];
            final int dstBand = (dstBands == null) ? zi : dstBands[zi];
            if (multipleBands != null) {
                try {
                    // we need to take in account the source bands parameter
                    int sourceBand = bands == null ? zi : bands[zi];
                    // since the value dimension has multiple bands we need to update the first
                    // range
                    Range range = new Range(sourceBand, sourceBand, 1);
                    // reading the dimensions values corresponding to the current band
                    section.setRange(0, range);
                } catch (InvalidRangeException exception) {
                    throw netcdfFailure(exception);
                }
            }
            final Array array = readSection(wrapper, section);
            if (flipYAxis) {
                final IndexIterator it = array.getIndexIterator();
                for (int y = ymax; --y >= ymin; ) {
                    for (int x = xmin; x < xmax; x++) {
                        switch (type) {
                            case DataBuffer.TYPE_DOUBLE:
                                {
                                    raster.setSample(x, y, dstBand, it.getDoubleNext());
                                    break;
                                }
                            case DataBuffer.TYPE_FLOAT:
                                {
                                    raster.setSample(x, y, dstBand, it.getFloatNext());
                                    break;
                                }
                            case DataBuffer.TYPE_BYTE:
                                {
                                    byte b = it.getByteNext();
                                    // int myByte = (0x000000FF & ((int) b));
                                    // short anUnsignedByte = (short) myByte;
                                    // raster.setSample(x, y, dstBand, anUnsignedByte);
                                    raster.setSample(x, y, dstBand, b);
                                    break;
                                }
                            default:
                                {
                                    raster.setSample(x, y, dstBand, it.getIntNext());
                                    break;
                                }
                        }
                    }
                }
            } else {
                switch (type) {
                    case DataBuffer.TYPE_DOUBLE:
                        {
                            DoubleBuffer doubleBuffer =
                                    array.getDataAsByteBuffer().asDoubleBuffer();
                            double[] samples = new double[destRegion.width * destRegion.height];
                            doubleBuffer.get(samples);
                            raster.setSamples(
                                    xmin,
                                    ymin,
                                    destRegion.width,
                                    destRegion.height,
                                    dstBand,
                                    samples);
                            break;
                        }
                    case DataBuffer.TYPE_FLOAT:
                        float[] samples = new float[destRegion.width * destRegion.height];
                        FloatBuffer floatBuffer = array.getDataAsByteBuffer().asFloatBuffer();
                        floatBuffer.get(samples);
                        raster.setSamples(
                                xmin, ymin, destRegion.width, destRegion.height, dstBand, samples);
                        break;
                    case DataBuffer.TYPE_BYTE:
                        // THIS ONLY WORKS FOR ONE BAND!!
                        raster.setDataElements(
                                xmin,
                                ymin,
                                destRegion.width,
                                destRegion.height,
                                array.getDataAsByteBuffer().array());
                        break;
                    case DataBuffer.TYPE_INT:
                        IntBuffer intBuffer = array.getDataAsByteBuffer().asIntBuffer();
                        int[] intSamples = new int[destRegion.width * destRegion.height];
                        intBuffer.get(intSamples);
                        raster.setSamples(
                                xmin,
                                ymin,
                                destRegion.width,
                                destRegion.height,
                                dstBand,
                                intSamples);
                        break;
                    default:
                        {
                            final IndexIterator it = array.getIndexIterator();
                            for (int y = ymin; y < ymax; y++) {
                                for (int x = xmin; x < xmax; x++) {
                                    raster.setSample(x, y, dstBand, it.getIntNext());
                                }
                            }
                            break;
                        }
                }
            }
            /*
             * Checks for abort requests after reading. It would be a waste of a
             * potentially good image (maybe the abort request occurred after we
             * just finished the reading) if we didn't implemented the
             * 'isCancel()' method. But because of the later, which is checked
             * by the NetCDF library, we can't assume that the image is
             * complete.
             */
            if (abortRequested()) {
                processReadAborted();
                return image;
            }
            /*
             * Reports progress here, not in the deeper loop, because the costly
             * part is the call to 'variable.read(...)' which can't report
             * progress. The loop that copy pixel values is fast, so reporting
             * progress there would be pointless.
             */
            processImageProgress(zi * toPercent);
        }
        processImageComplete();
        return image;
    }

