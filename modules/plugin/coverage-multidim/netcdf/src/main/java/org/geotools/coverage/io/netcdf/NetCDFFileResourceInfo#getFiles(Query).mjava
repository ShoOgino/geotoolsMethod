    @Override
    public CloseableIterator<FileGroup> getFiles(Query query) {
        // normally the different type names are actually sharing the same files, but we cannot be
        // sure, a manually setup mosaic could indeed have multiple types with different files in
        // them...
        List<CoverageSlice> fc = null;
        try {
            // WrappedCoverageSlicesCatalog share the DB. Therefore I have to deal with 
            // the location attribute 
            boolean sharedCatalog = slicesCatalog instanceof WrappedCoverageSlicesCatalog; 
            Query updatedQuery = (query != null && sharedCatalog) ? query : new Query();

            if (sharedCatalog) {
                final List<SortBy> clauses = new ArrayList<SortBy>(1);
                clauses.add(new SortByImpl(
                        FeatureUtilities.DEFAULT_FILTER_FACTORY.property(CoverageSlice.Attributes.LOCATION),
                        SortOrder.ASCENDING));
                final SortBy[] sb = clauses.toArray(new SortBy[] {});
                final boolean isSortBySupported = slicesCatalog.getQueryCapabilities(coverageName).supportsSorting(sb);
                if (isSortBySupported) {
                    updatedQuery.setSortBy(sb);
                }    
            }

            updatedQuery.setTypeName(coverageName);

            //TODO: Make sure to add different iterator for stores
            //not supporting sortBy

            // Get all the features matching the query
            fc = slicesCatalog.getGranules(updatedQuery);

            // They are already an in memory list
            return sharedCatalog ? new WrappedCoverageSlicesToFileGroupIterator(fc) : new SimpleCoverageSlicesToFileGroupIterator(fc);
        } catch (IOException ioe) {
            throw new RuntimeException(ioe);
        }
    }

