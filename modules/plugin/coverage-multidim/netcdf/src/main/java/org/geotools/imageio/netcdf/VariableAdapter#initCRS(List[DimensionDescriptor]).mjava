    /**
     * @param dimensions 
     * @return
     * @throws IllegalArgumentException
     * @throws RuntimeException
     * @throws IOException
     * @throws IllegalStateException
     */
    private List<CoordinateVariable<?>> initCRS(List<DimensionDescriptor> dimensions) throws IllegalArgumentException, RuntimeException,
            IOException, IllegalStateException {
        // from UnidataVariableAdapter        
        this.coordinateSystem = NetCDFCRSUtilities.getCoordinateSystem(variableDS);
        if (coordinateSystem == null){
            throw new IllegalArgumentException("Provided CoordinateSystem is null");
        }
        // Wrapper for the CoordinateSystem
        coordinateSystem = new CoordinateSystemAdapter(coordinateSystem);

        /*
         * Adds the axis in reverse order, because the NetCDF image reader put the last dimensions in the rendered image. Typical NetCDF convention is
         * to put axis in the (time, depth, latitude, longitude) order, which typically maps to (longitude, latitude, depth, time) order in GeoTools
         * referencing framework.
         */
        final List<CoordinateVariable<?>> otherAxes = new ArrayList<CoordinateVariable<?>>();
        int index=-1;
        for(CoordinateAxis axis :coordinateSystem.getCoordinateAxes()){
            index++;
            String fullName = axis.getFullName();
            if (NetCDFUtilities.getIgnoredDimensions().contains(fullName)) {
                ignoredDimensions.add(fullName);
                continue;
            }
            CoordinateVariable<?> cv=reader.georeferencing.getCoordinateVariable(axis.getShortName());
            if (cv == null) { 
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Unable to find a coordinate variable for " + fullName);
                }
                index--;
                continue;
            }
            switch(cv.getAxisType()){
            case Time:case RunTime:
                initTemporalDomain(cv, dimensions);
                tDimensionIndex = index;
                continue;
            case GeoZ:case Height:case Pressure:
                String axisName = cv.getName();
                if (NetCDFCRSUtilities.VERTICAL_AXIS_NAMES.contains(axisName)) {
                    initVerticalDomain(cv, dimensions);
                }else{
                    otherAxes.add(cv);
                }
                zDimensionIndex = index;
                continue;  
            case GeoX: case GeoY: case Lat: case Lon:
                // do nothing
                continue;
            default:
                otherAxes.add(cv);
            }
            
        }

        // ////
        // Creating the CoordinateReferenceSystem
        // ////
        ReferencedEnvelope bbox = reader.georeferencing.getBoundingBox(variableDS.getShortName());
        coordinateReferenceSystem = bbox.getCoordinateReferenceSystem();
        return otherAxes;
    }

