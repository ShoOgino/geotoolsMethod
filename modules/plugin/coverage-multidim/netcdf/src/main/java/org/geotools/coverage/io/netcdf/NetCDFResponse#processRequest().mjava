    /**
     * This method creates the GridCoverage2D from the underlying file given a specified envelope,
     * and a requested dimension.
     *
     * @throws java.io.IOException
     */
    private void processRequest() throws IOException {

        // is this query empty?
        if (request.spatialRequestHelper.isEmpty()) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log(Level.FINE, "Request is empty: " + request.toString());
            }
            return;
        }

        // assemble granules
        prepareParams();
        String timeFilterAttribute = null;
        String elevationFilterAttribute = null;
        CoverageReadRequest readRequest = (CoverageReadRequest) getRequest();
        RangeType rangeType = request.source.getRangeType(null);
        List<DimensionDescriptor> dimensionDescriptors = request.source.getDimensionDescriptors();
        for (DimensionDescriptor dimensionDescriptor : dimensionDescriptors) {
            if (dimensionDescriptor.getName().equalsIgnoreCase(NetCDFUtilities.ELEVATION_DIM)) {
                // TODO Update this with ranged attributes
                elevationFilterAttribute = dimensionDescriptor.getStartAttribute();
            } else if (dimensionDescriptor.getName().equalsIgnoreCase(NetCDFUtilities.TIME_DIM)) {
                // TODO Update this with ranged attributes
                timeFilterAttribute = dimensionDescriptor.getStartAttribute();
            }
        }

        // set the destination bands based on the bands parameter
        baseReadParameters.setBands(readRequest.getBands());

        Set<DateRange> temporalSubset = readRequest.getTemporalSubset();
        Set<NumberRange<Double>> verticalSubset = readRequest.getVerticalSubset();
        RangeType requestedRange = readRequest.getRangeSubset();
        Set<FieldType> fieldTypes = requestedRange.getFieldTypes();

        //
        // adding GridCoverages to the results list
        //
        // //
        Set<SampleDimension> sampleDims = null;
        for (FieldType fieldType : fieldTypes) {
            final Name name = fieldType.getName();
            sampleDims = fieldType.getSampleDimensions();
            if (rangeType != null) {
                final FieldType ft = rangeType.getFieldType(name.getLocalPart());
                if (ft != null) sampleDims = ft.getSampleDimensions();
            }
        }

        // when calculating the sample dimensions we need to take in account the bands parameter
        GridSampleDimension[] sampleDimensions =
                sampleDims != null
                        ? sampleDims.toArray(new GridSampleDimension[sampleDims.size()])
                        : new GridSampleDimension[0];
        int[] bands = readRequest.getBands();
        if (bands != null) {
            int maxBandIndex = Arrays.stream(bands).max().getAsInt();
            if (bands.length > 0 && (sampleDims == null || maxBandIndex > sampleDims.size())) {
                throw new IllegalArgumentException("Invalid bands parameter provided.");
            }
            GridSampleDimension[] updatedSampleDimensions = new GridSampleDimension[bands.length];
            for (int i = 0; i < bands.length; i++) {
                updatedSampleDimensions[i] = sampleDimensions[bands[i]];
            }
            sampleDimensions = updatedSampleDimensions;
        }

        // Forcing creation of subsets (even with a single null element)
        Set<DateRange> tempSubset = null;
        if (!temporalSubset.isEmpty()) {
            tempSubset = temporalSubset;
        } else {
            tempSubset = new HashSet<DateRange>();
            tempSubset.add(null);
        }

        Set<NumberRange<Double>> vertSubset = null;
        if (!verticalSubset.isEmpty()) {
            vertSubset = verticalSubset;
        } else {
            vertSubset = new HashSet<NumberRange<Double>>();
            vertSubset.add(null);
        }

        Map<String, Set<?>> domainsSubset = readRequest.getAdditionalDomainsSubset();
        Filter requestFilter = request.originalRequest.getFilter();
        double[] noData = null;
        if (sampleDimensions != null && sampleDimensions.length > 0) {
            GridSampleDimension sampleDimension = sampleDimensions[0];
            noData = sampleDimension.getNoDataValues();
        }

        // handling date and time
        for (DateRange timeRange : tempSubset) {
            for (NumberRange<Double> elevation : vertSubset) {

                Query query = new Query();
                // handle time and elevation
                createTimeElevationQuery(
                        timeRange,
                        elevation,
                        query,
                        requestFilter,
                        timeFilterAttribute,
                        elevationFilterAttribute);

                // handle additional params
                additionalParamsManagement(query, domainsSubset, dimensionDescriptors);

                // set query typename
                query.setTypeName(request.name);

                // handle default params
                if (timeRange == null && timeFilterAttribute != null) {
                    Query(query, timeFilterAttribute);
                }
                if (elevation == null && elevationFilterAttribute != null) {
                    Query(query, elevationFilterAttribute);
                }
                defaultParamsManagement(query, domainsSubset, dimensionDescriptors);

                // bbox
                query.setFilter(
                        FeatureUtilities.DEFAULT_FILTER_FACTORY.and(
                                query.getFilter(),
                                FeatureUtilities.DEFAULT_FILTER_FACTORY.bbox(
                                        FeatureUtilities.DEFAULT_FILTER_FACTORY.property(
                                                "the_geom"),
                                        targetBBox)));

                List<Integer> indexes = request.source.reader.getImageIndex(query);
                if (indexes == null || indexes.isEmpty()) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine(" No indexes found for this query: " + query.toString());
                    }
                    continue;
                }
                int imageIndex = indexes.get(0);
                final RenderedImage image =
                        loadRaster(
                                baseReadParameters,
                                imageIndex,
                                targetBBox,
                                finalWorldToGridCorner,
                                hints,
                                noData);

                // create the coverage
                GridCoverage2D gridCoverage = prepareCoverage(image, sampleDimensions, noData);

                // Adding coverage domain
                if (gridCoverage != null) {
                    GridCoverage gcResponse =
                            new DefaultGridCoverageResponse(gridCoverage, timeRange, elevation);
                    addResult(gcResponse);
                }
            }
        }

        // success
        setStatus(Status.SUCCESS);
    }

