    /**
     * Returns a format to use for parsing values along the specified axis type. This method is
     * invoked when parsing the date part of axis units like "<cite>days since 1990-01-01
     * 00:00:00</cite>". Subclasses should override this method if the date part is formatted in a
     * different way. The default implementation returns the following formats:
     *
     * <p>
     *
     * <ul>
     *   <li>For {@linkplain AxisType#Time time axis}, a {@link DateFormat} using the {@code
     *       "yyyy-MM-dd HH:mm:ss"} pattern in UTC {@linkplain TimeZone timezone}.
     *   <li>For all other kind of axis, a {@link NumberFormat}.
     * </ul>
     *
     * <p>The {@linkplain Locale#CANADA Canada locale} is used by default for most formats because
     * it is relatively close to ISO (for example regarding days and months order in dates) while
     * using the English symbols.
     *
     * @param type The type of the axis.
     * @param prototype An example of the values to be parsed. Implementations may parse this
     *     prototype when the axis type alone is not sufficient. For example the {@linkplain
     *     AxisType#Time time axis type} should uses the {@code "yyyy-MM-dd"} date pattern, but some
     *     files do not follow this convention and use the default local instead.
     * @return The format for parsing values along the axis.
     */
    public static Format getAxisFormat(final AxisType type, final String prototype) {
        if (!type.equals(AxisType.Time) && !(type.equals(AxisType.RunTime))) {
            return NumberFormat.getNumberInstance(Locale.CANADA);
        }
        char dateSeparator = '-'; // The separator used in ISO format.
        boolean twoDigitYear = false; // Year is two digits
        boolean yearLast = false; // Year is first in ISO pattern.
        boolean namedMonth = false; // Months are numbers in the ISO pattern.
        boolean monthFirst = false; // Month first (assumes yearLast AND namedMonth true as well)
        boolean addT = false;
        boolean appendZ = false;
        int dateLength = 0;
        if (prototype != null) {
            /*
             * Performs a quick check on the prototype content. If the prototype
             * seems to use a different date separator than the ISO one, we will
             * adjust the pattern accordingly. Also checks if the year seems to
             * appears last rather than first, and if the month seems to be
             * written using letters rather than digits.
             */
            int field = 1;
            int digitCount = 0;

            final int length = prototype.length();
            for (int i = 0; i < length; i++) {
                final char c = prototype.charAt(i);
                if (Character.isWhitespace(c)) {
                    if (monthFirst && field == 1) {
                        dateLength++; // move to next field
                    } else {
                        break; // Checks only the dates, ignore the hours.
                    }
                } else if (Character.isDigit(c)) {
                    digitCount++;
                    dateLength++;
                    continue; // Digits are legal in all cases.
                } else if (Character.isLetter(c) && field <= 2) {
                    if (field == 1) {
                        yearLast = true;
                        monthFirst = true;
                    }
                    namedMonth = true;
                    dateLength++;
                    continue; // Letters are legal for month only.
                } else if (field == 1 || monthFirst && field == 2) {
                    dateSeparator = c;
                    dateLength++;
                } else if (c == dateSeparator) {
                    dateLength++;
                } else if (c == 'T') {
                    addT = true;
                } else if (c == 'Z' && i == length - 1) {
                    appendZ = true;
                }

                if ((field == 1 || yearLast && field == 3) && digitCount <= 2) {
                    twoDigitYear = true;
                }

                digitCount = 0;
                field++;
            }
            if (digitCount >= 4) {
                yearLast = true;
                twoDigitYear = false;
            }
        }
        String pattern = null;
        if (yearLast) {
            pattern =
                    (monthFirst ? "MMM dd-" : "dd-" + (namedMonth ? "MMM-" : "MM-"))
                            + (twoDigitYear ? "yy" : "yyyy");
        } else {
            pattern = (twoDigitYear ? "yy-" : "yyyy-") + (namedMonth ? "MMM-" : "MM-") + "dd";
            if (dateLength < pattern.length()) {
                // case of truncated date
                pattern = pattern.substring(0, dateLength);
            }
        }
        pattern = pattern.replace('-', dateSeparator);
        int lastColon = prototype.lastIndexOf(":"); // $NON-NLS-1$
        if (lastColon != -1) {
            pattern += addT ? "'T'" : " ";
            pattern += prototype != null && lastColon >= 16 ? "HH:mm:ss" : "HH:mm";
        }
        // TODO: Improve me:
        // Handle timeZone
        pattern += appendZ ? "'Z'" : "";
        final DateFormat format = new SimpleDateFormat(pattern, Locale.CANADA);
        format.setTimeZone(TimeZone.getTimeZone("UTC"));
        return format;
    }

