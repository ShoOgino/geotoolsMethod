    /**
     * Constructor 
     * 
     * @param driver
     * @param source
     * @param additionalParameters
     * @param hints
     * @param listener
     * @throws IOException
     */
    @SuppressWarnings("serial")
    NetCDFAccess( Driver driver, URL source, Map<String, Serializable> additionalParameters, Hints hints,
            ProgressListener listener ) throws DataSourceException {

        super(
                driver,
                EnumSet.of(AccessType.READ_ONLY),
                new HashMap<String, Parameter< ? >>(){{put(DefaultFileDriver.URL.key, DefaultFileDriver.URL);}},
                source,
                additionalParameters);

        // get the protocol
        final String protocol = source.getProtocol();

        // file
        if (!(protocol.equalsIgnoreCase("file")||protocol.equalsIgnoreCase("http") || protocol.equalsIgnoreCase("dods"))) {
            throw new DataSourceException("Wrong protocol for URL:"+source.toExternalForm().toString());
        }
        File sourceFile = null;
        if (protocol.equalsIgnoreCase("file")){
            // convert to file
            sourceFile = DataUtilities.urlToFile(source);
            
            // check that it is a file,exists and can be at least read
            if (!sourceFile.exists() || !sourceFile.isFile() || !sourceFile.canRead()){
                throw new DataSourceException("Invalid source");            
            }
        }

        // initialize
        // get the needed info from them to set the extent
        try {
            reader = (NetCDFImageReader) NetCDFDriver.SPI.createReaderInstance();
            if (hints != null && hints.containsKey(Utils.AUXILIARY_FILES_PATH)) {
                String prefix = "";
                if (hints.containsKey(Utils.PARENT_DIR)) {
                    prefix = (String) hints.get(Utils.PARENT_DIR) + File.separatorChar;
                }
                String filePath = prefix + (String) hints.get(Utils.AUXILIARY_FILES_PATH);
                reader.setAuxiliaryFilesPath(filePath);
            }
            reader.setInput(this.source);

            if (names == null) {
                names = new ArrayList<Name>();
                final Collection<Name> originalNames = reader.getCoveragesNames();
                for (Name name : originalNames) {
                    Name coverageName = new NameImpl(/*namePrefix + */name.toString());
                    names.add(coverageName);
                }
            }
        } catch (Exception e) {
            throw new DataSourceException(e);
        }
    }

