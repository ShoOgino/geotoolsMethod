    /**
     * Index Initialization. store indexing information.
     *
     * @return
     * @throws InvalidRangeException
     * @throws IOException
     */
    protected int initIndex() throws InvalidRangeException, IOException {
        DefaultTransaction transaction =
                new DefaultTransaction("indexTransaction" + System.nanoTime());
        int numImages = 0;
        try {

            // init slice catalog
            DataStoreConfiguration datastoreConfig =
                    ancillaryFileManager.getDatastoreConfiguration();
            boolean isShared = datastoreConfig.isShared();
            initCatalog(datastoreConfig);
            final List<Variable> variables = dataset.getVariables();
            if (variables != null) {

                // cycle on all variables to get parse them
                for (final Variable var_ : variables) {
                    if (var_ != null && var_ instanceof VariableDS) {
                        final VariableDS variable = (VariableDS) var_;

                        // get the name
                        // check if it is filtered or not
                        String varName = variable.getFullName();
                        if (!ancillaryFileManager.acceptsVariable(varName)) {
                            continue;
                        }

                        // is it acceptable?
                        if (!NetCDFUtilities.isVariableAccepted(variable, checkType, dataset)) {
                            continue;
                        }

                        // COVERAGE NAME
                        // Add the accepted variable to the list of coverages name
                        final Name coverageName = getCoverageName(varName);
                        final CoordinateSystem cs =
                                NetCDFCRSUtilities.getCoordinateSystem(variable);
                        final SimpleFeatureType indexSchema =
                                getIndexSchema(coverageName, cs, isShared);
                        // get variable adapter which maps to a coverage in the end
                        final VariableAdapter vaAdapter = getCoverageDescriptor(coverageName);

                        if (indexSchema == null) {
                            throw new IllegalStateException(
                                    "Unable to created index schema for coverage:" + coverageName);
                        }
                        if (LOGGER.isLoggable(Level.FINEST)) {
                            LOGGER.finest("Collecting slices for: " + coverageName);
                        }

                        final int variableImageStartIndex = numImages;
                        final int numberOfSlices = vaAdapter.getNumberOfSlices();
                        numImages += numberOfSlices;

                        int startPagingIndex = 0;
                        final int limit = INTERNAL_INDEX_CREATION_PAGE_SIZE;
                        final ListFeatureCollection collection =
                                new ListFeatureCollection(indexSchema);

                        // features may be < slices, since some slices do not really exist
                        // but we do count them as processed
                        int processedSlices = 0;
                        while (processedSlices < numberOfSlices) {
                            // Get a bunch of features
                            processedSlices +=
                                    vaAdapter.getFeatures(startPagingIndex, limit, collection);
                            if (variableImageStartIndex != 0 || isShared) {
                                // Need to updated the imageIndex of the features since all indexes
                                // are zero based inside each variable but we need to index them
                                // inside
                                // the whole NetCDF dataset.
                                updateFeaturesIndex(collection, variableImageStartIndex, isShared);
                            }
                            final int features = collection.size();
                            if (features > 0) {
                                // adding granules to the catalog and updating the number of written
                                // features
                                CoverageSlicesCatalog catalog = getCatalog();
                                if (catalog != null) {
                                    catalog.addGranules(
                                            indexSchema.getTypeName(), collection, transaction);
                                }
                                collection.clear();
                                startPagingIndex += features;
                            }
                        }
                    }
                }
            }
            // write things to disk
            ancillaryFileManager.writeToDisk();
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Committing changes to the DB");
            }
            transaction.commit();
        } catch (Throwable e) {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Rollback");
            }
            if (transaction != null) {
                transaction.rollback();
            }
            throw new IOException(e);
        } finally {
            try {
                if (transaction != null) {
                    transaction.close();
                }
            } catch (Throwable t) {

            }
        }
        return numImages;
    }

