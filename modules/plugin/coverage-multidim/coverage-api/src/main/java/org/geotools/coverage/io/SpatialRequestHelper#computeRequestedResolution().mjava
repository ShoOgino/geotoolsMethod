    /**
     * Computes the requested resolution which is going to be used for selecting overviews and or
     * deciding decimation factors on the target coverage.
     *
     * <p>In case the requested envelope is in the same {@link CoordinateReferenceSystem} of the
     * coverage we compute the resolution using the requested {@link MathTransform}. Notice that it
     * must be a {@link LinearTransform} or else we fail.
     *
     * <p>In case the requested envelope is not in the same {@link CoordinateReferenceSystem} of the
     * coverage we
     *
     * @throws DataSourceException in case something bad happens during reprojections and/or
     *     intersections.
     */
    private void computeRequestedResolution() throws DataSourceException {

        try {

            // let's try to get the resolution from the requested gridToWorld
            if (requestedGridToWorld instanceof LinearTransform) {

                //
                // the crs of the request and the one of the coverage are NOT the
                // same and the conversion is not , we can get the resolution from envelope + raster
                // directly
                //
                if (destinationToSourceTransform != null
                        && !destinationToSourceTransform.isIdentity()) {

                    //
                    // compute the approximated resolution in the request crs, notice that we are
                    // assuming a reprojection that keeps the raster area unchanged hence
                    // the effect is a degradation of quality, but we might take that into account
                    // emprically
                    //
                    requestedResolution = null;
                    //
                    // // compute the raster that correspond to the crop bbox at the highest
                    // resolution
                    // final Rectangle sourceRasterArea = new GeneralGridEnvelope(
                    // CRS.transform(
                    // PixelTranslation.translate(rasterManager.getRaster2Model(),PixelInCell.CELL_CENTER,PixelInCell.CELL_CORNER).inverse(),
                    // cropBBox),PixelInCell.CELL_CORNER,false).toRectangle();
                    // XRectangle2D.intersect(sourceRasterArea,
                    // rasterManager.spatialDomainManager.coverageRasterArea, sourceRasterArea);
                    // if(sourceRasterArea.isEmpty())
                    // throw new DataSourceException("The request source raster area is empty");

                    final GridToEnvelopeMapper geMapper =
                            new GridToEnvelopeMapper(
                                    new GridEnvelope2D(destinationRasterArea), cropBBox);
                    final AffineTransform tempTransform = geMapper.createAffineTransform();
                    // final double scaleX=XAffineTransform.getScaleX0((AffineTransform)
                    // requestedGridToWorld)/XAffineTransform.getScaleX0(tempTransform);
                    // final double scaleY=XAffineTransform.getScaleY0((AffineTransform)
                    // requestedGridToWorld)/XAffineTransform.getScaleY0(tempTransform);
                    // //
                    // // empiric adjustment to get a finer resolution to have better quality when
                    // reprojecting
                    // // TODO make it parametric
                    // //
                    // requestedRasterScaleFactors= new double[2];
                    // requestedRasterScaleFactors[0]=scaleX*1.0;
                    // requestedRasterScaleFactors[1]=scaleY*1.0;

                    requestedResolution =
                            new double[] {
                                XAffineTransform.getScaleX0(tempTransform),
                                XAffineTransform.getScaleY0(tempTransform)
                            };

                } else {

                    // the crs of the request and the one of the coverage are the
                    // same, we can get the resolution from the grid to world
                    requestedResolution =
                            new double[] {
                                XAffineTransform.getScaleX0(requestedGridToWorld),
                                XAffineTransform.getScaleY0(requestedGridToWorld)
                            };
                }
            } else
                // should not happen
                throw new UnsupportedOperationException(
                        Errors.format(
                                ErrorKeys.UNSUPPORTED_OPERATION_$1,
                                requestedGridToWorld.toString()));

            // leave
            return;
        } catch (Throwable e) {
            if (LOGGER.isLoggable(Level.INFO))
                LOGGER.log(Level.INFO, "Unable to compute requested resolution", e);
        }

        //
        // use the coverage resolution since we cannot compute the requested one
        //
        LOGGER.log(
                Level.WARNING, "Unable to compute requested resolution, using highest available");
        requestedResolution = coverageProperties.fullResolution;
    }

