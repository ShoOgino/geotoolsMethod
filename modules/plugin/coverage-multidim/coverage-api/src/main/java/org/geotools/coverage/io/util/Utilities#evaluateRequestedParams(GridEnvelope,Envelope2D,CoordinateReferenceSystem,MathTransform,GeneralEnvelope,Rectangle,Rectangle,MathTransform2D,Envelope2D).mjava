    /**
     * Evaluates the requested envelope and builds a new adjusted version of it fitting this
     * coverage envelope.
     *
     * <p>While adjusting the requested envelope this methods also compute the source region as a
     * rectangle which is suitable for a successive read operation with {@link ImageIO} to do
     * crop-on-read.
     *
     * @param requestedEnvelope is the envelope we are requested to load.
     * @param sourceRegion represents the area to load in raster space. This parameter cannot be
     *     null since it gets filled with whatever the crop region is depending on the <code>
     *     requestedEnvelope</code>.
     * @param requestedDim is the requested region where to load data of the specified envelope.
     * @param readGridToWorld the Grid to world transformation to be used
     * @return the adjusted requested envelope, empty if no requestedEnvelope has been specified,
     *     {@code null} in case the requested envelope does not intersect the coverage envelope or
     *     in case the adjusted requested envelope is covered by a too small raster region (an empty
     *     region).
     * @throws DataSourceException in case something bad occurs
     */
    public static GeneralEnvelope evaluateRequestedParams(
            GridEnvelope originalGridRange,
            Envelope2D baseEnvelope2D,
            CoordinateReferenceSystem spatialReferenceSystem2D,
            MathTransform originalGridToWorld,
            GeneralEnvelope requestedEnvelope,
            Rectangle sourceRegion,
            Rectangle requestedDim,
            MathTransform2D readGridToWorld,
            Envelope2D wgs84BaseEnvelope2D)
            throws DataSourceException {

        GeneralEnvelope adjustedRequestedEnvelope = new GeneralEnvelope(2);
        GeneralGridEnvelope baseGridRange = (GeneralGridEnvelope) originalGridRange;

        try {
            // ////////////////////////////////////////////////////////////////
            //
            // Check if we have something to load by intersecting the
            // requested envelope with the bounds of this data set.
            //
            // ////////////////////////////////////////////////////////////////
            if (requestedEnvelope != null) {
                final GeneralEnvelope requestedEnvelope2D =
                        Utilities.getRequestedEnvelope2D(requestedEnvelope);

                // ////////////////////////////////////////////////////////////
                //
                // INTERSECT ENVELOPES AND CROP Destination REGION
                //
                // ////////////////////////////////////////////////////////////
                adjustedRequestedEnvelope =
                        Utilities.getIntersection(
                                baseEnvelope2D,
                                spatialReferenceSystem2D,
                                requestedEnvelope2D,
                                requestedDim,
                                readGridToWorld,
                                wgs84BaseEnvelope2D);
                if (adjustedRequestedEnvelope == null) return null;

                // /////////////////////////////////////////////////////////////////////
                //
                // CROP SOURCE REGION
                //
                // /////////////////////////////////////////////////////////////////////
                sourceRegion.setRect(
                        Utilities.getCropRegion(
                                adjustedRequestedEnvelope,
                                Utilities.getOriginalGridToWorld(
                                        originalGridToWorld, PixelInCell.CELL_CORNER)));
                if (sourceRegion.isEmpty()) {
                    if (LOGGER.isLoggable(Level.INFO)) {
                        LOGGER.log(
                                Level.INFO,
                                "Too small envelope resulting in empty cropped raster region");
                    }
                    return null;
                    // TODO: Future versions may define a 1x1 rectangle starting
                    // from the lower coordinate
                }
                if (!sourceRegion.intersects(baseGridRange.toRectangle()) || sourceRegion.isEmpty())
                    throw new DataSourceException("The crop region is invalid.");
                sourceRegion.setRect(sourceRegion.intersection(baseGridRange.toRectangle()));

                if (LOGGER.isLoggable(Level.FINE)) {
                    StringBuilder sb =
                            new StringBuilder("Adjusted Requested Envelope = ")
                                    .append(adjustedRequestedEnvelope.toString())
                                    .append("\n")
                                    .append("Requested raster dimension = ")
                                    .append(requestedDim.toString())
                                    .append("\n")
                                    .append("Corresponding raster source region = ")
                                    .append(sourceRegion.toString());
                    LOGGER.log(Level.FINE, sb.toString());
                }

            } else {
                // don't use the source region. Set an empty one
                sourceRegion.setBounds(new Rectangle(0, 0, Integer.MIN_VALUE, Integer.MIN_VALUE));
            }
        } catch (TransformException | FactoryException e) {
            throw new DataSourceException("Unable to create a coverage for this source", e);
        }
        return adjustedRequestedEnvelope;
    }

