    public List<CoverageSlice> getGranules(final Query q) throws IOException {
        Utilities.ensureNonNull("query", q);
        final List<CoverageSlice> returnValue = new ArrayList<CoverageSlice>();
        final Lock lock = rwLock.readLock();
        try {
            lock.lock();
            checkStore();
            final String typeName = q.getTypeName();

            //
            // Load tiles informations, especially the bounds, which will be reused
            //
            final SimpleFeatureSource featureSource = slicesIndexStore.getFeatureSource(typeName);
            if (featureSource == null) {
                throw new NullPointerException(
                        "The provided SimpleFeatureSource is null, it's impossible to create an index!");
            }
            Transaction tx = null;
            SimpleFeatureIterator it = null;
            try {

                // Transform feature stores will use an autoCommit transaction which doesn't
                // have any state. Getting the features iterator may throw an exception  
                // by interpreting a null state as a closed transaction. Therefore
                // we use a DefaultTransaction instance when dealing with stores. 
                if (featureSource instanceof FeatureStore) {
                    tx = new DefaultTransaction("getGranulesTransaction" + System.nanoTime());
                    ((FeatureStore) featureSource).setTransaction(tx);
                }
                final SimpleFeatureCollection features = featureSource.getFeatures(q);
                if (features == null) {
                    throw new NullPointerException(
                            "The provided SimpleFeatureCollection is null, it's impossible to create an index!");
                }

                // load the feature from the underlying datastore as needed
                it = features.features();
                if (it == null) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine("The provided SimpleFeatureCollection returned a null iterator, it's impossible to create an index!");
                    }
                    return Collections.emptyList();
                }
                if (!it.hasNext()) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine("The provided SimpleFeatureCollection is empty, it's impossible to create an index!");
                    }
                    return Collections.emptyList();
                }
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Index Loaded");
                }

                // getting the features
                while (it.hasNext()) {
                    SimpleFeature feature = it.next();
                    final SimpleFeature sf = (SimpleFeature) feature;
                    final CoverageSlice slice;

                    // caching by granule's index
                    synchronized (coverageSliceDescriptorsCache) {
                        Integer granuleIndex = (Integer) sf.getAttribute(IMAGE_INDEX_ATTR);
                        if (coverageSliceDescriptorsCache.containsKey(granuleIndex)) {
                            slice = coverageSliceDescriptorsCache.get(granuleIndex);
                        } else {
                            // create the granule coverageDescriptor
                            slice = new CoverageSlice(sf);
                            coverageSliceDescriptorsCache.put(granuleIndex, slice);
                        }
                    }
                    returnValue.add(slice);
                }
            } finally {
                if (it != null) {
                    it.close();
                }

                if (tx != null) {
                    tx.close();
                }
            }
            // return
            return returnValue;
        } catch (Throwable e) {
            final IOException ioe = new IOException();
            ioe.initCause(e);
            throw ioe;
        } finally {
            lock.unlock();
        }
    }

