    /**
     * Evaluates the requested envelope and builds a new adjusted version of it
     * fitting this coverage envelope.
     * 
     * <p>
     * While adjusting the requested envelope this methods also compute the
     * source region as a rectangle which is suitable for a successive read
     * operation with {@link ImageIO} to do crop-on-read.
     * 
     * 
     * @param requestedBBox
     *                is the envelope we are requested to load.
     * @param sourceRasterArea
     *                represents the area to load in raster space. This
     *                parameter cannot be null since it gets filled with
     *                whatever the crop region is depending on the
     *                <code>requestedEnvelope</code>.
     * @param requestedRasterArea
     *                is the requested region where to load data of the
     *                specified envelope.
     * @param readGridToWorld
     *                the Grid to world transformation to be used
     * @return the adjusted requested envelope, empty if no requestedEnvelope
     *         has been specified, {@code null} in case the requested envelope
     *         does not intersect the coverage envelope or in case the adjusted
     *         requested envelope is covered by a too small raster region (an
     *         empty region).
     * 
     * @throws DataSourceException
     *                 in case something bad occurs
     */
    private void prepareRequestResponseSpatialElements()
            throws DataSourceException {
        try {
            // ////////////////////////////////////////////////////////////////
            //
            // DO WE HAVE A REQUESTED AREA?
        	//
        	// Check if we have something to load by intersecting the
            // requested envelope with the bounds of this data set.
            //
            // ////////////////////////////////////////////////////////////////
            if (requestedBBox != null) {


                // ////////////////////////////////////////////////////////////
                //
                // ADJUST ENVELOPES AND RASTER REQUESTED AREA to fall withing the coverage bbox
                //
                // ////////////////////////////////////////////////////////////
                adjustRequestedBBox();
                if (requestedBBox == null||requestedBBox.isEmpty())
                {	  	
                    if (LOGGER.isLoggable(Level.FINE)) 
                        LOGGER.log(Level.FINE, "RequestedBBox empty or null");
                	//this means that we do not have anything to load at all!
                    emptyRequest=true;
                    return;
                }

                // /////////////////////////////////////////////////////////////////////
                //
                // CROP SOURCE REGION using the refined requested envelope
                //
                // /////////////////////////////////////////////////////////////////////
                coverageRequestedRasterArea.setRect(getCropRegion());
                if (coverageRequestedRasterArea.isEmpty()) 
                {
                    if (LOGGER.isLoggable(Level.FINE)) 
                        LOGGER.log(Level.FINE, "Requested envelope too small resulting in empty cropped raster region");
                    // TODO: Future versions may define a 1x1 rectangle starting
                    // from the lower coordinate
                    emptyRequest=true;
	                return;
	            }
                if (!coverageRequestedRasterArea.intersects(coverageRasterArea))
                    throw new DataSourceException("The crop region is invalid.");
                XRectangle2D.intersect(coverageRequestedRasterArea, coverageRasterArea, coverageRequestedRasterArea);

                if (LOGGER.isLoggable(Level.FINE)) {
                    StringBuffer sb = new StringBuffer(
                            "Adjusted Requested Envelope = ").append(
                            		requestedBBox.toString()).append("\n")
                            .append("Requested raster dimension = ").append(
                                    requestedRasterArea.toString()).append("\n")
                            .append("Corresponding raster source region = ")
                            .append(coverageRequestedRasterArea.toString());
                    LOGGER.log(Level.FINE, sb.toString());
                }
                return;
            }
        } catch (TransformException e) {
            throw new DataSourceException(
                    "Unable to create a coverage for this source", e);
        } catch (FactoryException e) {
            throw new DataSourceException(
                    "Unable to create a coverage for this source", e);
        }
        
//        get it all!
        requestedBBox=coverageBBox;
        requestedRasterArea=(Rectangle) coverageRasterArea.clone();
        coverageRequestedRasterArea=(Rectangle) coverageRasterArea.clone();
        requestedResolution=coverageFullResolution.clone();

    }

