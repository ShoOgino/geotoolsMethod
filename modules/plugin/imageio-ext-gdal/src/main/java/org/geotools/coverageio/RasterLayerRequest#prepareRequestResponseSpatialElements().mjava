    /**
     * Evaluates the requested envelope and builds a new adjusted version of it fitting this
     * coverage envelope.
     *
     * <p>While adjusting the requested envelope this methods also compute the source region as a
     * rectangle which is suitable for a successive read operation with {@link ImageIO} to do
     * crop-on-read.
     *
     * @throws DataSourceException in case something bad occurs
     */
    private void prepareRequestResponseSpatialElements() throws DataSourceException {
        try {
            // ////////////////////////////////////////////////////////////////
            //
            // DO WE HAVE A REQUESTED AREA?
            //
            // Check if we have something to load by intersecting the
            // requested envelope with the bounds of this data set.
            //
            // ////////////////////////////////////////////////////////////////
            if (requestedBBox != null) {

                // ////////////////////////////////////////////////////////////
                //
                // ADJUST ENVELOPES AND RASTER REQUESTED AREA to fall withing the coverage bbox
                //
                // ////////////////////////////////////////////////////////////
                adjustRequestedBBox();
                if (requestedBBox == null || requestedBBox.isEmpty()) {
                    if (LOGGER.isLoggable(Level.FINE))
                        LOGGER.log(Level.FINE, "RequestedBBox empty or null");
                    // this means that we do not have anything to load at all!
                    emptyRequest = true;
                    return;
                }

                // /////////////////////////////////////////////////////////////////////
                //
                // CROP SOURCE REGION using the refined requested envelope
                //
                // /////////////////////////////////////////////////////////////////////
                coverageRequestedRasterArea.setRect(getCropRegion());
                if (coverageRequestedRasterArea.isEmpty()) {
                    if (LOGGER.isLoggable(Level.FINE))
                        LOGGER.log(
                                Level.FINE,
                                "Requested envelope too small resulting in empty cropped raster region");
                    // TODO: Future versions may define a 1x1 rectangle starting
                    // from the lower coordinate
                    emptyRequest = true;
                    return;
                }
                if (!coverageRequestedRasterArea.intersects(coverageRasterArea))
                    throw new DataSourceException("The crop region is invalid.");
                XRectangle2D.intersect(
                        coverageRequestedRasterArea,
                        coverageRasterArea,
                        coverageRequestedRasterArea);

                if (LOGGER.isLoggable(Level.FINE)) {
                    String message =
                            "Adjusted Requested Envelope = "
                                    + requestedBBox.toString()
                                    + "\nRequested raster dimension = "
                                    + requestedRasterArea.toString()
                                    + "\nCorresponding raster source region = "
                                    + coverageRequestedRasterArea.toString();
                    LOGGER.log(Level.FINE, message);
                }
                return;
            }
        } catch (TransformException e) {
            throw new DataSourceException("Unable to create a coverage for this source", e);
        } catch (FactoryException e) {
            throw new DataSourceException("Unable to create a coverage for this source", e);
        }

        //        get it all!
        requestedBBox = coverageBBox;
        requestedRasterArea = (Rectangle) coverageRasterArea.clone();
        coverageRequestedRasterArea = (Rectangle) coverageRasterArea.clone();
        requestedResolution = coverageFullResolution.clone();
    }

