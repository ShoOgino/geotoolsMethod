    /**
     * This method creates the GridCoverage2D from the underlying file given a specified envelope,
     * and a requested dimension.
     *
     * @param iUseJAI specify if the underlying read process should leverage on a JAI ImageRead
     *     operation or a simple direct call to the {@code read} method of a proper {@code
     *     ImageReader}.
     * @param useMultithreading specify if the underlying read process should use multithreading
     *     when a JAI ImageRead operation is requested
     * @param overviewPolicy the overview policy which need to be adopted
     * @return a {@code GridCoverage}
     * @throws java.io.IOException
     */
    private GridCoverage createCoverage(
            File input,
            ImageReadParam imageReadParam,
            final boolean useJAI,
            final boolean useMultithreading,
            final boolean adjustGridToWorld)
            throws IOException {
        // ////////////////////////////////////////////////////////////////////
        //
        // Doing an image read for reading the coverage.
        //
        // ////////////////////////////////////////////////////////////////////
        PlanarImage raster = readRaster(input, useJAI, imageReadParam, useMultithreading);

        final boolean useFootprint =
                multiLevelRoi != null
                        && footprintBehavior != null
                        && footprintBehavior.handleFootprints();
        Geometry inclusionGeometry = useFootprint ? multiLevelRoi.getFootprint() : null;
        ReferencedEnvelope granuleBBOX = originatingCoverageRequest.getCoverageBBOX();
        ReferencedEnvelope cropBBox =
                new ReferencedEnvelope(originatingCoverageRequest.getRequestedBBox());
        final ReferencedEnvelope bbox =
                useFootprint
                        ? new ReferencedEnvelope(
                                granuleBBOX.intersection(inclusionGeometry.getEnvelopeInternal()),
                                granuleBBOX.getCoordinateReferenceSystem())
                        : granuleBBOX;

        // intersection of this tile bound with the current crop bbox
        final ReferencedEnvelope intersection =
                new ReferencedEnvelope(
                        bbox.intersection(cropBBox), cropBBox.getCoordinateReferenceSystem());
        if (intersection.isEmpty()
                || (useFootprint
                        && inclusionGeometry != null
                        && !JTS.toGeometry(cropBBox).intersects(inclusionGeometry))) {
            if (LOGGER.isLoggable(java.util.logging.Level.FINE)) {
                LOGGER.fine(
                        "Got empty intersection for granule "
                                + this.toString()
                                + " with request "
                                + originatingCoverageRequest.toString()
                                + " Resulting in no data loaded: Empty result");
            }
            return null;
        }

        // adjust roi
        if (useFootprint) {

            ROI transformed;
            try {
                // Getting Image Bounds
                final int width = raster.getWidth();
                final int height = raster.getHeight();
                Rectangle imgBounds =
                        new Rectangle(raster.getMinX(), raster.getMinY(), width, height);
                Rectangle sourceArea = imageReadParam.getSourceRegion();

                // Getting Transformed ROI
                final AffineTransform finalRaster2Model =
                        new AffineTransform(
                                (AffineTransform) originatingCoverageRequest.getRaster2Model());
                finalRaster2Model.concatenate(CoverageUtilities.CENTER_TO_CORNER);

                // Compute scale and translate factors
                double decimationScaleX = ((1.0 * sourceArea.width) / width);
                double decimationScaleY = ((1.0 * sourceArea.height) / height);
                final AffineTransform decimationScaleTranform =
                        XAffineTransform.getScaleInstance(decimationScaleX, decimationScaleY);
                final AffineTransform afterDecimationTranslateTranform =
                        XAffineTransform.getTranslateInstance(sourceArea.x, sourceArea.y);

                if (!XAffineTransform.isIdentity(
                        afterDecimationTranslateTranform, CoverageUtilities.AFFINE_IDENTITY_EPS)) {
                    finalRaster2Model.concatenate(afterDecimationTranslateTranform);
                }
                if (!XAffineTransform.isIdentity(
                        decimationScaleTranform, CoverageUtilities.AFFINE_IDENTITY_EPS)) {
                    finalRaster2Model.concatenate(decimationScaleTranform);
                }

                transformed =
                        multiLevelRoi.getTransformedROI(
                                finalRaster2Model.createInverse(),
                                0,
                                imgBounds,
                                imageReadParam,
                                originatingCoverageRequest.getReadType());
                // Check for vectorial ROI
                if (transformed instanceof ROIGeometry
                        && ((ROIGeometry) transformed).getAsGeometry().isEmpty()) {
                    // inset might have killed the geometry fully
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine(
                                "The transformed geometry became empty, maybe due to inset having "
                                        + "wiped out the geometry. Returning null");
                    }
                    return null;
                }

                PlanarImage pi = PlanarImage.wrapRenderedImage(raster);
                if (!transformed.intersects(pi.getBounds())) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine(
                                "The transformed geometry doesn't intersect the image bounds. Returning null");
                    }
                    return null;
                }
                pi.setProperty("ROI", transformed);
                raster =
                        PlanarImage.wrapRenderedImage(
                                footprintBehavior.postProcessMosaic(raster, transformed, hints));

            } catch (NoninvertibleTransformException e) {
                if (LOGGER.isLoggable(java.util.logging.Level.INFO))
                    LOGGER.info(
                            "Unable to create inverse transformation from GridToWorld when managing the ROI");
                return null;
            }
        }

        // /////////////////////////////////////////////////////////////////////
        //
        // Creating the coverage
        //
        // /////////////////////////////////////////////////////////////////////
        if (adjustGridToWorld) {
            // I need to calculate a new transformation (raster2Model)
            // between the cropped image and the required envelope
            final int ssWidth = raster.getWidth();
            final int ssHeight = raster.getHeight();
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.log(
                        Level.FINE, "Coverage read: width = " + ssWidth + " height = " + ssHeight);
            }

            // //
            //
            // setting new coefficients to define a new affineTransformation
            // to be applied to the grid to world transformation
            // ------------------------------------------------------
            //
            // With respect to the original envelope, the obtained
            // planarImage needs to be rescaled and translated. The scaling
            // factors are computed as the ratio between the cropped source
            // region sizes and the read image sizes. The translate
            // settings are represented by the offsets of the source region.
            //
            // //
            final Rectangle sourceRegion = imageReadParam.getSourceRegion();
            final double scaleX = sourceRegion.width / (1.0 * ssWidth);
            final double scaleY = sourceRegion.height / (1.0 * ssHeight);
            final double translateX = sourceRegion.x;
            final double translateY = sourceRegion.y;
            return createCoverageFromImage(
                    raster,
                    ConcatenatedTransform.create(
                            ProjectiveTransform.create(
                                    new AffineTransform(
                                            scaleX, 0, 0, scaleY, translateX, translateY)),
                            raster2Model));
        } else {
            // In case of no transformation is required (As an instance,
            // when reading the whole image)
            return createCoverageFromImage(raster);
        }
    }

