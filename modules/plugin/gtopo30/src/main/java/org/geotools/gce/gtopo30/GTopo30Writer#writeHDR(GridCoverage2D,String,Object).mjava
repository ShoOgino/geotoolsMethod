    /**
     * Writing down the header file for the gtopo30 format:
     *
     * @param coverage The GridCoverage to write
     * @param file The destination object (can be a File or ZipOutputStream)
     * @throws IOException If the file could not be written
     */
    private void writeHDR(final GridCoverage2D gc, final String name, final Object dest)
            throws IOException {

        // final GeneralEnvelope envelope = (GeneralEnvelope) gc.getEnvelope();
        final double noData = -9999.0;

        // checking the directions of the axes.
        // we need to understand how the axes of this gridcoverage are
        // specified
        /*
         * Note from Martin: I suggest to replace all the above lines by the commented code below.
         * The change need to be tested in order to make sure that I didn't made a mistake in the
         * mathematic. Note that 'lonFirst' totally vanish.
         */
        final AffineTransform gridToWorld = (AffineTransform) gc.getGridGeometry().getGridToCRS2D();
        boolean lonFirst = (XAffineTransform.getSwapXY(gridToWorld) != -1);

        final double geospatialDx =
                Math.abs((lonFirst) ? gridToWorld.getScaleX() : gridToWorld.getShearY());
        final double geospatialDy =
                Math.abs((lonFirst) ? gridToWorld.getScaleY() : gridToWorld.getShearX());

        // getting corner coordinates of the left upper corner
        final double xUpperLeft =
                lonFirst ? gridToWorld.getTranslateX() : gridToWorld.getTranslateY();
        final double yUpperLeft =
                lonFirst ? gridToWorld.getTranslateY() : gridToWorld.getTranslateX();
        /*
        			final AffineTransform worldToGrid = (AffineTransform) gc
        					.getGridGeometry().getGridToCoordinateSystem().inverse();

        			final double geospatialDx = 1 / XAffineTransform.getScaleX0(worldToGrid);
        			final double geospatialDy = 1 / XAffineTransform.getScaleY0(worldToGrid);

        			// getting corner coordinates of the left upper corner
        			final double xUpperLeft = -worldToGrid.getTranslateX() * geospatialDx;
        			final double yUpperLeft = -worldToGrid.getTranslateY() * geospatialDy;
        */

        // calculating the physical resolution over x and y.
        final int geometryWidth = gc.getGridGeometry().getGridRange().getSpan(0);
        final int geometryHeight = gc.getGridGeometry().getGridRange().getSpan(1);

        if (dest instanceof File) {

            final PrintWriter out =
                    new PrintWriter(
                            new BufferedOutputStream(
                                    new FileOutputStream(
                                            new File(
                                                    (File) dest,
                                                    new StringBuffer(name)
                                                            .append(".HDR")
                                                            .toString()))));

            // output header and assign header fields
            out.print("BYTEORDER");
            out.print(" ");
            out.println("M");

            out.print("LAYOUT");
            out.print(" ");
            out.println("BIL");

            out.print("NROWS");
            out.print(" ");
            out.println(geometryHeight);

            out.print("NCOLS");
            out.print(" ");
            out.println(geometryWidth);

            out.print("NBANDS");
            out.print(" ");
            out.println("1");

            out.print("NBITS");
            out.print(" ");
            out.println("16");

            out.print("BANDROWBYTES");
            out.print(" ");
            out.println(geometryWidth * 2);

            out.print("TOTALROWBYTES");
            out.print(" ");
            out.println(geometryWidth * 2);

            out.print("BANDGAPBYTES");
            out.print(" ");
            out.println(0);

            out.print("NODATA");
            out.print(" ");
            out.println((int) noData);

            out.print("ULXMAP");
            out.print(" ");
            out.println(xUpperLeft);

            out.print("ULYMAP");
            out.print(" ");
            out.println(yUpperLeft);

            out.print("XDIM");
            out.print(" ");
            out.println(geospatialDx);

            out.print("YDIM");
            out.print(" ");
            out.println(geospatialDy);
            out.flush();
            out.close();
        } else {
            final ZipOutputStream outZ = (ZipOutputStream) dest;
            final ZipEntry e = new ZipEntry(gc.getName().toString() + ".HDR");
            outZ.putNextEntry(e);

            // writing world file
            outZ.write("BYTEORDER".getBytes());
            outZ.write(" ".getBytes());
            outZ.write("M".getBytes());
            outZ.write("\n".getBytes());

            outZ.write("LAYoutZ".getBytes());
            outZ.write(" ".getBytes());
            outZ.write("BIL".getBytes());
            outZ.write("\n".getBytes());

            outZ.write("NROWS".getBytes());
            outZ.write(" ".getBytes());
            outZ.write(Integer.toString(geometryHeight).getBytes());
            outZ.write("\n".getBytes());

            outZ.write("NCOLS".getBytes());
            outZ.write(" ".getBytes());
            outZ.write(Integer.toString(geometryWidth).getBytes());
            outZ.write("\n".getBytes());

            outZ.write("NBANDS".getBytes());
            outZ.write(" ".getBytes());
            outZ.write("1".getBytes());
            outZ.write("\n".getBytes());

            outZ.write("NBITS".getBytes());
            outZ.write(" ".getBytes());
            outZ.write("16".getBytes());
            outZ.write("\n".getBytes());

            outZ.write("BANDROWBYTES".getBytes());
            outZ.write(" ".getBytes());
            outZ.write(Integer.toString(geometryWidth * 2).getBytes());
            outZ.write("\n".getBytes());

            outZ.write("TOTALROWBYTES".getBytes());
            outZ.write(" ".getBytes());
            outZ.write(Integer.toString(geometryWidth * 2).getBytes());
            outZ.write("\n".getBytes());

            outZ.write("BANDGAPBYTES".getBytes());
            outZ.write(" ".getBytes());
            outZ.write("0".getBytes());
            outZ.write("\n".getBytes());

            outZ.write("NODATA".getBytes());
            outZ.write(" ".getBytes());
            outZ.write(Integer.toString((int) noData).getBytes());
            outZ.write("\n".getBytes());

            outZ.write("ULXMAP".getBytes());
            outZ.write(" ".getBytes());
            outZ.write(Double.toString(xUpperLeft + (geospatialDx / 2)).getBytes());
            outZ.write("\n".getBytes());

            outZ.write("ULYMAP".getBytes());
            outZ.write(" ".getBytes());
            outZ.write(Double.toString(yUpperLeft - (geospatialDy / 2)).getBytes());
            outZ.write("\n".getBytes());

            outZ.write("XDIM".getBytes());
            outZ.write(" ".getBytes());
            outZ.write(Double.toString(geospatialDx).getBytes());
            outZ.write("\n".getBytes());

            outZ.write("YDIM".getBytes());
            outZ.write(" ".getBytes());
            outZ.write(Double.toString(geospatialDy).toString().getBytes());
            outZ.write("\n".getBytes());

            outZ.closeEntry();

            ((ZipOutputStream) dest).closeEntry();
        }
    }

