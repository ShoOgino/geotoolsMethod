	/**
	 * Parses the reader for the known properties
	 * 
	 * @param properties
	 *            the map to be filled in
	 * @param reader
	 *            the source data
	 * 
	 * @throws IOException
	 *             for reading errors
	 * @throws DataSourceException
	 *             for unrecoverable data format violations
	 */
	@SuppressWarnings("unchecked")
        private void parseHeaderFile(final BufferedReader reader) throws IOException {
		String currLine = reader.readLine();
		while (currLine != null) {
			// remove uneeded spaces
			currLine = currLine.trim();

			// get key and value
			int firstSpaceIndex = currLine.indexOf(' ');

			if (firstSpaceIndex == -1) {
				throw new IOException("Illegal line in GTOPO30 header file");
			}

			final String key = currLine.substring(0, firstSpaceIndex).toUpperCase();
			final String value = currLine.substring(firstSpaceIndex).trim();

			// be tolerant about unknown keys, all we need is a subset of the
			// knows keys, the others will be discarded
			if (propertyMap.containsKey(key)) {
				final Class propClass = getPropertyClass(key);

				try {
					if (propClass == String.class) {
					    propertyMap.put(key, value);
					} else if (propClass == Integer.class) {
					    propertyMap.put(key, Integer.valueOf(value));
					} else if (propClass == Double.class) {
					    propertyMap.put(key, Double.valueOf(value));
					}
				} catch (NumberFormatException nfe) {
					final IOException ex = new IOException();
					ex.initCause(nfe);
					throw ex;
				}
			}

			// read next line
			currLine = reader.readLine();
		}

		// closing the reader
		reader.close();
	}

