	/**
	 * Loading the tiles which overlap with the requested envelope.
	 * 
	 * 
	 * 
	 * @param requestedEnvelope
	 * @param dim
	 * @param params
	 * @param overviewPolicy
	 * @return A {@link GridCoverage}, well actually a {@link GridCoverage2D}.
	 * @throws IOException
	 */
	private GridCoverage2D loadTiles(GeneralEnvelope requestedEnvelope,
			Rectangle dim, GeneralParameterValue[] params, OverviewPolicy overviewPolicy)
			throws IOException {

		// /////////////////////////////////////////////////////////////////////
		//
		// Check if we have something to load by intersecting the requested
		// envelope with the bounds of the data set.
		//
		// If the requested envelope is not in the same crs of the data set crs
		// we have to perform a conversion towards the latter crs before
		// intersecting anything.
		//
		// /////////////////////////////////////////////////////////////////////
		if (requestedEnvelope != null) {
			if (!CRS.equalsIgnoreMetadata(requestedEnvelope
					.getCoordinateReferenceSystem(), this.crs)) {
				try {
					// transforming the envelope back to the data set crs
					final MathTransform transform = CRS.findMathTransform(requestedEnvelope.getCoordinateReferenceSystem(),	crs,true);
					if (!transform.isIdentity()) {
						requestedEnvelope = CRS.transform(transform,requestedEnvelope);
						requestedEnvelope.setCoordinateReferenceSystem(this.crs);

						if (LOGGER.isLoggable(Level.FINE))
							LOGGER.fine(new StringBuilder("Reprojected envelope ").append(requestedEnvelope.toString()).append(" crs ").append(crs.toWKT()).toString());
					}
				} catch (TransformException e) {
					throw new DataSourceException("Unable to create a coverage for this source", e);
				} catch (FactoryException e) {
					throw new DataSourceException("Unable to create a coverage for this source", e);
				}
			}
			if (!requestedEnvelope.intersects(this.originalEnvelope, false))
				return null;

			// intersect the requested area with the bounds of this layer
			requestedEnvelope.intersect(originalEnvelope);

		} else {
			requestedEnvelope = new GeneralEnvelope(originalEnvelope);

		}
		requestedEnvelope.setCoordinateReferenceSystem(this.crs);
		// ok we got something to return
		try {
			return loadRequestedTiles(requestedEnvelope, dim, params,overviewPolicy);
		} catch (TransformException e) {
			throw new DataSourceException(e);
		}

	}

