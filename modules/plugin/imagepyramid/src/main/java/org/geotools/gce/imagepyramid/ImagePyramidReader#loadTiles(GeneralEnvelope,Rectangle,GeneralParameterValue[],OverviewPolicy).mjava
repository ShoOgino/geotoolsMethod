    /**
     * Loading the tiles which overlap with the requested envelope.
     * 
     * 
     * 
     * @param requestedEnvelope
     * @param dim
     * @param params
     * @param overviewPolicy
     * @return A {@link GridCoverage}, well actually a {@link GridCoverage2D}.
     * @throws IOException
     */
    private GridCoverage2D loadTiles(GeneralEnvelope requestedEnvelope, Rectangle dim,
            GeneralParameterValue[] params, OverviewPolicy overviewPolicy) throws IOException {

        //
        // Check if we have something to load by intersecting the requested
        // envelope with the bounds of the data set.
        //
        // If the requested envelope is not in the same crs of the data set crs
        // we have to perform a conversion towards the latter crs before
        // intersecting anything.
        //

        if (requestedEnvelope != null) {
            if (!CRS.equalsIgnoreMetadata(requestedEnvelope.getCoordinateReferenceSystem(),
                    this.crs)) {
                try {
                    // transforming the envelope back to the data set crs
                    if (!CRS.equalsIgnoreMetadata(requestedEnvelope.getCoordinateReferenceSystem(),
                            crs)) {
                        requestedEnvelope = CRS.transform(requestedEnvelope, crs);
                        requestedEnvelope.setCoordinateReferenceSystem(this.crs);

                        if (LOGGER.isLoggable(Level.FINE))
                            LOGGER.fine(new StringBuilder("Reprojected envelope ")
                                    .append(requestedEnvelope.toString()).append(" crs ")
                                    .append(crs.toWKT()).toString());
                    }
                } catch (TransformException e) {
                    throw new DataSourceException("Unable to create a coverage for this source", e);
                }
            }
            if (!requestedEnvelope.intersects(this.originalEnvelope, false))
                return null;

            // intersect the requested area with the bounds of this layer
            requestedEnvelope.intersect(originalEnvelope);

        } else {
            requestedEnvelope = new GeneralEnvelope(originalEnvelope);

        }
        requestedEnvelope.setCoordinateReferenceSystem(this.crs);
        // ok we got something to return
        try {
            return loadRequestedTiles(requestedEnvelope, dim, params, overviewPolicy);
        } catch (TransformException e) {
            throw new DataSourceException(e);
        }

    }

