    static URL checkSource(Object source, Hints hints) {
        URL sourceURL = null;
        File sourceFile = null;

        //
        // Check source
        //
        // if it is a URL or a String let's try to see if we can get a file to
        // check if we have to build the index
        if (source instanceof File) {
            sourceFile = (File) source;
            sourceURL = URLs.fileToUrl(sourceFile);
        } else if (source instanceof URL) {
            sourceURL = (URL) source;
            if (sourceURL.getProtocol().equals("file")) {
                sourceFile = URLs.urlToFile(sourceURL);
            }
        } else if (source instanceof String) {
            // is it a File?
            final String tempSource = (String) source;
            File tempFile = new File(tempSource);
            if (!tempFile.exists()) {
                // is it a URL
                try {
                    sourceURL = new URL(tempSource);
                    sourceFile = URLs.urlToFile(sourceURL);
                } catch (MalformedURLException e) {
                    sourceURL = null;
                    sourceFile = null;
                }
            } else {
                sourceURL = URLs.fileToUrl(tempFile);
                sourceFile = tempFile;
            }
        } else {
            // we really don't know how to convert the thing... give up
            if (LOGGER.isLoggable(Level.WARNING)) {
                LOGGER.warning(
                        "we really don't know how to convert the thing: " + source != null
                                ? source.toString()
                                : "null");
            }
            return null;
        }

        // logging
        if (LOGGER.isLoggable(Level.FINE)) {
            if (sourceFile != null) {
                final String message = fileStatus(sourceFile);
                LOGGER.fine(message);
            }
        }

        //
        // Handle cases where the pyramid descriptor file already exists
        //
        // can't do anything with it
        if (sourceFile == null || !sourceFile.exists()) {
            return sourceURL;
        }

        // if it's already a file we don't need to adjust it, will try to open as is
        if (!sourceFile.isDirectory()) {
            return sourceURL;
        }

        // it's a directory, let's see if it already has a pyramid description file inside
        File directory = sourceFile;
        sourceFile = new File(directory, directory.getName() + ".properties");
        // logging
        if (LOGGER.isLoggable(Level.FINE)) {
            if (sourceFile != null) {
                final String message = fileStatus(sourceFile);
                LOGGER.fine(message);
            }
        }
        if (sourceFile.exists()) {
            return URLs.fileToUrl(sourceFile);
        }

        //
        // Try to build the sub-folders mosaics
        //
        // if the structure of the directories is gdal_retile like, move the root files in their
        // own sub directory
        File zeroLevelDirectory = new File(directory, "0");
        IOFileFilter directoryFilter = FileFilterUtils.directoryFileFilter();
        File[] numericDirectories = directory.listFiles(new NumericDirectoryFilter());
        File[] directories = directory.listFiles((FileFilter) directoryFilter);

        // do we have at least one numeric? sub-directory?
        if (numericDirectories == null || numericDirectories.length == 0) {
            if (LOGGER.isLoggable(Level.INFO)) {
                LOGGER.info(
                        "I was unable to determine a structure similar to the GDAL Retile one for the provided path: "
                                + directory);
            }
            return null;
        }

        // check the gdal case and move files if necessary
        if (!zeroLevelDirectory.exists()
                && (directories != null && numericDirectories.length == directories.length)) {
            LOGGER.log(
                    Level.INFO,
                    "Detected gdal_retile file structure, "
                            + "moving root files to the '0' subdirectory");
            if (zeroLevelDirectory.mkdir()) {
                if (LOGGER.isLoggable(Level.FINE)) {
                    LOGGER.fine("Created '0' subidr, now moving files");
                }
                FileFilter notDirFilter = FileFilterUtils.notFileFilter(directoryFilter);
                File[] files = directory.listFiles(notDirFilter);
                if (files != null) {
                    for (File f : files) {
                        if (LOGGER.isLoggable(Level.FINE)) {
                            LOGGER.fine("Moving file" + f.getAbsolutePath());
                        }
                        if (LOGGER.isLoggable(Level.FINEST)) {
                            LOGGER.finest(fileStatus(f));
                        }
                        if (!f.renameTo(new File(zeroLevelDirectory, f.getName())))
                            LOGGER.log(
                                    Level.WARNING,
                                    "Could not move "
                                            + f.getAbsolutePath()
                                            + " to "
                                            + zeroLevelDirectory
                                            + " check the permission inside the source directory "
                                            + f.getParent()
                                            + " and target directory "
                                            + zeroLevelDirectory);
                    }
                }
                directories = directory.listFiles((FileFilter) directoryFilter);
            } else {
                if (LOGGER.isLoggable(Level.INFO)) {
                    LOGGER.info(
                            "I was unable to create the 0 directory. check the file permission in the parent directory:"
                                    + sourceFile.getParent());
                }
                return null;
            }
        }

        // scan each subdirectory and try to build a mosaic in it, accumulate the resulting mosaics
        List<MosaicInfo> mosaics = new ArrayList<MosaicInfo>();
        ImageMosaicFormat mosaicFactory = new ImageMosaicFormat();
        if (directories != null) {
            for (File subdir : directories) {
                if (mosaicFactory.accepts(subdir, hints)) {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.fine(
                                "Trying to build mosaic for the directory:"
                                        + subdir.getAbsolutePath());
                    }
                    ImageMosaicReader reader = null;
                    try {
                        reader = mosaicFactory.getReader(subdir, hints);
                        String referenceName = checkConsistency(reader);
                        MosaicInfo mosaicInfo = new MosaicInfo(subdir, reader, referenceName);
                        mosaics.add(mosaicInfo);
                    } finally {
                        if (reader != null) {
                            try {
                                reader.dispose();
                            } catch (Throwable t) {
                                // Does nothing
                            }
                        }
                    }
                } else {
                    if (LOGGER.isLoggable(Level.INFO)) {
                        LOGGER.info(
                                "Unable to build mosaic for the directory:"
                                        + subdir.getAbsolutePath());
                    }
                }
            }
        }

        // do we have at least one level?
        if (mosaics.size() == 0) {
            return null;
        }

        // sort the mosaics by resolution and check they are actually in ascending resolution order
        // for both X and Y resolutions
        Collections.sort(mosaics);
        for (int i = 1; i < mosaics.size(); i++) {
            double[] resprev = mosaics.get(i - 1).getResolutions()[0];
            double[] res = mosaics.get(i).getResolutions()[0];
            if (resprev[1] > res[1]) {
                LOGGER.log(
                        Level.INFO,
                        "Invalid mosaic, y resolution in "
                                + mosaics.get(i - 1).getPath()
                                + " is greater than the one in "
                                + mosaics.get(i).getPath()
                                + " whilst x resolutions "
                                + "have the opposite relationship");
                return null;
            }
        }

        //
        // We have everything we need, build the final pyramid descriptor info
        //
        // build the property file
        Properties properties = new Properties();
        String coverageNames = mosaics.get(0).getCoverageNames();
        properties.put("Name", coverageNames != null ? coverageNames : directory.getName());
        properties.put("LevelsNum", String.valueOf(mosaics.size()));
        StringBuilder sbDirNames = new StringBuilder();
        StringBuilder sbLevels = new StringBuilder();
        for (MosaicInfo mi : mosaics) {
            sbDirNames.append(mi.getName()).append(" ");
            appendResolutionLevels(sbLevels, mi.getResolutions());
        }
        properties.put("LevelsDirs", sbDirNames.toString());
        properties.put("Levels", sbLevels.toString().trim());
        GeneralEnvelope envelope = mosaics.get(0).getEnvelope();
        properties.put(
                "Envelope2D",
                envelope.getMinimum(0)
                        + ","
                        + envelope.getMinimum(1)
                        + " "
                        + envelope.getMaximum(0)
                        + ","
                        + envelope.getMaximum(1));
        
        try (OutputStream os = new FileOutputStream(sourceFile)) {
            properties.store(os, "Automatically generated");
        } catch (IOException e) {
            LOGGER.log(
                    Level.INFO,
                    "We could not generate the pyramid property file " + sourceFile.getPath(),
                    e);
            return null;
        } 

        // build the .prj file if possible
        if (envelope.getCoordinateReferenceSystem() != null) {
            File prjFile = new File(directory, directory.getName() + ".prj");
            PrintWriter pw = null;
            try {
                pw = new PrintWriter(new FileOutputStream(prjFile));
                pw.print(envelope.getCoordinateReferenceSystem().toString());
            } catch (IOException e) {
                LOGGER.log(
                        Level.INFO,
                        "We could not write out the projection file " + prjFile.getPath(),
                        e);
                return null;
            } finally {
                if (pw != null) pw.close();
            }
        }

        return URLs.fileToUrl(sourceFile);
    }

