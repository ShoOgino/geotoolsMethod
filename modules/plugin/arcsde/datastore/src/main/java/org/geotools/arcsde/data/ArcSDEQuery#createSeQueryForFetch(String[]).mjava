    /**
     * creates an SeQuery with the filters provided to the constructor and returns it. Queries
     * created with this method can be used to execute and fetch results. They cannot be used for
     * other operations, such as calculating layer extents, or result count.
     * <p>
     * Difference with {@link #createSeQueryForFetch(Session, String[])} is tha this function tells
     * <code>SeQuery.setSpatialConstraints</code> to NOT return geometry based bitmasks, which are
     * needed for calculating the query extent and result count, but not for fetching SeRows.
     * </p>
     * 
     * @param propertyNames
     *            names of attributes to build the query for, respecting order
     * @throws SeException
     *             if the ArcSDE Java API throws it while creating the SeQuery or setting it the
     *             spatial constraints.
     * @throws IOException
     */
    private SeQuery createSeQueryForFetch(String[] propertyNames) throws SeException, IOException {
        if (LOGGER.isLoggable(Level.FINEST)) {
            LOGGER.finest("constructing new sql query with connection: " + session
                    + ", propnames: " + java.util.Arrays.asList(propertyNames)
                    + " sqlConstruct where clause: '" + this.filters.getSeSqlConstruct().getWhere()
                    + "'");
        }

        final SeQueryInfo qInfo = filters.getQueryInfo(propertyNames);
        if (sortByClause != null) {
            qInfo.setByClause(sortByClause);
        }

        final SeFilter[] spatialConstraints = this.filters.getSpatialFilters();
        if (LOGGER.isLoggable(Level.FINER)) {
            String msg = "ArcSDE query is: " + toString(qInfo);
            LOGGER.finer(msg);
        }

        final SeQuery seQuery;

        seQuery = session.prepareQuery(qInfo, spatialConstraints, versioningHandler);

        return seQuery;
    }

