    /**
     * @param filter
     * @param sdeMethod
     * @param truth de default truth value for <code>sdeMethod</code>
     * @param extraData if an instanceof java.lang.Boolean, <code>truth</code> is and'ed with its
     *        boolean value. May have been set by {@link #visit(Not, Object)} to revert the logical
     *        evaluation criteria.
     */
    private void addSpatialFilter(final BinarySpatialOperator filter, final int sdeMethod,
            final boolean truth, final Object extraData) {
        boolean appliedTruth = truth;

        // At the time of writing, extraData can only be null or false.
        // appliedTruth is calculated from following matrix.
        //
        // appliedTruth truth extraData
        // true ........false....false
        // false........true.....false
        // false........false....null
        // true.........true.....null
        if (extraData != null && extraData instanceof Boolean) {
            boolean andValue = ((Boolean) extraData).booleanValue();
            if (andValue) {
                /**
                 * TRUE ... should not occur, so fallback to old behaviour.
                 */
                appliedTruth = truth && andValue;
            } else {
                /**
                 * FALSE ... toggle truth Parameter, so for example NOT DISJOINT works properly see
                 * http://jira.codehaus.org/browse/GEOS-3735 for more information.
                 */
                appliedTruth = !truth;
            }
        }
        org.opengis.filter.expression.Expression left, right;
        PropertyName propertyExpr;
        Literal geomLiteralExpr;

        left = filter.getExpression1();
        right = filter.getExpression2();
        if (left instanceof PropertyName && right instanceof Literal) {
            propertyExpr = (PropertyName) left;
            geomLiteralExpr = (Literal) right;
        } else if (right instanceof PropertyName && left instanceof Literal) {
            propertyExpr = (PropertyName) right;
            geomLiteralExpr = (Literal) left;
        } else {
            String err = "SDE currently supports one geometry and one "
                    + "attribute expr.  You gave: " + left + ", " + right;
            throw new IllegalArgumentException(err);
        }

        // Should probably assert that attExpr's property name is equal to
        // spatialCol...

        // HACK: we want to support <namespace>:SHAPE, but current FM doesn't
        // support it. I guess we should try stripping the prefix and seeing if
        // that
        // matches...
        final String spatialCol = featureType.getGeometryDescriptor().getLocalName();
        final String rawPropName = propertyExpr.getPropertyName();
        String localPropName = rawPropName;
        if (rawPropName.indexOf(":") != -1) {
            localPropName = rawPropName.substring(rawPropName.indexOf(":") + 1);
        }
        if ("".equals(localPropName)) {
            log.fine("Empty property name found on filter, using default geometry property");
            localPropName = spatialCol;
        }
        if (!rawPropName.equalsIgnoreCase(spatialCol)
                && !localPropName.equalsIgnoreCase(spatialCol)) {
            throw new IllegalArgumentException("When querying against a spatial "
                    + "column, your property name must match the spatial"
                    + " column name.You used '" + propertyExpr.getPropertyName()
                    + "', but the DB's spatial column name is '" + spatialCol + "'");
        }
        Geometry geom = (Geometry) geomLiteralExpr.getValue();

        // To prevent errors in ArcSDE, we first trim the user's Filter
        // geometry to the extents of our layer.
        ArcSDEGeometryBuilder gb = ArcSDEGeometryBuilder.builderFor(Polygon.class);
        SeExtent seExtent = this.sdeLayer.getExtent();

        // If a layer just has one point in it (or one very horizontal or
        // vertical line) then we may have
        // a layer extent that's a point or line. We need to correct this.
        if (seExtent.getMaxX() == seExtent.getMinX()) {
            seExtent = new SeExtent(seExtent.getMinX() - 100, seExtent.getMinY(),
                    seExtent.getMaxX() + 100, seExtent.getMaxY());
        }
        if (seExtent.getMaxY() == seExtent.getMinY()) {
            seExtent = new SeExtent(seExtent.getMinX(), seExtent.getMinY() - 100,
                    seExtent.getMaxX(), seExtent.getMaxY() + 100);
        }

        try {
            // Now make an SeShape
            SeShape filterShape;

            if(seExtent.isEmpty() == true)
            {
                // The extent of the sdeLayer is uninitialised so create an extent.
                // If seExtent.isEmpty() == true, when passed to SeShape.generateRectangle()
                // an exception occurs.
                filterShape = new SeShape(this.sdeLayer.getCoordRef());
            }
            else
            {
                SeShape extent = new SeShape(this.sdeLayer.getCoordRef());
                extent.generateRectangle(seExtent);

            // this is a bit hacky, but I don't yet know this code well enough
            // to do it right. Basically if the geometry collection is
            // completely
            // outside of the area of the layer then an intersection will return
            // a geometryCollection (two seperate geometries not intersecting
            // will
            // be a collection of two). Passing this into GeometryBuilder causes
            // an exception. So what I did was just look to see if it is a gc
            // and if so then just make a null seshape, as it shouldn't match
            // any features in arcsde. -ch
            if (geom.getClass() == GeometryCollection.class) {
                filterShape = new SeShape(this.sdeLayer.getCoordRef());
            } else {
                gb = ArcSDEGeometryBuilder.builderFor(geom.getClass());
                filterShape = gb.constructShape(geom, this.sdeLayer.getCoordRef());
            }
            }
            // Add the filter to our list
            SeShapeFilter shapeFilter = new SeShapeFilter(getLayerName(),
                    this.sdeLayer.getSpatialColumn(), filterShape, sdeMethod, appliedTruth);
            this.sdeSpatialFilters.add(shapeFilter);
        } catch (IOException ioe) {
            throw new RuntimeException(ioe);
        } catch (SeException se) {
            throw new RuntimeException(se);
        }
    }

