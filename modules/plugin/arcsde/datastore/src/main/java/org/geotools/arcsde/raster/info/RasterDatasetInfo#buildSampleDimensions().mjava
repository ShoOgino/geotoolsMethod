    @SuppressWarnings({ "unchecked", "rawtypes" })
    private List<GridSampleDimension> buildSampleDimensions() {

        final int numBands = getNumBands();
        List<GridSampleDimension> dimensions = new ArrayList<GridSampleDimension>(numBands);

        final Color transparent = new Color(0, 0, 0, 0);

        List<RasterBandInfo> bands = subRasterInfo.get(0).getBands();

        for (RasterBandInfo band : bands) {
            // use native cell type, in case no-data value has been computed to account for
            // sample depth promotion, we want to category to keep being the native range for
            // the values category
            final RasterCellType targetCellType = getNativeCellType();
            String bandName = band.getBandName();

            final double statsMin = band.getStatsMin();
            final double statsMax = band.getStatsMax();

            NumberRange<?> sampleValueRange;
            if (Double.isNaN(statsMin) || Double.isNaN(statsMax)) {
                sampleValueRange = targetCellType.getSampleValueRange();
            } else {
                sampleValueRange = NumberRange.create(statsMin, statsMax);
                Class elementClass = targetCellType.getSampleValueRange().getElementClass();
                sampleValueRange = sampleValueRange.castTo(elementClass);
            }

            final Color[] colorRange = null;

            final boolean geophysics = isGeoPhysics();

            Category valuesCat = new Category("values", colorRange, sampleValueRange,
                    LinearTransform1D.IDENTITY).geophysics(geophysics);

            Category[] categories;
            if (geophysics) {
                double noDataValue = band.getNoDataValue().doubleValue();
                // same as Category.NODATA but for the actual nodata value instead of hardcoded to
                // zero
                Category nodataCat = new Category(
                        Vocabulary.formatInternational(VocabularyKeys.NODATA), transparent,
                        noDataValue);
                categories = new Category[] { valuesCat, nodataCat };
            } else {
                // do not build a nodata category. A nodata value that doesn't overlap the value
                // range couldn't be determined
                categories = new Category[] { valuesCat };
            }
            /*
             * if (band.isHasStats()) { //can't do this, get an exception telling categories
             * overlap.. so no real way to express the statistics, uh? Category catMin = new
             * Category("Min", null, band.getStatsMin()).geophysics(true); Category catMax = new
             * Category("Max", null, band.getStatsMin()).geophysics(true); Category catMean = new
             * Category("Mean", null, band.getStatsMin()).geophysics(true); Category catStdDev = new
             * Category("StdDev", null, band.getStatsMin()) .geophysics(true); categories = new
             * Category[] { valuesCat, nodataCat, catMin, catMax, catMean, catStdDev }; } else {
             * categories = new Category[] { valuesCat, nodataCat }; }
             */

            // .geophysics(false) because our sample model always corresponds to the packed view
            // (whether it matches the underlying sample depth or we're promoting in order to make
            // room for the nodata value).
            GridSampleDimension sampleDim = new GridSampleDimension(bandName, categories, null)
                    .geophysics(false);

            dimensions.add(sampleDim);
        }
        return dimensions;
    }

