    /**
     * tests that no more than pool.maxConnections connections can be created, and once one
     * connection is freed, it is ready to be used again.
     * 
     * @throws Exception
     */
    @Test
    public void testMaxConnections() throws Exception {
        final int MIN_CONNECTIONS = 2;
        final int MAX_CONNECTIONS = 2;

        Map<String, Serializable> params = new HashMap<String, Serializable>(
                this.connectionParameters);
        params.put(MIN_CONNECTIONS_PARAM_NAME, Integer.valueOf(MIN_CONNECTIONS));
        params.put(MAX_CONNECTIONS_PARAM_NAME, Integer.valueOf(MAX_CONNECTIONS));

        createPool(params);

        ISession[] sessions = new ISession[MAX_CONNECTIONS];
        // try to get the maximun number of connections specified, and do not
        // release anyone
        for (int i = 0; i < MAX_CONNECTIONS; i++) {
            sessions[i] = pool.getSession();
        }

        // now that the max number of connections is reached, the pool
        // should throw an UnavailableArcSDEConnectionException
        try {
            this.pool.getSession();
            fail("since the max number of connections was reached, the pool should have throwed an UnavailableArcSDEConnectionException");
        } catch (UnavailableConnectionException ex) {
            LOGGER.fine("maximun number of connections reached, got an UnavailableArcSDEConnectionException, it's OK");
        }

        // now, free one and check the same conection is returned on the
        // next call to getConnection()
        ISession expected = sessions[0];
        expected.dispose();

        Thread.sleep(1000);
        ISession session = this.pool.getSession();
        assertEquals(expected, session);
    }

