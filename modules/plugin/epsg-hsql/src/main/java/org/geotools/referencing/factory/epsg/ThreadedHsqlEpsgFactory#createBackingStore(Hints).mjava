    /**
     * Returns the backing-store factory for HSQL syntax. If the cached tables are not available,
     * they will be created now from the SQL scripts bundled in this plugin.
     *
     * @param  hints A map of hints, including the low-level factories to use for CRS creation.
     * @return The EPSG factory using HSQL syntax.
     * @throws SQLException if connection to the database failed.
     */
    protected AbstractAuthorityFactory createBackingStore(final Hints hints) throws SQLException {
        final Logger logger = Logging.getLogger(LOGGER);
        logger.log(Level.FINE, "Building backing store for " + getClass().getName());

        final DataSource source = getDataSource();
        final File directory    = getDirectory(source);
        directory.mkdirs();
        if (!dataExists(directory)) {
            FileLock lock = null;
            try {
                // get an exclusive lock
                lock = acquireLock(directory);
                
                // if after getting the lock the database is still incomplete let's work on it
                if(!dataExists(directory)) {
                    /*
                     * HSQL has created automatically an empty database. We need to populate it.
                     * Executes the SQL scripts bundled in the JAR. In theory, each line contains
                     * a full SQL statement. For this plugin however, we have compressed "INSERT
                     * INTO" statements using Compactor class in this package.
                     */
                    final LogRecord record = Loggings.format(Level.FINE,
                            LoggingKeys.CREATING_CACHED_EPSG_DATABASE_$1, VERSION);
                    record.setLoggerName(logger.getName());
                    logger.log(record);
                
                    ZipInputStream zin = new ZipInputStream(ThreadedHsqlEpsgFactory.class.getResourceAsStream(ZIP_FILE));
                    ZipEntry ze = null;
                    byte[] buf = new byte[1024];
                    int read = 0;
                    while ((ze = zin.getNextEntry()) != null) {
                      FileOutputStream fout = new FileOutputStream(new File(directory, ze.getName()));
                      while((read = zin.read(buf)) > 0) {
                        fout.write(buf, 0, read);
                      }
                      zin.closeEntry();
                      fout.close();
                    }
                    zin.close();
                    
                    // mark the successful creation
                    new File(directory, MARKER_FILE).createNewFile();
                }
            } catch (IOException exception) {
                SQLException e = new SQLException(Errors.format(ErrorKeys.CANT_READ_$1, ZIP_FILE));
                e.initCause(exception); // TODO: inline cause when we will be allowed to target Java 6.
                throw e;
            } finally {
                if(lock != null) {
                    try {
                        lock.release();
                        lock.channel().close();
                        new File(directory, LOCK_FILE).delete();
                    } catch(IOException e) {
                        // does not matter, was just cleanup
                    }
                }
            }
            
        }
        FactoryUsingHSQL factory = new FactoryUsingHSQL(hints, getDataSource().getConnection());
        factory.setValidationQuery("CALL NOW()");
        return factory;
    }

