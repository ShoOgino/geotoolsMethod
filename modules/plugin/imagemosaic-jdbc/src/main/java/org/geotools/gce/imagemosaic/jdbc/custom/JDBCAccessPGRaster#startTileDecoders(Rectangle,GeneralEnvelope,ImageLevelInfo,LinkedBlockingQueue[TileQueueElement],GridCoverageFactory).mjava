    /**
     * startTileDecoders
     *
     * @param pixelDimension Not Used (passed as per interface requirement)
     * @param requestEnvelope Geographic Envelope of request
     * @param info Pyramid Level
     * @param tileQueue Queue to place retrieved tile into
     * @param coverageFactory not used (passed as per interface requirement)
     */

    /*
     * (non-Javadoc)
     *
     * @see org.geotools.gce.imagemosaic.jdbc.JDBCAccess#startTileDecoders(java.awt.Rectangle,
     * org.geotools.geometry.GeneralEnvelope, org.geotools.gce.imagemosaic.jdbc.ImageLevelInfo,
     * java.util.concurrent.LinkedBlockingQueue)
     */
    public void startTileDecoders(
            Rectangle pixelDimension,
            GeneralEnvelope requestEnvelope,
            ImageLevelInfo levelInfo,
            LinkedBlockingQueue<TileQueueElement> tileQueue,
            GridCoverageFactory coverageFactory)
            throws IOException {
        Date start = new Date();
        Connection con = null;
        List<ImageDecoderThread> threads = new ArrayList<ImageDecoderThread>();
        ExecutorService pool = getExecutorServivicePool();

        String gridStatement = statementMap.get(levelInfo);

        try {
            con = getConnection();
            try (PreparedStatement s = con.prepareStatement(gridStatement)) {
                WKBWriter w = new WKBWriter();
                byte[] bytes = w.write(polyFromEnvelope(requestEnvelope));
                s.setBytes(1, bytes);
                s.setInt(2, levelInfo.getSrsId());

                try (ResultSet r = s.executeQuery()) {
                    while (r.next()) {
                        // byte[] tileBytes = getTileBytes(r,2);
                        byte[] tileBytes = r.getBytes(2);
                        byte[] envBytes = r.getBytes(1);
                        WKBReader reader = new WKBReader();
                        Geometry g;
                        try {
                            g = reader.read(envBytes);
                        } catch (ParseException e) {
                            LOGGER.log(Level.SEVERE, e.getMessage(), e);
                            throw new IOException(e);
                        }
                        Envelope env = g.getEnvelopeInternal();
                        Rectangle2D tmp =
                                new Rectangle2D.Double(
                                        env.getMinX(),
                                        env.getMinY(),
                                        env.getWidth(),
                                        env.getHeight());
                        GeneralEnvelope tileGeneralEnvelope = new GeneralEnvelope(tmp);
                        tileGeneralEnvelope.setCoordinateReferenceSystem(
                                requestEnvelope.getCoordinateReferenceSystem());

                        ImageDecoderThread thread =
                                new ImageDecoderThread(
                                        tileBytes,
                                        "",
                                        tileGeneralEnvelope,
                                        pixelDimension,
                                        requestEnvelope,
                                        levelInfo,
                                        tileQueue,
                                        getConfig());
                        // thread.start();
                        threads.add(thread);
                        pool.execute(thread);
                    }
                }
            }
        } catch (SQLException e) {
            LOGGER.log(Level.SEVERE, e.getMessage(), e);
            throw new IOException(e);
        } finally {
            try {
                con.close();
            } catch (SQLException e1) {
            }
        }

        if (LOGGER.isLoggable(Level.INFO))
            LOGGER.info(
                    "Getting "
                            + threads.size()
                            + " Tiles needs "
                            + ((new Date()).getTime() - start.getTime())
                            + " millisecs");

        // wait for all threads dto finish and write end marker
        pool.shutdown();
        try {
            pool.awaitTermination(3600, TimeUnit.SECONDS); // wait for one hour
        } catch (InterruptedException e) {
            throw new RuntimeException(e.getLocalizedMessage());
        }

        tileQueue.add(TileQueueElement.ENDELEMENT);

        if (LOGGER.isLoggable(Level.INFO))
            LOGGER.info(
                    "Getting and decoding  "
                            + threads.size()
                            + " Tiles needs "
                            + ((new Date()).getTime() - start.getTime())
                            + " millisecs");
    }

