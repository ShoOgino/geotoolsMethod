    /** @see java.lang.Thread#run() */
    @Override
    public void run() {
        if ((imageBytes == null) || (imageBytes.length == 0)) { // nothing to do
            return;
        }

        try {

            BufferedImage bufferedImage = null;

            boolean triedFromStream = false;
            if (levelInfo.getCanImageIOReadFromInputStream()) {
                bufferedImage = ImageIO.read(new ByteArrayInputStream(imageBytes));
                triedFromStream = true;
            }
            if (bufferedImage == null) {
                if (triedFromStream)
                    LOGGER.warning("Could not read " + location + " from stream, switch to JAI");
                bufferedImage = readImage2(imageBytes);
            }

            if (requestEnvelope.contains(tileEnvelope, true) == false) {
                GeneralEnvelope savedTileEnvelope = new GeneralEnvelope(tileEnvelope);
                tileEnvelope.intersect(requestEnvelope);

                double scaleX = savedTileEnvelope.getSpan(0) / bufferedImage.getWidth();
                double scaleY = savedTileEnvelope.getSpan(1) / bufferedImage.getHeight();
                int xmin =
                        (int)
                                (Math.round(
                                        (tileEnvelope.getMinimum(0)
                                                        - savedTileEnvelope.getMinimum(0))
                                                / scaleX));
                int ymin =
                        (int)
                                (Math.round(
                                        (savedTileEnvelope.getMaximum(1)
                                                        - tileEnvelope.getMaximum(1))
                                                / scaleY));
                int xmax =
                        (int)
                                (Math.round(
                                        (tileEnvelope.getMaximum(0)
                                                        - savedTileEnvelope.getMinimum(0))
                                                / scaleX));
                int ymax =
                        (int)
                                (Math.round(
                                        (savedTileEnvelope.getMaximum(1)
                                                        - tileEnvelope.getMinimum(1))
                                                / scaleY));
                int width = xmax - xmin;
                int height = ymax - ymin;

                if ((width > 0) && (height > 0)) {

                    BufferedImage clippedImage =
                            bufferedImage.getSubimage(xmin, ymin, width, height);

                    tileQueue.add(new TileQueueElement(location, clippedImage, tileEnvelope));
                }
            } else {
                tileQueue.add(new TileQueueElement(location, bufferedImage, tileEnvelope));
            }
        } catch (IOException ex) {
            LOGGER.severe("Decorde error for tile " + location);
            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);
            throw new RuntimeException(ex);
        }
    }

