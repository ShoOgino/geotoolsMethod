    /**
     * Used to update an existing style based on the provided input.
     *
     * @param fts
     * @param ruleIndex
     * @param styleExpression
     * @throws IllegalFilterException
     */
    public static void modifyFTS(FeatureTypeStyle fts, int ruleIndex, String styleExpression)
            throws IllegalFilterException {
        Rule thisRule = fts.rules().get(ruleIndex);
        Filter filter = thisRule.getFilter();

        if (filter instanceof And) { // ranged expression
            // figure out the appropriate values

            String[] newValue = styleExpression.split("\\.\\."); // $NON-NLS-1$

            if (newValue.length != 2) {
                throw new IllegalArgumentException(
                        "StyleExpression has incorrect syntax; min..max expected.");
            }

            List<Filter> children = ((BinaryLogicOperator) filter).getChildren();

            if (children.size() > 2) {
                throw new IllegalArgumentException(
                        "This method currently only supports logical filters with exactly 2 children.");
            }

            // we're expecting 2 compare subfilters
            PropertyIsGreaterThanOrEqualTo filter1 =
                    (PropertyIsGreaterThanOrEqualTo) children.get(0);
            BinaryComparisonOperator filter2 = (BinaryComparisonOperator) children.get(1);

            // filter1 should be 1 <= x and filter2 should be x <(=) 5
            if (!(filter1.getExpression2().equals(filter2.getExpression1()))) {
                throw new IllegalArgumentException(
                        "Subfilters or subExpressions in incorrect order");
            }

            if (!filter1.getExpression1().toString().equals(newValue[0])) {
                // lower bound value has changed, update
                filter1 = ff.greaterOrEqual(filter1.getExpression1(), ff.literal(newValue[0]));
            }

            if (!filter2.getExpression2().toString().equals(newValue[1])) {
                // upper bound value has changed, update
                if (filter2 instanceof PropertyIsLessThan) {
                    filter2 = ff.less(filter1.getExpression1(), ff.literal(newValue[1]));
                } else if (filter2 instanceof PropertyIsLessThanOrEqualTo) {
                    filter2 = ff.lessOrEqual(filter1.getExpression1(), ff.literal(newValue[1]));
                } else {
                    throw new IllegalArgumentException(
                            "Filter 2 in the comparison is not less or less or equal??");
                }
            }

            // style events don't handle filters yet, so fire the change event for filter
            thisRule.setFilter(filter);

            // TODO: adjust the previous and next filters (uses isFirst, isLast)
        } else if (filter instanceof Or || filter instanceof PropertyIsEqualTo) {
            // explicit expression obtain the expression containing the attribute

            Expression attrExpression;

            if (filter instanceof Or) {
                attrExpression =
                        ((BinaryComparisonOperator) ((Or) filter).getChildren().get(0))
                                .getExpression1();
            } else { // COMPARE_EQUALS (simple explicit expression)
                attrExpression = ((PropertyIsEqualTo) filter).getExpression1();
            }

            // recreate the filter with the new values
            thisRule.setFilter(toExplicitFilter(styleExpression, attrExpression));

            // TODO: remove duplicate values from other filters
        } else {
            throw new IllegalArgumentException("Unrecognized filter type.");
        }
    }

