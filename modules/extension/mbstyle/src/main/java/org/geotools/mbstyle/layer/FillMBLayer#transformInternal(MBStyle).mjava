    /**
     * Transform MBFillLayer to GeoTools FeatureTypeStyle.
     *
     * <p>Notes:
     *
     * <ul>
     *   <li>stroke-width is assumed to be 1 (not specified by MapBox style)
     * </ul>
     *
     * @param styleContext The MBStyle to which this layer belongs, used as a context for things
     *     like resolving sprite and glyph names to full urls.
     * @return FeatureTypeStyle
     */
    @Override
    public List<FeatureTypeStyle> transformInternal(MBStyle styleContext) {
        MBStyleTransformer transformer = new MBStyleTransformer(parse);
        // use factory to avoid defaults values
        org.geotools.styling.Stroke stroke =
                sf.stroke(
                        fillOutlineColor(),
                        fillOpacity(),
                        ff.literal(1),
                        ff.literal("miter"),
                        ff.literal("butt"),
                        null,
                        null);

        // from fill pattern or fill color
        Fill fill;
        if (hasFillPattern()) {

            // If the fill-pattern is a literal string (not a function), then
            // we need to support Mapbox {token} replacement.
            Expression fillPatternExpr = fillPattern();
            if (fillPatternExpr instanceof Literal) {
                String text = fillPatternExpr.evaluate(null, String.class);
                if (text.trim().isEmpty()) {
                    fillPatternExpr = ff.literal(" ");
                } else {
                    fillPatternExpr = transformer.cqlExpressionFromTokens(text);
                }
            }

            ExternalGraphic eg =
                    transformer.createExternalGraphicForSprite(fillPatternExpr, styleContext);
            GraphicFill gf =
                    sf.graphicFill(
                            Arrays.asList(eg),
                            fillOpacity(),
                            null,
                            null,
                            null,
                            fillTranslateDisplacement());
            stroke.setOpacity(ff.literal(0));
            fill = sf.fill(gf, null, null);
        } else {
            fill = sf.fill(null, fillColor(), fillOpacity());
        }

        PolygonSymbolizer symbolizer =
                sf.polygonSymbolizer(
                        getId(),
                        ff.property((String) null),
                        sf.description(Text.text("fill"), null),
                        Units.PIXEL,
                        stroke,
                        fill,
                        fillTranslateDisplacement(),
                        ff.literal(0));

        MBFilter filter = getFilter();

        Rule rule =
                sf.rule(
                        getId(),
                        null,
                        null,
                        0.0,
                        Double.POSITIVE_INFINITY,
                        Arrays.asList(symbolizer),
                        filter.filter());

        return Collections.singletonList(
                sf.featureTypeStyle(
                        getId(),
                        sf.description(
                                Text.text("MBStyle " + getId()),
                                Text.text("Generated for " + getSourceLayer())),
                        null, // (unused)
                        Collections.emptySet(),
                        filter.semanticTypeIdentifiers(),
                        Arrays.asList(rule)));
    }

