    /**
     * Generate GeoTools {@link Filter} from json definition.
     *
     * <p>This filter specifying conditions on source features. Only features that match the filter
     * are displayed.
     *
     * @return GeoTools {@link Filter} specifying conditions on source features.
     */
    public Filter filter() {
        if (json == null || json.isEmpty()) {
            return Filter.INCLUDE; // by default include everything!
        }
        String operator = parse.get(json, 0);
        //
        // TYPE
        //
        if (("==".equals(operator)
                        || "!=".equals(operator)
                        || "in".equals(operator)
                        || "!in".equals(operator))
                && parse.isString(json, 1)
                && "$type".equals(parse.get(json, 1))) {
            return filterByGeometryType(json, operator);
        }
        //
        // ID
        //
        if (("==".equals(operator)
                        || "!=".equals(operator)
                        || "has".equals(operator)
                        || "!has".equals(operator)
                        || "in".equals(operator)
                        || "!in".equals(operator))
                && parse.isString(json, 1)
                && "$id".equals(parse.get(json, 1))) {
            return filterByFeatureIdentifier(json, operator);
        }

        //
        // Feature Property
        //

        // Existential Filters
        if ("!has".equals(operator)) {
            String key = parse.get(json, 1);
            return ff.isNull(ff.property(key)); // null is the same as no value present
        } else if ("has".equals(operator)) {
            String key = parse.get(json, 1);
            return ff.not(ff.isNull(ff.property(key)));
        }
        // Comparison Filters
        else if ("==".equals(operator)) {
            return filterEqualTo(json);
        } else if ("!=".equals(operator)) {
            return filterNotEqual(json);
        } else if (">".equals(operator)) {
            return filterGreater(json);
        } else if (">=".equals(operator)) {
            return filterGreaterOrEqual(json);
        } else if ("<".equals(operator)) {
            return filterLess(json);
        } else if ("<=".equals(operator)) {
            return filterLessOrEqual(json);
        }
        // Set Membership Filters
        else if ("in".equals(operator)) {
            return filterIn(json, true);
        } else if ("!in".equals(operator)) {
            return filterIn(json, false);
        }
        // Combining Filters
        else if ("all".equals(operator)) {
            return filterAll(json);
        } else if ("any".equals(operator)) {
            return filterAny(json);
        } else if ("none".equals(operator)) {
            return filterNone(json);
        }
        // MBExpression filters
        else if ("case".equals(operator)) {
            Expression caseExpr = MBExpression.transformExpression(json);
            return ff.equals(caseExpr, ff.literal(true));
        } else if ("coalesce".equals(operator)) {
            Expression coalesce = MBExpression.transformExpression(json);
            return ff.equals(coalesce, ff.literal(true));
        } else if ("match".equals(operator)) {
            Expression match = MBExpression.transformExpression(json);
            return ff.equals(match, ff.literal(true));
        } else if ("within".equals(operator)) {
            Expression within = MBExpression.transformExpression(json);
            return ff.equals(within, ff.literal(true));
        } else {
            throw new MBFormatException(
                    "Data expression or filter \""
                            + operator
                            + "\" invalid. It may be misspelled or not supported by this implementation:"
                            + json);
        }
    }

