    /**
     * Transform {@link SymbolMBLayer} to GeoTools FeatureTypeStyle.
     *
     * @param styleContext The MBStyle to which this layer belongs, used as a context for things
     *     like resolving sprite and glyph names to full urls.
     * @return FeatureTypeStyle
     */
    public List<FeatureTypeStyle> transformInternal(MBStyle styleContext) {
        MBStyleTransformer transformer = new MBStyleTransformer(parse);
        StyleBuilder sb = new StyleBuilder();
        List<Symbolizer> symbolizers = new ArrayList<>();

        LabelPlacement labelPlacement;
        // Create point or line placement

        // Functions not yet supported for symbolPlacement, so try to evaluate or use default.
        String symbolPlacementVal =
                transformer.requireLiteral(
                        symbolPlacement(), String.class, "point", "symbol-placement", getId());
        Expression fontSize = textSize();
        if ("point".equalsIgnoreCase(symbolPlacementVal.trim())) {
            // Point Placement (default)
            PointPlacement pointP = sb.createPointPlacement();
            // Set anchor point (translated by text-translate)
            // GeoTools AnchorPoint doesn't seem to have an effect on PointPlacement
            pointP.setAnchorPoint(anchorPoint());

            // MapBox text-translate: +y means down, expressed in px
            Displacement displacement = null;
            if (hasTextTranslate()) {
                Displacement textTranslate = textTranslateDisplacement();
                textTranslate.setDisplacementY(
                        ff.multiply(ff.literal(-1), textTranslate.getDisplacementY()));
                displacement = textTranslate;
            }
            // MapBox test-offset: +y mean down and expressed in ems
            Displacement textOffset = null;
            if (hasTextOffset()) {
                textOffset = textOffsetDisplacement();
                textOffset.setDisplacementX(ff.multiply(fontSize, textOffset.getDisplacementX()));
                textOffset.setDisplacementY(
                        ff.multiply(
                                fontSize,
                                ff.multiply(ff.literal(-1), textOffset.getDisplacementY())));
                if (displacement == null) {
                    displacement = textOffset;
                } else {
                    displacement.setDisplacementX(
                            ff.add(displacement.getDisplacementX(), textOffset.getDisplacementX()));
                    displacement.setDisplacementY(
                            ff.add(displacement.getDisplacementY(), textOffset.getDisplacementY()));
                }
            }
            pointP.setDisplacement(displacement);
            pointP.setRotation(textRotate());

            labelPlacement = pointP;
        } else {
            // Line Placement
            LinePlacement lineP = sb.createLinePlacement(null);
            lineP.setRepeated(true);

            // pixels (geotools) vs ems (mapbox) for text-offset
            lineP.setPerpendicularOffset(
                    ff.multiply(
                            fontSize,
                            ff.multiply(
                                    ff.literal(-1), textOffsetDisplacement().getDisplacementY())));

            labelPlacement = lineP;
        }

        // the default value of the halo color is rgba(0,0,0,0) that is, no halo drawn,
        // regardless of the value of other halo parameters
        Expression haloColor = textHaloColor();
        Halo halo = null;
        if (!(haloColor instanceof Literal)
                || (haloColor.evaluate(null, Color.class).getAlpha() > 0)) {
            halo = sf.halo(sf.fill(null, haloColor, null), textHaloWidth());
        }
        Fill fill = sf.fill(null, textColor(), textOpacity());

        // leverage GeoTools ability to have several distinct fonts, inherited from SLD 1.0
        List<Font> fonts = new ArrayList<>();
        List<String> staticFonts = getTextFont();
        if (staticFonts != null) {
            for (String textFont : staticFonts) {
                FontAttributesExtractor fae = new FontAttributesExtractor(textFont);
                Font font =
                        sb.createFont(
                                ff.function(
                                        FontAlternativesFunction.NAME.getName(),
                                        ff.literal(fae.getBaseName())),
                                ff.literal(fae.isItalic() ? "italic" : "normal"),
                                ff.literal(fae.isBold() ? "bold" : "normal"),
                                fontSize);
                fonts.add(font);
            }
        } else if (textFont() != null) {
            Expression dynamicFont = textFont();
            Font font =
                    sb.createFont(
                            ff.function(
                                    FontAlternativesFunction.NAME.getName(),
                                    ff.function(
                                            MapBoxFontBaseNameFunction.NAME.getName(),
                                            dynamicFont)),
                            ff.function(MapBoxFontStyleFunction.NAME.getName(), dynamicFont),
                            ff.function(MapBoxFontWeightFunction.NAME.getName(), dynamicFont),
                            fontSize);
            fonts.add(font);
        }

        // If the textField is a literal string (not a function), then
        // we need to support Mapbox token replacement.
        Expression textExpression = textField();
        if (textExpression instanceof Literal) {
            String text = textExpression.evaluate(null, String.class);
            if (text.trim().isEmpty()) {
                textExpression = ff.literal(" ");
            } else {
                textExpression = transformer.cqlExpressionFromTokens(text);
            }
        }
        if (hasTextTransform()) {
            textExpression = ff.function("StringTransform", textExpression, textTransform());
        }

        TextSymbolizer2 symbolizer =
                (TextSymbolizer2)
                        sf.textSymbolizer(
                                getId(),
                                ff.property((String) null),
                                sf.description(Text.text("text"), null),
                                Units.PIXEL,
                                textExpression,
                                null,
                                labelPlacement,
                                halo,
                                fill);
        symbolizer.fonts().clear();
        symbolizer.fonts().addAll(fonts);

        Number symbolSpacing =
                transformer.requireLiteral(
                        symbolSpacing(), Number.class, 250, "symbol-spacing", getId());
        symbolizer.getOptions().put(LABEL_REPEAT_KEY, String.valueOf(symbolSpacing));

        // text max angle - only for line placement
        // throw MBFormatException if point placement
        if (labelPlacement instanceof LinePlacement) {
            // followLine will be true if line placement, it is an implied default of MBstyles.
            symbolizer.getOptions().put(FORCE_LEFT_TO_RIGHT_KEY, String.valueOf(textKeepUpright()));
            symbolizer.getOptions().put(FOLLOW_LINE_KEY, "true");
            symbolizer.getOptions().put(MAX_ANGLE_DELTA_KEY, String.valueOf(getTextMaxAngle()));
            symbolizer.getOptions().put(GROUP_KEY, "true");
            symbolizer.getOptions().put(LABEL_ALL_GROUP_KEY, "true");
        } else if (hasTextMaxAngle()) {
            throw new MBFormatException(
                    "Property text-max-angle requires symbol-placement = line but symbol-placement = "
                            + symbolPlacementVal);
        }
        // conflictResolution
        // Mapbox allows text overlap and icon overlap separately. GeoTools only has
        // conflictResolution.
        Boolean textAllowOverlap =
                transformer.requireLiteral(
                        textAllowOverlap(), Boolean.class, false, "text-allow-overlap", getId());
        Boolean iconAllowOverlap =
                transformer.requireLiteral(
                        iconAllowOverlap(), Boolean.class, false, "icon-allow-overlap", getId());

        symbolizer
                .getOptions()
                .put(
                        CONFLICT_RESOLUTION_KEY,
                        String.valueOf(!(textAllowOverlap || iconAllowOverlap)));

        String textFitVal =
                transformer
                        .requireLiteral(
                                iconTextFit(), String.class, "none", "icon-text-fit", getId())
                        .trim();
        if ("height".equalsIgnoreCase(textFitVal) || "width".equalsIgnoreCase(textFitVal)) {
            symbolizer.getOptions().put(GRAPHIC_RESIZE_KEY, STRETCH.name());
        } else if ("both".equalsIgnoreCase(textFitVal)) {
            symbolizer.getOptions().put(GRAPHIC_RESIZE_KEY, PROPORTIONAL.name());
        } else {
            // Default
            symbolizer.getOptions().put(GRAPHIC_RESIZE_KEY, NONE.name());
        }

        // Kept commented out as a reminder not to bring this back. It breaks rendering
        // on server side, as the labels are actually cut at tile borders, unlike client side
        // where they can just continue over, and one can hope they won't overlap
        //        if (!getSymbolAvoidEdges()) {
        //            symbolizer.getOptions().put(PARTIALS_KEY, "true");
        //        }
        symbolizer.getOptions().put(PARTIALS_KEY, "false");

        // Mapbox allows you to sapecify an array of values, one for each side
        if (getIconTextFitPadding() != null && !getIconTextFitPadding().isEmpty()) {
            symbolizer
                    .getOptions()
                    .put(GRAPHIC_MARGIN_KEY, String.valueOf(getIconTextFitPadding().get(0)));
        } else {
            symbolizer.getOptions().put(GRAPHIC_MARGIN_KEY, "0");
        }

        // text-padding default value is 2 in mapbox, will override Geoserver defaults
        if (!hasIconImage()
                || "point".equalsIgnoreCase(symbolPlacementVal.trim())
                || (getTextPadding().doubleValue()) >= (getIconPadding().doubleValue())) {
            symbolizer.getOptions().put("spaceAround", String.valueOf(getTextPadding()));
        }
        // halo blur
        // layer.textHaloBlur();

        // auto wrap
        // getTextSize defaults to 16, and getTextMaxWidth defaults to 10
        // converts text-max-width(mbstyle) from ems to pixels for autoWrap(sld)
        // Only supported when text-max-width and text-size are not functions (because vendor
        // options don't take expressions)
        if (hasTextMaxWidth()) {
            double textMaxWidth =
                    transformer.requireLiteral(
                            textMaxWidth(), Double.class, 10.0, "text-max-width", getId());
            double textSize =
                    transformer.requireLiteral(
                            fontSize,
                            Double.class,
                            16.0,
                            "text-size (when text-max-width is specified)",
                            getId());
            symbolizer.getOptions().put(AUTO_WRAP_KEY, String.valueOf(textMaxWidth * textSize));
        }

        // If the layer has an icon image, add it to our symbolizer
        if (hasIconImage()) {
            // Check to see that hasTextField() is true check to see if IconPadding is greater to
            // put to spaceAround
            if (!hasTextField()
                    || ((getIconPadding().doubleValue()) > (getTextPadding().doubleValue()))
                            && !"point".equalsIgnoreCase(symbolPlacementVal.trim())) {
                symbolizer
                        .getOptions()
                        .put(TextSymbolizer.SPACE_AROUND_KEY, String.valueOf(getIconPadding()));
            }
            // If we have an icon with a Point placement force graphic placement independ
            // of the label final position (each one gets its own anchor and displacement)
            Graphic graphic = getGraphic(transformer, styleContext);
            if ("point".equalsIgnoreCase(symbolPlacementVal.trim())) {
                symbolizer.getOptions().put(GRAPHIC_PLACEMENT_KEY, INDEPENDENT.name());
            }
            // the mapbox-gl library does not paint the graphic if the icon cannot be found
            symbolizer.getOptions().put(PointSymbolizer.FALLBACK_ON_DEFAULT_MARK, "false");
            symbolizer.setGraphic(graphic);
        }

        // make sure rendering paints the labels in the same layer based order that
        // Mapbox GL would use
        if (labelPriority != null) {
            symbolizer.setPriority(ff.literal(labelPriority));
        }

        symbolizers.add(symbolizer);
        MBFilter filter = getFilter();

        // List of opengis rules here (needed for constructor)
        List<org.opengis.style.Rule> rules = new ArrayList<>();
        Rule rule =
                sf.rule(
                        getId(),
                        null,
                        null,
                        0.0,
                        Double.POSITIVE_INFINITY,
                        symbolizers,
                        filter.filter());

        rules.add(rule);

        return Collections.singletonList(
                sf.featureTypeStyle(
                        getId(),
                        sf.description(
                                Text.text("MBStyle " + getId()),
                                Text.text("Generated for " + getSourceLayer())),
                        null, // (unused)
                        Collections.emptySet(),
                        filter.semanticTypeIdentifiers(), // we only expect this to be applied to
                        // polygons
                        rules));
    }

