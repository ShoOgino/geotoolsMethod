    /**
     * <b>validateSingleLayer Purpose:</b> <br>
     *
     * <p>This validation tests for a geometry that overlaps with itself. Uses JTS'
     * Geometry.overlaps(Geometry) and Geometry.contains(Geometry)method. The DE-9IM intersection
     * matrix for overlaps is: T*T***T** (for two points or two surfaces) 1*T***T** (for two curves)
     * Contains DE-9IM intersection matrix is T*F**F***. <b>Description:</b><br>
     *
     * <p>The function filters the SimpleFeatureSource using the given bounding box. It creates
     * iterators over the filtered FeatureSource. It calls overlaps() and contains() using the
     * geometries in the SimpleFeatureSource layer. Tests the results of the method calls against
     * the given expected results. Returns true if the returned results and the expected results are
     * true, false otherwise. * Author: bowens<br>
     * Created on: Apr 27, 2004<br>
     *
     * @param featureSourceA - the SimpleFeatureSource to pull the original geometries from. This
     *     geometry is the one that is tested for overlapping itself
     * @param expected - boolean value representing the user's expected outcome of the test
     * @param results - ValidationResults
     * @param bBox - Envelope - the bounding box within which to perform the overlaps() and
     *     contains()
     * @return boolean result of the test
     * @throws Exception - IOException if iterators improperly closed
     */
    private boolean validateSingleLayer(
            SimpleFeatureSource featureSourceA,
            boolean expected,
            ValidationResults results,
            ReferencedEnvelope bBox)
            throws Exception {
        boolean success = true;
        int errors = 0;
        Date date1 = new Date();
        SimpleFeatureType ft = featureSourceA.getSchema();

        if (LOGGER.isLoggable(Level.INFO)) {
            LOGGER.info("---------------- In Overlaps Integrity ----------------");
        }

        SimpleFeatureCollection collectionA = null;

        if (bBox != null && !bBox.isNull() && bBox.getHeight() != 0.0 && bBox.getWidth() != 0.0) {
            Filter filter = filterBBox(bBox, ft);
            collectionA = featureSourceA.getFeatures(filter);
        } else collectionA = featureSourceA.getFeatures();

        SimpleFeatureIterator fr1 = null;
        SimpleFeatureIterator fr2 = null;
        try {
            fr1 = collectionA.features();
            if (fr1 == null) return success;

            while (fr1.hasNext()) {
                SimpleFeature f1 = fr1.next();

                Geometry g1 = (Geometry) f1.getDefaultGeometry();
                Filter filter2 =
                        filterBBox(
                                ReferencedEnvelope.reference(
                                        g1.getEnvelope().getEnvelopeInternal()),
                                ft);

                SimpleFeatureCollection collectionB = featureSourceA.getFeatures(filter2);

                fr2 = collectionB.features();
                try {
                    while (fr2 != null && fr2.hasNext()) {
                        SimpleFeature f2 = fr2.next();
                        Geometry g2 = (Geometry) f2.getDefaultGeometry();
                        if (!usedIDs.contains(f2.getID())) {

                            if (!f1.getID()
                                    .equals(f2.getID())) // if they are the same feature, move
                            // onto the next one
                            {
                                // if(g1.overlaps(g2) != expected || g1.contains(g2) != expected)
                                if (g1.relate(g2, "1********") != expected) {
                                    // results.error( f1,
                                    // f1.getDefaultGeometry().getGeometryType()+"
                                    // "+getGeomTypeRefA()+"("+f1.getID()+")"+" overlapped
                                    // "+getGeomTypeRefA()+"("+f2.getID()+"), Result was not
                                    // "+expected );
                                    if (results != null) {
                                        results.error(
                                                f1,
                                                ""
                                                        + getGeomTypeRefA()
                                                        + "("
                                                        + f1.getID()
                                                        + ")"
                                                        + " overlapped "
                                                        + getGeomTypeRefA()
                                                        + "("
                                                        + f2.getID()
                                                        + ")");
                                    }
                                    success = false;
                                    errors++;
                                }
                            }
                        }
                    }
                    usedIDs.add(f1.getID());
                    // if (counter%countInterval == 0 && showPrintLines)
                    //	System.out.println("count: " + counter);

                } finally {
                    if (fr2 != null) fr2.close();
                }
            } // end while 1
        } finally {
            Date date2 = new Date();
            float dt = date2.getTime() - date1.getTime();
            if (LOGGER.isLoggable(Level.INFO)) {
                LOGGER.info("########## Validation duration: " + dt);
                LOGGER.info("########## Validation errors: " + errors);
            }
            if (fr1 != null) fr1.close();
        }

        return success;
    }

