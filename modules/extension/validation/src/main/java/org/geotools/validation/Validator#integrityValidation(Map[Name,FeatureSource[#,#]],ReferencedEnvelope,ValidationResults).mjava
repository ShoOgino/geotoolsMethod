    /**
     * Integrity validation will iterate over all data stores passed in through the stores map and
     * run the tests associated with each store. Author: bowens<br>
     * Created on: Jun 26, 2004<br>
     *
     * @param featureStores Map of required FeatureStores by typeRef (dataStoreId:typeName)
     * @param bBox
     * @throws IOException
     * @throws Exception
     */
    public void integrityValidation(
            Map<Name, FeatureSource<?, ?>> featureStores,
            ReferencedEnvelope bBox,
            ValidationResults results)
            throws IOException, Exception // WfsTransactionException
            {
        // Data catalog = request.getWFS().getData();
        // ValidationProcessor validation = request.getValidationProcessor();
        if (validationProcessor == null) {
            LOGGER.warning("Validation Processor unavaialble");
            return;
        }
        LOGGER.finer("Required to validate " + featureStores.size() + " typeRefs");
        LOGGER.finer("within " + bBox);

        // go through each typeName passed in through stores
        // and ask what we need to check
        Set typeRefs = new HashSet();
        for (Name name : featureStores.keySet()) {
            String typeRef = typeRef(name);
            typeRefs.add(typeRef);

            Set dependencies = validationProcessor.getDependencies(typeRef);
            LOGGER.finer("typeRef " + typeRef + " requires " + dependencies);
            if (dependencies != null && dependencies.size() > 0) typeRefs.addAll(dependencies);
        }

        // Grab a source for each typeName we need to check
        // Grab from the provided stores - so we check against
        // the transaction
        //
        Map sources = new HashMap();

        for (Iterator i = typeRefs.iterator(); i.hasNext(); ) {
            String typeRef = (String) i.next();
            LOGGER.finer("Searching for required typeRef: " + typeRef);

            /**
             * This checks to see if we have already loaded in any feature stores. They can be
             * loaded already if we are in a transaction operation. If this is for the "do it"
             * button, there will be no feature stores already loaded and thus we always hit the
             * 'else' statement.
             */
            if (featureStores.containsKey(typeRef)) // if it was passed in through stores
            {
                LOGGER.finer(" found required typeRef: " + typeRef + " (it was already loaded)");
                sources.put(typeRef, featureStores.get(typeRef));
            } else // if we have to go get it (ie. it is a dependant for a test)
            {
                // These will be using Transaction.AUTO_COMMIT
                // this is okay as they were not involved in our
                // Transaction...
                LOGGER.finer(" could not find typeRef: " + typeRef + " (we will now load it)");
                String split[] = typeRef.split(":");
                String dataStoreId = split[0];
                String typeName = split[1];
                LOGGER.finer(
                        " going to look for dataStoreId:"
                                + dataStoreId
                                + " and typeName:"
                                + typeName);

                // FeatureTypeInfo meta = catalog.getFeatureTypeInfo(typeName);
                LOGGER.finer(" loaded required typeRef: " + typeRef);
                FeatureSource<?, ?> source = repository.source(dataStoreId, typeName);
                sources.put(typeRef, source);
            }
        }
        LOGGER.finer("Total of " + sources.size() + " SimpleFeatureSource marshalled for testing");
        final Map failed = new TreeMap();

        try {
            // should never be null, but confDemo is giving grief, and I
            // don't want transactions to mess up just because validation
            // stuff is messed up. ch
            LOGGER.finer("Runing integrity tests using validation validationProcessor ");
            validationProcessor.runIntegrityTests(featureStores.keySet(), sources, bBox, results);
        } catch (Exception badIdea) {
            java.util.logging.Logger.getGlobal().log(java.util.logging.Level.INFO, "", badIdea);
            // ValidationResults should of handled stuff will redesign :-)
            throw new DataSourceException("Validation Failed", badIdea);
        }
        if (failed.isEmpty()) {
            LOGGER.finer("All validation tests passed");
            return; // everything worked out
        }

        /**
         * One or more of the tests failed if we reached here, so dump out the information from teh
         * tests that failed.
         */
        LOGGER.finer("Validation fail - marshal result for transaction document");
        StringBuffer message = new StringBuffer();
        for (Iterator i = failed.entrySet().iterator(); i.hasNext(); ) {
            Map.Entry entry = (Map.Entry) i.next();
            message.append(entry.getKey());
            message.append(" failed test ");
            message.append(entry.getValue());
            message.append("\n");
        }
        // throw new Exception("Validation - " + message.toString());
        // throw new WfsTransactionException(message.toString(), "validation");
    }

