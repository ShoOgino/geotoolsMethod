    /**
     * <b>validateMultipleLayers Purpose:</b> <br>
     *
     * <p>This validation tests for a geometry crosses another geometry. Uses JTS'
     * Geometry.crosses(Geometry) method. The DE-9IM intersection matrix for crosses is T*T******
     * (for a point and a curve, a point and an area or a line and an area) 0******** (for two
     * curves) <b>Description:</b><br>
     *
     * <p>The function filters the FeatureSources using the given bounding box. It creates iterators
     * over both filtered FeatureSources. It calls overlaps() and contains()using the geometries in
     * the SimpleFeatureSource layers. Tests the results of the method call against the given
     * expected results. Returns true if the returned results and the expected results are true,
     * false otherwise. Author: bowens<br>
     * Created on: Apr 27, 2004<br>
     *
     * @param featureSourceA - the SimpleFeatureSource to pull the original geometries from. This
     *     geometry is the one that is tested for overlaping with the other
     * @param featureSourceB - the SimpleFeatureSource to pull the other geometries from - these
     *     geometries will be those that may overlap the first geometry
     * @param expected - boolean value representing the user's expected outcome of the test
     * @param results - ValidationResults
     * @param bBox - Envelope - the bounding box within which to perform the overlaps() and
     *     contains()
     * @return boolean result of the test
     * @throws Exception - IOException if iterators improperly closed
     */
    private boolean validateMultipleLayers(
            SimpleFeatureSource featureSourceA,
            SimpleFeatureSource featureSourceB,
            boolean expected,
            ValidationResults results,
            Envelope bBox)
            throws Exception {
        boolean success = true;

        Filter filter = null;

        // JD: fix this!!
        // filter = (Filter) ff.createBBoxExpression(bBox);

        SimpleFeatureCollection featureResultsA = featureSourceA.getFeatures(filter);
        SimpleFeatureCollection featureResultsB = featureSourceB.getFeatures(filter);

        SimpleFeatureIterator fr1 = null;
        SimpleFeatureIterator fr2 = null;
        try {
            fr1 = featureResultsA.features();

            if (fr1 == null) return success;

            while (fr1.hasNext()) {
                SimpleFeature f1 = fr1.next();
                Geometry g1 = (Geometry) f1.getDefaultGeometry();
                fr2 = featureResultsB.features();

                while (fr2 != null && fr2.hasNext()) {
                    SimpleFeature f2 = fr2.next();
                    Geometry g2 = (Geometry) f2.getDefaultGeometry();
                    // System.out.println("Do the two overlap?->" + g1.overlaps(g2));
                    // System.out.println("Does the one contain the other?->" + g1.contains(g2));
                    if (g1.overlaps(g2) != expected || g1.contains(g2) != expected) {
                        results.error(
                                f1,
                                ((Geometry) f1.getDefaultGeometry()).getGeometryType()
                                        + " "
                                        + getGeomTypeRefA()
                                        + " overlapped "
                                        + getGeomTypeRefB()
                                        + "("
                                        + f2.getID()
                                        + "), Result was not "
                                        + expected);
                        success = false;
                    }
                }
            }
        } finally {
            fr1.close();
            if (fr2 != null) fr2.close();
        }

        return success;
    }

