    /**
     * runIntegrityTests
     *
     * <p>Performs a lookup on the FeatureTypeInfo name to determine what IntegrityTests need to be
     * performed. Once these tests are gathered, they are run on the collection features in the
     * Envelope, defined by a SimpleFeatureSource (not a FeatureCollection!). The first validation
     * test lookup checks to see if there are any validations that are to be performed on every
     * FeatureTypeInfo. An example of this could be a uniqueID() test on a unique column value in
     * all FeatureTypes. Once those tests have been gathered, a lookup is performed on the TypeName
     * of the FeatureTypeInfo to check for specific Integrity validation tests. A list of validation
     * tests is returned from each lookup, if any exist. When all the validation tests have been
     * gathered, each test is iterated through then run on each Feature, with the ValidationResults
     * coming along for the ride, collecting error information.
     *
     * @param typeRefs List of modified features, or null to use stores.keySet()
     * @param stores the Map of effected features (Map of key=typeRef, value="featureSource"
     * @param envelope The bounding box that contains all modified Features
     * @param results Storage for the results of the validation tests.
     * @throws Exception Throws an exception if the HashMap contains a value that is not a
     *     FeatureSource
     */
    public void runIntegrityTests(
            Set<Name> typeRefs, Map stores, ReferencedEnvelope envelope, ValidationResults results)
            throws Exception {
        if ((integrityLookup == null) || (integrityLookup.size() == 0)) {
            LOGGER.fine("No tests defined by integrityLookup - validation not needed");

            return;
        }

        LOGGER.fine("Starting validation tests for:" + typeRefs);
        LOGGER.fine("Marshalled " + stores.size() + " FeatureSources for testing");
        LOGGER.fine("Testing limited to " + envelope);

        if (typeRefs == null) {
            LOGGER.finer("Using default typeRegs for stores");
            typeRefs = stores.keySet();
        } else if (typeRefs.isEmpty()) {
            LOGGER.finer("Validation test abandond - nothing was modified");
        }

        // convert each HashMap element into FeatureSources
        //
        List tests = new ArrayList();

        // check for any tests that are to be performed on ALL features
        //
        LOGGER.finer("Finding tests for everybody");

        List anyTests = (List) integrityLookup.get(ANYTYPENAME);

        if ((anyTests != null) && !anyTests.isEmpty()) {
            tests.addAll(anyTests);
        }

        LOGGER.finer("Found " + tests.size() + " tests (so far)");

        // for each modified FeatureTypeInfo
        //
        LOGGER.finer("Finding tests for modified typeRefs");

        for (Name name : typeRefs) {
            String typeRef = typeRef(name);

            LOGGER.finer("Finding tests for typeRef:" + typeRef);

            List moreTests = (List) integrityLookup.get(typeRef);

            if ((moreTests != null) && !moreTests.isEmpty()) {
                tests.addAll(moreTests);
            }
        }

        if (tests.isEmpty()) {
            LOGGER.finer("Validation test abandond - no tests found to run");

            return;
        }

        LOGGER.finer("Validation test about to run - " + tests.size() + " tests found");

        for (Iterator j = tests.iterator(); j.hasNext(); ) {
            IntegrityValidation validator = (IntegrityValidation) j.next();

            LOGGER.finer("Running test:" + validator.getName());
            results.setValidation(validator);

            try {
                boolean success = validator.validate(stores, envelope, results);

                if (!success) {
                    results.error(null, "Was not successful");
                }
            } catch (Throwable e) {
                LOGGER.finer("Validation test died:" + validator.getName());

                String error = e.getClass().getName();

                if (e.getMessage() != null) {
                    error += (" - " + e.getMessage());
                }

                LOGGER.log(Level.WARNING, validator.getName() + " failed with " + error, e);
                e.printStackTrace();
                results.error(null, error);
            }
        }
    }

