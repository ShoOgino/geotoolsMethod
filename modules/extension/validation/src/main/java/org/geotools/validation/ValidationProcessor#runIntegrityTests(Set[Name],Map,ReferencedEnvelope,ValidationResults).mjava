    /**
     * runIntegrityTests
     * 
     * <p>
     * Performs a lookup on the FeatureTypeInfo name to determine what
     * IntegrityTests need to be performed. Once these tests are gathered,
     * they are run on the collection  features in the Envelope, defined by a
     * SimpleFeatureSource (not a FeatureCollection!). The first validation test
     * lookup checks to see if there are any validations that are to be
     * performed on every FeatureTypeInfo. An example of this could be a
     * uniqueID() test on a unique column value in all FeatureTypes. Once
     * those tests have been gathered, a lookup is performed on the TypeName
     * of the FeatureTypeInfo to check for specific Integrity validation
     * tests. A list of validation tests is returned from each lookup, if any
     * exist. When all the validation tests have been gathered, each test is
     * iterated through then run on each Feature, with the ValidationResults
     * coming along for the ride, collecting error information.
     * </p>
     *
     * @param typeRefs List of modified features, or null to use
     *        stores.keySet()
     * @param stores the Map of effected features (Map of key=typeRef,
     *        value="featureSource"
     * @param envelope The bounding box that contains all modified Features
     * @param results Storage for the results of the validation tests.
     *
     * @throws Exception Throws an exception if the HashMap contains a value
     *         that is not a FeatureSource
     */
    public void runIntegrityTests(Set<Name> typeRefs, Map stores, ReferencedEnvelope envelope,
        ValidationResults results) throws Exception {
        if ((integrityLookup == null) || (integrityLookup.size() == 0)) {
            LOGGER.fine(
                "No tests defined by integrityLookup - validation not needed");

            return;
        }

        LOGGER.fine("Starting validation tests for:" + typeRefs);
        LOGGER.fine("Marshalled " + stores.size()
            + " FeatureSources for testing");
        LOGGER.fine("Testing limited to " + envelope);

        if (typeRefs == null) {
            LOGGER.finer("Using default typeRegs for stores");
            typeRefs = stores.keySet();
        } else if (typeRefs.isEmpty()) {
            LOGGER.finer("Validation test abandond - nothing was modified");
        }

        // convert each HashMap element into FeatureSources
        //
        List tests = new ArrayList();

        // check for any tests that are to be performed on ALL features
        //
        LOGGER.finer("Finding tests for everybody");

        List anyTests = (List) integrityLookup.get(ANYTYPENAME);

        if ((anyTests != null) && !anyTests.isEmpty()) {
            tests.addAll(anyTests);
        }

        LOGGER.finer("Found " + tests.size() + " tests (so far)");

        // for each modified FeatureTypeInfo
        //
        LOGGER.finer("Finding tests for modified typeRefs");

        for (Name name : typeRefs ) {
            String typeRef = typeRef( name );
            
            LOGGER.finer("Finding tests for typeRef:" + typeRef);

            List moreTests = (List) integrityLookup.get(typeRef);

            if ((moreTests != null) && !moreTests.isEmpty()) {
                tests.addAll(moreTests);
            }
        }

        if (tests.isEmpty()) {
            LOGGER.finer("Validation test abandond - no tests found to run");

            return;
        }

        LOGGER.finer("Validation test about to run - " + tests.size()
            + " tests found");

        for (Iterator j = tests.iterator(); j.hasNext();) {
            IntegrityValidation validator = (IntegrityValidation) j.next();

            LOGGER.finer("Running test:" + validator.getName());
            results.setValidation(validator);

            try {
                boolean success = validator.validate(stores, envelope, results);

                if (!success) {
                    results.error(null, "Was not successful");
                }
            } catch (Throwable e) {
                LOGGER.finer("Validation test died:" + validator.getName());

                String error = e.getClass().getName();

                if (e.getMessage() != null) {
                    error += (" - " + e.getMessage());
                }

                LOGGER.log(Level.WARNING,
                    validator.getName() + " failed with " + error, e);
                e.printStackTrace();
                results.error(null, error);
            }
        }
    }

