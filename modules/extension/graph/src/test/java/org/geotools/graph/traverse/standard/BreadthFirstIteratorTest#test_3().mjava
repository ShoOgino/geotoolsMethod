    /**
     * Create a balanced binary tree and do a normal traversal starting at root. <br>
     * <br>
     * Expected: 1. Every node should be visited. 2. For each level in the tree, each node in the
     * level should be visited before any node in a lower level
     */
    @Test
    public void test_3() {
        int k = 4;
        Object[] obj = GraphTestUtil.buildPerfectBinaryTree(builder(), k);
        Node root = (Node) obj[0];

        CountingWalker walker =
                new CountingWalker() {
                    @Override
                    public int visit(Graphable element, GraphTraversal traversal) {
                        element.setCount(getCount());
                        return super.visit(element, traversal);
                    }
                };

        BreadthFirstIterator iterator = createIterator();
        BasicGraphTraversal traversal =
                new BasicGraphTraversal(builder().getGraph(), walker, iterator);
        traversal.init();

        iterator.setSource(root);
        traversal.traverse();

        GraphVisitor visitor =
                component -> {
                    // ensure component visited
                    Assert.assertTrue(component.isVisited());

                    int level = component.getObject().toString().length();

                    // check all nodes that are at a lower level in the tree
                    for (Node other : builder().getGraph().getNodes()) {
                        if (other.getObject().toString().length() > level)
                            Assert.assertTrue(other.getCount() > component.getCount());
                    }
                    return 0;
                };

        builder().getGraph().visitNodes(visitor);

        // ensure nodes visited once
        Assert.assertEquals(walker.getCount(), (int) Math.pow(2, k + 1) - 1);
    }

