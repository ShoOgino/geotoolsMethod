    /**
     * Creates a balanced binary tree consisting of a specefied number of levels. Each node created
     * contains a string representing the nodes location in the tree.<br>
     * <br>
     * locstring(root) = "0"; locstring(node) = locstring(parent) + ".0" (if left child);
     * locstring(node) = locstring(parent) + ".1" (if right child);
     *
     * @param builder Builder to construct graph with
     * @param levels Number of levels in the tree.
     * @return A 2 element object array. 0 = root node 1 = map of locstring to node
     */
    public static Object[] buildPerfectBinaryTree(GraphBuilder builder, int levels) {
        HashMap<Object, Node> id2node = new HashMap<>();

        // a balanced binary tree
        Node root = builder.buildNode();
        root.setObject("0");
        id2node.put(root.getObject(), root);

        builder.addNode(root);

        Queue<Graphable> queue = new ArrayDeque<>((int) Math.pow(2, levels + 1));
        queue.add(root);

        // build a complete binary tree
        // number of nodes = 2^(n+1) - 1
        int level = 0;
        while (level < levels) {
            int nnodes = (int) Math.pow(2, level);
            for (int i = 0; i < nnodes; i++) {
                Node n = (Node) queue.remove();

                Node ln = builder.buildNode();
                ln.setObject(n.getObject() + ".0");
                id2node.put(ln.getObject(), ln);

                Node rn = builder.buildNode();
                rn.setObject(n.getObject() + ".1");
                id2node.put(rn.getObject(), rn);

                Edge le = builder.buildEdge(n, ln);
                Edge re = builder.buildEdge(n, rn);

                builder.addNode(ln);
                builder.addNode(rn);
                builder.addEdge(le);
                builder.addEdge(re);

                queue.add(ln);
                queue.add(rn);
            }
            level++;
        }

        return (new Object[] {root, id2node});
    }

