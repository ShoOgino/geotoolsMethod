  /**
   * Creates a balanced binary tree consisting of a specefied number of levels. 
   * Each node created contains a string representing the nodes location in 
   * the tree.<BR>
   * <BR>
   * locstring(root) = "0";
   * locstring(node) = locstring(parent) + ".0" (if left child);
   * locstring(node) = locstring(parent) + ".1" (if right child);
   *   
   * @param builder Builder to construct graph with
   * @param levels Number of levels in the tree.
   *
   * @return A 2 element object array.
   *         0 = root node
   *         1 = map of locstring to node
   */
  public static Object[] buildPerfectBinaryTree(
    GraphBuilder builder, int levels
  ) {
    HashMap id2node = new HashMap();
    
    //a balanced binary tree
    Node root = builder.buildNode();
    root.setObject(new String("0"));
    id2node.put(root.getObject(), root);
    
    builder.addNode(root);
    
    FIFOQueue queue = new FIFOQueue((int)Math.pow(2, levels+1));
    queue.enq(root);
    
    //build a complete binary tree 
    // number of nodes = 2^(n+1) - 1
    int level = 0;
    while (level < levels) {   
      int nnodes = (int)Math.pow(2, level);
      for (int i = 0; i < nnodes; i++) {
        Node n = (Node)queue.deq();  
        
        Node ln = builder.buildNode();
        ln.setObject(n.getObject() + ".0");
        id2node.put(ln.getObject(), ln);
        
        Node rn = builder.buildNode();
        rn.setObject(n.getObject() + ".1");
        id2node.put(rn.getObject(), rn);
        
        Edge le = builder.buildEdge(n, ln);
        Edge re = builder.buildEdge(n, rn);
        
        builder.addNode(ln);
        builder.addNode(rn);
        builder.addEdge(le);
        builder.addEdge(re); 
        
        queue.enq(ln);
        queue.enq(rn);  
      }
      level++; 
    }
    
    return(new Object[]{root, id2node});
  }

