  /**
   * Create a balanced binary tree and do a traversal starting at root and 
   * suspending at the first node seen that is not the root, (should be left 
   * child). Then continue the traversal.
   * <BR>
   * <BR>
   * Expected: After suspend:
   *           1. Only root and first non root should be visited.
   *           
   *           After continue:
   *           1. First node visited should be sibling of suspending node.
   *           2. Every node should be visited.
   */
   public void test_4() {
     int k = 4;
     Object[] obj = GraphTestUtil.buildPerfectBinaryTree(builder(), k);
     final Node root = (Node)obj[0];
     final Map obj2node = (Map)obj[1];
     final Node ln = (Node)obj2node.get(root.getObject().toString() + ".0");
     final Node rn = (Node)obj2node.get(root.getObject().toString() + ".1");
     
     CountingWalker walker = new CountingWalker() {
       private int m_mode = 0;
       
       public int visit(Graphable element, GraphTraversal traversal) {
         super.visit(element, traversal);
         if (m_mode == 0) {
           if (element != root) {
             //check which child of root was first visited
             m_mode++;
             return(GraphTraversal.SUSPEND);  
           }   
         }  
         else if (m_mode == 1) {
           String eid = element.getObject().toString();
           if (ln.isVisited()) assertTrue(element == rn);  
           else assertTrue(element == ln);
            
           m_mode++;  
         }
         
         return(GraphTraversal.CONTINUE);
       }
     };
          
     BreadthFirstIterator iterator = createIterator();
     BasicGraphTraversal traversal = new BasicGraphTraversal(
       builder().getGraph(), walker, iterator
     );
     traversal.init();
     
     iterator.setSource(root);
     traversal.traverse();
     
     //ensure that only root and one of children is visited
     assertTrue(root.isVisited());
     assertTrue(
       (rn.isVisited() && !ln.isVisited()) || 
       (!rn.isVisited() && ln.isVisited())
     ); 
     
     GraphVisitor visitor = new GraphVisitor() {
       public int visit(Graphable component) {
         if (component != root && component != ln && component != rn) {
           assertTrue(!component.isVisited());  
         } 
         return(0);
       }
     };
     builder().getGraph().visitNodes(visitor);
     
     //ensure nodes only visited once
     assertTrue(walker.getCount() == 2);
     
     traversal.traverse();
     
     //ensure all nodes visited
     visitor = new GraphVisitor() {
       public int visit(Graphable component) {
         assertTrue(component.isVisited());
         return(0);
       }
     };
     
     builder().getGraph().visitNodes(visitor);
     
     //ensure nodes visited once
     //ensure nodes only visited once
     assertTrue(walker.getCount() == (int)Math.pow(2,k+1)-1);
   }

