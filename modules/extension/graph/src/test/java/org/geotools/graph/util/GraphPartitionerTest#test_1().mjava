    /**
     * Create a balanced binary tree and then remove the root node and partition. <br>
     * <br>
     * Expected: 1. Two graphs should be created. One for each subtree of original.
     */
    @Test
    public void test_1() {
        int k = 4;
        Object[] obj = GraphTestUtil.buildPerfectBinaryTree(builder(), k);
        Node root = (Node) obj[0];
        Map id2node = (Map) obj[1];

        Node lc = (Node) id2node.get("0.0");
        Node rc = (Node) id2node.get("0.1");

        builder().removeNode(root);

        GraphPartitioner parter = new GraphPartitioner(builder().getGraph());
        parter.partition();

        List partitions = parter.getPartitions();

        Assert.assertEquals(2, partitions.size());

        Graph left = (Graph) partitions.get(0);
        Graph right = (Graph) partitions.get(1);

        if (!left.getNodes().contains(lc)) {
            // swap
            left = (Graph) partitions.get(1);
            right = (Graph) partitions.get(0);
        }

        Assert.assertTrue(left.getNodes().contains(lc));
        Assert.assertTrue(right.getNodes().contains(rc));

        Assert.assertEquals(left.getNodes().size(), (int) Math.pow(2, k) - 1);
        Assert.assertEquals(left.getEdges().size(), (int) Math.pow(2, k) - 2);
        Assert.assertEquals(right.getNodes().size(), (int) Math.pow(2, k) - 1);
        Assert.assertEquals(right.getEdges().size(), (int) Math.pow(2, k) - 2);

        GraphVisitor visitor =
                component -> {
                    Assert.assertTrue(component.getObject().toString().startsWith("0.0"));
                    return 0;
                };
        left.visitNodes(visitor);

        visitor =
                component -> {
                    Assert.assertTrue(component.getObject().toString().startsWith("0.1"));
                    return 0;
                };
        right.visitNodes(visitor);
    }

