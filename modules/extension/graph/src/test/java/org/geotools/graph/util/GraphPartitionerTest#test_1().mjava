    /**
     * Create a balanced binary tree and then remove the root node and partition. <br>
     * <br>
     * Expected: 1. Two graphs should be created. One for each subtree of original.
     */
    public void test_1() {
        int k = 4;
        Object[] obj = GraphTestUtil.buildPerfectBinaryTree(builder(), k);
        Node root = (Node) obj[0];
        Map id2node = (Map) obj[1];

        Node lc = (Node) id2node.get("0.0");
        Node rc = (Node) id2node.get("0.1");

        builder().removeNode(root);

        GraphPartitioner parter = new GraphPartitioner(builder().getGraph());
        parter.partition();

        List partitions = parter.getPartitions();

        assertEquals(2, partitions.size());

        Graph left = (Graph) partitions.get(0);
        Graph right = (Graph) partitions.get(1);

        if (!left.getNodes().contains(lc)) {
            // swap
            left = (Graph) partitions.get(1);
            right = (Graph) partitions.get(0);
        }

        assertTrue(left.getNodes().contains(lc));
        assertTrue(right.getNodes().contains(rc));

        assertEquals(left.getNodes().size(), (int) Math.pow(2, k) - 1);
        assertEquals(left.getEdges().size(), (int) Math.pow(2, k) - 2);
        assertEquals(right.getNodes().size(), (int) Math.pow(2, k) - 1);
        assertEquals(right.getEdges().size(), (int) Math.pow(2, k) - 2);

        GraphVisitor visitor =
                new GraphVisitor() {
                    public int visit(Graphable component) {
                        assertTrue(component.getObject().toString().startsWith("0.0"));
                        return 0;
                    }
                };
        left.visitNodes(visitor);

        visitor =
                new GraphVisitor() {
                    public int visit(Graphable component) {
                        assertTrue(component.getObject().toString().startsWith("0.1"));
                        return 0;
                    }
                };
        right.visitNodes(visitor);
    }

