  /**
   * Create a balanced binary tree and do a normal traversal starting at root 
   * and then kill at right right child of root, then resume
   * <BR>
   * <BR>
   * Expected: 1. Every node in left subtree should be visited
   *           2. Every node in right substree (minus right child of root)
   *              should not be visited
   *           
   */
  public void test_5() {
    int k = 4;
    Object[] obj = GraphTestUtil.buildPerfectBinaryTree(builder(), k);
    Map id2node = (Map)obj[1];
    
    final Node root = (Node)obj[0];
    final Node lc = (Node)id2node.get(root.getObject().toString() + ".0");
    final Node rc = (Node)id2node.get(root.getObject().toString() + ".1");
    
    CountingWalker walker = new CountingWalker() {
      private int m_mode = 0;
      
      public int visit(Graphable element, GraphTraversal traversal) {
        super.visit(element, traversal);
        if (m_mode == 0) {
          if (element == rc) {
            m_mode++;
            return(GraphTraversal.KILL_BRANCH);
          }    
        }
        return(GraphTraversal.CONTINUE);  
      }
    };
    
    final DijkstraIterator iterator = createIterator();
    iterator.setSource((Node)obj[0]);
    
    BasicGraphTraversal traversal = new BasicGraphTraversal(
      builder().getGraph(), walker, iterator 
    );
    traversal.init();
    traversal.traverse();
    
    GraphVisitor visitor = new GraphVisitor() {
      public int visit(Graphable component) {
        if (component == root || component == lc || component == rc) 
          assertTrue(component.isVisited());
        else {
          String id = component.getObject().toString();
          if (id.startsWith("0.1.")) assertTrue(!component.isVisited());
          else assertTrue(component.isVisited());
        }
        
        return 0;
      }
    };
    builder().getGraph().visitNodes(visitor);
    
    assertTrue(walker.getCount() == Math.pow(2,k)+1);
  }

