    /**
     * Create a balanced binary tree and do a traversal starting at root and kill branch at the
     * first node seen that is not the root, (should be left child). Then continue the traversal.
     * <br>
     * <br>
     * Expected: After kill: 1. All nodes should be visited except for sub nodes of first child of
     * root visited. (the kill node)
     *
     * <p>After continue: 1. Same as after kill.
     */
    public void test_5() {
        int k = 4;
        Object[] obj = GraphTestUtil.buildPerfectBinaryTree(builder(), k);
        final Node root = (Node) obj[0];
        final Map obj2node = (Map) obj[1];
        final Node ln = (Node) obj2node.get(root.getObject().toString() + ".0");
        final Node rn = (Node) obj2node.get(root.getObject().toString() + ".1");

        CountingWalker walker =
                new CountingWalker() {
                    private int m_mode = 0;

                    @Override
                    public int visit(Graphable element, GraphTraversal traversal) {
                        element.setCount(getCount());
                        super.visit(element, traversal); // set count

                        if (m_mode == 0) {
                            if (element != root) {
                                m_mode++;
                                return (GraphTraversal.KILL_BRANCH);
                            }
                        } else if (m_mode == 1) {
                            assertTrue(
                                    (ln.isVisited() && element == rn)
                                            || (rn.isVisited() && element == ln));
                            m_mode++;
                        }

                        return (GraphTraversal.CONTINUE);
                    }
                };

        DepthFirstIterator iterator = createIterator();
        BasicGraphTraversal traversal =
                new BasicGraphTraversal(builder().getGraph(), walker, iterator);
        traversal.init();

        iterator.setSource(root);
        traversal.traverse();

        // ensure that subnodes of first visited after root are not visited
        final String id =
                (ln.getCount() < rn.getCount())
                        ? ln.getObject().toString()
                        : rn.getObject().toString();

        GraphVisitor visitor =
                new GraphVisitor() {
                    @Override
                    public int visit(Graphable component) {
                        String eid = component.getObject().toString();
                        if (eid.length() <= id.length()) assertTrue(component.isVisited());
                        else if (eid.startsWith(id)) assertFalse(component.isVisited());
                        else assertTrue(component.isVisited());

                        return (0);
                    }
                };
        builder().getGraph().visitNodes(visitor);
        assertEquals(walker.getCount(), (int) Math.pow(2, k) + 1);

        traversal.traverse();

        builder().getGraph().visitNodes(visitor);
        assertEquals(walker.getCount(), (int) Math.pow(2, k) + 1);
    }

