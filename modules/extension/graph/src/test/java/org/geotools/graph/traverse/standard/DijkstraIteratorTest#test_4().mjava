  /**
   * Create a balanced binary tree and do a normal traversal starting at root 
   * and then suspend at right right child of root, then resume
   * <BR>
   * <BR>
   * Expected: After suspend:
   *           1. Not every node should be visited
   *           After resume:      
   *           1. Every node should be visited.
   */
  public void test_4() {
    int k = 4;
    Object[] obj = GraphTestUtil.buildPerfectBinaryTree(builder(), k);
    Map id2node = (Map)obj[1];
    
    final Node root = (Node)obj[0];
    final Node lc = (Node)id2node.get(root.getObject().toString() + ".0");
    final Node rc = (Node)id2node.get(root.getObject().toString() + ".1");
    
    CountingWalker walker = new CountingWalker() {
      private int m_mode = 0;
      
      public int visit(Graphable element, GraphTraversal traversal) {
        super.visit(element, traversal);
        if (m_mode == 0) {
          if (element == rc) {
            m_mode++;
            return(GraphTraversal.SUSPEND);
          }    
        }
        return(GraphTraversal.CONTINUE);  
      }
    };
    
    final DijkstraIterator iterator = createIterator();
    iterator.setSource((Node)obj[0]);
    
    BasicGraphTraversal traversal = new BasicGraphTraversal(
      builder().getGraph(), walker, iterator 
    );
    traversal.init();
    traversal.traverse();
    
    GraphVisitor visitor = new GraphVisitor() {
      public int visit(Graphable component) {
        if (component != root && component != lc && component != rc) 
          assertTrue(!component.isVisited());
        
        return 0;
      }
    };
    builder().getGraph().visitNodes(visitor);
    
    //resume
    traversal.traverse();
    
    visitor = new GraphVisitor() {
      public int visit(Graphable component) {
        assertTrue(component.isVisited());
        return(0);  
      }  
    };
    builder().getGraph().visitNodes(visitor);
    assertTrue(walker.getCount() == Math.pow(2,k+1)-1);
  }

