    /**
     * Create a balanced binary tree and do a normal traversal starting at root. <br>
     * <br>
     * Expected: 1. #nodes_visited <= #nodes 2. The parent of each node should be the same as the
     * parent of the tree. 3. G = depth. H = infinity if the target is not in any subtree of this
     * node or depth difference between target node and current node otherwise.
     *
     * @throws WrongPathException
     */
    public void test_3() {
        int k = 4;
        Object[] obj = GraphTestUtil.buildPerfectBinaryTree(builder(), k);
        final Node root = (Node) obj[0];
        final HashMap map = (HashMap) obj[1];
        HashMap rmap = new HashMap();
        Map.Entry[] set = new Map.Entry[map.size()];
        map.entrySet().toArray(set);
        for (int i = 0; i < set.length; i++) {
            rmap.put(set[i].getValue(), set[i].getKey());
        }
        final HashMap hashmap = rmap;

        class Factory {
            public AStarIterator.AStarFunctions createFunctions(Node target) {
                return (new AStarIterator.AStarFunctions(target) {
                    public double cost(AStarNode n1, AStarNode n2) {
                        return 1;
                    }

                    public double h(Node n) {
                        String dest = hashmap.get(this.getDest()).toString();
                        String current = hashmap.get(n).toString();
                        if (dest.startsWith(current)) {
                            // n under dest
                            dest = dest.replaceAll("\\D", "");
                            current = current.replaceAll("\\D", "");
                            return dest.length() - current.length();
                        } else {
                            return Double.POSITIVE_INFINITY;
                        }
                    }
                });
            }
        }
        Factory f = new Factory();

        AStarShortestPathFinder walker =
                new AStarShortestPathFinder(
                        builder().getGraph(),
                        root,
                        ((Node) map.get("0.1.0.1")),
                        f.createFunctions(((Node) map.get("0.1.0.1"))));

        walker.calculate();
        MyVisitor visitor = new MyVisitor();
        builder().getGraph().visitNodes(visitor);
        // #1
        assertTrue(visitor.count > 0);
        assertTrue(visitor.count < map.size() + 1);
        Path p = null;
        try {
            p = walker.getPath();
        } catch (Exception e) {
            java.util.logging.Logger.getGlobal().log(java.util.logging.Level.INFO, "", e);
        }
        p.getEdges();
        assertTrue(p.size() == 4);
        // #2
        for (int j = 0; j < p.size() - 1; j++) {
            Node n = (Node) p.get(j);
            Node parent = (Node) p.get(j + 1);
            String n_id = rmap.get(n).toString();
            String parent_id = rmap.get(parent).toString();
            assertTrue(n_id.startsWith(parent_id));
        }
    }

