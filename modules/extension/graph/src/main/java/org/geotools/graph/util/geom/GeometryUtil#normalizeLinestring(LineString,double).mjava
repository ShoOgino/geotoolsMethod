    public static LineString normalizeLinestring(LineString line, double sample) {
        Coordinate[] c = line.getCoordinates();
        boolean[] remove = new boolean[c.length];
        int nremove = 0;

        double[] add = new double[c.length];
        int nadd = 0;

        // special case if linestirng 2 coordinates
        if (c.length == 2) {
            if (distance(c, 0, 1) > sample) {
                // do the point interepolation
                int n = (int) (distance(c, 0, 1) / sample);
                if (n > 1) {
                    nadd += n - 1;
                    add[0] = distance(c, 0, 1) / ((double) n);
                }
            } else return (line);
        } else {
            int i = 0;
            while (i < c.length - 2) {
                // Coordinate c1 = c[i];
                int j = i + 1;

                while (j < c.length - 1) {
                    // Coordinate c2 = c[j];
                    if (distance(c, i, j) < sample) {
                        remove[j] = true;
                        nremove++;
                        j++;
                    } else break;
                }

                int n = (int) (distance(c, i, j) / (sample));
                if (n > 1) {
                    add[i] = distance(c, i, j) / ((double) n);
                    nadd += n - 1;
                }

                i = j;
            }

            // the last two points that will not be removed may need to be adjusted
            for (int k = c.length - 2; k >= 1; k--) {
                if (!remove[k]) {
                    // if distance between this point and last point is less then sample
                    // remove this point, and find the point before it, and asjust the
                    // interval in which to add points

                    if (distance(c, c.length - 1, k) < sample) {
                        remove[k] = true;
                        nremove++;

                        // move backward to find the last coordinate that wasn't removed
                        // and readjust any points that were added
                        int l = k - 1;
                        for (; l >= 0; l--) {
                            if (!remove[l]) break;
                        }

                        if (l > -1) {
                            int n = (int) (distance(c, l, k) / sample);
                            if (n > 1) {
                                add[l] = 0d;
                                nadd -= (n - 1);
                            }

                            // recalculate
                            n = (int) (distance(c, l, c.length - 1) / sample);
                            if (n > 1) {
                                add[l] = distance(c, l, c.length - 1) / ((double) n);
                                nadd += n - 1;
                            }
                        }
                    } else {
                        // if the last point is the second to last in the coordinate
                        // array, we may have to add points inbetween
                        if (k == c.length - 2) {
                            // determine if we need to add any points between last two points
                            int n = (int) (distance(c, k, c.length - 1) / sample);
                            if (n > 1) {
                                nadd += n - 1;
                                add[k] = distance(c, k, c.length - 1) / ((double) n);
                            }
                        }
                    }

                    break;
                }
            }

            //	    if (!remove[c.length-2]) {
            //	      if (c[c.length-1].distance(c[c.length-2]) < sample) {
            //		      remove[c.length-2] = true;
            //		      nremove++;
            //
            //		      //move backward to find the last coordinate that wasn't removed
            //		      // and readjust any points that were added
            //		      int k = c.length-3;
            //		      for (; k >= 0; k--) {
            //		        if (!remove[k]) break;
            //		      }
            //
            //		      if (k > -1) {
            //		        int n = (int) (c[k].distance(c[c.length-2]) / sample);
            //		        if (n > 1) {
            //		          add[k] = 0d;
            //		          nadd -= (n-1);
            //		        }
            //
            //		        //recalculate
            //		        n = (int)(c[k].distance(c[c.length-1]) / sample);
            //		        if (n > 1) {
            //		          add[k] = c[k].distance(c[c.length-1]) / ((double)n);
            //		          nadd += n-1;
            //		        }
            //
            //		      }
            //		    }
            //		    else {
            //		      //determine if we need to add any points between last two points
            //		      int n = (int) (c[c.length-2].distance(c[c.length-1]) / sample);
            //	        if (n > 1) {
            //	          nadd += n-1;
            //	          add[c.length-2] = c[c.length-2].distance(c[c.length-1]) / ((double)n);
            //	        }
            //
            //		    }
            //	    }
        }

        Coordinate[] newc = new Coordinate[c.length - nremove + nadd];
        // Coordinate[] newc = new Coordinate[c.length-nremove];
        int j = 0;
        for (int i = 0; i < c.length; i++) {
            if (!remove[i]) {
                newc[j++] = c[i];
                if (add[i] > 0d) {
                    int next = -1;
                    for (int k = i + 1; k < c.length && next == -1; k++) {
                        if (!remove[k]) next = k;
                    }
                    if (next == -1) continue;

                    double dx = (c[next].x - c[i].x) * (add[i]) / distance(c, i, next);
                    double dy = (c[next].y - c[i].y) * (add[i]) / distance(c, i, next);

                    int n = (int) (distance(c, i, next) / add[i] + +0.000001);
                    for (int k = 1; k < n; k++) {
                        newc[j++] = new Coordinate(c[i].x + k * dx, c[i].y + k * dy);
                    }
                }
            }
        }

        //    for (int i = 0; i < newc.length; i++) {
        //      Coordinate coord = newc[i];
        //      if (coord != null)
        //        System.out.println("POINT(" + coord.x + " " + coord.y + ")");
        //      else System.out.println("null");
        //    }

        return (gf().createLineString(newc));
    }

