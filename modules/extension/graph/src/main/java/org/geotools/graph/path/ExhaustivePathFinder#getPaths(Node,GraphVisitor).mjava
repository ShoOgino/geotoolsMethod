    public List getPaths(Node from, GraphVisitor visitor) {
        List<Path> paths = new ArrayList<>();

        // create a map to maintain iterator state
        Map<Node, Iterator<? extends Graphable>> node2related = new HashMap<>();

        // create the stack and place start node on
        IndexedStack<Node> stack = new IndexedStack<>();
        stack.push(from);

        int iterations = 0;
        O:
        while (!stack.isEmpty() && (iterations++ < m_maxitr)) {
            // peek the stack
            Node top = (Node) stack.peek();

            switch (visitor.visit(top)) {
                case END_PATH_AND_CONTINUE:
                    paths.add(new Path(stack));
                    stack.pop();
                    continue;

                case END_PATH_AND_STOP:
                    paths.add(new Path(stack));
                    break O;

                case KILL_PATH:
                    stack.pop();
                    continue;

                case CONTINUE_PATH:
            }

            Iterator<? extends Graphable> related = null;
            if ((related = node2related.get(top)) == null) {
                related = top.getRelated();
                node2related.put(top, related);
            }

            while (stack.size() < m_maxplen && related.hasNext()) {
                Node adj = (Node) related.next();
                if (stack.contains(adj)) continue;

                // push adjacent onto stack, and reset iterator
                stack.push(adj);
                node2related.put(adj, adj.getRelated());

                continue O;
            }

            // all adjacent have been processed or are in stack
            stack.pop();
        }

        return (paths);
    }

