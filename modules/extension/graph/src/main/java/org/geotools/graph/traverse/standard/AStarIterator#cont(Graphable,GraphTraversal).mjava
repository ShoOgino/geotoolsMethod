    /**
     * Makes a step of the A* algorithm. Takes the current node, looks for its neighbours. The ones
     * which are closed are discarted. The ones "in" the opened queue are checked to see if its
     * necessary to update them. The rest of the nodes are initialized as AStarNodes and inserted in
     * the opened queue.
     *
     * @see org.geotools.graph.traverse.GraphIterator#cont(Graphable)
     */
    @Override
    public void cont(Graphable current, GraphTraversal traversal) {
        Node currdn = (Node) current;
        AStarNode currAsn;
        AStarNode nextAsn;

        currAsn = m_nodemap.get(currdn);
        if (currAsn == null) {
            throw new IllegalArgumentException("AStarIterator: The node is not in the open list");
        }
        currAsn.close();
        for (Iterator<?> itr = getRelated(current); itr.hasNext(); ) {
            Node next = (Node) itr.next();
            if (m_nodemap.containsKey(next)) {
                nextAsn = m_nodemap.get(next);
                if (!nextAsn.isClosed()) {
                    if ((currAsn.getG() + m_afuncs.cost(currAsn, nextAsn)) < nextAsn.getG()) {
                        m_pqueue.remove(nextAsn);
                        nextAsn.setG(currAsn.getG() + m_afuncs.cost(currAsn, nextAsn));
                        nextAsn.setParent(currAsn);
                        m_pqueue.add(nextAsn);
                    }
                }
            } else { // create new AStarNode
                nextAsn = new AStarNode(next, m_afuncs.h(next));
                nextAsn.setG(currAsn.getG() + m_afuncs.cost(currAsn, nextAsn));
                nextAsn.setParent(currAsn);
                m_pqueue.add(nextAsn);
                m_nodemap.put(next, nextAsn);
            }
        }
    }

