    /**
     * Upon each iteration of the traversal, a component is returned from the iterator and passed to
     * the visitor. The traversal interprets the return codes from the walker and performs the
     * following actions. <br>
     * <br>
     *
     * <TABLE border="1" width="60%" style="font-family:Arial;font-size=10pt">
     *   <TH width="20%">Code</TH>
     *   <TH width="40%">Action Performed</TH>
     *   <TR>
     *     <TD align="center">CONTINUE</TD>
     *     <TD>The traversal instructs the iterator to continue and starts the
     *         next stage of iteration.</TD>
     *   </TR>
     *  <TR>
     *     <TD align="center">SUSPEND</TD>
     *     <TD>The traversal instructs the iterator to continue but does not start
     *         the next stage of iteration, returning from traverse().</TD>
     *  </TR>
     *  <TR>
     *     <TD align="center">KILL_BRANCH</TD>
     *     <TD>The traversal instructs the iterator to kill the current branch
     *         and starts the next stage of iteration.</TD>
     *   </TR>
     *  <TR>
     *     <TD align="center">STOP</TD>
     *     <TD>The traversal does not instruct the iterator to continue and
     *         does not start the next of iteration, returning from traverse()
     *     </TD>
     *   </TR>
     * </TABLE>
     *
     * @see GraphTraversal#traverse()
     */
    public void traverse() {
        Graphable current;

        // get next component from iterator, null means stop
        O:
        while ((current = m_iterator.next(this)) != null) {
            setVisited(current, true);

            // pass the component to the visitor
            switch (m_walker.visit(current, null)) {
                case CONTINUE:
                    // signal iterator to continue from this point and start next
                    // iteration of traversal
                    m_iterator.cont(current, this);
                    continue;

                case SUSPEND:
                    // signal iterator to continue from this point, but do not start
                    // next iteration
                    m_iterator.cont(current, this);
                    return;

                case KILL_BRANCH:
                    // signal iterator to kill branch at this point and start next
                    // iteration
                    m_iterator.killBranch(current, this);
                    continue;

                case STOP:
                    // stop traversal
                    break O;

                default:
                    // illegal return value from walker
                    throw new IllegalStateException("Unrecognized return value from GraphWalker");
            }
        }

        // traversal complete, signal to walker
        m_walker.finish();
    }

