    /**
     * Performs the partition.
     *
     * @return True if the partition was successful, otherwise false.
     */
    public boolean partition() {
        // strategy is to perform a depth first search from a node, every node is
        // reaches is connected therefore in the same partition
        // when traversal ends, start from a new source, repeat until no more
        // sources

        try {
            m_nvisited = m_graph.getNodes().size();

            DepthFirstIterator iterator = new DepthFirstIterator();
            BasicGraphTraversal traversal = new BasicGraphTraversal(m_graph, this, iterator);

            Iterator sources = m_graph.getNodes().iterator();

            traversal.init();
            m_partition = new ArrayList();

            while (m_nvisited > 0) {

                // find a node that hasn't been visited and set as source of traversal
                Node source = null;
                while (sources.hasNext()) {
                    source = (Node) sources.next();
                    if (!source.isVisited()) break;
                }

                // if we could not find a source, return false
                if (source == null || source.isVisited()) return (false);

                iterator.setSource(source);
                traversal.traverse();
            }

            // create the individual graphs
            HashSet nodes = null;
            HashSet edges = null;
            ArrayList graphs = new ArrayList();

            for (Iterator itr = m_partitions.iterator(); itr.hasNext(); ) {
                m_partition = (ArrayList) itr.next();
                if (m_partition.size() == 0) continue;

                nodes = new HashSet();
                edges = new HashSet();
                for (Iterator nitr = m_partition.iterator(); nitr.hasNext(); ) {
                    Node node = (Node) nitr.next();
                    nodes.add(node);
                    edges.addAll(node.getEdges());
                }

                graphs.add(new BasicGraph(nodes, edges));
            }

            m_partitions = graphs;

            return (true);
        } catch (Exception e) {
            java.util.logging.Logger.getGlobal().log(java.util.logging.Level.INFO, "", e);
        }
        return (false);
    }

