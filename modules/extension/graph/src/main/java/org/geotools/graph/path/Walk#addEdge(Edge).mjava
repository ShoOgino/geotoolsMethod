    public boolean addEdge(Edge e) {
        // append edge to end of path, path must be empty, or last node in path
        // must be a node of the edge

        // save current edge list
        List<Edge> edges = getEdges();

        if (isEmpty()) {
            // add both nodes
            add(e.getNodeA());
            add(e.getNodeB());
        } else {
            // walk is not empty, check to see if the last node is related to the edge
            Node last = getLast();

            if (last.equals(e.getNodeA())) {
                add(e.getNodeB());
            } else if (last.equals(e.getNodeB())) {
                add(e.getNodeA());
            } else return (false);
        }

        // the addition of nodes resets the internal edge list so it must be rebuilt.
        // In the case that an edge shares both of its nodes with another edge
        // it is possible for the list to be rebuilt properly (ie. not contain
        // the edge being added). To rectify this situation, a backup copy of the
        // edge list is saved before the addition, the addition performed, the
        // edge explicitly added to the backup edge list, and the internal
        // edge list replaced by the modified backup
        edges.add(e);
        m_edges = edges;

        return (true);
    }

