  public boolean addEdge(Edge e) {
    //append edge to end of path, path must be empty, or last node in path
  	// must be a node of the edge
  	
  	//save current edge list
  	List edges = getEdges();
  	
  	if (isEmpty()) {
  	  //add both nodes
  		add(e.getNodeA());
  		add(e.getNodeB());
  	}
  	else {
  	  //walk is not empty, check to see if the last node is related to the edge
  	  Node last = getLast();
  	  
  	  if (last.equals(e.getNodeA())) {
  	    add(e.getNodeB());  	
  	  }
  	  else if (last.equals(e.getNodeB())) {
  	    add(e.getNodeA());	
  	  }
  	  else return(false);
  	}
  	
    //the addition of nodes resets the internal edge list so it must be rebuilt.
  	// In the case that an edge shares both of its nodes with another edge
  	// it is possible for the list to be rebuilt properly (ie. not contain
  	// the edge being added). To rectify this situation, a backup copy of the 
  	// edge list is saved before the addition, the addition performed, the 
  	// edge explicitly added to the backup edge list, and the internal
  	// edge list replaced by the modified backup
	  edges.add(e);
	  m_edges = edges;
	  
  	return(true);
  }

