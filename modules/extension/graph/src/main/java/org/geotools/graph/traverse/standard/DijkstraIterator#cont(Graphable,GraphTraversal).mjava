    /**
     * Looks for adjacent nodes to the current node which are in the adjacent node and updates
     * costs.
     *
     * @see org.geotools.graph.traverse.GraphIterator#cont(Graphable)
     */
    @Override
    public void cont(Graphable current, GraphTraversal traversal) {
        DijkstraNode currdn = nodemap.get(current);

        for (Iterator<? extends Graphable> itr = getRelated(current); itr.hasNext(); ) {
            Node related = (Node) itr.next();
            if (!traversal.isVisited(related)) {
                DijkstraNode reldn = nodemap.get(related);

                // calculate cost from current node to related node
                double cost = weighter.getWeight(currdn.node.getEdge(related)) + currdn.cost;

                // if cost less than current cost of related node, update
                if (cost < reldn.cost) {
                    queue.remove(reldn);
                    reldn.cost = cost;
                    reldn.parent = currdn;
                    queue.add(reldn);
                }
            }
        }
    }

