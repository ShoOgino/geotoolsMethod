    /**
     * Looks for adjacent nodes to the current node which are in the adjacent node and updates
     * costs.
     *
     * @see org.geotools.graph.traverse.GraphIterator#cont(Graphable)
     */
    public void cont(Graphable current, GraphTraversal traversal) {
        DijkstraNode currdn = (DijkstraNode) nodemap.get(current);

        for (Iterator itr = getRelated(current); itr.hasNext(); ) {
            Node related = (Node) itr.next();
            if (!traversal.isVisited(related)) {
                DijkstraNode reldn = (DijkstraNode) nodemap.get(related);

                // calculate cost from current node to related node
                double cost = weighter.getWeight(currdn.node.getEdge(related)) + currdn.cost;

                // calculate the cost of going through the node
                if (nweighter != null) {
                    double ncost = 0d;
                    if (currdn.parent != null) {
                        Edge e1 = currdn.parent.node.getEdge(currdn.node);
                        Edge e2 = currdn.node.getEdge(related);
                        ncost = nweighter.getWeight(currdn.node, e1, e2);
                    }
                }
                // if cost less than current cost of related node, update
                if (cost < reldn.cost) {
                    reldn.cost = cost;
                    reldn.parent = currdn;
                    queue.update(reldn);
                }
            }
        }
    }

