    public Set<Tile> findTilesInExtent(ReferencedEnvelope _mapExtent, int scaleFactor,
            boolean recommendedZoomLevel, int maxNumberOfTiles) {

        ReferencedEnvelope mapExtent = createSafeEnvelopeInWGS84(_mapExtent);

        ReferencedEnvelope extent = normalizeExtent(mapExtent);

        // only continue, if we have tiles that cover the requested extent
        if (!extent.intersects((Envelope) getBounds())) {
            return Collections.emptySet();
        }

        TileFactory tileFactory = getTileFactory();

        // TODO CRS
        ScaleZoomLevelMatcher zoomLevelMatcher = null;
        try {

            zoomLevelMatcher = new ScaleZoomLevelMatcher(getTileCrs(), getProjectedTileCrs(),
                    CRS.findMathTransform(getTileCrs(), getProjectedTileCrs()),
                    CRS.findMathTransform(getProjectedTileCrs(), getTileCrs()), mapExtent,
                    mapExtent, scaleFactor);

        } catch (FactoryException e) {
            throw new RuntimeException(e);
        }

        // TODO understand the minus 1 below
        int zoomLevelA = getZoomLevelToUse(zoomLevelMatcher, scaleFactor, recommendedZoomLevel) - 1;
        if (zoomLevelA <= 0)
            zoomLevelA = 0; // this is related to the -1 above!
        ZoomLevel zoomLevel = tileFactory.getZoomLevel(zoomLevelA, this);

        long maxNumberOfTilesForZoomLevel = zoomLevel.getMaxTileNumber();

        // Map<String, Tile> tileList = new HashMap<String, Tile>();
        Set<Tile> tileList = new HashSet<Tile>(100);

        // Let's get the first tile which covers the upper-left corner
        Tile firstTile = tileFactory.findTileAtCoordinate(extent.getMinX(), extent.getMaxY(),
                zoomLevel, this);

        addTileToCache(firstTile);
        tileList.add(firstTile);

        Tile firstTileOfRow = firstTile;
        Tile movingTile = firstTile;

        // Loop column
        do {
            // Loop row
            do {

                // get the next tile right of this one
                // Tile rightNeighbour = movingTile.getRightNeighbour();
                Tile rightNeighbour = tileFactory.findRightNeighbour(movingTile, this);// movingTile.getRightNeighbour();

                // Check if the new tile is still part of the extent and
                // that we don't have the first tile again
                if (extent.intersects((Envelope) rightNeighbour.getExtent())
                        && !firstTileOfRow.equals(rightNeighbour)) {

                    addTileToCache(rightNeighbour);
                    tileList.add(rightNeighbour);

                    movingTile = rightNeighbour;
                } else {

                    break;
                }
                if (tileList.size() > maxNumberOfTiles) {
                    LOGGER.warning("Reached tile limit of " + maxNumberOfTiles
                            + ". Returning an empty collection.");
                    return Collections.emptySet();
                }
            } while (tileList.size() < maxNumberOfTilesForZoomLevel);

            // get the next tile under the first one of the row
            // Tile lowerNeighbour = firstTileOfRow.getLowerNeighbour();
            Tile lowerNeighbour = tileFactory.findLowerNeighbour(firstTileOfRow, this);

            // Check if the new tile is still part of the extent
            if (extent.intersects((Envelope) lowerNeighbour.getExtent())
                    && !firstTile.equals(lowerNeighbour)) {

                // System.out.printf("N: %s %s", lowerNeighbour.getId(),
                // addTileToList(lowerNeighbour));

                addTileToCache(lowerNeighbour);
                tileList.add(lowerNeighbour);

                firstTileOfRow = movingTile = lowerNeighbour;
            } else {
                break;
            }
        } while (tileList.size() < maxNumberOfTilesForZoomLevel);

        return tileList;
    }

