    /**
     * Returns a two element array of PropertyName, Literal ( Geometry )
     *
     * @param node The parse tree.
     * @return A two element array of expressions for a BinarySpatialOp type.
     */
    static Expression[] spatial(Node node, FilterFactory2 ff, GeometryFactory gf) {
        List names = node.getChildValues(PropertyName.class);
        if (names.size() == 2) {
            // join
            return new Expression[] {(Expression) names.get(0), (Expression) names.get(1)};
        }

        PropertyName name = node.getChildValue(PropertyName.class);
        Expression spatial = null;

        if (node.hasChild(Geometry.class)) {
            spatial = ff.literal(node.getChildValue(Geometry.class));
        } else if (node.hasChild(Envelope.class)) {
            // JD: creating an envelope here would break a lot of our code, for instance alot of
            // code that encodes a filter into sql will choke on this
            Envelope envelope = node.getChildValue(Envelope.class);
            Polygon polygon =
                    gf.createPolygon(
                            gf.createLinearRing(
                                    new Coordinate[] {
                                        new Coordinate(envelope.getMinX(), envelope.getMinY()),
                                        new Coordinate(envelope.getMaxX(), envelope.getMinY()),
                                        new Coordinate(envelope.getMaxX(), envelope.getMaxY()),
                                        new Coordinate(envelope.getMinX(), envelope.getMaxY()),
                                        new Coordinate(envelope.getMinX(), envelope.getMinY())
                                    }),
                            null);

            if (envelope instanceof ReferencedEnvelope) {
                polygon.setUserData(((ReferencedEnvelope) envelope).getCoordinateReferenceSystem());
            }

            spatial = ff.literal(polygon);
        } else {
            // look for an expression that is not a property name
            for (Node child : node.getChildren()) {
                // if property name, skip
                if (child.getValue() instanceof PropertyName) {
                    continue;
                }

                // if expression, use it
                if (child.getValue() instanceof Expression) {
                    spatial = (Expression) child.getValue();
                    break;
                }
            }
        }

        return new Expression[] {name, spatial};
    }

