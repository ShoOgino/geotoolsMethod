    @SuppressWarnings({"rawtypes", "unchecked"})
    public List AbstractFeatureType_getProperties(
            Object object,
            XSDElementDeclaration element,
            SchemaIndex schemaIndex,
            Set<String> toFilter,
            Configuration configuration) {

        Feature feature = (Feature) object;

        // check if this was a resolved feature, if so dont return anything
        // TODO: this is just a hack for our lame xlink implementation
        if (feature.getUserData().get("xlink:id") != null) {
            return Collections.EMPTY_LIST;
        }

        FeatureType featureType = feature.getType();

        String namespace = featureType.getName().getNamespaceURI();

        if (namespace == null) {
            namespace = element.getTargetNamespace();
        }

        String typeName = featureType.getName().getLocalPart();
        QName qualifiedTypeName = new QName(namespace, typeName);

        // find the type in the schema
        XSDTypeDefinition type = schemaIndex.getTypeDefinition(qualifiedTypeName);

        if (type == null) {
            // type not found, do a check for an element, and use its type
            XSDElementDeclaration e = schemaIndex.getElementDeclaration(qualifiedTypeName);

            if (e != null) {
                type = e.getTypeDefinition();
            }
        }

        if (type == null) {
            if (featureType instanceof SimpleFeatureType) {
                // could not find the feature type in the schema, create a mock one
                LOGGER.fine(
                        "Could find type for "
                                + typeName
                                + " in the schema, generating type from feature.");
                type =
                        createXmlTypeFromFeatureType(
                                (SimpleFeatureType) featureType, schemaIndex, toFilter);
            } else {
                // look for an element declaration smuggled in the UserData map.
                XSDElementDeclaration e =
                        (XSDElementDeclaration)
                                feature.getDescriptor()
                                        .getUserData()
                                        .get(XSDElementDeclaration.class);
                if (e != null) {
                    type = e.getTypeDefinition();
                } else if (element != null) {
                    // as a last resort, use type definition from element declaration
                    XSDTypeDefinition elementTypeDef = element.getTypeDefinition();
                    QName qualifiedElementTypeName =
                            new QName(
                                    elementTypeDef.getTargetNamespace(), elementTypeDef.getName());
                    if (qualifiedTypeName.equals(qualifiedElementTypeName)) {
                        type = elementTypeDef;
                    }
                }
            }
        }

        if (type == null) {
            throw new RuntimeException(
                    "Could not find type for " + qualifiedTypeName + " in schema");
        }

        List particles = Schemas.getChildElementParticles(type, true);
        List properties = new ArrayList();
        Set<Name> unsubstPropertyNames = null;

        O:
        for (int i = 0; i < particles.size(); i++) {
            XSDParticle particle = (XSDParticle) particles.get(i);
            XSDElementDeclaration attribute = (XSDElementDeclaration) particle.getContent();

            if (attribute.isElementDeclarationReference()) {
                attribute = attribute.getResolvedElementDeclaration();
            }

            if (gml.qName("boundedBy")
                    .equals(new QName(attribute.getTargetNamespace(), attribute.getName()))) {
                BoundingBox bounds = getBoundedBy(feature, configuration);
                if (bounds != null) {
                    properties.add(new Object[] {particle, bounds});
                }
            } else if (featureType instanceof SimpleFeatureType) {
                // first simple feature hack, if the schema "overrides" gml attributes like
                // name and description, ignore the gml version
                boolean skip = false;
                if (gml.getNamespaceURI().equals(attribute.getTargetNamespace())) {
                    for (int j = i + 1; j < particles.size(); j++) {
                        XSDParticle particle2 = (XSDParticle) particles.get(j);
                        XSDElementDeclaration attribute2 =
                                (XSDElementDeclaration) particle2.getContent();
                        if (attribute2.isElementDeclarationReference()) {
                            attribute2 = attribute2.getResolvedElementDeclaration();
                        }
                        if (attribute2.getName().equals(attribute.getName())) {
                            skip = true;
                            break;
                        }
                    }
                }
                if (skip) {
                    continue;
                }

                // simple feature brain damage: discard namespace
                // make sure the feature type has an element
                if (!isValidDescriptor(featureType, new NameImpl(attribute.getName()))) {
                    continue;
                }
                // get the value
                Object attributeValue = ((SimpleFeature) feature).getAttribute(attribute.getName());
                if (attributeValue != null && attributeValue instanceof Geometry) {
                    Object obj = ((Geometry) attributeValue).getUserData();
                    Map<Object, Object> userData = new HashMap<Object, Object>();
                    if (obj != null && obj instanceof Map) {
                        userData.putAll((Map) obj);
                    }
                    userData.put(
                            CoordinateReferenceSystem.class,
                            featureType.getCoordinateReferenceSystem());
                    ((Geometry) attributeValue).setUserData(userData);
                }
                properties.add(new Object[] {particle, attributeValue});
            } else {
                // namespaces matter for non-simple feature types
                Name propertyName =
                        new NameImpl(attribute.getTargetNamespace(), attribute.getName());
                // make sure the feature type has an element
                if (!isValidDescriptor(featureType, propertyName)) {
                    continue;
                }
                Collection<Property> featureProperties = feature.getProperties(propertyName);
                // if no feature properties are found for this element check substitution groups
                if (featureProperties.size() == 0) {
                    if (unsubstPropertyNames == null) {
                        // lazy initialisation of a set of all property names that
                        // will be obtained without considering substitution groups
                        unsubstPropertyNames =
                                (Set<Name>)
                                        particles
                                                .stream()
                                                .map(
                                                        new Function() {

                                                            @Override
                                                            public Object apply(Object particle) {
                                                                XSDElementDeclaration attr =
                                                                        (XSDElementDeclaration)
                                                                                ((XSDParticle)
                                                                                                particle)
                                                                                        .getContent();
                                                                if (attr
                                                                        .isElementDeclarationReference()) {
                                                                    attr =
                                                                            attr
                                                                                    .getResolvedElementDeclaration();
                                                                }
                                                                return new NameImpl(
                                                                        attr.getTargetNamespace(),
                                                                        attr.getName());
                                                            }
                                                        })
                                                .collect(Collectors.toSet());
                    }
                    for (XSDElementDeclaration xsdElementDeclaration :
                            attribute.getSubstitutionGroup()) {
                        Name substPropertyName =
                                new NameImpl(
                                        xsdElementDeclaration.getTargetNamespace(),
                                        xsdElementDeclaration.getName());
                        if (!unsubstPropertyNames.contains(substPropertyName)) {
                            featureProperties = feature.getProperties(substPropertyName);
                            if (featureProperties.size() > 0) {
                                // the particle is used outside this class, replace
                                // the particle with the correct substituted element
                                particle =
                                        (XSDParticle) particle.cloneConcreteComponent(true, false);
                                particle.setContent(xsdElementDeclaration);
                                break;
                            }
                        }
                    }
                }
                // get the value (might be multiple)
                for (Property property : featureProperties) {
                    Object value;
                    if (property instanceof ComplexAttribute) {
                        // do not unpack complex attributes as these may have their own bindings,
                        // which
                        // will be applied by the encoder
                        value = property;
                    } else if (property instanceof GeometryAttribute) {
                        value = property.getValue();
                        if (value != null) {
                            // ensure CRS is passed to the Geometry object
                            Geometry geometry = (Geometry) value;
                            CoordinateReferenceSystem crs =
                                    ((GeometryAttribute) property)
                                            .getDescriptor()
                                            .getCoordinateReferenceSystem();
                            Map<Object, Object> userData = new HashMap<Object, Object>();
                            Object obj = geometry.getUserData();
                            if (obj != null && obj instanceof Map) {
                                userData.putAll((Map) obj);
                            }
                            userData.put(CoordinateReferenceSystem.class, crs);
                            geometry.setUserData(userData);
                        }
                    } else {
                        // non-complex bindings are unpacked as for simple feature case
                        value = property.getValue();
                    }
                    properties.add(new Object[] {particle, value});
                }
            }
        }

        return properties;
    }

