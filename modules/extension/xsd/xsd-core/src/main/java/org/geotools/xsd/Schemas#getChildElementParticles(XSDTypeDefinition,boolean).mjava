    /**
     * Returns a list of all child element particles that corresponde to element declarations of the
     * specified type, no order is guaranteed.
     *
     * <p>The <code>includeParents</code> flag controls if this method should returns those elements
     * defined on parent types.
     *
     * @param type THe type.
     * @param includeParents flag indicating if parent types should be processed
     * @return A list of {@link XSDParticle}.
     */
    public static final List<XSDParticle> getChildElementParticles(
            XSDTypeDefinition type, boolean includeParents) {
        final Set<XSDElementDeclaration> contents = new HashSet<>();
        final List<XSDParticle> particles = new ArrayList<>();
        TypeWalker.Visitor visitor =
                new TypeWalker.Visitor() {
                    public boolean visit(XSDTypeDefinition type) {
                        // simple types don't have children
                        if (type instanceof XSDSimpleTypeDefinition) {
                            return true;
                        }

                        XSDComplexTypeDefinition cType = (XSDComplexTypeDefinition) type;

                        ElementVisitor visitor =
                                new ElementVisitor() {
                                    public void visit(XSDParticle particle) {
                                        XSDElementDeclaration element =
                                                (XSDElementDeclaration) particle.getContent();

                                        if (element.isElementDeclarationReference()) {
                                            element = element.getResolvedElementDeclaration();
                                        }

                                        // make sure unique
                                        if (!contents.contains(element)) {
                                            contents.add(element);
                                            particles.add(particle);
                                        }
                                    }
                                };

                        visitElements(cType, visitor);

                        return true;
                    }
                };

        if (includeParents) {
            // walk up the type hierarchy of the element to generate a list of
            // possible elements
            new TypeWalker().rwalk(type, visitor);
        } else {
            // just visit this type
            visitor.visit(type);
        }

        return new ArrayList<>(particles);
    }

