    /**
     * Pre-parses the instance component checking the following:
     *
     * <p>
     */
    protected Object preParse(InstanceComponent instance) {
        // we only preparse text, so simple types
        XSDSimpleTypeDefinition type = null;

        if (instance.getTypeDefinition() instanceof XSDSimpleTypeDefinition) {
            type = (XSDSimpleTypeDefinition) instance.getTypeDefinition();
        } else {
            XSDComplexTypeDefinition complexType =
                    (XSDComplexTypeDefinition) instance.getTypeDefinition();

            if (complexType.getContentType() instanceof XSDSimpleTypeDefinition) {
                type = (XSDSimpleTypeDefinition) complexType.getContentType();
            }
        }

        String text = instance.getText();

        if (type != null) {
            // alright, lets preparse some text
            // first base on variety
            if (type.getVariety() == XSDVariety.LIST_LITERAL) {
                // list, whiteSpace is fixed to "COLLAPSE
                text = Whitespace.COLLAPSE.preparse(text);

                // lists are seperated by spaces
                String[] list = text.split(" +");

                // apply the facets
                // 1. length
                // 2. maxLength
                // 3. minLength
                // 4. enumeration
                //                if (type.getLengthFacet() != null) {
                //                    XSDLengthFacet length = type.getLengthFacet();
                //
                //                    if (list.length != length.getValue()) {
                //                        // validation exception
                //                    }
                //                }
                //
                //                if (type.getMaxLengthFacet() != null) {
                //                    XSDMaxLengthFacet length = type.getMaxLengthFacet();
                //
                //                    if (list.length > length.getValue()) {
                //                        // validation exception
                //                    }
                //                }
                //
                //                if (type.getMinLengthFacet() != null) {
                //                    XSDMinLengthFacet length = type.getMinLengthFacet();
                //
                //                    if (list.length < length.getValue()) {
                //                        // validation exception
                //                    }
                //                }

                //                if (!type.getEnumerationFacets().isEmpty()) {
                //                    // gather up all teh possible values
                //                    Set values = new HashSet();
                //
                //                    for (Iterator e = type.getEnumerationFacets().iterator();
                // e.hasNext(); ) {
                //                        XSDEnumerationFacet enumeration = (XSDEnumerationFacet)
                // e.next();
                //
                //                        for (Iterator v = enumeration.getValue().iterator();
                // v.hasNext(); ) {
                //                            values.add(v.next());
                //                        }
                //                    }
                //
                //                    for (int i = 0; i < list.length; i++) {
                //                        if (!values.contains(list[i])) {
                //                            // validation exception
                //                        }
                //                    }
                //                }

                // now we must parse the items up
                final XSDSimpleTypeDefinition itemType = type.getItemTypeDefinition();
                List<Object> parsed = new ArrayList<>();

                // create a pseudo declaration
                final XSDElementDeclaration element =
                        XSDFactory.eINSTANCE.createXSDElementDeclaration();
                element.setTypeDefinition(itemType);

                if (instance.getName() != null) {
                    element.setName(instance.getName());
                }

                if (instance.getNamespace() != null) {
                    element.setTargetNamespace(instance.getNamespace());
                }

                // create a new instance of the specified type
                InstanceComponentImpl theInstance =
                        new InstanceComponentImpl() {
                            public XSDTypeDefinition getTypeDefinition() {
                                return itemType;
                            }

                            public XSDNamedComponent getDeclaration() {
                                return element;
                            };
                        };

                for (int i = 0; i < list.length; i++) {
                    theInstance.setText(list[i]);

                    // perform the parse
                    ParseExecutor executor = new ParseExecutor(theInstance, null, context, parser);
                    parser.getBindingWalker().walk(element, executor, context);

                    parsed.add(executor.getValue());
                }

                return parsed;
            } else if (type.getVariety() == XSDVariety.UNION_LITERAL) {
                // union, "valueSpace" and "lexicalSpace" facets are the union of the contained
                // datatypes
                return text;
            } else {
                // atomic

                // walk through the facets and preparse as necessary
                for (Iterator f = type.getFacets().iterator(); f.hasNext(); ) {
                    XSDFacet facet = (XSDFacet) f.next();

                    if (facet instanceof XSDWhiteSpaceFacet && !parser.isCDATA()) {
                        XSDWhiteSpaceFacet whitespace = (XSDWhiteSpaceFacet) facet;

                        if (whitespace.getValue() == XSDWhiteSpace.REPLACE_LITERAL) {
                            text = Whitespace.REPLACE.preparse(text);
                        }

                        if (whitespace.getValue() == XSDWhiteSpace.COLLAPSE_LITERAL) {
                            text = Whitespace.COLLAPSE.preparse(text);
                        }

                        if (whitespace.getValue() == XSDWhiteSpace.PRESERVE_LITERAL) {
                            // XML spec seems to indicate that this is wrong, but then abstracts etc
                            // look wrong.
                            // https://www.w3.org/TR/xmlschema-2/#dt-whiteSpace
                            // however we need to not trim attributes as then GML coordinates don't
                            // work!
                            if (!(instance instanceof AttributeInstance)) {
                                text = text.trim();
                            }
                        }
                    }
                }

                return text;
            }
        } else {
            // type is not simple, or complex with simple content, do a check
            // for mixed
            if (instance.getTypeDefinition() instanceof XSDComplexTypeDefinition
                    && ((XSDComplexTypeDefinition) instance.getTypeDefinition()).isMixed()) {
                // Collapse the text, but don't do so for CDATA where it's meant to be preserved
                if (!parser.isCDATA()) {
                    text = Whitespace.COLLAPSE.preparse(text);
                }
            }
        }
        if (!parser.isCDATA()) {
            text = Whitespace.COLLAPSE.preparse(text);
        }
        return text;
    }

