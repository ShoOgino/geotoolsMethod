    public void encode(Object object, QName name, ContentHandler handler)
            throws IOException, SAXException {

        // maintain a stack of (encoding,element declaration pairs)
        Stack<EncodingEntry> encoded = null;

        // make sure the xs namespace is declared
        if (namespaces.getPrefix(XS.NAMESPACE) == null) {
            namespaces.declarePrefix("xs", XS.NAMESPACE);
        }

        try {
            serializer = handler;

            if (!inline) {
                serializer.startDocument();
            }

            if (namespaceAware) {
                // write out all the namespace prefix value mappings
                for (Enumeration e = namespaces.getPrefixes(); e.hasMoreElements(); ) {
                    String prefix = (String) e.nextElement();
                    String uri = namespaces.getURI(prefix);

                    if ("xml".equals(prefix)) {
                        continue;
                    }
                    serializer.startPrefixMapping(prefix, uri);
                }
                for (Map.Entry<String, String> stringStringEntry :
                        schema.getQNamePrefixToNamespaceMap().entrySet()) {
                    Map.Entry entry = (Map.Entry) stringStringEntry;
                    String pre = (String) entry.getKey();
                    String ns = (String) entry.getValue();

                    if (XSDUtil.SCHEMA_FOR_SCHEMA_URI_2001.equals(ns)) {
                        continue;
                    }

                    // skip ones already registered
                    if (namespaces.getPrefix(ns) != null) {
                        continue;
                    }
                    serializer.startPrefixMapping(pre != null ? pre : "", ns);
                    serializer.endPrefixMapping(pre != null ? pre : "");

                    namespaces.declarePrefix((pre != null) ? pre : "", ns);
                }

                // ensure a default namespace prefix set
                if (namespaces.getURI("") == null) {
                    namespaces.declarePrefix("", schema.getTargetNamespace());
                }
            }

            // create the document
            DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();

            try {
                doc = docFactory.newDocumentBuilder().newDocument();
            } catch (ParserConfigurationException e) {
                new IOException().initCause(e);
            }

            encoded = new Stack<>();

            // add the first entry
            XSDElementDeclaration root = index.getElementDeclaration(name);

            if (root == null) {
                // check for context hint, this is only used when running the encoder
                // in test mode
                QName typeDefintion = rootElementType;

                if (typeDefintion == null) {
                    typeDefintion =
                            (QName)
                                    context.getComponentInstance(
                                            "http://geotools.org/typeDefinition");
                }

                if (typeDefintion != null) {
                    XSDTypeDefinition type = index.getTypeDefinition(typeDefintion);

                    if (type == null) {
                        throw new NullPointerException();
                    }

                    // create a mock element declaration
                    root = XSDFactory.eINSTANCE.createXSDElementDeclaration();
                    root.setName(name.getLocalPart());
                    root.setTargetNamespace(name.getNamespaceURI());
                    root.setTypeDefinition(type);
                }
            }

            if (root == null) {
                String msg = "Could not find element declaration for:" + name;
                throw new IllegalArgumentException(msg);
            }

            encoded.add(new EncodingEntry(object, root, null));

            while (!encoded.isEmpty()) {
                EncodingEntry entry = encoded.peek();

                if (entry.encoding != null) {
                    // element has been started, get the next child
                    if (!entry.children.isEmpty()) {
                        Object[] child = entry.children.get(0);
                        XSDElementDeclaration element =
                                ((XSDElementDeclaration) child[0]).getResolvedElementDeclaration();
                        Iterator itr = (Iterator) child[1];

                        if (itr.hasNext()) {
                            Object next = itr.next();

                            // here we check for instanceof EncoderDelegate
                            if (next instanceof EncoderDelegate) {
                                // do not add entry to the stack, just delegate to encode
                                try {
                                    ((EncoderDelegate) next).encode(handler);
                                } catch (Exception e) {
                                    throw new RuntimeException(e);
                                }
                            } else {
                                if (next instanceof ComplexAttribute
                                        && relaxed
                                        && isNonStripedNestedElement(next, element)) {
                                    for (Property property :
                                            ((ComplexAttribute) next).getProperties()) {
                                        // add object sub properties, i.e. nested complex features
                                        encoded.push(new EncodingEntry(property, element, entry));
                                    }
                                } else {
                                    // add the next object to be encoded to the stack
                                    encoded.push(new EncodingEntry(next, element, entry));
                                }
                            }
                        } else {
                            // iterator done, close it
                            Object source = child[2];
                            closeIterator(itr, source);

                            // this child is done, remove from child list
                            entry.children.remove(0);
                        }
                    } else {
                        // no more children, finish the element
                        end(entry.encoding, entry.element);
                        encoded.pop();

                        // clean up the entry
                        entry.object = null;
                        entry.element = null;
                        entry.encoding = null;
                        entry.children = null;
                        entry.parent = null;
                    }
                } else {
                    // start the encoding of the entry

                    // first make sure the element is not abstract
                    if (entry.element.isAbstract()) {
                        // look for a non abstract substitute - substitution groups are subject to
                        // changes over time, so we make a copy to avoid being hit with a
                        // ConcurrentModificationException
                        List sub = safeCopy(entry.element.getSubstitutionGroup());

                        if (sub.size() > 0) {
                            // match up by type
                            List<Object[]> matches = new ArrayList<>();

                            for (Object o : sub) {
                                XSDElementDeclaration e = (XSDElementDeclaration) o;

                                if (e == null || e.equals(entry.element)) {
                                    continue;
                                }

                                if (e.getName() == null) {
                                    continue;
                                }

                                // look up the binding
                                Binding binding =
                                        bindingLoader.loadBinding(
                                                new QName(e.getTargetNamespace(), e.getName()),
                                                context);

                                if (binding == null) {
                                    // try the type
                                    XSDTypeDefinition type = e.getType();

                                    if (type == null || type.getName() == null) {
                                        continue;
                                    }

                                    binding =
                                            bindingLoader.loadBinding(
                                                    new QName(
                                                            type.getTargetNamespace(),
                                                            type.getName()),
                                                    context);
                                }

                                if (binding == null) {
                                    continue;
                                }

                                if (binding.getType() == null) {
                                    logger.warning(
                                            "Binding: "
                                                    + binding.getTarget()
                                                    + " returns null type.");
                                    continue;
                                }

                                // match up the type
                                if (binding.getType().isAssignableFrom(entry.object.getClass())) {
                                    // we have a match, store as an (element,binding) tuple
                                    matches.add(new Object[] {e, binding});
                                }
                            }

                            // if one, we are gold
                            if (matches.size() == 1) {
                                entry.element = (XSDElementDeclaration) matches.get(0)[0];
                            }
                            // if multiple we have a problem
                            else if (matches.size() > 0) {
                                if (logger.isLoggable(Level.FINE)) {
                                    StringBuffer msg =
                                            new StringBuffer(
                                                    "Found multiple non-abstract bindings for ");
                                    msg.append(entry.element.getName()).append(": ");

                                    for (Object[] match : matches) {
                                        msg.append(match.getClass().getName());
                                        msg.append(", ");
                                    }

                                    logger.fine(msg.toString());
                                }

                                // try sorting by the type of the binding
                                Collections.sort(matches, new MatchComparator());
                            }

                            if (matches.size() > 0) {
                                entry.element = (XSDElementDeclaration) matches.get(0)[0];
                            }

                            // if zero, just use the abstract element
                        }
                    }

                    if (entry.element.isAbstract()) {
                        logger.fine(entry.element.getName() + " is abstract");
                    }

                    entry.encoding =
                            entry.parent != null
                                    ? (Element)
                                            encode(
                                                    entry.object,
                                                    entry.element,
                                                    entry.parent.element.getType())
                                    : (Element) encode(entry.object, entry.element);

                    // add any more attributes
                    List attributes = index.getAttributes(entry.element);

                    for (Object value : attributes) {
                        XSDAttributeDeclaration attribute = (XSDAttributeDeclaration) value;

                        // do not encode the attribute if it has already been
                        // encoded by the parent
                        String ns = attribute.getTargetNamespace();
                        String local = attribute.getName();

                        if ((entry.encoding.getAttributeNS(ns, local) != null)
                                && !"".equals(entry.encoding.getAttributeNS(ns, local))) {
                            continue;
                        }

                        // get the object(s) for this attribute
                        GetPropertyExecutor executor =
                                new GetPropertyExecutor(entry.object, attribute);

                        BindingVisitorDispatch.walk(
                                object, bindingWalker, entry.element, executor, context);

                        if (executor.getChildObject() != null) {
                            // encode the attribute
                            Attr attr = (Attr) encode(executor.getChildObject(), attribute);

                            if (attr != null) {
                                entry.encoding.setAttributeNodeNS(attr);
                            }
                        }
                    }

                    // write out the leading edge of the element
                    if (schemaLocations != null) {
                        // root element, add schema locations if set
                        if (!schemaLocations.isEmpty()) {
                            // declare the schema instance mapping
                            serializer.startPrefixMapping("xsi", XSDUtil.SCHEMA_INSTANCE_URI_2001);
                            serializer.endPrefixMapping("xsi");
                            namespaces.declarePrefix("xsi", XSDUtil.SCHEMA_INSTANCE_URI_2001);

                            StringBuffer schemaLocation = new StringBuffer();

                            for (Iterator e = schemaLocations.entrySet().iterator();
                                    e.hasNext(); ) {
                                Map.Entry tuple = (Map.Entry) e.next();
                                String namespaceURI = (String) tuple.getKey();
                                String location = (String) tuple.getValue();

                                schemaLocation.append(namespaceURI + " " + location);

                                if (e.hasNext()) {
                                    schemaLocation.append(" ");
                                }
                            }

                            entry.encoding.setAttributeNS(
                                    XSDUtil.SCHEMA_INSTANCE_URI_2001,
                                    "xsi:schemaLocation",
                                    schemaLocation.toString());
                        }

                        schemaLocations = null;
                    }

                    start(entry.encoding, entry.element);

                    // TODO: this method of getting at properties won't maintain order very well,
                    // need
                    // to come up with a better system that is capable of handling feature types
                    for (PropertyExtractor propertyExtractor : propertyExtractors) {
                        if (propertyExtractor.canHandle(entry.object)) {
                            List extracted =
                                    propertyExtractor.properties(entry.object, entry.element);
                            O:
                            for (Object o : extracted) {
                                Object[] tuple = (Object[]) o;
                                XSDParticle particle = (XSDParticle) tuple[0];
                                XSDElementDeclaration child =
                                        (XSDElementDeclaration) particle.getContent();

                                if (child == null) {
                                    continue;
                                }

                                // check for a comment
                                if ((child != null)
                                        && (COMMENT.getNamespaceURI()
                                                .equals(child.getTargetNamespace()))
                                        && COMMENT.getLocalPart().equals(child.getName())) {
                                    comment(child.getElement());

                                    continue;
                                }

                                if (child.isElementDeclarationReference()) {
                                    child = child.getResolvedElementDeclaration();
                                }

                                // do not encode the element if the parent has already
                                // been encoded by the parent
                                String ns = child.getTargetNamespace();
                                String local = child.getName();

                                for (int i = 0;
                                        i < entry.encoding.getChildNodes().getLength();
                                        i++) {
                                    Node node = entry.encoding.getChildNodes().item(i);

                                    if (node instanceof Element) {
                                        if (ns != null) {
                                            if (ns.equals(node.getNamespaceURI())
                                                    && local.equals(node.getLocalName())) {
                                                continue O;
                                            }
                                        } else {
                                            if (local.equals(node.getLocalName())) {
                                                continue O;
                                            }
                                        }
                                    }
                                }

                                Object obj = tuple[1];

                                // if the value is null, can we skip it? Or do we have to go out
                                // with an non empty element with xs:nil?
                                if (obj == null) {
                                    if (particle.getMinOccurs() == 0) {
                                        // just skip it
                                        continue;
                                    } else if (!child.isNillable()) {
                                        // log an error and skip the element, but we're encoding
                                        // something invalid
                                        logger.fine(
                                                "Property "
                                                        + ns
                                                        + ":"
                                                        + local
                                                        + " not found but minoccurs > 0 ");
                                        // skip this regardless
                                        continue;
                                    }
                                    // minOccurs > 0 && nillable -> we'll encode an empty element
                                    // with xs:nil
                                }

                                // figure out the maximum number of occurrences
                                int maxOccurs = 1;

                                if (particle.isSetMaxOccurs()) {
                                    maxOccurs = particle.getMaxOccurs();
                                } else {
                                    // look the containing group
                                    if (particle.eContainer() instanceof XSDModelGroup) {
                                        XSDModelGroup group = (XSDModelGroup) particle.eContainer();

                                        if (group.eContainer() instanceof XSDParticle) {
                                            XSDParticle cParticle =
                                                    (XSDParticle) group.eContainer();

                                            if (cParticle.isSetMaxOccurs()) {
                                                maxOccurs = cParticle.getMaxOccurs();
                                            }
                                        }
                                    }
                                }

                                if ((maxOccurs == -1) || (maxOccurs > 1)) {
                                    // may have a collection or array, unwrap it
                                    Iterator iterator = null;

                                    if (obj instanceof Iterator) {
                                        iterator = (Iterator) obj;
                                    } else if (obj != null && obj.getClass().isArray()) {
                                        Object[] array = (Object[]) obj;
                                        iterator = Arrays.asList(array).iterator();
                                    } else if (obj instanceof Collection) {
                                        Collection collection = (Collection) obj;
                                        iterator = collection.iterator();
                                    } else if (obj instanceof FeatureCollection) {
                                        @SuppressWarnings("unchecked")
                                        FeatureCollection<FeatureType, Feature> collection =
                                                (FeatureCollection) obj;
                                        iterator = DataUtilities.iterator(collection.features());
                                    } else {
                                        iterator = new SingleIterator(obj);
                                    }

                                    entry.children.add(new Object[] {child, iterator, obj});
                                } else {
                                    // only one, just add the object
                                    entry.children.add(
                                            new Object[] {child, new SingleIterator(obj), obj});
                                }
                            }
                        }
                    }
                }
            }

            if (!inline) {
                serializer.endDocument();
            }

        } finally {
            // cleanup
            index.destroy();

            // close any iterators still present in the stack, this will only occur in an exception
            // case
            if (encoded != null) {
                while (!encoded.isEmpty()) {
                    EncodingEntry entry = encoded.pop();
                    if (!entry.children.isEmpty()) {
                        Object[] child = entry.children.get(0);
                        Iterator itr = (Iterator) child[1];
                        try {
                            closeIterator(itr, child[2]);
                        } catch (Exception e) {
                            // ignore, we are already in an error case.
                        }
                    }
                }
            }
            // TODO: there are probably other references to elements of XSDSchema objects, we should
            // kill them too
        }
    }

