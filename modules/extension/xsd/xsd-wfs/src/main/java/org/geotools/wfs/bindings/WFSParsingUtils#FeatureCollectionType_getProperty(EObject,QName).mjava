    public static Object FeatureCollectionType_getProperty(EObject fc, QName name) {
        List<FeatureCollection> features = features(fc);
        FeatureCollection first = features.get(0);

        if ("boundedBy".equals(name.getLocalPart())) {
            ReferencedEnvelope bounds = null;
            if (features.size() == 1) {
                bounds = first.getBounds();
            } else {
                // aggregate
                bounds = new ReferencedEnvelope(first.getBounds());
                for (int i = 1; i < features.size(); i++) {
                    bounds.expandToInclude(features.get(i).getBounds());
                }
            }
            if (bounds == null || bounds.isNull()) {
                // wfs 2.0 does not allow for "gml:Null"
                if (WFS.NAMESPACE.equals(name.getNamespaceURI())) {
                    return null;
                }
            }
            return bounds;
        }

        if ("featureMember".equals(name.getLocalPart()) || "member".equals(name.getLocalPart())) {
            if (features.size() == 1) {
                // just return the single
                return first;
            }

            // different behaviour across versions, in wfs < 2.0 we merge all the features into
            // a single collection, wfs 2.0+ we create a feature collection that contains multiple
            // feature collections
            if ("featureMember".equals(name.getLocalPart())) {
                // wrap in a single
                return new CompositeFeatureCollection(features);
            }

            // we need to recalculate numberMatched, and numberRetunred
            int numberMatched = -1;
            if (EMFUtils.has(fc, "numberMatched")) {
                Number n = (Number) EMFUtils.get(fc, "numberMatched");
                numberMatched = n != null ? n.intValue() : -1;
            } else if (EMFUtils.has(fc, "numberOfFeatures")) {
                Number n = (Number) EMFUtils.get(fc, "numberOfFeatures");
                numberMatched = n != null ? n.intValue() : -1;
            }

            // create new feature collections
            List<FeatureCollectionType> members = new ArrayList(features.size());
            for (Iterator<FeatureCollection> it = features.iterator(); it.hasNext(); ) {
                FeatureCollection featureCollection = it.next();

                FeatureCollectionType member = Wfs20Factory.eINSTANCE.createFeatureCollectionType();
                member.setTimeStamp((Calendar) EMFUtils.get(fc, "timeStamp"));
                member.getMember().add(featureCollection);
                members.add(member);

                if (numberMatched == -1) {
                    continue;
                }

                // TODO: calling size() here is bad because it requires a nother trip to the
                // underlying datastore... perhaps try to keep count of the size of each feature
                // collection at a higher level
                int size = featureCollection.size();

                member.setNumberReturned(BigInteger.valueOf(size));

                if (it.hasNext()) {
                    numberMatched -= size;
                    member.setNumberMatched(BigInteger.valueOf(size));
                } else {
                    member.setNumberMatched(BigInteger.valueOf(numberMatched));
                }
            }
            return members;
        }

        return null;
    }

