    /**
     * @see AbstractComplexBinding#getProperties(java.lang.Object,
     *     org.eclipse.xsd.XSDElementDeclaration)
     */
    @Override
    public List<Object[]> getProperties(Object object, XSDElementDeclaration element)
            throws Exception {
        if (object == null) {
            return null;
        }

        List<Object[ /* 2 */]> properties = new ArrayList<>();
        XSDTypeDefinition typeDef = element.getTypeDefinition();
        boolean isAnyType =
                typeDef.getName() != null
                        && typeDef.getTargetNamespace() != null
                        && typeDef.getName().equals(XS.ANYTYPE.getLocalPart())
                        && typeDef.getTargetNamespace().equals(XS.NAMESPACE);
        if (isAnyType) {
            Collection complexAtts;
            if (object instanceof Collection) {
                // collection of features
                complexAtts = (Collection) object;
            } else if (object instanceof ComplexAttribute) {
                // get collection of features from this attribute
                complexAtts = ((ComplexAttribute) object).getProperties();
            } else {
                return null;
            }
            for (Object complex : complexAtts) {
                if (complex instanceof ComplexAttribute) {
                    PropertyDescriptor descriptor = ((Attribute) complex).getDescriptor();
                    if (descriptor.getUserData() != null) {
                        Object propertyElement =
                                descriptor.getUserData().get(XSDElementDeclaration.class);
                        if (propertyElement != null
                                && propertyElement instanceof XSDElementDeclaration) {
                            XSDParticle substitutedChildParticle =
                                    XSDFactory.eINSTANCE.createXSDParticle();
                            substitutedChildParticle.setMaxOccurs(descriptor.getMaxOccurs());
                            substitutedChildParticle.setMinOccurs(descriptor.getMinOccurs());
                            XSDElementDeclaration wrapper =
                                    XSDFactory.eINSTANCE.createXSDElementDeclaration();
                            wrapper.setResolvedElementDeclaration(
                                    (XSDElementDeclaration) propertyElement);
                            substitutedChildParticle.setContent(wrapper);
                            properties.add(new Object[] {substitutedChildParticle, complex});
                        }
                    }
                }
            }
            return properties;
        }
        if (object instanceof ComplexAttribute) {
            ComplexAttribute complex = (ComplexAttribute) object;
            for (XSDParticle childParticle :
                    Schemas.getChildElementParticles(element.getTypeDefinition(), true)) {
                XSDElementDeclaration childElement =
                        (XSDElementDeclaration) childParticle.getContent();
                if (childElement.isElementDeclarationReference()) {
                    childElement = childElement.getResolvedElementDeclaration();
                }
                for (XSDElementDeclaration e : childElement.getSubstitutionGroup()) {
                    Name name = new NameImpl(e.getTargetNamespace(), e.getName());
                    Collection<Property> nameProperties = complex.getProperties(name);
                    if (!nameProperties.isEmpty()) {
                        // Particle creation stolen from BindingPropertyExtractor.
                        // I do not know why a wrapper is required; monkey see, monkey do.
                        // Without the wrapper, get an NPE in BindingPropertyExtractor.
                        XSDParticle substitutedChildParticle =
                                XSDFactory.eINSTANCE.createXSDParticle();
                        substitutedChildParticle.setMaxOccurs(childParticle.getMaxOccurs());
                        substitutedChildParticle.setMinOccurs(childParticle.getMinOccurs());
                        XSDElementDeclaration wrapper =
                                XSDFactory.eINSTANCE.createXSDElementDeclaration();
                        wrapper.setResolvedElementDeclaration(e);
                        substitutedChildParticle.setContent(wrapper);
                        for (Property property : nameProperties) {
                            /*
                             * Note : Returning simple feature value is not necessary as it has been
                             * taken care in the 1st For Loop of BindingPropertyExtractor.java -
                             * List properties(Object, XSDElementDeclaration) method
                             */
                            if (property instanceof ComplexAttribute) {
                                properties.add(new Object[] {substitutedChildParticle, property});
                            } else if (property instanceof GeometryAttribute) {
                                Object attType =
                                        complex.getType()
                                                .getUserData()
                                                .get(XSDTypeDefinition.class);
                                boolean duplicate = false;
                                // handle substitution group for geometries too, but make sure
                                // it's not already handled in BindingPropertyExtractor
                                // otherwise it would be encoded as xlink:href as the id has already
                                // been seen
                                if (attType != null && attType instanceof XSDTypeDefinition) {
                                    XSDTypeDefinition attTypeDef = (XSDTypeDefinition) attType;
                                    for (XSDParticle attChild :
                                            Schemas.getChildElementParticles(attTypeDef, true)) {
                                        XSDElementDeclaration childEl =
                                                (XSDElementDeclaration) attChild.getContent();
                                        if (childEl.isElementDeclarationReference()) {
                                            childEl = childEl.getResolvedElementDeclaration();
                                        }
                                        if (childEl.equals(e)) {
                                            duplicate = true;
                                            break;
                                        }
                                    }
                                }
                                if (!duplicate) {
                                    properties.add(
                                            new Object[] {
                                                substitutedChildParticle, property.getValue()
                                            });
                                }
                            }
                        }
                    }
                }
            }
        }

        List<XSDParticle> anyElementParticles =
                new ArrayList<>(Schemas.getAnyElementParticles(element.getTypeDefinition()));
        if (!anyElementParticles.isEmpty()) {
            Collection complexAtts = null;
            if (object instanceof Collection) {
                // collection of features
                complexAtts = (Collection) object;
            } else if (object instanceof ComplexAttribute) {
                // get collection of features from this attribute
                complexAtts = ((ComplexAttribute) object).getProperties();
            }
            if (complexAtts == null) complexAtts = Collections.emptyList();

            // If child elements can't be retrieved from
            // Schemas.getChildElementParticles(element.getTypeDefinition(), true)),
            // properties list is empty. In this case, add all the complex
            // attributes in the object to the properties list.
            if (properties.isEmpty()) {
                for (Object complex : complexAtts) {
                    // only process complex attributes
                    if (complex instanceof ComplexAttribute) {
                        ComplexAttribute newComplexAtt = (ComplexAttribute) complex;
                        PropertyDescriptor descriptor = newComplexAtt.getDescriptor();
                        if (descriptor.getUserData() != null) {
                            Object propertyElement =
                                    descriptor.getUserData().get(XSDElementDeclaration.class);
                            if (propertyElement != null
                                    && propertyElement instanceof XSDElementDeclaration) {
                                XSDParticle substitutedChildParticle =
                                        XSDFactory.eINSTANCE.createXSDParticle();
                                substitutedChildParticle.setMaxOccurs(descriptor.getMaxOccurs());
                                substitutedChildParticle.setMinOccurs(descriptor.getMinOccurs());
                                XSDElementDeclaration wrapper =
                                        XSDFactory.eINSTANCE.createXSDElementDeclaration();
                                wrapper.setResolvedElementDeclaration(
                                        (XSDElementDeclaration) propertyElement);
                                substitutedChildParticle.setContent(wrapper);
                                properties.add(
                                        new Object[] {substitutedChildParticle, newComplexAtt});
                            }
                        }
                    }
                }
            }

            /*
             * properties list is not empty.
             *
             * It's possible <any> and <element> co-exist in the same type. For example,
             *
             * <sequence>
             *     <any/>
             *     <element name="..." type="...">
             * </sequence>
             *
             * In this case, only add <any> complex attributes to the properties list. The following
             * code is not covered in unit test, as app-schema, doesn't support <any> as a
             * targetAttribute in a mapping file.
             */
            else {
                List<XSDParticle> elementParticles =
                        new ArrayList<>(
                                Schemas.getChildElementParticles(
                                        element.getTypeDefinition(), false));
                for (Object complex : complexAtts) {
                    if (complex instanceof ComplexAttribute) {
                        ComplexAttribute newComplexAtt = (ComplexAttribute) complex;
                        PropertyDescriptor descriptor = ((Attribute) complex).getDescriptor();
                        if (descriptor.getUserData() != null) {
                            Object propertyElement =
                                    descriptor.getUserData().get(XSDElementDeclaration.class);
                            if (propertyElement != null
                                    && propertyElement instanceof XSDElementDeclaration) {
                                XSDParticle substitutedChildParticle =
                                        XSDFactory.eINSTANCE.createXSDParticle();
                                substitutedChildParticle.setMaxOccurs(descriptor.getMaxOccurs());
                                substitutedChildParticle.setMinOccurs(descriptor.getMinOccurs());
                                XSDElementDeclaration wrapper =
                                        XSDFactory.eINSTANCE.createXSDElementDeclaration();
                                wrapper.setResolvedElementDeclaration(
                                        (XSDElementDeclaration) propertyElement);
                                substitutedChildParticle.setContent(wrapper);
                                boolean propertyExist = false;
                                for (XSDParticle childParticle : elementParticles) {
                                    XSDElementDeclaration childElement =
                                            (XSDElementDeclaration) childParticle.getContent();
                                    if (childElement.isElementDeclarationReference()) {
                                        childElement = childElement.getResolvedElementDeclaration();
                                    }
                                    String existingName = childElement.getName();
                                    String newName =
                                            newComplexAtt.getDescriptor().getName().getLocalPart();
                                    if (existingName.equals(newName)) {
                                        propertyExist = true;
                                        break;
                                    }
                                }
                                if (!propertyExist) {
                                    properties.add(
                                            new Object[] {substitutedChildParticle, newComplexAtt});
                                }
                            }
                        }
                    }
                }
            }
        }
        return properties;
    }

