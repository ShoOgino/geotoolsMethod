    /**
     * Creates a list of {@link org.geotools.data.complex.AttributeMapping} from the attribute
     * mapping configurations in the provided list of {@link AttributeMapping}
     */
    private List<AttributeMapping> getAttributeMappings(
            final AttributeDescriptor root,
            final List attDtos,
            String itemXpath,
            CoordinateReferenceSystem crs,
            boolean isJDBC)
            throws IOException {
        List<AttributeMapping> attMappings = new LinkedList<>();

        /** Label and parent label are specific for web service backend */
        for (Object dto : attDtos) {

            org.geotools.data.complex.config.AttributeMapping attDto;
            attDto = (org.geotools.data.complex.config.AttributeMapping) dto;

            String idExpr = attDto.getIdentifierExpression();
            String idXpath = null;
            if (idExpr == null) {
                // this might be because it's an XPath expression
                idXpath = attDto.getIdentifierPath();
                if (idXpath != null) {
                    // validate without indexed elements
                    final StepList inputXPathSteps =
                            XPath.steps(root, itemXpath + "/" + idXpath, namespaces);
                    validateConfiguredNamespaces(inputXPathSteps);
                }
            }

            String sourceExpr = attDto.getSourceExpression();
            String inputXPath = null;
            if (sourceExpr == null) {
                // this might be because it's an XPath expression
                inputXPath = attDto.getInputAttributePath();
                if (inputXPath != null) {
                    final StepList inputXPathSteps =
                            XPath.steps(root, itemXpath + "/" + inputXPath, namespaces);
                    validateConfiguredNamespaces(inputXPathSteps);
                }
            }
            String expectedInstanceTypeName = attDto.getTargetAttributeSchemaElement();

            final String targetXPath = attDto.getTargetAttributePath();
            final StepList targetXPathSteps = XPath.steps(root, targetXPath, namespaces);
            validateConfiguredNamespaces(targetXPathSteps);

            final boolean isMultiValued = attDto.isMultiple();

            final Expression idExpression =
                    (idXpath == null)
                            ? parseOgcCqlExpression(idExpr)
                            : new AttributeExpressionImpl(
                                    idXpath,
                                    new Hints(
                                            FeaturePropertyAccessorFactory.NAMESPACE_CONTEXT,
                                            this.namespaces));
            // if the data source is a data access, the input XPath expression is the source
            // expression
            final Expression sourceExpression;

            sourceExpression =
                    (inputXPath == null)
                            ? parseOgcCqlExpression(sourceExpr)
                            : new AttributeExpressionImpl(
                                    inputXPath,
                                    new Hints(
                                            FeaturePropertyAccessorFactory.NAMESPACE_CONTEXT,
                                            this.namespaces));

            final AttributeType expectedInstanceOf;

            final Map<Name, Expression> clientProperties = getClientProperties(attDto);

            if (expectedInstanceTypeName != null) {
                Name expectedNodeTypeName = Types.degloseName(expectedInstanceTypeName, namespaces);
                expectedInstanceOf = typeRegistry.getAttributeType(expectedNodeTypeName, null, crs);
                if (expectedInstanceOf == null) {
                    String msg =
                            "mapping expects and instance of "
                                    + expectedNodeTypeName
                                    + " for attribute "
                                    + targetXPath
                                    + " but the attribute descriptor was not found";
                    throw new DataSourceException(msg);
                }
            } else {
                expectedInstanceOf = null;
            }
            AttributeMapping attMapping;
            String sourceElement = attDto.getLinkElement();
            if (sourceElement != null) {
                // nested complex attributes, this could be a function expression for polymorphic
                // types
                Expression elementExpr = parseOgcCqlExpression(sourceElement);
                String sourceField = attDto.getLinkField();
                StepList sourceFieldSteps = null;
                if (sourceField != null) {
                    // it could be null for polymorphism mapping,
                    // i.e. when the linked element maps to the same table as the container mapping
                    sourceFieldSteps = XPath.steps(root, sourceField, namespaces);
                }
                // a nested feature
                NestedAttributeMapping customNestedMapping =
                        CustomImplementationsFinder.find(
                                this,
                                idExpression,
                                sourceExpression,
                                targetXPathSteps,
                                isMultiValued,
                                clientProperties,
                                elementExpr,
                                sourceFieldSteps,
                                namespaces);
                if (customNestedMapping != null) {
                    attMapping = customNestedMapping;
                } else if (isJoining() && isJDBC) {
                    attMapping =
                            new JoiningNestedAttributeMapping(
                                    idExpression,
                                    sourceExpression,
                                    targetXPathSteps,
                                    isMultiValued,
                                    clientProperties,
                                    elementExpr,
                                    sourceFieldSteps,
                                    namespaces);
                } else {
                    attMapping =
                            new NestedAttributeMapping(
                                    idExpression,
                                    sourceExpression,
                                    targetXPathSteps,
                                    isMultiValued,
                                    clientProperties,
                                    elementExpr,
                                    sourceFieldSteps,
                                    namespaces);
                }

            } else {
                attMapping =
                        new AttributeMapping(
                                idExpression,
                                sourceExpression,
                                attDto.getSourceIndex(),
                                targetXPathSteps,
                                expectedInstanceOf,
                                isMultiValued,
                                clientProperties,
                                attDto.getMultipleValue());
            }

            if (attDto.isList()) {
                attMapping.setList(true);
            }

            if (attDto.encodeIfEmpty()) {
                attMapping.setEncodeIfEmpty(true);
            }

            /** Label and parent label are specific for web service backend */
            if (attDto.getLabel() != null) {
                attMapping.setLabel(attDto.getLabel());
            }
            if (attDto.getParentLabel() != null) {
                attMapping.setParentLabel(attDto.getParentLabel());
            }
            if (attDto.getInstancePath() != null) {
                attMapping.setInstanceXpath(attDto.getInstancePath());
            }

            // sets the external index (e.g. Solr) field for the current attribute mapping
            // the value will be NULL if no external index is being used
            attMapping.setIndexField(attDto.getIndexField());

            attMappings.add(attMapping);
        }
        return attMappings;
    }

