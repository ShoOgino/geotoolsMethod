    /** Gets a feature reader for a JDBC multivalued mapping. */
    public FeatureReader<SimpleFeatureType, SimpleFeature> getJoiningReaderInternal(
            JdbcMultipleValue mv, JoiningQuery query) throws IOException {
        // split the filter
        Filter[] split = splitFilter(query.getFilter());
        Filter preFilter = split[0];
        Filter postFilter = split[1];

        if (postFilter != null && postFilter != Filter.INCLUDE) {
            throw new IllegalArgumentException("Postfilters not allowed in Joining Queries");
        }

        // rebuild a new query with the same params, but just the pre-filter
        JoiningQuery preQuery = new JoiningQuery(query);
        preQuery.setFilter(preFilter);
        preQuery.setRootMapping(query.getRootMapping());

        // Build the feature type returned by this query. Also build an eventual extra feature type
        // containing the attributes we might need in order to evaluate the post filter
        SimpleFeatureType querySchema;
        if (query.getPropertyNames() == Query.ALL_NAMES) {
            querySchema = getSchema();
        } else {
            querySchema = SimpleFeatureTypeBuilder.retype(getSchema(), query.getPropertyNames());
        }
        // rebuild and add primary key column if there's no idExpression pointing to a database
        // column
        // this is so we can retrieve the PK later to use for feature chaining grouping
        SimpleFeatureType fullSchema =
                (query.hasIdColumn() && query.getQueryJoins() == null)
                        ? querySchema
                        : getFeatureType(querySchema, query);

        // grab connection
        Connection cx = getDataStore().getConnection(getState().getTransaction());

        // create the reader
        FeatureReader<SimpleFeatureType, SimpleFeature> reader;

        try {
            // this allows PostGIS to page the results and respect the fetch size
            if (getState().getTransaction() == Transaction.AUTO_COMMIT) {
                cx.setAutoCommit(false);
            }

            // build up a statement for the content
            String sql = selectSQL(querySchema, preQuery, null);
            getDataStore().getLogger().fine(sql);

            StringBuffer finalSql = new StringBuffer();
            finalSql.append("SELECT ");
            SimpleFeatureType featureType = getDataStore().getSchema(mv.getTargetTable());
            PrimaryKey primaryKeys = getDataStore().getPrimaryKey(featureType);
            for (PrimaryKeyColumn primaryKey : primaryKeys.getColumns()) {
                encodeColumnName(finalSql, mv.getTargetTable(), primaryKey.getName());
                finalSql.append(", ");
            }
            for (String property : mv.getProperties()) {
                encodeColumnName(finalSql, mv.getTargetTable(), property);
                finalSql.append(", ");
            }
            finalSql.delete(finalSql.length() - 2, finalSql.length());
            // encode value expression
            FilterToSQL cfToSql = createFilterToSQL(getDataStore().getSchema(mv.getTargetTable()));
            cfToSql.setFieldEncoder(
                    field -> {
                        StringBuffer fieldSql = new StringBuffer();
                        getDataStore().dialect.encodeTableName(mv.getTargetTable(), fieldSql);
                        fieldSql.append(".");
                        fieldSql.append(field);
                        return fieldSql.toString();
                    });
            finalSql.append(" FROM ");
            getDataStore().encodeTableName(mv.getTargetTable(), finalSql, null);
            finalSql.append(" INNER JOIN (").append(sql).append(") AS ");
            getDataStore().dialect.encodeTableName("mv", finalSql);
            finalSql.append(" ON ");
            getDataStore().dialect.encodeTableName("mv", finalSql);
            finalSql.append(".");
            getDataStore().dialect.encodeColumnName(null, mv.getSourceColumn(), finalSql);
            finalSql.append(" = ");
            getDataStore().encodeTableName(mv.getTargetTable(), finalSql, null);
            finalSql.append(".");
            getDataStore().dialect.encodeColumnName(null, mv.getTargetColumn(), finalSql);
            SimpleFeatureTypeBuilder b = new SimpleFeatureTypeBuilder();
            b.setName(new NameImpl(null, mv.getTargetTable()));
            b.add("id", Object.class);
            b.add("value", Object.class);
            query.setPropertyNames(mv.getProperties());
            SimpleFeatureType featrueType =
                    SimpleFeatureTypeBuilder.retype(
                            getDataStore().getSchema(mv.getTargetTable()),
                            query.getPropertyNames());
            reader = new JDBCFeatureReader(finalSql.toString(), cx, this, featrueType, query);
        } catch (Exception e) {
            // close the connection
            getDataStore().closeSafe(cx);
            // safely rethrow
            throw (IOException) new IOException().initCause(e);
        }

        return reader;
    }

