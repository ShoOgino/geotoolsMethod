    /**
     * Create order by field for specific table name
     * 
     * @param tableName
     * @param sort
     * @param orderByFields
     * @param sql 
     * @throws IOException
     * @throws SQLException
     */
    protected void sort(String tableName, SortBy[] sort , Set<String> orderByFields, boolean alias, StringBuffer sql) throws IOException, SQLException {        
        for (int i = 0; i < sort.length; i++) {
            if(SortBy.NATURAL_ORDER.equals(sort[i])|| SortBy.REVERSE_ORDER.equals(sort[i])) {
                throw new IOException("Cannot do natural order in joining queries");                    
            } else {
                StringBuffer mySql = new StringBuffer();
                if (alias) {
                   encodeColumnName2(sort[i].getPropertyName().getPropertyName(), tableName, mySql, null);
                } else {
                   encodeColumnName(sort[i].getPropertyName().getPropertyName(), tableName, mySql, null);
                }
                if (!mySql.toString().isEmpty() && orderByFields.add(mySql.toString())) {
                	// if it's not already in ORDER BY (because you can't have duplicate column names in order by)
                	// add it to the query buffer
                	if (orderByFields.size() > 1) {
                		sql.append(", ");                		
                	}
                	sql.append(mySql);

                    if (sort[i].getSortOrder() == SortOrder.DESCENDING) {
                        sql.append(" DESC");
                    } else {
                        sql.append(" ASC");
                    }                	
                }
            }
        }
    }

