    /** Helper method that gets the values associated with multivalued mapping. */
    private List<MultiValueContainer> extractMultipleValues(
            Feature sourceFeature, AttributeMapping attributeMapping) throws IOException {
        MultipleValue multipleValue = attributeMapping.getMultipleValue();
        if (!(multipleValue instanceof JdbcMultipleValue)) {
            // extension point for multiple values support (e.g. Solr)
            List<Object> values = multipleValue.getValues(sourceFeature, attributeMapping);
            return MultiValueContainer.toList(sourceFeature, values);
        }
        // jdbc multiple values are explicitly handled
        JdbcMultipleValue jdbcMultipleValue = (JdbcMultipleValue) multipleValue;
        // let's see if we have the multiple values already in cache
        Map<Object, List<MultiValueContainer>> candidates = jdbcMultiValues.get(jdbcMultipleValue);
        if (candidates == null) {
            candidates = new HashMap<>();
            // we need to get the values from the jdbc based data source
            if (!(mappedSource instanceof JoiningJDBCFeatureSource)) {
                // ouch, this should a jdbc based data source
                throw new RuntimeException(
                        String.format(
                                "JDBC multi values only work with JDBC based data sources, got '%s'.",
                                mappedSource.getName()));
            }
            JoiningJDBCFeatureSource jdbcDataSource = (JoiningJDBCFeatureSource) mappedSource;
            // query the multiple values
            FeatureReader<SimpleFeatureType, SimpleFeature> featuresReader =
                    jdbcDataSource.getJoiningReaderInternal(
                            jdbcMultipleValue, (JoiningQuery) this.query);
            // read and cache the multiple values obtained
            while (featuresReader.hasNext()) {
                SimpleFeature readFeature = featuresReader.next();
                // get the read feature foreign key associated value
                Object targetColumnValue =
                        readFeature.getProperty(jdbcMultipleValue.getTargetColumn()).getValue();
                List<MultiValueContainer> candidatesValues = candidates.get(targetColumnValue);
                if (candidatesValues == null) {
                    // no values yet for the current foreign key value
                    candidatesValues = new ArrayList<>();
                    candidates.put(targetColumnValue, candidatesValues);
                }
                Object targetValue = jdbcMultipleValue.getTargetValue().evaluate(readFeature);
                candidatesValues.add(new MultiValueContainer(readFeature, targetValue));
            }
            jdbcMultiValues.put(jdbcMultipleValue, candidates);
        }
        // get the multiple values for the current jdbc multiple values attribute
        Object sourceColumnValue =
                sourceFeature.getProperty(jdbcMultipleValue.getSourceColumn()).getValue();
        return candidates.get(sourceColumnValue);
    }

