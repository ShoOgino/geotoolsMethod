    /**
     * Get matching input features that are stored in this mapping using a supplied link value.
     *
     * @return The matching input feature
     */
    @Override
    public List<Feature> getInputFeatures(
            Object caller,
            Object foreignKeyValue,
            List<Object> idValues,
            Object feature,
            CoordinateReferenceSystem reprojection,
            List<PropertyName> selectedProperties,
            boolean includeMandatory)
            throws IOException {

        if (isSameSource()) {
            // if linkField is null, this method shouldn't be called because the mapping
            // should use the same table, and handles it differently
            throw new UnsupportedOperationException(
                    "Link field is missing from feature chaining mapping!");
        }

        @SuppressWarnings("PMD.CloseResource") // not managed here
        Transaction transaction = null;
        if (caller instanceof AbstractMappingFeatureIterator) {
            transaction = ((AbstractMappingFeatureIterator) caller).getTransaction();
        }

        Instance instance = instances.get(caller);
        if (instance == null) {
            throw new IllegalArgumentException(
                    "Trying to read Joining Nested Attribute Mapping that is not open.");
        }

        Object featureTypeName = getNestedFeatureType(feature);
        if (featureTypeName == null || !(featureTypeName instanceof Name)) {
            throw new IllegalArgumentException(
                    "Internal error: Feature type name expected but found " + featureTypeName);
        }
        @SuppressWarnings("PMD.CloseResource") // not managed here (field, closed later)
        DataAccessMappingFeatureIterator featureIterator =
                instance.featureIterators.get(featureTypeName);
        if (featureIterator == null) {
            featureIterator =
                    initSourceFeatures(
                            instance,
                            (Name) featureTypeName,
                            reprojection,
                            selectedProperties,
                            includeMandatory,
                            0,
                            null,
                            transaction);
        }
        Expression nestedSourceExpression = instance.nestedSourceExpressions.get(featureTypeName);
        if (nestedSourceExpression == null) {
            throw new IllegalArgumentException(
                    "Internal error: nested source expression expected but found "
                            + featureTypeName);
        }

        ArrayList<Feature> matchingFeatures = new ArrayList<>();

        if (featureIterator != null) {
            while (featureIterator.hasNext()
                    && featureIterator
                            .peekNextValue(nestedSourceExpression)
                            .toString()
                            .equals(foreignKeyValue.toString())
                    && featureIterator.checkForeignIdValues(idValues)) {
                matchingFeatures.addAll(featureIterator.skip());
            }
        }

        // skip all others
        for (Name name : instance.featureIterators.keySet()) {
            @SuppressWarnings("PMD.CloseResource") // not managed here, field, closed later
            DataAccessMappingFeatureIterator fIt = instance.featureIterators.get(name);
            if (fIt != featureIterator) {
                skipFeatures(
                        fIt, instance.nestedSourceExpressions.get(name), foreignKeyValue, idValues);
            }
        }
        instance.skipped.add(new Instance.Skip(idValues));

        return matchingFeatures;
    }

