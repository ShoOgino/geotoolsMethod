    /**
     * Generates a 'SELECT p1, p2, ... FROM ... WHERE ...' prepared statement.
     * 
     * @param featureType
     *            the feature type that the query must return (may contain less attributes than the
     *            native one)
     * @param attributes
     *            the properties queried, or {@link Query#ALL_NAMES} to gather all of them
     * @param query
     *            the query to be run. The type name and property will be ignored, as they are
     *            supposed to have been already embedded into the provided feature type
     * @param cx
     *            The database connection to be used to create the prepared statement
     * @throws SQLException 
     * @throws IOException 
     * @throws FilterToSQLException
     */
    protected String selectSQL(SimpleFeatureType featureType, JoiningQuery query, AtomicReference<PreparedFilterToSQL> toSQLref) throws IOException, SQLException, FilterToSQLException {
        
        // first we create from clause, for aliases
        
        StringBuffer fromclause = new StringBuffer();
        getDataStore().encodeTableName(featureType.getTypeName(), fromclause, query.getHints());
        
        //joining
        Set<String> tableNames = new HashSet<String>();
        
        String lastTypeName = featureType.getTypeName();
        String curTypeName = lastTypeName;
        
        String[] aliases = null;
        
        if (query.getQueryJoins() != null) {
            
            aliases = new String[query.getQueryJoins().size()];
            
            for (int i=0; i< query.getQueryJoins().size(); i++) {
                JoiningQuery.QueryJoin join = query.getQueryJoins().get(i);
                
                fromclause.append(" INNER JOIN ");
                String alias = null;
                
                FilterToSQL toSQL1 = createFilterToSQL(getDataStore().getSchema(lastTypeName));
                FilterToSQL toSQL2 = createFilterToSQL(getDataStore().getSchema(join.getJoiningTypeName()));
                
                String last_alias = createAlias(lastTypeName, tableNames);                        
                tableNames.add(last_alias);
                curTypeName = last_alias;       
                if (tableNames.contains(join.getJoiningTypeName()) ) {
                    alias = createAlias(join.getJoiningTypeName(), tableNames);

                    aliases[i] = alias;
                    
                    getDataStore().encodeTableName(join.getJoiningTypeName(), fromclause, query.getHints());
                    fromclause.append(" ");
                    getDataStore().dialect.encodeTableName(alias, fromclause);
                    fromclause.append(" ON ( ");
                    
                    toSQL2.setFieldEncoder(new JoiningFieldEncoder(alias));                 
                    fromclause.append(toSQL2.encodeToString(join.getForeignKeyName()));
                    
                } else {
                    aliases[i] = null;
                    getDataStore().encodeTableName(join.getJoiningTypeName(), fromclause, query.getHints());
                    fromclause.append(" ON ( ");
                    toSQL2.setFieldEncoder(new JoiningFieldEncoder(join.getJoiningTypeName()));                 
                    fromclause.append(toSQL2.encodeToString(join.getForeignKeyName()));                    
                }
                fromclause.append(" = ");
                toSQL1.setFieldEncoder(new JoiningFieldEncoder(curTypeName));                 
                fromclause.append(toSQL1.encodeToString(join.getJoiningKeyName()));
                fromclause.append(") ");      
                lastTypeName = join.getJoiningTypeName();
                curTypeName = alias == null ? lastTypeName : alias;
            }
        }
        
        //begin sql
        StringBuffer sql = new StringBuffer();
        sql.append("SELECT ");
        
        // primary key
        PrimaryKey key = null;

        try {
            key = getDataStore().getPrimaryKey(featureType);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        Set<String> pkColumnNames = new HashSet<String>();
        String colName;
        for ( PrimaryKeyColumn col : key.getColumns() ) {
            colName = col.getName();
            encodeColumnName(colName, featureType.getTypeName(), sql, query.getHints());
            sql.append(",");
            pkColumnNames.add(colName);
        }
        
        //other columns
        for (AttributeDescriptor att : featureType.getAttributeDescriptors()) {
            // skip the eventually exposed pk column values
            String columnName = att.getLocalName();
            if(pkColumnNames.contains(columnName))
                continue;
            
            if (att instanceof GeometryDescriptor) {
                //encode as geometry
                encodeGeometryColumn((GeometryDescriptor) att, featureType.getTypeName(), sql, query.getHints());

                //alias it to be the name of the original geometry
                getDataStore().dialect.encodeColumnAlias(columnName, sql);
            } else {
                encodeColumnName(columnName, featureType.getTypeName(), sql, query.getHints());
                
            }

            sql.append(",");
        }
        
        if (query.getQueryJoins() != null && query.getQueryJoins().size() > 0) {
            for (int i = 0; i < query.getQueryJoins().size(); i++) {
                for (int j = 0; j < query.getQueryJoins().get(i).getSortBy().length; j++) {
                    if (aliases[i] != null) {
                        getDataStore().dialect.encodeColumnName(aliases[i], query.getQueryJoins()
                                .get(i).getSortBy()[j].getPropertyName().getPropertyName(), sql);
                    } else {
                        encodeColumnName(query.getQueryJoins().get(i).getSortBy()[j]
                                .getPropertyName().getPropertyName(), query.getQueryJoins().get(i)
                                .getJoiningTypeName(), sql, query.getHints());
                        
                    }
                    sql.append(" ").append(FOREIGN_ID + "_" + i + "_" + j).append(",");                    
                }
            }
        }
        
        sql.setLength(sql.length() - 1);        

        sql.append(" FROM ");
        
        sql.append(fromclause);
        
        //filtering
        FilterToSQL toSQL = null;
        Filter filter = query.getFilter();
        if (filter != null && !Filter.INCLUDE.equals(filter)) {
            //encode filter
            try {
                SortBy[] lastSortBy = null;
                // leave it as null if it's asking for a subset, since we don't want to join to get
                // other rows of same id
                // since we don't want a full feature, but a subset only
                if (!query.isSubset()) {
                    // grab the full feature type, as we might be encoding a filter
                    // that uses attributes that aren't returned in the results
                    lastSortBy = query.getQueryJoins() == null || query.getQueryJoins().size() == 0 ? query
                            .getSortBy() : query.getQueryJoins()
                            .get(query.getQueryJoins().size() - 1).getSortBy();
                }
                String lastTableName = query.getQueryJoins() == null || query.getQueryJoins().size()== 0 ? query.getTypeName() :
                    query.getQueryJoins().get(query.getQueryJoins().size()-1).getJoiningTypeName();
                String lastTableAlias = query.getQueryJoins() == null || query.getQueryJoins().size()== 0 ? query.getTypeName() :
                    aliases[query.getQueryJoins().size()-1] == null? lastTableName : aliases[query.getQueryJoins().size()-1];
                
                toSQL = createFilterToSQL(getDataStore().getSchema(lastTableName));
                
                if (lastSortBy != null) {
                    //we will use another join for the filter
                    //assuming that the last sort by specifies the ID of the parent feature                   
                    //this way we will ensure that if the table is denormalized, that all rows
                    //with the same ID are included (for multi-valued features)
                    
                    sql.append(" INNER JOIN ( SELECT DISTINCT ");
                    for (int i=0; i < lastSortBy.length; i++) {
                         getDataStore().dialect.encodeColumnName(null, lastSortBy[i].getPropertyName().getPropertyName(), sql);
                         if (i < lastSortBy.length-1) sql.append(",");
                    }
                    sql.append(" FROM ");
                    getDataStore().encodeTableName(lastTableName, sql, query.getHints());                                        
                    sql.append(" ").append(toSQL.encodeToString(filter));
                    sql.append(" ) ");
                    getDataStore().dialect.encodeTableName(TEMP_FILTER_ALIAS, sql);
                    sql.append(" ON ( ");
                    for (int i=0; i < lastSortBy.length; i++) {
                        encodeColumnName2(lastSortBy[i].getPropertyName().getPropertyName(), lastTableAlias , sql, null);            
                        sql.append(" = ");
                        encodeColumnName2(lastSortBy[i].getPropertyName().getPropertyName(), TEMP_FILTER_ALIAS , sql, null);
                        if (i < lastSortBy.length-1) sql.append(" AND ");
                    }
                    sql.append(" ) ");                    
                }
                else {
                    toSQL.setFieldEncoder(new JoiningFieldEncoder(curTypeName));                    
                    sql.append(" ").append(toSQL.encodeToString(filter));
                }
            } catch (FilterToSQLException e) {
                throw new RuntimeException(e);
            }
        }

        //sorting
        sort(query, sql, aliases, pkColumnNames);
        
        // finally encode limit/offset, if necessary
        getDataStore().applyLimitOffset(sql, query);
        
        if (toSQLref != null && toSQL instanceof PreparedFilterToSQL) {
            toSQLref.set((PreparedFilterToSQL) toSQL);
        }
        
        return sql.toString();
    }        

