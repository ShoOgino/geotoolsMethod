    /**
     * Get the maching built features that are stored in this mapping using a supplied link value
     *
     * @param reprojection Reprojected CRS or null
     * @param selectedProperties list of properties to get
     * @return The matching simple features
     */
    @Override
    public List<Feature> getFeatures(
            Object caller,
            Object foreignKeyValue,
            List<Object> idValues,
            CoordinateReferenceSystem reprojection,
            Object feature,
            List<PropertyName> selectedProperties,
            boolean includeMandatory,
            int resolveDepth,
            Integer resolveTimeOut)
            throws IOException {

        if (isSameSource()) {
            // if linkField is null, this method shouldn't be called because the mapping
            // should use the same table, and handles it differently
            throw new UnsupportedOperationException(
                    "Link field is missing from feature chaining mapping!");
        }

        @SuppressWarnings("PMD.CloseResource") // not managed here
        Transaction transaction = null;
        if (caller instanceof AbstractMappingFeatureIterator) {
            transaction = ((AbstractMappingFeatureIterator) caller).getTransaction();
        }

        Instance instance = instances.get(caller);
        if (instance == null) {
            throw new IllegalArgumentException(
                    "Trying to read Joining Nested Attribute Mapping that is not open.");
        }

        Object featureTypeName = getNestedFeatureType(feature);
        if (featureTypeName == null || !(featureTypeName instanceof Name)) {
            throw new IllegalArgumentException("Something is wrong!!");
        }
        @SuppressWarnings("PMD.CloseResource") // not managed here, closed later
        DataAccessMappingFeatureIterator featureIterator =
                instance.featureIterators.get((Name) featureTypeName);
        if (featureIterator == null) {
            featureIterator =
                    initSourceFeatures(
                            instance,
                            (Name) featureTypeName,
                            reprojection,
                            selectedProperties,
                            includeMandatory,
                            resolveDepth,
                            resolveTimeOut,
                            transaction);
        }
        Expression nestedSourceExpression =
                instance.nestedSourceExpressions.get((Name) featureTypeName);
        if (nestedSourceExpression == null) {
            throw new IllegalArgumentException(
                    "Internal error: nested source expression expected but found "
                            + featureTypeName);
        }

        ArrayList<Feature> matchingFeatures = new ArrayList<>();

        if (featureIterator != null) {
            while (featureIterator.hasNext()
                    && featureIterator.checkForeignIdValues(idValues)
                    && featureIterator
                            .peekNextValue(nestedSourceExpression)
                            .toString()
                            .equals(foreignKeyValue.toString())) {
                matchingFeatures.add(featureIterator.next());
            }
        }

        // skip all others
        for (Name name : instance.featureIterators.keySet()) {
            @SuppressWarnings("PMD.CloseResource") // not managed here, field, closed later
            DataAccessMappingFeatureIterator fIt = instance.featureIterators.get(name);
            if (fIt != featureIterator) {
                skipFeatures(
                        fIt, instance.nestedSourceExpressions.get(name), foreignKeyValue, idValues);
            }
        }
        instance.skipped.add(new Instance.Skip(idValues));

        return matchingFeatures;
    }

