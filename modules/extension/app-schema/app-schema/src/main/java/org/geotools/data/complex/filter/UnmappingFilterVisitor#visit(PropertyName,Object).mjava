    @Override
    public List<Expression> visit(PropertyName expr, Object arg1) {

        String targetXPath = expr.getPropertyName();
        // replace the artificial DEFAULT_GEOMETRY property with the actual one
        if (DEFAULT_GEOMETRY_LOCAL_NAME.equals(targetXPath)) {
            targetXPath = mappings.getDefaultGeometryXPath();
        }

        NamespaceSupport namespaces = mappings.getNamespaces();
        AttributeDescriptor root = mappings.getTargetFeature();

        List<NestedAttributeMapping> nestedMappings = mappings.getNestedMappings();
        // break into single steps
        StepList simplifiedSteps = XPath.steps(root, targetXPath, namespaces);

        List<Expression> matchingMappings = mappings.findMappingsFor(simplifiedSteps, false);
        Iterator<Expression> it = matchingMappings.iterator();
        while (it.hasNext()) {
            if (it.next() == null) {
                // remove spurious null values, which are returned by findMappingsFor only to notify
                // the caller that joining for simple content should go to the post filter
                it.remove();
            }
        }

        if (!nestedMappings.isEmpty()) {
            // means some attributes are mapped separately in feature chaining
            for (NestedAttributeMapping nestedMapping : nestedMappings) {
                if (simplifiedSteps.startsWith(nestedMapping.getTargetXPath())) {
                    Expression nestedAttributeExpression =
                            CustomImplementationsFinder.find(
                                    mappings, simplifiedSteps, nestedMapping);
                    if (nestedAttributeExpression != null) {
                        matchingMappings.add(nestedAttributeExpression);
                    } else {
                        matchingMappings.add(
                                new NestedAttributeExpression(simplifiedSteps, nestedMapping));
                    }
                }
            }
        }

        matchingMappings.remove(Expression.NIL);

        if (matchingMappings.isEmpty()) {
            throw new IllegalArgumentException("Can't find source expression for: " + targetXPath);
        }

        return matchingMappings;
    }

