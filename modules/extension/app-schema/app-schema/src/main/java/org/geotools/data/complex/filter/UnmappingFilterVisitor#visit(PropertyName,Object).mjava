    public List<Expression> visit(PropertyName expr, Object arg1) {
        String targetXPath = expr.getPropertyName();
        NamespaceSupport namespaces = mappings.getNamespaces();
        AttributeDescriptor root = mappings.getTargetFeature();

        List<NestedAttributeMapping> nestedMappings = mappings.getNestedMappings();
        // break into single steps
        StepList simplifiedSteps = XPath.steps(root, targetXPath, namespaces);

        List<Expression> matchingMappings = mappings.findMappingsFor(simplifiedSteps, false);
        Iterator<Expression> it = matchingMappings.iterator();
        while (it.hasNext()) {
            if (it.next() == null) {
                // remove spurious null values, which are returned by findMappingsFor only to notify
                // the caller that joining for simple content should go to the post filter
                it.remove();
            }
        }

        if (!nestedMappings.isEmpty()) {
            // means some attributes are mapped separately in feature chaining
            for (NestedAttributeMapping nestedMapping : nestedMappings) {
                if (simplifiedSteps.startsWith(nestedMapping.getTargetXPath())) {
                    matchingMappings.add(new NestedAttributeExpression(simplifiedSteps,
                            nestedMapping));
                }
            }
        }

        if (matchingMappings.size() == 0) {
            throw new IllegalArgumentException("Can't find source expression for: " + targetXPath);
        }

        return matchingMappings;
    }

