    /**
     * Only used when joining is not used and pre-filter exists because the sources will match
     * the prefilter but there might be denormalised rows with same id that don't.
     * @param fId
     * @param features
     * @throws IOException
     */
    private List<Feature> setNextFilteredFeature(String fId) throws IOException {
        FeatureCollection<? extends FeatureType, ? extends Feature> matchingFeatures;
        Query query = new Query();
        if (reprojection != null) {
            if (sourceFeatures.getSchema().getGeometryDescriptor() != null
                    && !this.isReprojectionCrsEqual(this.mappedSource.getSchema()
                            .getCoordinateReferenceSystem(), this.reprojection)) {
                query.setCoordinateSystemReproject(reprojection);
            }
        }

        if (mapping.getFeatureIdExpression().equals(Expression.NIL)) {
            // no real feature id mapping,
            // so let's find by database row id
            Set<FeatureId> ids = new HashSet<FeatureId>();
            FeatureId featureId = namespaceAwareFilterFactory.featureId(fId);
            ids.add(featureId);
            query.setFilter(namespaceAwareFilterFactory.id(ids));
            matchingFeatures = this.mappedSource.getFeatures(query);
        } else {
            // in case the expression is wrapped in a function, eg. strConcat
            // that's why we don't always filter by id, but do a PropertyIsEqualTo
            query.setFilter(namespaceAwareFilterFactory.equals(mapping.getFeatureIdExpression(),
                    namespaceAwareFilterFactory.literal(fId)));
            matchingFeatures = this.mappedSource.getFeatures(query);
        }

        FeatureIterator<? extends Feature> iterator = matchingFeatures.features();

        List<Feature> features = new ArrayList<Feature>();
        while (iterator.hasNext()) {
            features.add(iterator.next());
        }
        // Probably cause there is no primary key nor idExpression
        if (features.isEmpty()) {
            features.add(curSrcFeature);
        }

        filteredFeatures.add(fId);

        iterator.close();
        
        curSrcFeature = null;
        
        return features;
    }

