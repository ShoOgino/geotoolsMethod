    /**
     * Only used when joining is not used and pre-filter exists because the sources will match the
     * prefilter but there might be denormalised rows with same id that don't.
     */
    private List<Feature> setNextFilteredFeature(String fId) throws IOException {
        FeatureCollection<? extends FeatureType, ? extends Feature> matchingFeatures;
        Query query = new Query();
        if (reprojection != null) {
            if (sourceFeatures.getSchema().getGeometryDescriptor() != null
                    && !this.isReprojectionCrsEqual(
                            this.mappedSource.getSchema().getCoordinateReferenceSystem(),
                            this.reprojection)) {
                query.setCoordinateSystemReproject(reprojection);
            }
        }

        Filter fidFilter;

        if (mapping.getFeatureIdExpression().equals(Expression.NIL)) {
            // no real feature id mapping,
            // so let's find by database row id
            Set<FeatureId> ids = new HashSet<FeatureId>();
            FeatureId featureId = namespaceAwareFilterFactory.featureId(fId);
            ids.add(featureId);
            fidFilter = namespaceAwareFilterFactory.id(ids);
        } else {
            // in case the expression is wrapped in a function, eg. strConcat
            // that's why we don't always filter by id, but do a PropertyIsEqualTo
            fidFilter =
                    namespaceAwareFilterFactory.equals(
                            mapping.getFeatureIdExpression(),
                            namespaceAwareFilterFactory.literal(fId));
        }

        // HACK HACK HACK
        // evaluate filter that applies to this list as we want a subset
        // instead of full result
        // this is a temporary solution for Bureau of Meteorology
        // requirement for timePositionList
        if (listFilter != null) {
            List<Filter> filters = new ArrayList<Filter>();
            filters.add(listFilter);
            filters.add(fidFilter);
            fidFilter = namespaceAwareFilterFactory.and(filters);
        }
        // END OF HACK

        query.setFilter(fidFilter);
        matchingFeatures = this.mappedSource.getFeatures(query);

        List<Feature> features = new ArrayList<Feature>();
        try (FeatureIterator<? extends Feature> iterator = matchingFeatures.features()) {
            while (iterator.hasNext()) {
                features.add(iterator.next());
            }
            // Probably cause there is no primary key nor idExpression
            if (features.isEmpty()) {
                features.add(curSrcFeature);
            }

            filteredFeatures.add(fId);
        }

        curSrcFeature = null;

        return features;
    }

