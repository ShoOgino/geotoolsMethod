    private void buildFilter(
            JoiningQuery query,
            StringBuffer sql,
            Set<String> lastPkColumnNames,
            FilterToSQL toSQL,
            Filter filter,
            SortBy[] lastSortBy,
            String lastTableName,
            String lastTableAlias,
            Collection<String> ids,
            String curTypeName)
            throws SQLException, FilterToSQLException, IOException {
        // we will use another join for the filter
        // assuming that the last sort by specifies the ID of the parent feature
        // this way we will ensure that if the table is denormalized, that all rows
        // with the same ID are included (for multi-valued features)

        StringBuffer sortBySQL = new StringBuffer();
        sortBySQL.append(" INNER JOIN ( SELECT DISTINCT ");
        boolean hasSortBy = false;
        boolean isMultiSort = lastSortBy.length > 1 && ids.isEmpty();
        hasSortBy =
                isMultiSort
                        ? buildFiterBasedOnPk(
                                query,
                                toSQL,
                                filter,
                                lastSortBy,
                                lastTableName,
                                lastTableAlias,
                                lastPkColumnNames,
                                sortBySQL,
                                hasSortBy)
                        : buildFiterBasedOnSortBy(
                                query,
                                toSQL,
                                filter,
                                lastSortBy,
                                lastTableName,
                                lastTableAlias,
                                ids,
                                sortBySQL,
                                hasSortBy);

        if (lastSortBy.length == 0) {
            // GEOT-4554: if ID expression is not specified, use PK
            Set<String> lastTablePk = getAllPrimaryKeys(getDataStore().getSchema(lastTableName));
            int i = 0;
            for (String pk : lastTablePk) {
                getDataStore().dialect.encodeColumnName(null, pk, sortBySQL);
                sortBySQL.append(" FROM ");
                if (!lastTableAlias.equals(lastTableName))
                    getDataStore()
                            .encodeAliasedTableName(
                                    lastTableName, sortBySQL, query.getHints(), lastTableAlias);
                else getDataStore().encodeTableName(lastTableName, sortBySQL, query.getHints());
                String sqlFilter;
                if (NestedFilterToSQL.isNestedFilter(filter)) {
                    toSQL.setFieldEncoder(new JoiningFieldEncoder(curTypeName, getDataStore()));
                    sortBySQL.append(" WHERE ");
                    sqlFilter = createNestedFilter(filter, query, toSQL).toString();
                } else {
                    sqlFilter = toSQL.encodeToString(filter);
                }
                sortBySQL.append(" ").append(sqlFilter);
                sortBySQL.append(" ) ");
                getDataStore().dialect.encodeTableName(TEMP_FILTER_ALIAS, sortBySQL);
                sortBySQL.append(" ON ( ");
                encodeColumnName2(pk, lastTableAlias, sortBySQL, null);
                sortBySQL.append(" = ");
                encodeColumnName2(pk, TEMP_FILTER_ALIAS, sortBySQL, null);
                if (i < lastPkColumnNames.size() - 1) {
                    sortBySQL.append(" AND ");
                }
                i++;
                hasSortBy = true;
            }
        }
        if (hasSortBy) {
            if (sortBySQL.toString().endsWith(" AND ")) {
                sql.append(sortBySQL.substring(0, sortBySQL.length() - 5)).append(" ) ");
            } else {
                sql.append(sortBySQL).append(" ) ");
            }
        }
    }

