    /**
     * @param mappingProperties
     * @param mapping
     * @return <code>null</code> if all surrogate attributes shall be queried, else the list of
     *     needed surrogate attributes to satisfy the mapping of prorperties in <code>
     *     mappingProperties</code>
     */
    private List<PropertyName> getSurrogatePropertyNames(
            List<PropertyName> requestedProperties,
            FeatureTypeMapping mapping,
            boolean includeMandatory) {
        List<PropertyName> propNames = null;
        final AttributeDescriptor targetDescriptor = mapping.getTargetFeature();
        if (requestedProperties != null && requestedProperties.size() > 0) {
            requestedProperties = new ArrayList<PropertyName>(requestedProperties);
            Set<PropertyName> requestedSurrogateProperties = new HashSet<PropertyName>();
            // add all surrogate attributes involved in mapping of the requested
            // target schema attributes
            List<AttributeMapping> attMappings = mapping.getAttributeMappings();
            // NC - add feature to list, to include its ID expression
            requestedProperties.add(filterFac.property(mapping.getTargetFeature().getName()));

            // get source type
            AttributeType mappedType;
            try {
                mappedType = mapping.getSource().getSchema();
            } catch (UnsupportedOperationException e) {
                // web service backend doesn't support getSchema()
                mappedType = null;
            }

            for (final AttributeMapping entry : attMappings) {
                final StepList targetSteps = entry.getTargetXPath();

                boolean addThis = false;

                if (includeMandatory) {
                    PropertyName targetProp =
                            filterFac.property(targetSteps.toString(), mapping.getNamespaces());
                    Object descr = targetProp.evaluate(targetDescriptor.getType());
                    if (descr instanceof PropertyDescriptor) {
                        if (((PropertyDescriptor) descr).getMinOccurs() >= 1) {
                            addThis = true;
                        }
                    }
                }

                if (!addThis) {
                    for (PropertyName requestedProperty : requestedProperties) {
                        // replace the artificial DEFAULT_GEOMETRY property with the actual one
                        if (DEFAULT_GEOMETRY_LOCAL_NAME.equals(
                                requestedProperty.getPropertyName())) {
                            String defGeomPath = mapping.getDefaultGeometryXPath();
                            requestedProperty =
                                    filterFac.property(defGeomPath, mapping.getNamespaces());
                        }

                        StepList requestedPropertySteps;
                        if (requestedProperty.getNamespaceContext() == null) {
                            requestedPropertySteps =
                                    XPath.steps(
                                            targetDescriptor,
                                            requestedProperty.getPropertyName(),
                                            mapping.getNamespaces());
                        } else {
                            requestedPropertySteps =
                                    XPath.steps(
                                            targetDescriptor,
                                            requestedProperty.getPropertyName(),
                                            requestedProperty.getNamespaceContext());
                        }

                        if (requestedPropertySteps == null
                                ? matchProperty(requestedProperty.getPropertyName(), targetSteps)
                                : matchProperty(requestedPropertySteps, targetSteps)) {
                            addThis = true;
                            break;
                        }
                    }
                }

                if (addThis) {
                    final Expression sourceExpression = entry.getSourceExpression();
                    final Expression idExpression = entry.getIdentifierExpression();
                    // NC - include client properties
                    final Collection<Expression> clientProperties =
                            entry.getClientProperties().values();

                    FilterAttributeExtractor extractor = new FilterAttributeExtractor();
                    sourceExpression.accept(extractor, null);
                    idExpression.accept(extractor, null);

                    // RA - include function parameters in linkField
                    if (entry instanceof NestedAttributeMapping) {
                        final Expression linkFieldExpression =
                                ((NestedAttributeMapping) entry).nestedFeatureType;
                        linkFieldExpression.accept(extractor, null);
                    }

                    Iterator<Expression> it = clientProperties.iterator();
                    while (it.hasNext()) {
                        it.next().accept(extractor, null);
                    }
                    Set<String> exprAtts = extractor.getAttributeNameSet();

                    for (String mappedAtt : exprAtts) {
                        if (!mappedAtt.equals("Expression.NIL")) { // NC - ignore Nil Expression
                            if (mappedType == null) {
                                // web service backend.. no underlying simple feature
                                // so just assume that it exists..
                                requestedSurrogateProperties.add(filterFac.property(mappedAtt));
                            } else {
                                PropertyName propExpr = filterFac.property(mappedAtt);
                                Object object = propExpr.evaluate(mappedType);
                                AttributeDescriptor mappedAttribute = (AttributeDescriptor) object;
                                if (mappedAttribute != null) {
                                    requestedSurrogateProperties.add(filterFac.property(mappedAtt));
                                } else {
                                    LOGGER.info(
                                            "mapped type does not contains property " + mappedAtt);
                                }
                            }
                        }
                    }
                    LOGGER.fine("adding atts needed for : " + exprAtts);
                }
            }

            propNames = new ArrayList<PropertyName>(requestedSurrogateProperties);
        }
        return propNames;
    }

