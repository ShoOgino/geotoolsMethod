    /**
     * Creates a <code>org.geotools.data.Query</code> that operates over the surrogate DataStore, by
     * unrolling the <code>org.geotools.filter.Filter</code> contained in the passed
     * <code>query</code>, and replacing the list of required attributes by the ones of the mapped
     * FeatureType.
     * 
     * @param query
     * @param mapping
     * @return
     */
    @SuppressWarnings("unchecked")
    public Query unrollQuery(Query query, FeatureTypeMapping mapping) {
        Query unrolledQuery = Query.ALL;
        FeatureSource source = mapping.getSource();

        if (!Query.ALL.equals(query)) {
            Filter complexFilter = query.getFilter();
            Filter unrolledFilter = AppSchemaDataAccess.unrollFilter(complexFilter, mapping);

            Object includeProps = query.getHints().get(Query.INCLUDE_MANDATORY_PROPS);
            List<PropertyName> propNames = getSurrogatePropertyNames(query.getProperties(),
                    mapping,
                    includeProps instanceof Boolean && ((Boolean) includeProps).booleanValue());

            Query newQuery = new Query();
            String name = source.getName().getLocalPart();
            newQuery.setTypeName(name);
            newQuery.setFilter(unrolledFilter);
            newQuery.setProperties(propNames);
            newQuery.setCoordinateSystem(query.getCoordinateSystem());
            newQuery.setCoordinateSystemReproject(query.getCoordinateSystemReproject());
            newQuery.setHandle(query.getHandle());
            newQuery.setMaxFeatures(query.getMaxFeatures());
            
            List<SortBy> sort = new ArrayList<SortBy>();
            if (query.getSortBy() != null) {
                for (SortBy sortBy : query.getSortBy()) {
                    for (Expression expr : unrollProperty(sortBy.getPropertyName(), mapping)) {
                        if (expr != null) {
                            FilterAttributeExtractor extractor = new FilterAttributeExtractor();
                            expr.accept(extractor, null);
        
                            for (String att : extractor.getAttributeNameSet()) {
                                sort.add(new SortByImpl(filterFac.property(att), sortBy.getSortOrder()));
                            }
                        }
                    }
                }
            }

            if (query instanceof JoiningQuery) {
                FilterAttributeExtractor extractor = new FilterAttributeExtractor();
                mapping.getFeatureIdExpression().accept(extractor, null);

                for (String att : extractor.getAttributeNameSet()) {
                    sort.add(new SortByImpl(filterFac.property(att), SortOrder.ASCENDING));
                }

                JoiningQuery jQuery = new JoiningQuery(newQuery);
                jQuery.setQueryJoins(((JoiningQuery) query).getQueryJoins());
                jQuery.setSubset(((JoiningQuery) query).isSubset());
                unrolledQuery = jQuery;
            } else {
                unrolledQuery = newQuery;
            }

            unrolledQuery.setSortBy(sort.toArray(new SortBy[sort.size()]));

        }

        return unrolledQuery;
    }

