    /**
     * Run the query to get built features from a table based on a foreign key.
     *
     * @param foreignKeyValue foreign key to filter by
     * @param isMultiple true if the table is denormalised and multiple values are possible for the
     *     same id
     * @return list of built features
     */
    private List<Feature> getFilteredFeatures(Object foreignKeyValue, boolean isMultiple)
            throws IOException {
        if (nestedSourceExpression == null) {
            return Collections.emptyList();
        }

        ArrayList<Feature> matchingFeatures = new ArrayList<Feature>();

        Filter filter =
                filterFac.equals(this.nestedSourceExpression, filterFac.literal(foreignKeyValue));

        // get all the nested features based on the link values
        FeatureCollection<FeatureType, Feature> fCollection = source.getFeatures(filter);
        Filter matchingIdFilter = null;

        try (FeatureIterator<Feature> it = fCollection.features()) {
            if (nestedIdExpression.equals(Expression.NIL)) {
                HashSet<FeatureId> featureIds = new HashSet<FeatureId>();
                while (it.hasNext()) {
                    Feature f = it.next();
                    matchingFeatures.add(f);
                    if (isMultiple && f.getIdentifier() != null) {
                        featureIds.add(f.getIdentifier());
                    }
                }

                // Find features of the same id from denormalised view
                if (!featureIds.isEmpty()) {
                    matchingIdFilter = filterFac.id(featureIds);
                }
            } else {
                HashSet<String> featureIds = new HashSet<String>();
                while (it.hasNext()) {
                    Feature f = it.next();
                    matchingFeatures.add(f);
                    if (isMultiple) {
                        featureIds.add(
                                Converters.convert(nestedIdExpression.evaluate(f), String.class));
                    }
                }

                // Find features of the same id from denormalised view
                if (!featureIds.isEmpty()) {
                    List<Filter> idFilters = new ArrayList<Filter>(featureIds.size());
                    for (String id : featureIds) {
                        idFilters.add(filterFac.equals(nestedIdExpression, filterFac.literal(id)));
                    }
                    matchingIdFilter = filterFac.or(idFilters);
                }
            }
        }

        if (matchingIdFilter != null) {
            fCollection = source.getFeatures(matchingIdFilter);

            if (fCollection.size() > matchingFeatures.size()) {
                // there are rows of same id from denormalised view
                try (FeatureIterator<Feature> it = fCollection.features()) {
                    matchingFeatures.clear();
                    while (it.hasNext()) {
                        matchingFeatures.add(it.next());
                    }
                }
            }
        }

        return matchingFeatures;
    }

