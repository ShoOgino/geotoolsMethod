    public static IMappingFeatureIterator getInstance(
            AppSchemaDataAccess store,
            FeatureTypeMapping mapping,
            Query query,
            Filter unrolledFilter,
            Transaction transaction)
            throws IOException {

        if (mapping instanceof XmlFeatureTypeMapping) {
            return new XmlMappingFeatureIterator(store, mapping, query);
        }

        boolean isJoining = AppSchemaDataAccessConfigurator.isJoining();
        boolean removeQueryLimitIfDenormalised = false;

        FeatureSource mappedSource = mapping.getSource();

        if (isJoining
                && !(mappedSource instanceof JDBCFeatureSource
                        || mappedSource instanceof JDBCFeatureStore)) {
            // check if joining is explicitly set for non database backends
            if (AppSchemaDataAccessConfigurator.isJoiningSet()) {
                throw new IllegalArgumentException(
                        "Joining queries are only supported on JDBC data stores");
            } else {
                // override default behaviour
                // this is not intended
                isJoining = false;
            }
        }

        if (isJoining) {
            if (!(query instanceof JoiningQuery)) {
                boolean hasIdColumn =
                        !Expression.NIL.equals(mapping.getFeatureIdExpression())
                                && !(mapping.getFeatureIdExpression() instanceof Literal);
                query = new JoiningQuery(query);
                if (hasIdColumn) {
                    FilterAttributeExtractor extractor = new FilterAttributeExtractor();
                    mapping.getFeatureIdExpression().accept(extractor, null);
                    for (String pn : extractor.getAttributeNameSet()) {
                        ((JoiningQuery) query).addId(pn);
                    }
                }
                ((JoiningQuery) query).setRootMapping(mapping);
            }
        }
        IMappingFeatureIterator iterator;
        if (unrolledFilter != null) {
            // unrolledFilter is set in JoiningNestedAttributeMapping
            // so this is for nested features with joining
            query.setFilter(Filter.INCLUDE);
            Query unrolledQuery = store.unrollQuery(query, mapping);
            unrolledQuery.setFilter(unrolledFilter);
            if (query instanceof JoiningQuery && unrolledQuery instanceof JoiningQuery) {
                ((JoiningQuery) unrolledQuery)
                        .setRootMapping(((JoiningQuery) query).getRootMapping());
            }
            if (isSimpleType(mapping)) {
                iterator =
                        new MappingAttributeIterator(
                                store, mapping, query, unrolledQuery, transaction);
            } else {
                iterator =
                        new DataAccessMappingFeatureIterator(
                                store, mapping, query, unrolledQuery, false, transaction);
            }
        } else {
            // HACK HACK HACK
            // experimental/temporary solution for isList subsetting by filtering
            List<AttributeMapping> listMappings = mapping.getIsListMappings();
            Filter isListFilter = null;
            if (!listMappings.isEmpty()) {
                IsListFilterVisitor listChecker = new IsListFilterVisitor(listMappings, mapping);
                Filter complexFilter = query.getFilter();
                complexFilter.accept(listChecker, null);
                if (listChecker.isListFilterExists()) {
                    isListFilter = AppSchemaDataAccess.unrollFilter(complexFilter, mapping);
                }
            }
            // END OF HACK
            if (isJoining
                    || mappedSource instanceof JDBCFeatureSource
                    || mappedSource instanceof JDBCFeatureStore) {
                // has database as data source, we can use the data source filter capabilities
                FilterCapabilities capabilities = getFilterCapabilities(mappedSource);
                ComplexFilterSplitter splitter = new ComplexFilterSplitter(capabilities, mapping);
                Filter filter = query.getFilter();
                filter.accept(splitter, null);
                Filter preFilter = splitter.getFilterPre();
                query.setFilter(preFilter);
                filter = splitter.getFilterPost();

                if (isJoining) {
                    ((JoiningQuery) query).setDenormalised(mapping.isDenormalised());
                }
                if (isJoining && isListFilter != null) {
                    // pass it on in JoiningQuery so it can be handled when the SQL is prepared
                    // in JoiningJDBCSource
                    ((JoiningQuery) query).setSubset(true);
                    // also reset isListFilter to null so it doesn't perform the filtering in
                    // DataAccessMappingFeatureIterator except when post filtering is involved
                    // i.e. feature chaining is involved
                    if (filter == null || filter.equals(Filter.INCLUDE)) {
                        isListFilter = null;
                    }
                }
                // need to flag if this is non joining and has pre filter because it needs
                // to find denormalised rows that match the id (but doesn't match pre filter)
                boolean isFiltered = !isJoining && preFilter != null && preFilter != Filter.INCLUDE;
                // HACK HACK HACK
                // experimental/temporary solution for isList subsetting by filtering
                // Because subsetting should be done before the feature is built.. so we're not
                // using PostFilteringMappingFeatureIterator
                boolean hasPostFilter = false;
                if (isListFilter == null) {
                    // END OF HACK
                    if (filter != null && filter != Filter.INCLUDE) {
                        hasPostFilter = true;
                    }
                }
                int offset = 0;
                int maxFeatures = 1000000;
                if (hasPostFilter) {
                    // can't apply offset to the SQL query if using post filters
                    // it has to be applied to the post filter
                    offset = query.getStartIndex() == null ? 0 : query.getStartIndex();
                    query.setStartIndex(null);
                    maxFeatures = query.getMaxFeatures();
                    removeQueryLimitIfDenormalised = true;
                }
                iterator =
                        new DataAccessMappingFeatureIterator(
                                store,
                                mapping,
                                query,
                                isFiltered,
                                removeQueryLimitIfDenormalised,
                                hasPostFilter,
                                transaction);
                if (isListFilter != null) {
                    ((DataAccessMappingFeatureIterator) iterator).setListFilter(isListFilter);
                }
                if (hasPostFilter) {
                    iterator =
                            new PostFilteringMappingFeatureIterator(
                                    iterator, filter, maxFeatures, offset);
                }
            } else if (mappedSource instanceof MappingFeatureSource) {
                // web service data access wrapper
                iterator = new DataAccessMappingFeatureIterator(store, mapping, query);
                if (isListFilter != null) {
                    ((DataAccessMappingFeatureIterator) iterator).setListFilter(isListFilter);
                }
            } else {
                // non database sources e.g. property data store
                Filter filter = query.getFilter();
                iterator =
                        new DataAccessMappingFeatureIterator(
                                store, mapping, query, !Filter.INCLUDE.equals(filter), true);
                // HACK HACK HACK
                // experimental/temporary solution for isList subsetting by filtering
                if (isListFilter != null) {
                    ((DataAccessMappingFeatureIterator) iterator).setListFilter(isListFilter);
                }
                // END OF HACK
            }
        }
        return iterator;
    }

