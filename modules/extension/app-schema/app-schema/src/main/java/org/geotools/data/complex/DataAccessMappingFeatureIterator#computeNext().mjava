    protected Feature computeNext() throws IOException {

        String id = getNextFeatureId();
        List<Feature> sources = getSources(id);

        final AttributeDescriptor targetNode = mapping.getTargetFeature();
        final Name targetNodeName = targetNode.getName();

        AttributeBuilder builder = new AttributeBuilder(attf);
        builder.setDescriptor(targetNode);
        Feature target = (Feature) builder.build(id);

        for (AttributeMapping attMapping : selectedMapping) {
            try {
                if (skipTopElement(targetNodeName, attMapping.getTargetXPath(), targetNode.getType())) {
                    // ignore the top level mapping for the Feature itself
                    // as it was already set
                    continue;
                }
                if (attMapping.isList()) {
                    Attribute instance = setAttributeValue(target, null, sources.get(0),
                            attMapping, null, null, selectedProperties.get(attMapping));
                    if (sources.size() > 1 && instance != null) {
                        Object[] values = new Object[sources.size()];
                        Expression sourceExpr = attMapping.getSourceExpression();
                        int i = 0;
                        for (Feature source : sources) {
                            values[i] = getValue(sourceExpr, source);
                            i++;
                        }
                        String valueString = StringUtils.join(values, " ");
                        StepList fullPath = attMapping.getTargetXPath();
                        StepList leafPath = fullPath.subList(fullPath.size() - 1, fullPath.size());
                        if (instance instanceof ComplexAttributeImpl) {              
                            // xpath builder will work out the leaf attribute to set values on
                            xpathAttributeBuilder.set(instance, leafPath, valueString, null, null,
                                    false, sourceExpr);
                        } else {
                            // simple attributes
                            instance.setValue(valueString);
                        }
                    }
                } else if (attMapping.isMultiValued()) {
                    // extract the values from multiple source features of the same id
                    // and set them to one built feature
                    for (Feature source : sources) {
                        setAttributeValue(target, null, source, attMapping, null, null, selectedProperties.get(attMapping));
                    }
                } else {
                    setAttributeValue(target, null, sources.get(0), attMapping, null, null, selectedProperties.get(attMapping));
                    // When a feature is not multi-valued but still has multiple rows with the same ID in
                    // a denormalised table, by default app-schema only takes the first row and ignores
                    // the rest (see above). The following line is to make sure that the cursors in the
                    // 'joining nested mappings'skip any extra rows that were linked to those rows that are being ignored.
                    // Otherwise the cursor will stay there in the wrong spot and none of the following feature chaining
                    // will work. That can really only occur if the foreign key is not unique for the ID of the parent
                    // feature (otherwise all of those rows would be already passed when creating the feature based on
                    // the first row). This never really occurs in practice I have noticed, but it is a theoretic
                    // possibility, as there is no requirement for the foreign key to be unique per id.
                    skipNestedMapping(attMapping, sources.subList(1, sources.size()));
                }
            } catch (Exception e) {
                throw new RuntimeException("Error applying mapping with targetAttribute "
                        + attMapping.getTargetXPath(), e);
            }
        }
        cleanEmptyElements(target);
        
        return target;
    }

