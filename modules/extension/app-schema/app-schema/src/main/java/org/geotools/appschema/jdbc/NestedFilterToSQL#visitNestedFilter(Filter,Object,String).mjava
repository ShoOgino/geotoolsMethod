    protected Object visitNestedFilter(Filter filter, Object extraData, String xpath) {
        try {

            FeatureChainedAttributeVisitor nestedMappingsExtractor =
                    new FeatureChainedAttributeVisitor(rootMapping);
            nestedMappingsExtractor.visit(ff.property(xpath), null);
            List<FeatureChainedAttributeDescriptor> attributes =
                    nestedMappingsExtractor.getFeatureChainedAttributes();
            // encoding of filters on multiple nested attributes is not (yet) supported
            if (attributes.size() == 1) {
                FeatureChainedAttributeDescriptor nestedAttrDescr = attributes.get(0);

                int numMappings = nestedAttrDescr.chainSize();
                if (numMappings > 0 && nestedAttrDescr.isJoiningEnabled()) {
                    out.write("EXISTS (");

                    FeatureChainLink lastMappingStep = nestedAttrDescr.getLastLink();
                    StringBuffer sql = encodeSelectKeyFrom(lastMappingStep);
                    JDBCDataStore store =
                            (JDBCDataStore)
                                    lastMappingStep
                                            .getFeatureTypeMapping()
                                            .getSource()
                                            .getDataStore();
                    encodeMultipleValueJoin(nestedAttrDescr, store, sql);

                    for (int i = numMappings - 2; i > 0; i--) {
                        FeatureChainLink mappingStep = nestedAttrDescr.getLink(i);
                        if (mappingStep.hasNestedFeature()) {
                            FeatureTypeMapping parentFeature = mappingStep.getFeatureTypeMapping();
                            store = (JDBCDataStore) parentFeature.getSource().getDataStore();
                            String parentTableName =
                                    parentFeature.getSource().getSchema().getName().getLocalPart();

                            sql.append(" INNER JOIN ");
                            store.encodeTableName(parentTableName, sql, null);
                            sql.append(" ");
                            store.dialect.encodeTableName(mappingStep.getAlias(), sql);
                            sql.append(" ON ");
                            encodeJoinCondition(nestedAttrDescr, i, sql);
                        }
                    }

                    if (nestedAttrDescr.getAttributePath() != null) {
                        createWhereClause(filter, xpath, nestedAttrDescr, sql);

                        sql.append(" AND ");
                    } else {
                        sql.append(" WHERE ");
                    }

                    // join with root table
                    encodeJoinCondition(nestedAttrDescr, 0, sql);

                    out.write(sql.toString());
                    out.write(")");
                }
            }

            return extraData;

        } catch (java.io.IOException ioe) {
            throw new RuntimeException("Problem writing filter: ", ioe);
        } catch (SQLException e) {
            throw new RuntimeException("Problem writing filter: ", e);
        } catch (FilterToSQLException e) {
            throw new RuntimeException("Problem writing filter: ", e);
        }
    }

