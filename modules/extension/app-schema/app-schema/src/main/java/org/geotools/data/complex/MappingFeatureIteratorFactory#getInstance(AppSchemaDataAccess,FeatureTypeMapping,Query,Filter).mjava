    public static IMappingFeatureIterator getInstance(AppSchemaDataAccess store,
            FeatureTypeMapping mapping, Query query, Filter unrolledFilter) throws IOException {

        if (mapping instanceof XmlFeatureTypeMapping) {
            return new XmlMappingFeatureIterator(store, mapping, query);
        }

        boolean isJoining = AppSchemaDataAccessConfigurator.isJoining();

        if (isJoining) {
            if (!(query instanceof JoiningQuery)) {
                query = new JoiningQuery(query);
            }
        }
        IMappingFeatureIterator iterator;
        if (unrolledFilter != null) {
            // unrolledFilter is set in JoiningNestedAttributeMapping
            // so this is for nested features with joining
            query.setFilter(Filter.INCLUDE);
            Query unrolledQuery = store.unrollQuery(query, mapping);
            unrolledQuery.setFilter(unrolledFilter);
            if (isSimpleType(mapping)) {
                iterator = new MappingAttributeIterator(store, mapping, query, unrolledQuery);
            } else {
                iterator = new DataAccessMappingFeatureIterator(store, mapping, query,
                        unrolledQuery);
            }
        } else {
            FeatureSource mappedSource = mapping.getSource();
            if (isJoining || mappedSource instanceof JDBCFeatureSource
                    || mappedSource instanceof JDBCFeatureStore) {
                // has database as data source, we can use the data source filter capabilities
                FilterCapabilities capabilities = getFilterCapabilities(mappedSource);
                ComplexFilterSplitter splitter = new ComplexFilterSplitter(capabilities, mapping);
                Filter filter = query.getFilter();
                filter.accept(splitter, null);
                Filter preFilter = splitter.getFilterPre();
                query.setFilter(preFilter);
                filter = splitter.getFilterPost();

                int maxFeatures = Query.DEFAULT_MAX;
                if (filter != null && filter != Filter.INCLUDE) {
                    maxFeatures = query.getMaxFeatures();
                    query.setMaxFeatures(Query.DEFAULT_MAX);
                }
                // need to flag if this is non joining and has pre filter because it needs
                // to find denormalised rows that match the id (but doesn't match pre filter)
                boolean isFiltered = !isJoining && preFilter != null && preFilter != Filter.INCLUDE;
                iterator = new DataAccessMappingFeatureIterator(store, mapping, query, isFiltered);
                if (filter != null && filter != Filter.INCLUDE) {
                    iterator = new PostFilteringMappingFeatureIterator(iterator, filter,
                            maxFeatures);
                }
            } else if (mappedSource instanceof MappingFeatureSource) {
                // web service data access wrapper
                iterator = new DataAccessMappingFeatureIterator(store, mapping, query);
            } else {
                // non database sources e.g. property data store
                Query unrolledQuery = store.unrollQuery(query, mapping);
                Filter filter = unrolledQuery.getFilter();

                if (!filter.equals(Filter.INCLUDE) && !filter.equals(Filter.EXCLUDE)
                        && !(filter instanceof FidFilterImpl)) {
                    // non joining with filters
                    // the filter can't be passed to the data source as is and has to be
                    // performed
                    // per simple feature
                    // also in case the data is denormalised and the 2nd row matches the filter, it
                    // will still find the first row
                    // since this iterator would group the sources by id before evaluating the
                    // filter
                    unrolledQuery.setFilter(Filter.INCLUDE);

                    CoordinateReferenceSystem crs = query.getCoordinateSystemReproject();
                    if (crs != null) {
                        // remove reprojection too, as it should be done after filter is applied
                        // to be consistent with app-schema with JDBC sources
                        unrolledQuery.setCoordinateSystemReproject(null);
                    }
                    iterator = new FilteringMappingFeatureIterator(store, mapping, query,
                            unrolledQuery, filter);
                } else {
                    // non database sources with no filters
                    iterator = new DataAccessMappingFeatureIterator(store, mapping, query);
                }
            }
        }

        return iterator;
    }

