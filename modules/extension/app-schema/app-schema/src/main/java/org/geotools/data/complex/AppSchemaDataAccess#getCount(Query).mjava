    /**
     * Gets the number of the features that would be returned by this query for the specified
     * feature type.
     *
     * <p>If getBounds(Query) returns <code>-1</code> due to expense consider using <code>
     * getFeatures(Query).getCount()</code> as a an alternative.
     *
     * @param targetQuery Contains the Filter and MaxFeatures to find the bounds for.
     * @return The number of Features provided by the Query or <code>-1</code> if count is too
     *     expensive to calculate or any errors or occur.
     * @throws IOException
     * @throws IOException if there are errors getting the count
     */
    protected int getCount(final Query targetQuery) throws IOException {
        final FeatureTypeMapping mapping = getMappingByNameOrElement(getName(targetQuery));
        FeatureSource mappedSource = mapping.getSource();
        // Wrap with JoiningJDBCFeatureSource like in DataAccessMappingFeatureIterator
        // this is so it'd use the splitFilter in JoiningJDBCFeatureSource
        // otherwise you'll get an error when it can't find complex attributes in the
        // simple feature source
        if (mappedSource instanceof JDBCFeatureSource) {
            mappedSource = new JoiningJDBCFeatureSource((JDBCFeatureSource) mappedSource);
        } else if (mappedSource instanceof JDBCFeatureStore) {
            mappedSource = new JoiningJDBCFeatureSource((JDBCFeatureStore) mappedSource);
        }
        Query unmappedQuery = unrollQuery(targetQuery, mapping);
        return mappedSource.getCount(unmappedQuery);
    }

