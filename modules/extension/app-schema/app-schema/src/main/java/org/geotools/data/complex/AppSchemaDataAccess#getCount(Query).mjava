    /**
     * Gets the number of the features that would be returned by this query for the specified
     * feature type.
     *
     * <p>If getBounds(Query) returns <code>-1</code> due to expense consider using <code>
     * getFeatures(Query).getCount()</code> as a an alternative.
     *
     * @param targetQuery Contains the Filter and MaxFeatures to find the bounds for.
     * @return The number of Features provided by the Query or <code>-1</code> if count is too
     *     expensive to calculate or any errors or occur.
     * @throws IOException if there are errors getting the count
     */
    protected int getCount(final Query targetQuery) throws IOException {

        int count = 0;

        final FeatureTypeMapping mapping = getMappingByNameOrElement(getName(targetQuery));
        FeatureSource mappedSource = mapping.getSource();
        Filter filter = targetQuery.getFilter();
        FilterAttributeExtractor extractor = new FilterAttributeExtractor();
        filter.accept(extractor, null);
        Set<PropertyName> propertyNames = extractor.getPropertyNameSet();
        // Wrap with JoiningJDBCFeatureSource like in DataAccessMappingFeatureIterator
        // this is so it'd use the splitFilter in JoiningJDBCFeatureSource
        // otherwise you'll get an error when it can't find complex attributes in the
        // simple feature source
        if (mappedSource instanceof JDBCFeatureSource) {
            mappedSource = new JoiningJDBCFeatureSource((JDBCFeatureSource) mappedSource);
        } else if (mappedSource instanceof JDBCFeatureStore) {
            mappedSource = new JoiningJDBCFeatureSource((JDBCFeatureStore) mappedSource);
        }
        FeatureType featureType = mappedSource.getSchema();
        boolean canCount = canCount(targetQuery, mappedSource, mapping);
        if (canCount) {
            if (!hasNestedProperties(featureType, propertyNames)) {
                JoiningQuery joiningQuery = new JoiningQuery(targetQuery);
                joiningQuery.setRootMapping(mapping);
                count = mappedSource.getCount(joiningQuery);
            } else if (mappedSource instanceof JoiningJDBCFeatureSource) {
                count =
                        getCountNestedFilter(
                                (JoiningJDBCFeatureSource) mappedSource, targetQuery, mapping);
            }
        }
        return count;
    }

