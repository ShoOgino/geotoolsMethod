    /**
     * Gets the number of the features that would be returned by this query for the specified
     * feature type.
     * <p>
     * If getBounds(Query) returns <code>-1</code> due to expense consider using
     * <code>getFeatures(Query).getCount()</code> as a an alternative.
     * </p>
     * 
     * @param targetQuery
     *            Contains the Filter and MaxFeatures to find the bounds for.
     * @return The number of Features provided by the Query or <code>-1</code> if count is too
     *         expensive to calculate or any errors or occur.
     * @throws IOException
     * 
     * @throws IOException
     *             if there are errors getting the count
     */
    protected int getCount(final Query targetQuery) throws IOException {
        final FeatureTypeMapping mapping = getMappingByNameOrElement(getName(targetQuery));
        FeatureSource mappedSource = mapping.getSource();
        // Wrap with JoiningJDBCFeatureSource like in DataAccessMappingFeatureIterator
        // this is so it'd use the splitFilter in JoiningJDBCFeatureSource
        // otherwise you'll get an error when it can't find complex attributes in the 
        // simple feature source
        if (mappedSource instanceof JDBCFeatureSource) {
            mappedSource = new JoiningJDBCFeatureSource((JDBCFeatureSource) mappedSource);
        } else if (mappedSource instanceof JDBCFeatureStore) {
            mappedSource = new JoiningJDBCFeatureSource((JDBCFeatureStore) mappedSource);
        } 
        Query unmappedQuery = unrollQuery(targetQuery, mapping);
        return mappedSource.getCount(unmappedQuery);
    }

