    // properties can only be set by constructor, before initialising source features
    // (for joining nested mappings)
    private void setPropertyNames(Collection<PropertyName> propertyNames) {
        selectedProperties = new HashMap<>();

        if (propertyNames == null) {
            selectedMapping = mapping.getAttributeMappings();
        } else {
            final AttributeDescriptor targetDescriptor = mapping.getTargetFeature();
            selectedMapping = new ArrayList<>();

            for (AttributeMapping attMapping : mapping.getAttributeMappings()) {
                final StepList targetSteps = attMapping.getTargetXPath();
                boolean alreadyAdded = false;

                if (includeMandatory) {
                    PropertyName targetProp =
                            namespaceAwareFilterFactory.property(targetSteps.toString());
                    Object descr = targetProp.evaluate(targetDescriptor.getType());
                    if (descr instanceof PropertyDescriptor) {
                        if (((PropertyDescriptor) descr).getMinOccurs() >= 1) {
                            selectedMapping.add(attMapping);
                            selectedProperties.put(attMapping, new ArrayList<>());
                            alreadyAdded = true;
                        }
                    }
                }

                for (PropertyName requestedProperty : propertyNames) {
                    // replace the artificial DEFAULT_GEOMETRY property with the actual one
                    if (DEFAULT_GEOMETRY_LOCAL_NAME.equals(requestedProperty.getPropertyName())) {
                        String defGeomPath = mapping.getDefaultGeometryXPath();
                        requestedProperty = namespaceAwareFilterFactory.property(defGeomPath);
                    }

                    StepList requestedPropertySteps;
                    if (requestedProperty.getNamespaceContext() == null) {
                        requestedPropertySteps =
                                XPath.steps(
                                        targetDescriptor,
                                        requestedProperty.getPropertyName(),
                                        namespaces);
                    } else {
                        requestedPropertySteps =
                                XPath.steps(
                                        targetDescriptor,
                                        requestedProperty.getPropertyName(),
                                        requestedProperty.getNamespaceContext());
                    }
                    if (requestedPropertySteps == null
                            ? AppSchemaDataAccess.matchProperty(
                                    requestedProperty.getPropertyName(), targetSteps)
                            : AppSchemaDataAccess.matchProperty(
                                    requestedPropertySteps, targetSteps)) {
                        if (!alreadyAdded) {
                            selectedMapping.add(attMapping);
                            selectedProperties.put(attMapping, new ArrayList<>());
                            alreadyAdded = true;
                        }
                        if (requestedPropertySteps != null
                                && requestedPropertySteps.size() > targetSteps.size()) {
                            List<PropertyName> pnList = selectedProperties.get(attMapping);
                            StepList subProperty =
                                    requestedPropertySteps.subList(
                                            targetSteps.size(), requestedPropertySteps.size());
                            pnList.add(
                                    filterFac.property(
                                            subProperty.toString(),
                                            requestedProperty.getNamespaceContext()));
                        }
                    }
                }
            }
        }
    }

