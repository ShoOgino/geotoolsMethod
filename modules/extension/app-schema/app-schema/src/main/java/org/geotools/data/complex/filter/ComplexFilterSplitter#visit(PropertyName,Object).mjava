    public Object visit(PropertyName expression, Object notUsed) {

        // replace the artificial DEFAULT_GEOMETRY property with the actual one
        if (DEFAULT_GEOMETRY_LOCAL_NAME.equals(expression.getPropertyName())) {
            String defGeomPath = mappings.getDefaultGeometryXPath();
            FilterFactory2 ff = new FilterFactoryImplNamespaceAware(mappings.getNamespaces());
            expression = ff.property(defGeomPath);
        }

        // break into single steps
        StepList exprSteps =
                XPath.steps(
                        mappings.getTargetFeature(),
                        expression.getPropertyName(),
                        this.mappings.getNamespaces());

        if (exprSteps.containsPredicate()) {
            postStack.push(expression);
            return null;
        }

        List<Expression> matchingMappings = mappings.findMappingsFor(exprSteps, false);

        if (AppSchemaDataAccessConfigurator.shouldEncodeNestedFilters()) {
            // check nested mappings
            FeatureChainedAttributeVisitor nestedAttrExtractor =
                    new FeatureChainedAttributeVisitor(mappings);
            nestedAttrExtractor.visit(expression, null);

            List<FeatureChainedAttributeDescriptor> fcAttrs =
                    nestedAttrExtractor.getFeatureChainedAttributes();
            if (fcAttrs.size() == 0
                    && !nestedAttrExtractor.conditionalMappingWasFound()
                    && !FeatureChainedAttributeVisitor.isXlinkHref(exprSteps)) {
                throw new IllegalArgumentException(
                        String.format(
                                "Attribute \"%s\" not found in type \"%s\"",
                                expression, mappings.getTargetFeature().getName().toString()));
            }
            // encoding of filters on multiple nested attributes is not (yet) supported
            if (fcAttrs.size() == 1) {
                FeatureChainedAttributeDescriptor nestedAttrDescr = fcAttrs.get(0);
                if (nestedAttrDescr.chainSize() > 1 && nestedAttrDescr.isJoiningEnabled()) {
                    FeatureTypeMapping featureMapping =
                            nestedAttrDescr.getFeatureTypeOwningAttribute();
                    nestedAttributes.add(nestedAttrDescr);

                    // add source expressions for target attribute
                    List<Expression> nestedMappings =
                            featureMapping.findMappingsFor(
                                    nestedAttrDescr.getAttributePath(), false);
                    Iterator<Expression> it = matchingMappings.iterator();
                    while (it.hasNext()) {
                        if (it.next() == null) {
                            // necessary to enable encoding of nested filters when joining simple
                            // content
                            it.remove();
                        }
                    }
                    matchingMappings.addAll(nestedMappings);

                    // add source expressions for mappings used in join conditions, as they too must
                    // be encoded
                    for (int i = nestedAttrDescr.chainSize() - 2; i > 0; i--) {
                        FeatureChainLink mappingStep = nestedAttrDescr.getLink(i);
                        if (mappingStep.hasNestedFeature()) {
                            FeatureChainLink parentStep = nestedAttrDescr.getLink(i);

                            NestedAttributeMapping nestedAttr =
                                    parentStep.getNestedFeatureAttribute();
                            FeatureTypeMapping nestedFeature = null;
                            try {
                                nestedFeature = nestedAttr.getFeatureTypeMapping(null);
                            } catch (IOException e) {
                                LOGGER.warning(
                                        "Exception occurred processing nested filter, encoding"
                                                + "will be disabled: "
                                                + e.getMessage());
                                postStack.push(expression);
                                return null;
                            }

                            Expression nestedExpr =
                                    nestedAttr.getMapping(nestedFeature).getSourceExpression();
                            matchingMappings.add(nestedExpr);
                        }
                    }
                }
            } else {
                // we may have a direct match, so lets push this filter to the post stack right away
                postStack.push(expression);
                return null;
            }
        }

        if (matchingMappings.isEmpty()) {
            // handle multi value
            AttributeMapping candidate = mappings.getAttributeMapping(exprSteps);
            if (candidate != null
                    && candidate.isMultiValued()
                    && candidate.getMultipleValue() != null) {
                return super.visit(expression, notUsed);
            }
            postStack.push(expression);
            return null;
        } else {
            for (Expression expr : matchingMappings) {
                if (expr == null) {
                    // this is joining for simple content
                    // has to go to post stack because it comes from another table
                    postStack.push(expression);
                    return null;
                } else {
                    CapabilitiesExpressionVisitor visitor = new CapabilitiesExpressionVisitor();
                    expr.accept(visitor, null);
                    if (!visitor.isCapable()) {
                        postStack.push(expression);
                        return null;
                    }
                }
            }
        }

        return super.visit(expression, notUsed);
    }

