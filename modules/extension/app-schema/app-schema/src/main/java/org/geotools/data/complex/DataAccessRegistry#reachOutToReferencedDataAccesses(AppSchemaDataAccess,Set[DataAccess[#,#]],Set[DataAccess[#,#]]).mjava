    // recursive method to navigate the dependency graph, following feature chaining links
    private boolean reachOutToReferencedDataAccesses(AppSchemaDataAccess asda,
            Set<DataAccess<?, ?>> stillReferencedDataAccessInstances,
            Set<DataAccess<?, ?>> reachedDataAccessInstances) throws IOException {
        reachedDataAccessInstances.add(asda);
        for (Name typeName : asda.getNames()) {
            FeatureTypeMapping ftm = asda.getMappingByNameOrElement(typeName);
            List<NestedAttributeMapping> nestedMappings = ftm.getNestedMappings();
            if (nestedMappings != null) {
                for (NestedAttributeMapping nestedAttr : nestedMappings) {
                    // TODO: can't figure out how to support polymorphic mappings without
                    // evaluating the expression for every single feature, so, if a polymorphic
                    // mapping is found, return false to notify the caller that automatic
                    // disposal cannot be done safely
                    if (!nestedAttr.isConditional()) {
                        String nestedTypeNameAsString = nestedAttr.nestedFeatureType.toString();
                        Name nestedTypeName = Types.degloseName(nestedTypeNameAsString,
                                nestedAttr.getNamespaces());
                        try {
                            DataAccess<FeatureType, Feature> refDA = getDataAccess(nestedTypeName);
                            if (refDA instanceof AppSchemaDataAccess) {
                                AppSchemaDataAccess refASDA = (AppSchemaDataAccess) refDA;
                                if (refASDA.hidden) {
                                    stillReferencedDataAccessInstances.add(refASDA);
                                }
                                if (!reachedDataAccessInstances.contains(refASDA)) {
                                    // recursive call
                                    if (!reachOutToReferencedDataAccesses(refASDA,
                                            stillReferencedDataAccessInstances,
                                            reachedDataAccessInstances)) {
                                        return false;
                                    }
                                }
                            }
                        } catch (DataSourceException dse) {
                            LOGGER.log(Level.FINER, "Referenced data access not found: "
                                    + "probably it has been removed already, moving on...", dse);
                        }
                    } else {
                        LOGGER.finer("Polymorphic mapping found, disabling automatic disposal of hidden data accesses");
                        return false;
                    }
                }
            }
        }

        return true;
    }

