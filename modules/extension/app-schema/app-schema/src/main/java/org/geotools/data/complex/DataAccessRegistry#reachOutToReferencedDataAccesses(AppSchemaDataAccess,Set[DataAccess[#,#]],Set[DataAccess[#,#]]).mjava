    // recursive method to navigate the dependency graph, following feature chaining links
    private boolean reachOutToReferencedDataAccesses(
            AppSchemaDataAccess asda,
            Set<DataAccess<?, ?>> stillReferencedDataAccessInstances,
            Set<DataAccess<?, ?>> reachedDataAccessInstances)
            throws IOException {
        reachedDataAccessInstances.add(asda);
        for (Name typeName : asda.getNames()) {
            FeatureTypeMapping ftm = asda.getMappingByNameOrElement(typeName);
            List<NestedAttributeMapping> nestedMappings = ftm.getNestedMappings();
            if (nestedMappings != null) {
                for (NestedAttributeMapping nestedAttr : nestedMappings) {
                    // TODO: can't figure out how to support polymorphic mappings without
                    // evaluating the expression for every single feature, so, if a polymorphic
                    // mapping is found, return false to notify the caller that automatic
                    // disposal cannot be done safely
                    if (!nestedAttr.isConditional()) {
                        String nestedTypeNameAsString = nestedAttr.nestedFeatureType.toString();
                        Name nestedTypeName =
                                Types.degloseName(
                                        nestedTypeNameAsString, nestedAttr.getNamespaces());
                        try {
                            DataAccess<FeatureType, Feature> refDA = getDataAccess(nestedTypeName);
                            if (refDA instanceof AppSchemaDataAccess) {
                                AppSchemaDataAccess refASDA = (AppSchemaDataAccess) refDA;
                                if (refASDA.hidden) {
                                    stillReferencedDataAccessInstances.add(refASDA);
                                }
                                if (!reachedDataAccessInstances.contains(refASDA)) {
                                    // recursive call
                                    if (!reachOutToReferencedDataAccesses(
                                            refASDA,
                                            stillReferencedDataAccessInstances,
                                            reachedDataAccessInstances)) {
                                        return false;
                                    }
                                }
                            }
                        } catch (DataSourceException dse) {
                            LOGGER.log(
                                    Level.FINER,
                                    "Referenced data access not found: "
                                            + "probably it has been removed already, moving on...",
                                    dse);
                        }
                    } else {
                        LOGGER.finer(
                                "Polymorphic mapping found, disabling automatic disposal of hidden data accesses");
                        return false;
                    }
                }
            }
        }

        return true;
    }

