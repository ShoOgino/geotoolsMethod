    /**
     * Tests if the schema-to-FM parsing code developed for complex datastore configuration loading
     * can parse the GeoSciML types
     *
     * @throws Exception
     */
    @Test
    public void testParseSchema() throws Exception {
        SchemaIndex schemaIndex;
        try {
            // loadSchema(schemaBase + "commonSchemas_new/GeoSciML/Gsml.xsd");
            // use the absolute URL and let the Oasis Catalog resolve it to the local FS
            schemaIndex = loadSchema("http://schemas.opengis.net/GeoSciML/Gsml.xsd");
        } catch (Exception e) {
            java.util.logging.Logger.getGlobal().log(java.util.logging.Level.INFO, "", e);
            throw e;
        }

        AppSchemaFeatureTypeRegistry typeRegistry = new AppSchemaFeatureTypeRegistry();
        try {
            typeRegistry.addSchemas(schemaIndex);

            Name typeName = Types.typeName(GSMLNS, "MappedFeatureType");
            ComplexType mf = (ComplexType) typeRegistry.getAttributeType(typeName);
            assertNotNull(mf);
            assertTrue(mf instanceof FeatureType);

            typeName = Types.typeName("http://www.opengis.net/sampling/1.0", "SamplingFeatureType");
            mf = (ComplexType) typeRegistry.getAttributeType(typeName);
            assertNotNull(mf);
            assertTrue(mf instanceof FeatureType);
        } finally {
            typeRegistry.disposeSchemaIndexes();
        }
        /*
         * AttributeType superType = mf.getSuper(); assertNotNull(superType); Name superTypeName =
         * Types.typeName(SANS, "ProfileType"); assertEquals(superTypeName, superType.getName());
         * assertTrue(superType instanceof FeatureType); // ensure all needed types were parsed and
         * aren't just empty proxies Collection properties = mf.getProperties(); assertEquals(16,
         * properties.size()); Map expectedNamesAndTypes = new HashMap(); // from
         * gml:AbstractFeatureType expectedNamesAndTypes.put(name(GMLNS, "metaDataProperty"),
         * typeName(GMLNS, "MetaDataPropertyType")); expectedNamesAndTypes.put(name(GMLNS,
         * "description"), typeName(GMLNS, "StringOrRefType"));
         * expectedNamesAndTypes.put(name(GMLNS, "name"), typeName(GMLNS, "CodeType"));
         * expectedNamesAndTypes.put(name(GMLNS, "boundedBy"), typeName(GMLNS,
         * "BoundingShapeType")); expectedNamesAndTypes.put(name(GMLNS, "location"), typeName(GMLNS,
         * "LocationPropertyType")); // from sa:ProfileType expectedNamesAndTypes.put(name(SANS,
         * "begin"), typeName(GMLNS, "PointPropertyType")); expectedNamesAndTypes.put(name(SANS,
         * "end"), typeName(GMLNS, "PointPropertyType")); expectedNamesAndTypes.put(name(SANS,
         * "length"), typeName(SWENS, "RelativeMeasureType")); expectedNamesAndTypes.put(name(SANS,
         * "shape"), typeName(GEONS, "Shape1DPropertyType")); // sa:SamplingFeatureType
         * expectedNamesAndTypes.put(name(SANS, "member"), typeName(SANS,
         * "SamplingFeaturePropertyType")); expectedNamesAndTypes.put(name(SANS, "surveyDetails"),
         * typeName(SANS, "SurveyProcedurePropertyType")); expectedNamesAndTypes.put(name(SANS,
         * "associatedSpecimen"), typeName(SANS, "SpecimenPropertyType"));
         * expectedNamesAndTypes.put(name(SANS, "relatedObservation"), typeName(OMNS,
         * "AbstractObservationPropertyType")); // from xmml:mfType
         * expectedNamesAndTypes.put(name(XMMLNS, "drillMethod"), typeName(XMMLNS, "drillCode"));
         * expectedNamesAndTypes.put(name(XMMLNS, "collarDiameter"), typeName(GMLNS,
         * "MeasureType")); expectedNamesAndTypes.put(name(XMMLNS, "log"), typeName(XMMLNS,
         * "LogPropertyType"));
         *
         * for (Iterator it = expectedNamesAndTypes.entrySet().iterator(); it.hasNext();) {
         * Map.Entry entry = (Entry) it.next(); Name dName = (Name) entry.getKey(); Name tName =
         * (Name) entry.getValue();
         *
         * AttributeDescriptor d = (AttributeDescriptor) Types.descriptor(mf, dName);
         * assertNotNull("Descriptor not found: " + dName, d); AttributeType type; try { type =
         * d.getType(); } catch (Exception e) { LOGGER.log(Level.SEVERE, "type not parsed for " +
         * ((AttributeDescriptor) d).getName(), e); throw e; } assertNotNull(type);
         * assertNotNull(type.getName()); assertNotNull(type.getBinding()); if (tName != null) {
         * assertEquals(tName, type.getName()); } }
         *
         * Name tcl = Types.typeName(SWENS, "TypedCategoryListType"); AttributeType
         * typedCategoryListType = (AttributeType) typeRegistry.get(tcl);
         * assertNotNull(typedCategoryListType); assertFalse(typedCategoryListType instanceof
         * ComplexType);
         */
    }

