    /**
     * testFeatureChaining() tests one to many relationship, but the many side was on the chaining
     * side ie. geologic unit side (with many composition parts). This is to test that configuring
     * many on the the chained works. We're using composition part -> lithology here.
     */
    @Test
    public void testManyOnChainedSide() throws Exception {

        final String LITHOLOGY = "lithology";
        // get controlled concept features on their own
        int count = 0;
        Map<String, Feature> featureList = new HashMap<>();
        try (AbstractMappingFeatureIterator iterator =
                (AbstractMappingFeatureIterator) ccFeatures.features()) {
            while (iterator.hasNext()) {
                Feature f = iterator.next();
                featureList.put(f.getIdentifier().getID(), f);
                count++;
            }
        }
        assertEquals(5, count);

        try (FeatureIterator<Feature> cpIterator = cpFeatures.features()) {
            while (cpIterator.hasNext()) {
                Feature cpFeature = cpIterator.next();
                Collection<Property> lithologies = cpFeature.getProperties(LITHOLOGY);
                if (cpFeature.getIdentifier().toString().equals("cp.167775491936278812")) {
                    // see ControlledConcept.properties file:
                    // _=NAME:String,COMPOSITION_ID:String
                    // cc.1=name_a|cp.167775491936278812
                    // cc.1=name_b|cp.167775491936278812
                    // cc.1=name_c|cp.167775491936278812
                    // cc.2=name_2|cp.167775491936278812
                    assertEquals(2, lithologies.size());
                    Collection<String> lithologyIds = new ArrayList<>();
                    for (Property lithologyProperty : lithologies) {
                        Feature nestedFeature =
                                (Feature)
                                        ((Collection) lithologyProperty.getValue())
                                                .iterator()
                                                .next();
                        String fId = nestedFeature.getIdentifier().getID();
                        lithologyIds.add(fId);
                        Feature lithology = featureList.get(fId);
                        assertEquals(nestedFeature.getProperties(), lithology.getProperties());
                    }
                    assertTrue(featureList.keySet().containsAll(lithologyIds));
                } else {
                    // lithology is required
                    assertEquals(1, lithologies.size());
                }
            }
        }
    }

