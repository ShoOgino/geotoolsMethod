    /**
     * Success scenarios for keeping uniqueness of FeatureTypeMapping key (mappingName or
     * targetElement).
     */
    @Test
    public void testUniqueKey() throws IOException {
        /** When mappingName are present in both mappings, and they're unique */
        Set<TypeMapping> mappings = new HashSet<>();
        TypeMapping duplicate = new TypeMapping();
        duplicate.setMappingName(dtoMappingName.getTargetElementName());
        duplicate.setSourceDataStore(dtoMappingName.getSourceDataStore());
        duplicate.setSourceTypeName(dtoMappingName.getSourceTypeName());
        duplicate.setTargetElementName(dtoMappingName.getTargetElementName());
        mappings.add(dtoMappingName);
        mappings.add(duplicate);
        config.setTypeMappings(mappings);
        AppSchemaDataAccess da =
                new AppSchemaDataAccess(AppSchemaDataAccessConfigurator.buildMappings(config));
        assertNotNull(da);
        da.dispose();
        /**
         * When mappingName is present in one mapping, and it's different from the targetElement of
         * the other.
         */
        mappings.clear();
        mappings.add(dtoMappingName);
        mappings.add(dtoNoMappingName);
        config.setTypeMappings(mappings);
        assertTrue(config.getTypeMappings().containsAll(mappings));
        da = new AppSchemaDataAccess(AppSchemaDataAccessConfigurator.buildMappings(config));
        assertNotNull(da);
        da.dispose();
        // no need to test the scenario if both target elements are unique, as most of the other
        // app-schema test files are already like this.
    }

