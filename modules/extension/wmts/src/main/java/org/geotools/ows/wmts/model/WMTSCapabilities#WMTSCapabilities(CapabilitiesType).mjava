    public WMTSCapabilities(CapabilitiesType capabilities) throws ServiceException {
        caps = capabilities;
        setService(new WMTSService(caps.getServiceIdentification(), caps.getServiceProvider()));
        setVersion(caps.getServiceIdentification().getServiceTypeVersion().toString());
        ContentsType contents = caps.getContents();

        // Parse layers
        for (Object l : contents.getDatasetDescriptionSummary()) {

            if (l instanceof LayerType) {
                LayerType layerType = (LayerType) l;
                WMTSLayer layer = parseLayer(layerType);
                layers.add(layer);
                layerMap.put(layer.getName(), layer);

            } else {
                if (LOGGER.isLoggable(Level.INFO)) {
                    LOGGER.info("Unknown object " + l);
                }
            }
        }

        // Parse TileMatrixSets
        for (TileMatrixSetType tm : contents.getTileMatrixSet()) {
            TileMatrixSet matrixSet = parseMatrixSet(tm);
            matrixes.add(matrixSet);
            matrixSetMap.put(matrixSet.getIdentifier(), matrixSet);
        }

        // set layer SRS - this comes from the tile matrix link
        Set<String> srs = new TreeSet<>();
        Set<CoordinateReferenceSystem> crs = new HashSet<>();
        Map<String, CoordinateReferenceSystem> names = new HashMap<>();
        for (TileMatrixSet tms : matrixes) {

            CoordinateReferenceSystem refSystem = tms.getCoordinateReferenceSystem();
            crs.add(refSystem);
            names.put(tms.getIdentifier(), refSystem);

            srs.add(tms.getCrs());
        }

        // Fill in some layers info from the linked MatrixSets
        for (Layer l : layers) {
            WMTSLayer wmtsLayer = (WMTSLayer) l;
            Map<String, TileMatrixSetLink> tileMatrixLinks = wmtsLayer.getTileMatrixLinks();

            if (wmtsLayer.getLatLonBoundingBox() != null) {
                ReferencedEnvelope wgs84Env =
                        new ReferencedEnvelope(wmtsLayer.getLatLonBoundingBox());
                wmtsLayer.getBoundingBoxes().put("EPSG:4326", new CRSEnvelope(wgs84Env));
            } else {
                // if the layer does not provide wgs84bbox, let's assume a bbox
                // from the tilematrixset
                for (TileMatrixSetLink tmsLink : tileMatrixLinks.values()) {
                    TileMatrixSet tms = matrixSetMap.get(tmsLink.getIdentifier());
                    if (tms.getBbox() != null) {
                        // Take the first good bbox
                        // TODO: refer a bbox which is natively wgs84
                        ReferencedEnvelope re = new ReferencedEnvelope(tms.getBbox());
                        try {
                            ReferencedEnvelope wgs84re =
                                    re.transform(DefaultGeographicCRS.WGS84, true);
                            wmtsLayer.setLatLonBoundingBox(new CRSEnvelope(wgs84re));
                            break;
                        } catch (Exception ex) {
                            // the RE can't be projected on WGS84,
                            // so let's try another one
                            if (LOGGER.isLoggable(Level.FINE))
                                LOGGER.fine(
                                        "Can't use "
                                                + tms.getIdentifier()
                                                + " for bbox: "
                                                + ex.getMessage());
                            continue;
                        }
                    }
                }

                if (wmtsLayer.getLatLonBoundingBox() == null) {
                    // We did not find any good bbox
                    LOGGER.warning("No good Bbox found for layer " + l.getName());
                    // throw new ServiceException("No good Bbox found for layer " + l.getName());
                    CRSEnvelope latLonBoundingBox = new CRSEnvelope("CRS:84", -180, -90, 180, 90);
                    wmtsLayer.setLatLonBoundingBox(latLonBoundingBox);
                    wmtsLayer.setBoundingBoxes(latLonBoundingBox);
                }
            }

            ReferencedEnvelope wgs84Env = new ReferencedEnvelope(wmtsLayer.getLatLonBoundingBox());

            // add a bbox for every CRS
            for (TileMatrixSetLink tmsLink : tileMatrixLinks.values()) {
                CoordinateReferenceSystem tmsCRS = names.get(tmsLink.getIdentifier());
                wmtsLayer.setPreferredCRS(tmsCRS); // the preferred crs is just
                // an arbitrary one?
                String crsCode = tmsCRS.getName().getCode();

                if (wmtsLayer.getBoundingBoxes().containsKey(crsCode)) {
                    if (LOGGER.isLoggable(Level.FINE))
                        LOGGER.fine(
                                "Bbox for " + crsCode + " already exists for layer " + l.getName());
                    continue;
                }

                TileMatrixSet tms = matrixSetMap.get(tmsLink.getIdentifier());
                if (tms.getBbox() != null) {
                    wmtsLayer.getBoundingBoxes().put(crsCode, tms.getBbox());
                }

                // add bboxes
                try {
                    // make safe to CRS bounds
                    // making bbox safe may restrict it too much: let's trust in
                    // the declaration
                    wmtsLayer
                            .getBoundingBoxes()
                            .put(crsCode, new CRSEnvelope(wgs84Env.transform(tmsCRS, true)));
                    wmtsLayer.addSRS(tmsCRS);
                } catch (TransformException | FactoryException e) {
                    if (LOGGER.isLoggable(Level.INFO))
                        LOGGER.info("Not adding CRS " + crsCode + " for layer " + l.getName());
                }
            }
        }

        request = new WMTSRequest();
        // some REST capabilities don't fill this in but we need it later!
        OperationType operationType = new OperationType();
        operationType.setGet(null);
        request.setGetCapabilities(operationType);
        OperationsMetadataType operationsMetadata = caps.getOperationsMetadata();
        setType(WMTSServiceType.REST);
        boolean isKVP = false;
        boolean isREST = false;
        if (operationsMetadata != null) {
            for (Object op : operationsMetadata.getOperation()) {
                OperationType opt = operationType;
                net.opengis.ows11.OperationType opx = (net.opengis.ows11.OperationType) op;

                EList dcps = opx.getDCP();
                for (Object item : dcps) {
                    DCPType dcp = (DCPType) item;

                    EList gets = dcp.getHTTP().getGet();
                    for (Object value : gets) {
                        RequestMethodType get = (RequestMethodType) value;
                        try {
                            opt.setGet(new URL(get.getHref()));
                            if (!get.getConstraint().isEmpty()) {
                                for (Object con : get.getConstraint()) {
                                    DomainType dt = (DomainType) con;
                                    AllowedValuesType t = dt.getAllowedValues();
                                    for (Object v : t.getValue()) {
                                        ValueType vt = (ValueType) v;
                                        if (vt.getValue().equalsIgnoreCase("KVP")) {
                                            isKVP = true;
                                        } else if (vt.getValue().equalsIgnoreCase("REST")
                                                || vt.getValue().equalsIgnoreCase("RESTful")) {
                                            isREST = true;
                                        }
                                    }
                                }
                            }
                        } catch (MalformedURLException e) {
                            throw new ServiceException(
                                    "Error parsing WMTS operation URL: " + e.getMessage());
                        }
                    }
                    EList posts = dcp.getHTTP().getPost();
                    for (Object o : posts) {
                        RequestMethodType post = (RequestMethodType) o;
                        try {
                            opt.setPost(new URL(post.getHref()));
                            if (!post.getConstraint().isEmpty()) {
                                for (Object con : post.getConstraint()) {
                                    DomainType dt = (DomainType) con;
                                    AllowedValuesType t = dt.getAllowedValues();
                                    for (Object v : t.getValue()) {
                                        ValueType vt = (ValueType) v;
                                        if (vt.getValue().equalsIgnoreCase("KVP")) {
                                            isKVP = true;
                                        } else if (vt.getValue().equalsIgnoreCase("REST")
                                                || vt.getValue().equalsIgnoreCase("RESTful")) {
                                            isREST = true;
                                        }
                                    }
                                }
                            }
                        } catch (MalformedURLException e) {
                            throw new ServiceException(
                                    "Error parsing WMTS operation URL: " + e.getMessage());
                        }
                    }
                }
                if (isREST) { // Given the choice we prefer REST (it's less likely to be broken)
                    setType(WMTSServiceType.REST);
                } else if (isKVP) {
                    setType(WMTSServiceType.KVP);
                }
                if (opx.getName().equalsIgnoreCase("GetCapabilities")) {
                    request.setGetCapabilities(opt);
                } else if (opx.getName().equalsIgnoreCase("GetTile")) {
                    request.setGetTile(opt);
                }
            }
        }
    }

