    /**
     * Copies the content of one collection ({@code source}) into an other ({@code target}). If the
     * target collection is {@code null}, or if its type ({@link List} vs {@link Set}) doesn't
     * matches the type of the source collection, a new target collection is created.
     *
     * <p>A call to {@link #checkWritePermission} is implicit before the copy is performed.
     *
     * @param  <E> The type of elements in the collection.
     * @param source The source collection. {@code null} is synonymous to empty.
     * @param target The target collection, or {@code null} if not yet created.
     * @param elementType The base type of elements to put in the collection.
     * @return {@code target}, or a newly created collection.
     * @throws UnmodifiableMetadataException if this metadata is unmodifiable.
     */
    protected final <E> Collection<E> copyCollection(
            final Collection<? extends E> source, Collection<E> target, final Class<E> elementType)
            throws UnmodifiableMetadataException {
        if (unmodifiable == FREEZING) {
            /*
             * freeze() method is under progress. The source collection is already
             * an unmodifiable instance created by unmodifiable(Object).
             */
            assert !isModifiable(source);
            @SuppressWarnings("unchecked")
            final Collection<E> unmodifiable = (Collection<E>) source;
            return unmodifiable;
        }
        checkWritePermission();
        /*
         * It is not worth to copy the content if the current and the new instance are the
         * same. This is safe only using the != operator, not the equals(Object) method.
         * This optimization is required for efficient working of PropertyAccessor.set(...).
         */
        if (source != target) {
            if (source == null) {
                if (target != null) {
                    target.clear();
                }
            } else {
                final boolean isList = (source instanceof List);
                if (target != null && (target instanceof List) == isList) {
                    target.clear();
                } else {
                    int capacity = source.size();
                    if (isList) {
                        target = new MutableList<>(elementType, capacity);
                    } else {
                        capacity = Math.round(capacity / 0.75f) + 1;
                        target = new MutableSet<>(elementType, capacity);
                    }
                }
                target.addAll(source);
            }
        }
        return target;
    }

