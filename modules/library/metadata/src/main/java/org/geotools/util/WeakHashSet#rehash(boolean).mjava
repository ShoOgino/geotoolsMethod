    /**
     * Rehash {@link #table}.
     *
     * @param augmentation {@code true} if this method is invoked for augmenting {@link #table}, or
     *     {@code false} if it is invoked for making the table smaller.
     */
    private void rehash(final boolean augmentation) {
        assert Thread.holdsLock(this);
        assert valid();
        final long currentTime = System.currentTimeMillis();
        final int capacity = Math.max(Math.round(count / (LOAD_FACTOR / 2)), count + MIN_CAPACITY);
        if (augmentation
                ? (capacity <= table.length)
                : (capacity >= table.length || currentTime - lastRehashTime < HOLD_TIME)) {
            return;
        }
        lastRehashTime = currentTime;
        final Entry[] oldTable = table;
        newEntryTable(capacity);
        threshold = Math.round(capacity * LOAD_FACTOR);
        for (int i = 0; i < oldTable.length; i++) {
            for (Entry old = oldTable[i]; old != null; ) {
                final Entry e = old;
                old = old.next; // We keep 'next' right now because its value will change.
                final E obj_e = e.get();
                if (obj_e != null) {
                    final int index = (obj_e.hashCode() & 0x7FFFFFFF) % table.length;
                    e.index = index;
                    e.next = table[index];
                    table[index] = e;
                } else {
                    count--;
                }
            }
        }
        final Logger logger = Logging.getLogger("org.geotools.util");
        final Level level = Level.FINEST;
        if (logger.isLoggable(level)) {
            final LogRecord record =
                    new LogRecord(level, "Rehash from " + oldTable.length + " to " + table.length);
            record.setSourceMethodName(augmentation ? "unique" : "remove");
            record.setSourceClassName(WeakHashSet.class.getName());
            record.setLoggerName(logger.getName());
            logger.log(record);
        }
        assert valid();
    }

