    /**
     * Convenience method for testing two objects for equality. One or both objects may be null. If
     * both are non-null and are arrays, then every array elements will be compared.
     *
     * <p>This method may be useful when the objects may or may not be array. If they are known to
     * be arrays, consider using {@link Arrays#deepEquals(Object[],Object[])} or one of its
     * primitive counter-part instead.
     *
     * <p><strong>Rules for choosing an {@code equals} or {@code deepEquals} method</strong>
     *
     * <ul>
     *   <li>If <em>both</em> objects are declared as {@code Object[]} (not anything else like
     *       {@code String[]}), consider using {@link Arrays#deepEquals(Object[],Object[])} except
     *       if it is known that the array elements can never be other arrays.
     *   <li>Otherwise if both objects are arrays (e.g. {@code Expression[]}, {@code String[]},
     *       {@code int[]}, <cite>etc.</cite>), use {@link Arrays#equals(Object[],Object[])}. This
     *       rule is applicable to arrays of primitive type too, since {@code Arrays.equals} is
     *       overriden with primitive counter-parts.
     *   <li>Otherwise if at least one object is anything else than {@code Object} (e.g. {@code
     *       String}, {@code Expression}, <cite>etc.</cite>), use {@link #equals(Object,Object)}.
     *       Using this {@code deepEquals} method would be an overkill since there is no chance that
     *       {@code String} or {@code Expression} could be an array.
     *   <li>Otherwise if <em>both</em> objects are declared exactly as {@code Object} type and it
     *       is known that they could be arrays, only then invoke this {@code deepEquals} method. In
     *       such case, make sure that the hash code is computed using {@link #deepHashCode} for
     *       consistency.
     * </ul>
     *
     * @param object1 The first object to compare, or {@code null}.
     * @param object2 The second object to compare, or {@code null}.
     * @return {@code true} if both objects are equal.
     */
    public static boolean deepEquals(final Object object1, final Object object2) {
        if (object1 == object2) {
            return true;
        }
        if (object1 == null || object2 == null) {
            return false;
        }
        if (object1 instanceof Object[]) {
            return (object2 instanceof Object[])
                    && Arrays.deepEquals((Object[]) object1, (Object[]) object2);
        }
        if (object1 instanceof double[]) {
            return (object2 instanceof double[])
                    && Arrays.equals((double[]) object1, (double[]) object2);
        }
        if (object1 instanceof float[]) {
            return (object2 instanceof float[])
                    && Arrays.equals((float[]) object1, (float[]) object2);
        }
        if (object1 instanceof long[]) {
            return (object2 instanceof long[]) && Arrays.equals((long[]) object1, (long[]) object2);
        }
        if (object1 instanceof int[]) {
            return (object2 instanceof int[]) && Arrays.equals((int[]) object1, (int[]) object2);
        }
        if (object1 instanceof short[]) {
            return (object2 instanceof short[])
                    && Arrays.equals((short[]) object1, (short[]) object2);
        }
        if (object1 instanceof byte[]) {
            return (object2 instanceof byte[]) && Arrays.equals((byte[]) object1, (byte[]) object2);
        }
        if (object1 instanceof char[]) {
            return (object2 instanceof char[]) && Arrays.equals((char[]) object1, (char[]) object2);
        }
        if (object1 instanceof boolean[]) {
            return (object2 instanceof boolean[])
                    && Arrays.equals((boolean[]) object1, (boolean[]) object2);
        }
        return object1.equals(object2);
    }

