    /**
     * Construit une chaîne de caractères qui contiendra le
     * noeud spécifié ainsi que tous les noeuds enfants.
     *
     * @param model  Arborescence à écrire.
     * @param node   Noeud de l'arborescence à écrire.
     * @param buffer Buffer dans lequel écrire le noeud.
     * @param level  Niveau d'indentation (à partir de 0).
     * @param last   Indique si les niveaux précédents sont en train d'écrire leurs derniers items.
     * @return       Le tableau {@code last}, qui peut éventuellement avoir été agrandit.
     */
    private static boolean[] format(final TreeModel model, final Object node,
                                    final Appendable buffer, final int level, boolean[] last,
                                    final String lineSeparator) throws IOException
    {
        for (int i=0; i<level; i++) {
            if (i != level-1) {
                buffer.append(last[i] ? '\u00A0' : '\u2502').append("\u00A0\u00A0\u00A0");
            } else {
                buffer.append(last[i] ? '\u2514' : '\u251C').append("\u2500\u2500\u2500");
            }
        }
        buffer.append(String.valueOf(node)).append(lineSeparator);
        if (level >= last.length) {
            last = XArray.resize(last, level*2);
        }
        final int count = model.getChildCount(node);
        for (int i=0; i<count; i++) {
            last[level] = (i == count-1);
            last = format(model, model.getChild(node,i), buffer, level+1, last, lineSeparator);
        }
        return last;
    }

