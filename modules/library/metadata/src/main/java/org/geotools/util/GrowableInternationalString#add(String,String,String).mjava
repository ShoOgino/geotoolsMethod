    /**
     * Adds a string for the given property key. This is a convenience method for constructing an
     * {@code AbstractInternationalString} during iteration through the {@linkplain
     * java.util.Map.Entry entries} in a {@link Map}. It infers the {@link Locale} from the property
     * {@code key}, using the following steps:
     *
     * <ul>
     *   <li>If the {@code key} do not starts with the specified {@code prefix}, then this method do
     *       nothing and returns {@code false}.
     *   <li>Otherwise, the characters after the {@code prefix} are parsed as an ISO language and
     *       country code, and the {@link #add(Locale,String)} method is invoked.
     * </ul>
     *
     * <p>For example if the prefix is <code>"remarks"</code>, then the <code>"remarks_fr"</code>
     * property key stands for remarks in {@linkplain Locale#FRENCH French} while the <code>
     * "remarks_fr_CA"</code> property key stands for remarks in {@linkplain Locale#CANADA_FRENCH
     * French Canadian}.
     *
     * @param prefix The prefix to skip at the begining of the {@code key}.
     * @param key The property key.
     * @param string The localized string for the specified {@code key}.
     * @return {@code true} if the key has been recognized, or {@code false} otherwise.
     * @throws IllegalArgumentException if the locale after the prefix is an illegal code, or a
     *     different string value was already set for the given locale.
     */
    public boolean add(final String prefix, final String key, final String string)
            throws IllegalArgumentException {
        if (!key.startsWith(prefix)) {
            return false;
        }
        int position = prefix.length();
        final int length = key.length();
        final String[] parts = new String[] {"", "", ""};
        for (int i = 0; /*break condition inside*/ ; i++) {
            if (position == length) {
                final Locale locale =
                        (i == 0)
                                ? null
                                : unique(
                                        new Locale(
                                                parts[0] /* language */,
                                                parts[1] /* country  */,
                                                parts[2] /* variant  */));
                add(locale, string);
                return true;
            }
            if (key.charAt(position) != '_' || i == parts.length) {
                // Unknow character, or two many characters
                break;
            }
            int next = key.indexOf('_', ++position);
            if (next < 0) {
                next = length;
            } else if (next == position) {
                // Found two consecutive '_' characters
                break;
            }
            parts[i] = key.substring(position, position = next);
        }
        throw new IllegalArgumentException(
                Errors.format(
                        ErrorKeys.ILLEGAL_ARGUMENT_$2, "locale", key.substring(prefix.length())));
    }

