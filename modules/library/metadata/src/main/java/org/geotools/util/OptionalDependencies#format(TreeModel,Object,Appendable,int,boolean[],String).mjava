    /**
     * Construit une chaîne de caractères qui contiendra le noeud spécifié ainsi que tous les noeuds
     * enfants.
     *
     * @param model Arborescence à écrire.
     * @param node Noeud de l'arborescence à écrire.
     * @param buffer Buffer dans lequel écrire le noeud.
     * @param level Niveau d'indentation (à partir de 0).
     * @param last Indique si les niveaux précédents sont en train d'écrire leurs derniers items.
     * @return Le tableau {@code last}, qui peut éventuellement avoir été agrandit.
     */
    private static boolean[] format(
            final TreeModel model,
            final Object node,
            final Appendable buffer,
            final int level,
            boolean[] last,
            final String lineSeparator)
            throws IOException {
        for (int i = 0; i < level; i++) {
            if (i != level - 1) {
                buffer.append(last[i] ? '\u00A0' : '\u2502').append("\u00A0\u00A0\u00A0");
            } else {
                buffer.append(last[i] ? '\u2514' : '\u251C').append("\u2500\u2500\u2500");
            }
        }
        buffer.append(String.valueOf(node)).append(lineSeparator);
        if (level >= last.length) {
            last = XArray.resize(last, level * 2);
        }
        final int count = model.getChildCount(node);
        for (int i = 0; i < count; i++) {
            last[level] = (i == count - 1);
            last = format(model, model.getChild(node, i), buffer, level + 1, last, lineSeparator);
        }
        return last;
    }

