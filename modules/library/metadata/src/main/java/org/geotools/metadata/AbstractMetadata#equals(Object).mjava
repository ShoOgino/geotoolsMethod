    /**
     * Compares this metadata with the specified object for equality. The default implementation
     * uses Java reflection. Subclasses may override this method for better performances.
     *
     * <p>This method performs a <cite>deep</cite> comparaison (i.e. if this metadata contains other
     * metadata, the comparaison will walk through the other metadata content as well) providing
     * that every childs implement the {@link Object#equals} method as well. This is the case by
     * default if every childs are subclasses of {@code AbstractMetadata}.
     *
     * @param object The object to compare with this metadata.
     * @return {@code true} if the given object is equals to this metadata.
     */
    @Override
    public boolean equals(final Object object) {
        if (object == this) {
            return true;
        }
        if (object == null || !object.getClass().equals(getClass())) {
            return false;
        }
        /*
         * Opportunist usage of hash code if they are already computed. If they are not, we will
         * not compute them - they are not sure to be faster than checking directly for equality,
         * and hash code could be invalidated later anyway if the object change. Note that we
         * don't need to synchronize since reading int fields are garanteed to be atomic in Java.
         */
        final int c0 = hashCode;
        if (c0 != 0) {
            final int c1 = ((AbstractMetadata) object).hashCode;
            if (c1 != 0 && c0 != c1) {
                return false;
            }
        }
        final MetadataStandard standard = getStandard();
        /*
         * DEADLOCK WARNING: A deadlock may occur if the same pair of objects is being compared
         * in an other thread (see http://jira.codehaus.org/browse/GEOT-1777). Ideally we would
         * synchronize on 'this' and 'object' atomically (RFE #4210659). Since we can't in Java
         * a workaround is to always get the locks in the same order. Unfortunatly we have no
         * garantee that the caller didn't looked the object himself. For now the safest approach
         * is to not synchronize at all.
         */
        return standard.shallowEquals(this, object, false);
    }

