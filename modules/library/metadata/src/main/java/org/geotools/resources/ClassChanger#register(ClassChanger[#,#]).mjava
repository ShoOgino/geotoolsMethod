    /**
     * Registers a new converter. All registered {@link ClassChanger} will be taken in account by
     * the {@link #toNumber} method. The example below register a conversion for the {@link Date}
     * class:
     *
     * <blockquote>
     *
     * <pre>
     * &nbsp;ClassChanger.register(new ClassChanger(Date.class, Long.class) {
     * &nbsp;    protected Long convert(final Comparable o) {
     * &nbsp;        return ((Date) o).getTime();
     * &nbsp;    }
     * &nbsp;
     * &nbsp;    protected Comparable inverseConvert(final Number number) {
     * &nbsp;        return new Date(number.longValue());
     * &nbsp;    }
     * &nbsp;});
     * </pre>
     *
     * </blockquote>
     *
     * @param converter The {@link ClassChanger} to add.
     * @throws IllegalStateException if an other {@link ClassChanger} was already registered for the
     *     same {@code source} class. This is usually not a concern since the registration usually
     *     take place during the class initialization ("static" constructor).
     */
    public static synchronized void register(final ClassChanger<?, ?> converter)
            throws IllegalStateException {
        int i;
        for (i = 0; i < changers.length; i++) {
            if (changers[i].source.isAssignableFrom(converter.source)) {
                /*
                 * We found a converter for a parent class. The new converter should be
                 * inserted before its parent.  But before the insertion, we will check
                 * if this converter was not already registered later in the array.
                 */
                for (int j = i; j < changers.length; j++) {
                    if (changers[j].source.equals(converter.source)) {
                        throw new IllegalStateException(changers[j].toString());
                    }
                }
                break;
            }
        }
        changers = XArray.insert(changers, i, 1);
        changers[i] = converter;
    }

