    /**
     * Registers a new converter. All registered {@link ClassChanger} will
     * be taken in account by the {@link #toNumber} method. The example below
     * register a conversion for the {@link Date} class:
     *
     * <blockquote><pre>
     * &nbsp;ClassChanger.register(new ClassChanger(Date.class, Long.class) {
     * &nbsp;    protected Long convert(final Comparable o) {
     * &nbsp;        return ((Date) o).getTime();
     * &nbsp;    }
     * &nbsp;
     * &nbsp;    protected Comparable inverseConvert(final Number number) {
     * &nbsp;        return new Date(number.longValue());
     * &nbsp;    }
     * &nbsp;});
     * </pre></blockquote>
     *
     * @param  converter The {@link ClassChanger} to add.
     * @throws IllegalStateException if an other {@link ClassChanger} was already
     *         registered for the same {@code source} class. This is usually
     *         not a concern since the registration usually take place during the
     *         class initialization ("static" constructor).
     */
    public static synchronized void register(final ClassChanger<?,?> converter)
            throws IllegalStateException
    {
        int i;
        for (i=0; i<changers.length; i++) {
            if (changers[i].source.isAssignableFrom(converter.source)) {
                /*
                 * We found a converter for a parent class. The new converter should be
                 * inserted before its parent.  But before the insertion, we will check
                 * if this converter was not already registered later in the array.
                 */
                for (int j=i; j<changers.length; j++) {
                    if (changers[j].source.equals(converter.source)) {
                        throw new IllegalStateException(changers[j].toString());
                    }
                }
                break;
            }
        }
        changers = XArray.insert(changers, i, 1);
        changers[i] = converter;
    }

