    /**
     * Very low-level access to decoding ASCII characters in the form of a byte array. Does not
     * support automatically gunzipping or any other "fancy" features.
     *
     * @param source The Base64 encoded data
     * @return decoded data
     * @since 1.3
     */
    public static byte[] decode(byte[] source) {
        int len = source.length;
        int len34 = len * 3 / 4;
        byte[] outBuff = new byte[len34]; // Upper limit on size of output
        int outBuffPosn = 0;

        byte[] b4 = new byte[4];
        int b4Posn = 0;
        int i = 0;
        // byte   sbiCrop   = 0;
        byte sbiDecode = 0;
        for (i = 0; i < len; i++) {
            // sbiCrop = (byte)(source[i] & 0x7f); // Only the low seven bits
            sbiDecode = DECODABET[source[i]];

            if (sbiDecode > EQUALS_SIGN_ENC) // White space, Equals sign or better
            {
                b4[b4Posn++] = sbiDecode;
                if (b4Posn > 3) {
                    int temp =
                            ((b4[0] & 0xFF) << 18)
                                    | ((b4[1] & 0xFF) << 12)
                                    | ((b4[2] & 0xFF) << 6)
                                    | ((b4[3] & 0xFF));

                    outBuff[outBuffPosn++] = (byte) (temp >> 16);
                    outBuff[outBuffPosn++] = (byte) (temp >> 8);
                    outBuff[outBuffPosn++] = (byte) (temp);
                    // outBuffPosn += decode4to3new( b4, 0, outBuff, outBuffPosn );
                    b4Posn = 0;
                } // end if: quartet built
            } // end if: white space, equals sign or better
            else if (sbiDecode == EQUALS_SIGN_ENC) {
                b4[b4Posn++] = 0;
                if (b4Posn > 3) {
                    int temp =
                            ((b4[0] & 0xFF) << 18)
                                    | ((b4[1] & 0xFF) << 12)
                                    | ((b4[2] & 0xFF) << 6)
                                    | ((b4[3] & 0xFF));

                    outBuff[outBuffPosn++] = (byte) (temp >> 16);
                    outBuff[outBuffPosn++] = (byte) (temp >> 8);
                    outBuff[outBuffPosn++] = (byte) (temp);
                    // outBuffPosn += decode4to3new( b4, 0, outBuff, outBuffPosn );
                    b4Posn = 0;
                } // end if: quartet built
            }
        }
        return outBuff;
    } // end decode

