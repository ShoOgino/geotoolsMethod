    /**
     * Returns all class loaders to be used for scanning plugins. Current implementation returns the
     * following class loaders:
     *
     * <p>
     *
     * <ul>
     *   <li>{@linkplain Class#getClassLoader This object class loader}
     *   <li>{@linkplain Thread#getContextClassLoader The thread context class loader}
     *   <li>{@linkplain ClassLoader#getSystemClassLoader The system class loader}
     * </ul>
     *
     * The actual number of class loaders may be smaller if redundancies was found. If some more
     * classloaders should be scanned, they shall be added into the code of this method.
     *
     * @return All classloaders to be used for scanning plugins.
     */
    public final Set<ClassLoader> getClassLoaders() {
        final Set<ClassLoader> loaders = new HashSet<>();
        for (int i = 0; i < 4; i++) {
            final ClassLoader loader;
            try {
                switch (i) {
                    case 0:
                        loader = getClass().getClassLoader();
                        break;
                    case 1:
                        loader = FactoryRegistry.class.getClassLoader();
                        break;
                    case 2:
                        loader = Thread.currentThread().getContextClassLoader();
                        break;
                    case 3:
                        loader = ClassLoader.getSystemClassLoader();
                        break;
                        // Add any supplementary class loaders here, if needed.
                    default:
                        throw new AssertionError(i); // Should never happen.
                }
            } catch (SecurityException exception) {
                // We are not allowed to get a class loader.
                // Continue; some other class loader may be available.
                continue;
            }
            loaders.add(loader);
        }
        loaders.remove(null);
        loaders.addAll(GeoTools.getClassLoaders());

        /*
         * We now have a set of class loaders with duplicated object already removed
         * (e.g. system classloader == context classloader). However, we may still
         * have an other form of redundancie. A class loader may be the parent of an
         * other one. Try to remove those dependencies.
         */
        final ClassLoader[] asArray = loaders.toArray(new ClassLoader[loaders.size()]);
        for (ClassLoader loader : asArray) {
            try {
                while ((loader = loader.getParent()) != null) {
                    loaders.remove(loader);
                }
            } catch (SecurityException exception) {
                // We are not allowed to fetch the parent class loader.
                // Ignore (some redundancies may remains).
            }
        }
        if (loaders.isEmpty()) {
            LOGGER.warning("No class loaders available.");
        }
        return loaders;
    }

