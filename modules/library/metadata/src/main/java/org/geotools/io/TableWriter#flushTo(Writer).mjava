    /**
     * Écrit vers le flot spécifié toutes les cellules qui avaient été disposées dans le tableau.
     * Ces cellules seront automatiquement alignées en colonnes. Cette méthode peut être appelée
     * plusieurs fois pour écrire le même tableau par exemple vers plusieurs flots.
     *
     * @param out Flot vers où écrire les données.
     * @throws IOException si une erreur est survenue lors de l'écriture dans {@code out}.
     */
    private void flushTo(final Writer out) throws IOException {
        final String columnSeparator = this.separator;
        final String lineSeparator = System.getProperty("line.separator", "\n");
        final Cell[] currentLine = new Cell[width.length];
        final int cellCount = cells.size();
        for (int cellIndex = 0; cellIndex < cellCount; cellIndex++) {
            /*
             * Copie dans  {@code currentLine}  toutes les données qui seront à écrire
             * sur la ligne courante de la table. Ces données excluent le {@code null}
             * terminal.  La liste {@code currentLine} ne contiendra donc initialement
             * aucun élément nul, mais ses éléments seront progressivement modifiés (et mis
             * à {@code null}) pendant l'écriture de la ligne dans la boucle qui suit.
             */
            Cell lineFill = null;
            int currentCount = 0;
            do {
                final Cell cell = cells.get(cellIndex);
                if (cell == null) {
                    break;
                }
                if (cell.text == null) {
                    lineFill = new Cell("", cell.alignment, cell.fill);
                    break;
                }
                currentLine[currentCount++] = cell;
            } while (++cellIndex < cellCount);
            Arrays.fill(currentLine, currentCount, currentLine.length, lineFill);
            /*
             * La boucle suivante sera exécutée tant qu'il reste des lignes à écrire
             * (c'est-à-dire tant qu'au moins un élément de {@code currentLine}
             * est non-nul). Si une cellule contient un texte avec des caractères EOL,
             * alors cette cellule devra s'écrire sur plusieurs lignes dans la cellule
             * courante.
             */
            while (!isEmpty(currentLine)) {
                for (int j = 0; j < currentLine.length; j++) {
                    final boolean isFirstColumn = (j == 0);
                    final boolean isLastColumn = (j + 1 == currentLine.length);
                    final Cell cell = currentLine[j];
                    final int cellWidth = width[j];
                    if (cell == null) {
                        if (isFirstColumn) {
                            out.write(leftBorder);
                        }
                        repeat(out, SPACE, cellWidth);
                        out.write(isLastColumn ? rightBorder : columnSeparator);
                        continue;
                    }
                    String cellText = cell.toString();
                    int endCR = cellText.indexOf('\r');
                    int endLF = cellText.indexOf('\n');
                    int end = (endCR < 0) ? endLF : (endLF < 0) ? endCR : Math.min(endCR, endLF);
                    if (end >= 0) {
                        /*
                         * Si un retour chariot a été trouvé, n'écrit que la première
                         * ligne de la cellule. L'élément {@code currentLine[j]}
                         * sera modifié pour ne contenir que les lignes restantes qui
                         * seront écrites lors d'un prochain passage dans la boucle.
                         */
                        int top = end + 1;
                        if (endCR >= 0 && endCR + 1 == endLF) top++;
                        int scan = top;
                        final int textLength = cellText.length();
                        while (scan < textLength && Character.isWhitespace(cellText.charAt(scan))) {
                            scan++;
                        }
                        currentLine[j] = (scan < textLength) ? cell.substring(top) : null;
                        cellText = cellText.substring(0, end);
                    } else currentLine[j] = null;
                    final int textLength = cellText.length();
                    /*
                     * Si la cellule à écrire est en fait une bordure,
                     * on fera un traitement spécial pour utiliser les
                     * caractres de jointures {@link #BOX}.
                     */
                    if (currentCount == 0) {
                        assert textLength == 0;
                        final int verticalBorder;
                        if (cellIndex == 0) verticalBorder = -1;
                        else if (cellIndex >= cellCount - 1) verticalBorder = +1;
                        else verticalBorder = 0;
                        if (isFirstColumn) {
                            writeBorder(out, -1, verticalBorder, cell.fill);
                        }
                        repeat(out, cell.fill, cellWidth);
                        writeBorder(out, isLastColumn ? +1 : 0, verticalBorder, cell.fill);
                        continue;
                    }
                    /*
                     * Si la cellule n'est pas une bordure, il s'agit
                     * d'une cellule "normale".  Procde maintenant à
                     * l'écriture d'une ligne de la cellule.
                     */
                    if (isFirstColumn) {
                        out.write(leftBorder);
                    }
                    final Writer tabExpander =
                            (cellText.indexOf('\t') >= 0) ? new ExpandedTabWriter(out) : out;
                    switch (cell.alignment) {
                        default:
                            {
                                // Should not happen.
                                throw new AssertionError(cell.alignment);
                            }
                        case ALIGN_LEFT:
                            {
                                tabExpander.write(cellText);
                                repeat(tabExpander, cell.fill, cellWidth - textLength);
                                break;
                            }
                        case ALIGN_RIGHT:
                            {
                                repeat(tabExpander, cell.fill, cellWidth - textLength);
                                tabExpander.write(cellText);
                                break;
                            }
                        case ALIGN_CENTER:
                            {
                                final int rightMargin = (cellWidth - textLength) / 2;
                                repeat(tabExpander, cell.fill, rightMargin);
                                tabExpander.write(cellText);
                                repeat(
                                        tabExpander,
                                        cell.fill,
                                        (cellWidth - rightMargin) - textLength);
                                break;
                            }
                    }
                    out.write(isLastColumn ? rightBorder : columnSeparator);
                }
                out.write(lineSeparator);
            }
        }
    }

