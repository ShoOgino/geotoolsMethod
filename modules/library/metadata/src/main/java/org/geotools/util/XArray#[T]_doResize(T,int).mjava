    /**
     * Returns an array containing the same elements as the given {@code array} but with the
     * specified {@code length}, truncating or padding with {@code null} if necessary.
     *
     * <ul>
     *   <li>
     *       <p>If the given {@code length} is longer than the length of the given {@code array},
     *       then the returned array will contain all the elements of {@code array} at index
     *       <var>i</var> &lt; {@code array.length}. Elements at index <var>i</var> &gt;= {@code
     *       array.length} are initialized to {@code null}.
     *   <li>
     *       <p>If the given {@code length} is shorter than the length of the given {@code array},
     *       then the returned array will contain only the elements of {@code array} at index
     *       <var>i</var> &lt; {@code length}. Remainding elements are not copied.
     *   <li>
     *       <p>If the given {@code length} is equals to the length of the given {@code array}, then
     *       {@code array} is returned unchanged. <strong>No copy</strong> is performed. This
     *       behavior is what make this method different than {@link Arrays#copyOf}.
     *
     * @param  <T> The array elements.
     * @param array Array to copy.
     * @param length Length of the desired array.
     * @return A new array of the requested length, or {@code array} if the original array already
     *     have the requested length.
     * @see Arrays#copyOf(Object[],int)
     */
    private static <T> T doResize(final T array, final int length) {
        final int current = array == null ? 0 : Array.getLength(array);
        if (current != length) {
            @SuppressWarnings("unchecked")
            final T newArray = (T) Array.newInstance(array.getClass().getComponentType(), length);
            System.arraycopy(array, 0, newArray, 0, Math.min(current, length));
            return newArray;
        } else {
            return array;
        }
    }

