    /**
     * Returns the most specific class which is a common parent of all the specified classes. This
     * method should be invoked when no common parent has been found in the supplied list.
     */
    private static Class<?> commonSuperClass(final Collection<Class<?>> types) {
        // Build a list of all super classes.
        final Set<Class<?>> superTypes = new LinkedHashSet<>();
        for (Class<?> type : types) {
            while ((type = type.getSuperclass()) != null) {
                if (!superTypes.add(type)) {
                    // If the type was already in the set, then its super-types are in the set too.
                    break;
                }
            }
        }
        // Removes every elements that are not assignable from every supplied types.
        for (final Iterator<Class<?>> it = superTypes.iterator(); it.hasNext(); ) {
            final Class<?> candidate = it.next();
            for (final Class<?> type : types) {
                if (!candidate.isAssignableFrom(type)) {
                    it.remove();
                    break;
                }
            }
        }
        // Now removes every classes that can be assigned from an other classes.
        // We should have only one left, the most specific one in the hierarchy.
        return removeAssignables(superTypes);
    }

