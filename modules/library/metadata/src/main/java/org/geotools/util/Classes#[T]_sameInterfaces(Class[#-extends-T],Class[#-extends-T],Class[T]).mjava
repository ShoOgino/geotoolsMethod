    /**
     * Returns {@code true} if the two specified objects implements exactly the same set of
     * interfaces. Only interfaces assignable to {@code base} are compared. Declaration order
     * doesn't matter. For example in ISO 19111, different interfaces exist for different coordinate
     * system geometries ({@code CartesianCS}, {@code PolarCS}, etc.). We can check if two CS
     * implementations has the same geometry with the following code:
     *
     * <blockquote>
     *
     * <code>
     * if (sameInterfaces(cs1, cs2, {@linkplain org.opengis.referencing.cs.CoordinateSystem}.class))
     * </code>
     *
     * </blockquote>
     *
     * @param <T> A common parent for both objects.
     * @param object1 The first object to check for interfaces.
     * @param object2 The second object to check for interfaces.
     * @param base The parent of all interfaces to check.
     * @return {@code true} if both objects implement the same set of interfaces, considering only
     *     sub-interfaces of {@code base}.
     */
    public static <T> boolean sameInterfaces(
            final Class<? extends T> object1,
            final Class<? extends T> object2,
            final Class<T> base) {
        if (object1 == object2) {
            return true;
        }
        if (object1 == null || object2 == null) {
            return false;
        }
        final Class<?>[] c1 = object1.getInterfaces();
        final Class<?>[] c2 = object2.getInterfaces();
        /*
         * Trim all interfaces that are not assignable to 'base' in the 'c2' array.
         * Doing this once will avoid to redo the same test many time in the inner
         * loops j=[0..n].
         */
        int n = 0;
        for (Class<?> c : c2) {
            if (base.isAssignableFrom(c)) {
                c2[n++] = c;
            }
        }
        /*
         * For each interface assignable to 'base' in the 'c1' array, check if
         * this interface exists also in the 'c2' array. Order doesn't matter.
         */
        compare:
        for (final Class<?> c : c1) {
            if (base.isAssignableFrom(c)) {
                for (int j = 0; j < n; j++) {
                    if (c.equals(c2[j])) {
                        System.arraycopy(c2, j + 1, c2, j, --n - j);
                        continue compare;
                    }
                }
                return false; // Interface not found in 'c2'.
            }
        }
        return n == 0; // If n>0, at least one interface was not found in 'c1'.
    }

