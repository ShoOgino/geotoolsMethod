    /**
     * Returns a code list of the given type.
     *
     * @param type The type, as a subclass of {@link CodeList}.
     * @param identifier The identifier in the code list. This method accepts either The numerical
     *     value of the code to search for (usually the primary key), or the code name.
     * @return The code list element.
     * @throws SQLException if a SQL query failed.
     */
    private CodeList getCodeList(final Class<?> type, String identifier) throws SQLException {
        assert Thread.holdsLock(this);
        final String className = getClassName(type);
        int code; // The identifier as an integer.
        boolean isNumerical; // 'true' if 'code' is valid.
        try {
            code = Integer.parseInt(identifier);
            isNumerical = true;
        } catch (NumberFormatException exception) {
            code = 0;
            isNumerical = false;
        }
        /*
         * Converts the numerical value into the code list name.
         */
        if (isNumerical) {
            @SuppressWarnings("PMD.CloseResource") // managed in a field
            MetadataResult result = statements.get(type);
            if (result == null) {
                result = new MetadataResult(connection, codeQuery, getTableName(className));
                statements.put(type, result);
            }
            identifier = result.getString(identifier);
        }
        /*
         * Search a code list with the same name than the one declared
         * in the database. We will use name instead of code numerical
         * value, since the later is more bug prone.
         */
        final CodeList<?>[] values;
        try {
            values =
                    (CodeList[])
                            type.getMethod("values", (Class[]) null).invoke(null, (Object[]) null);
        } catch (NoSuchMethodException exception) {
            throw new MetadataException("Can't read code list.", exception); // TODO: localize
        } catch (IllegalAccessException exception) {
            throw new MetadataException("Can't read code list.", exception); // TODO: localize
        } catch (InvocationTargetException exception) {
            throw new MetadataException("Can't read code list.", exception); // TODO: localize
        }
        CodeList<?> candidate;
        final StringBuilder candidateName = new StringBuilder(className);
        candidateName.append('.');
        final int base = candidateName.length();
        if (code >= 1 && code < values.length) {
            candidate = values[code - 1];
            candidateName.append(candidate.name());
            if (identifier.equals(geoApiToIso.getProperty(candidateName.toString()))) {
                return candidate;
            }
        }
        /*
         * The previous code was an optimization which checked directly the code list
         * for the same code than the one used in the database. Most of the time, the
         * name matches and this loop is never executed. If we reach this point, then
         * maybe the numerical code are not the same in the database than in the Java
         * CodeList implementation. Check each code list element by name.
         */
        for (int i = 0; i < values.length; i++) {
            candidate = values[i];
            candidateName.setLength(base);
            candidateName.append(candidate.name());
            if (identifier.equals(geoApiToIso.getProperty(candidateName.toString()))) {
                return candidate;
            }
        }
        // TODO: localize
        throw new SQLException(
                "Unknow code list: \""
                        + identifier
                        + "\" in table \""
                        + getTableName(className)
                        + '"');
    }

