    /**
     * Returns an unmodifiable copy of the specified object. This method performs the following
     * heuristic tests:
     *
     * <p>
     *
     * <ul>
     *   <li>If the specified object is an instance of {@code ModifiableMetadata}, then {@link
     *       #unmodifiable()} is invoked on this object.
     *   <li>Otherwise, if the object is a {@linkplain Collection collection}, then the content is
     *       copied into a new collection of similar type, with values replaced by their
     *       unmodifiable variant.
     *   <li>Otherwise, if the object implements the {@link org.opengis.util.Cloneable} interface,
     *       then a clone is returned.
     *   <li>Otherwise, the object is assumed immutable and returned unchanged.
     * </ul>
     *
     * @param object The object to convert in an immutable one.
     * @return A presumed immutable view of the specified object.
     */
    @SuppressWarnings("unchecked") // We really don't know the collection types.
    static Object unmodifiable(final Object object) {
        /*
         * CASE 1 - The object is an implementation of ModifiableMetadata. It may have
         *          its own algorithm for creating an unmodifiable view of metadata.
         */
        if (object instanceof ModifiableMetadata) {
            return ((ModifiableMetadata) object).unmodifiable();
        }
        /*
         * CASE 2 - The object is a collection. All elements are replaced by their
         *          unmodifiable variant and stored in a new collection of similar
         *          type.
         */
        if (object instanceof Collection) {
            Collection<?> collection = (Collection) object;
            if (collection.isEmpty()) {
                if (collection instanceof List) {
                    collection = Collections.emptyList();
                } else {
                    collection = Collections.EMPTY_SET;
                }
            } else {
                final Object[] array = collection.toArray();
                for (int i = 0; i < array.length; i++) {
                    array[i] = unmodifiable(array[i]);
                }
                // Uses standard Java collections rather than Geotools Checked* classes,
                // since we don't need anymore synchronization or type checking.
                collection = UnmodifiableArrayList.wrap(array);
                if (collection instanceof Set) {
                    collection = Collections.unmodifiableSet(new LinkedHashSet<Object>(collection));
                }
                // Conservatively assumes a List if we are not sure to have a Set,
                // since the list is less destructive (no removal of duplicated).
            }
            return collection;
        }
        /*
         * CASE 3 - The object is a map. Copies all entries in a new map and replaces all values
         *          by their unmodifiable variant. The keys are assumed already immutable.
         */
        if (object instanceof Map) {
            Map map = (Map) object;
            if (map.isEmpty()) {
                return Collections.emptyMap();
            }
            map = new LinkedHashMap(map);
            for (final Iterator<Map.Entry> it = map.entrySet().iterator(); it.hasNext(); ) {
                final Map.Entry entry = it.next();
                entry.setValue(unmodifiable(entry.getValue()));
            }
            return Collections.unmodifiableMap(map);
        }
        /*
         * CASE 4 - The object is cloneable.
         */
        if (object instanceof org.opengis.util.Cloneable) {
            return ((org.opengis.util.Cloneable) object).clone();
        }
        /*
         * CASE 5 - Any other case. The object is assumed immutable and returned unchanged.
         */
        return object;
    }

