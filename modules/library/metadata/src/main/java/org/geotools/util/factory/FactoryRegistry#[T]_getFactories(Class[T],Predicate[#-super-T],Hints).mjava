    /**
     * Returns the factories in the registry for the specified category, filter and hints. Factories
     * that are not {@linkplain OptionalFactory#isAvailable available} will be ignored. This method
     * will {@linkplain #scanForPlugins() scan for plugins} the first time it is invoked for the
     * given category.
     *
     * @param <T> The class represented by the {@code category} argument.
     * @param category The category to look for. Usually an interface class (not the actual
     *     implementation class).
     * @param filter The optional filter predicate, or {@code null}.
     * @param hints The optional user requirements, or {@code null}.
     * @return Factories ready to use for the specified category, filter and hints.
     * @since 19
     */
    public synchronized <T> Stream<T> getFactories(
            final Class<T> category, final Predicate<? super T> filter, final Hints hints) {
        /*
         * The implementation of this method is very similar to the 'getUnfilteredFactories'
         * one except for filter handling. See the comments in 'getUnfilteredFactories' for
         * more implementation details.
         */
        if (scanningCategories.contains(category)) {
            // Please note you will get errors here if you accidentally allow
            // more than one thread to use your FactoryRegistry at a time.
            throw new RecursiveSearchException(category);
        }
        synchronizeIteratorProviders();
        scanForPluginsIfNeeded(category);
        Predicate<T> isAcceptable =
                factory -> isAcceptable(category.cast(factory), category, hints, filter);
        return getFactories(category, isAcceptable, true);
    }

