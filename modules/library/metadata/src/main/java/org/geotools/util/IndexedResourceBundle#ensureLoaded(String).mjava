    /**
     * Ensures that resource values are loaded. If they are not, load them immediately.
     *
     * @param key Key for the requested resource, or {@code null} if all resources are requested.
     *     This key is used mostly for constructing messages.
     * @return The resources.
     * @throws MissingResourceException if this method failed to load resources.
     */
    private String[] ensureLoaded(final String key) throws MissingResourceException {
        LogRecord record = null;
        try {
            String[] values;
            synchronized (this) {
                values = this.values;
                if (values != null) {
                    return values;
                }
                /*
                 * Prepares a log record.  We will wait for successful loading before
                 * posting this record.  If loading fails, the record will be changed
                 * into an error record. Note that the message must be logged outside
                 * the synchronized block, otherwise there is dead locks!
                 */
                record =
                        new LogRecord(Level.FINER, "Loaded resources for {0} from bundle \"{1}\".");
                record.setSourceClassName(getClass().getName());
                record.setSourceMethodName((key != null) ? "getObject" : "getKeys");
                /*
                 * Loads resources from the UTF file.
                 */
                InputStream in = null;
                String name = filename;
                boolean cleanupIn = true;
                while ((in = getClass().getResourceAsStream(name)) == null) {
                    final int ext = name.lastIndexOf('.');
                    final int lang = name.lastIndexOf('_', ext - 1);
                    if (lang <= 0) {
                        throw new FileNotFoundException(filename);
                    }
                    name = name.substring(0, lang) + name.substring(ext);
                }
                try (DataInputStream input = new DataInputStream(new BufferedInputStream(in))) {
                    this.values = values = new String[input.readInt()];
                    for (int i = 0; i < values.length; i++) {
                        values[i] = input.readUTF();
                        if (values[i].length() == 0) values[i] = null;
                    }
                    cleanupIn = true;
                } catch (Exception e) {
                    if (in != null && cleanupIn) {
                        in.close();
                    }
                }
                /*
                 * Now, log the message. This message is not localized.
                 */
                String language = getLocale().getDisplayName(Locale.US);
                if (language == null || language.length() == 0) {
                    language = "<default>";
                }
                record.setParameters(new String[] {language, getPackageName()});
            }
            final Logger logger = Logging.getLogger(IndexedResourceBundle.class);
            record.setLoggerName(logger.getName());
            logger.log(record);
            return values;
        } catch (IOException exception) {
            record.setLevel(Level.WARNING);
            record.setMessage(exception.getLocalizedMessage());
            record.setThrown(exception);
            final Logger logger = Logging.getLogger(IndexedResourceBundle.class);
            record.setLoggerName(logger.getName());
            logger.log(record);
            final MissingResourceException error =
                    new MissingResourceException(
                            exception.getLocalizedMessage(), getClass().getName(), key);
            error.initCause(exception);
            throw error;
        }
    }

