    /**
     * Parses a substring of the specified line. The content is immediately parsed and values can be
     * obtained using one of the {@code getValues(...)} method.
     *
     * @param line The line to parse.
     * @param lower Index of the first character in {@code line} to parse.
     * @param upper Index after the last character in {@code line} to parse.
     * @return The number of elements parsed in the specified line. The same information can be
     *     obtained with {@link #getValueCount}.
     * @throws ParseException If at least one column can't be parsed.
     */
    public int setLine(final String line, int lower, final int upper) throws ParseException {
        /*
         * Retient la ligne que l'utilisateur nous demande
         * de lire et oublie toutes les anciennes valeurs.
         */
        this.line = line;
        Arrays.fill(data, null);
        count = 0;
        /*
         * Procède au balayage de toutes les valeurs qui se trouvent sur la ligne spécifiée.
         * Le balayage s'arrêtera lorsque {@code lower} aura atteint {@code upper}.
         */
        load:
        while (true) {
            while (true) {
                if (lower >= upper) {
                    break load;
                }
                if (!Character.isWhitespace(line.charAt(lower))) break;
                lower++;
            }
            /*
             * Procède à la lecture de la donnée. Si la lecture échoue, on produira un message d'erreur
             * qui apparaîtra éventuellement en HTML afin de pouvoir souligner la partie fautive.
             */
            position.setIndex(lower);
            final Object datum =
                    format[Math.min(count, format.length - 1)].parseObject(line, position);
            final int next = position.getIndex();
            if (datum == null || next <= lower) {
                final int error = position.getErrorIndex();
                int end = error;
                while (end < upper && !Character.isWhitespace(line.charAt(end))) end++;
                throw new ParseException(
                        Errors.format(
                                ErrorKeys.PARSE_EXCEPTION_$2,
                                line.substring(lower, end).trim(),
                                line.substring(error, Math.min(error + 1, end))),
                        error);
            }
            /*
             * Mémorise la nouvelle donnée, en agrandissant
             * l'espace réservée en mémoire si c'est nécessaire.
             */
            if (count >= data.length) {
                data = XArray.resize(data, count + Math.min(count, 256));
                limits = XArray.resize(limits, data.length + 1);
            }
            limits[count] = lower;
            data[count++] = datum;
            lower = next;
        }
        limits[count] = lower;
        return count;
    }

