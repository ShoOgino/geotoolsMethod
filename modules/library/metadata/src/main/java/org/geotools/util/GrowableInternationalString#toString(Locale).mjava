    /**
     * Returns a string in the specified locale. If there is no string for the specified {@code
     * locale}, then this method search for a locale without the {@linkplain Locale#getVariant
     * variant} part. If no string are found, then this method search for a locale without the
     * {@linkplain Locale#getCountry country} part. For example if the <code>"fr_CA"</code> locale
     * was requested but not found, then this method looks for the <code>"fr"</code> locale. The
     * {@code null} locale (which stand for unlocalized message) is tried last.
     *
     * @param locale The locale to look for, or {@code null}.
     * @return The string in the specified locale, or in a default locale.
     */
    @Override
    public synchronized String toString(Locale locale) {
        String text;
        while (locale != null) {
            text = localMap.get(locale);
            if (text != null) {
                return text;
            }
            final String language = locale.getLanguage();
            final String country = locale.getCountry();
            final String variant = locale.getVariant();
            if (variant.length() != 0) {
                locale = new Locale(language, country);
                continue;
            }
            if (country.length() != 0) {
                locale = new Locale(language);
                continue;
            }
            break;
        }

        // Tries the string in the 'null' locale.
        text = localMap.get(null);
        if (text == null) {
            // No 'null' locale neither. Returns the first string in whatever locale.
            final Iterator<String> it = localMap.values().iterator();
            if (it.hasNext()) {
                return it.next();
            }
        }
        return text;
    }

