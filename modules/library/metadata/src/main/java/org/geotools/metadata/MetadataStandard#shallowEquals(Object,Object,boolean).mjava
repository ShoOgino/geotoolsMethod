    /**
     * Compares the two specified metadata objects. The comparaison is <cite>shallow</cite>, i.e.
     * all metadata attributes are compared using the {@link Object#equals} method without recursive
     * call to this {@code shallowEquals(...)} method for child metadata.
     *
     * <p>This method can optionaly excludes null values from the comparaison. In metadata, null
     * value often means "don't know", so in some occasion we want to consider two metadata as
     * different only if an attribute value is know for sure to be different.
     *
     * <p>The first arguments must be an implementation of a metadata interface, otherwise an
     * exception will be thrown. The two argument do not need to be the same implementation however.
     *
     * @param metadata1 The first metadata object to compare.
     * @param metadata2 The second metadata object to compare.
     * @param skipNulls If {@code true}, only non-null values will be compared.
     * @return {@code true} if the given metadata objects are equals.
     * @throws ClassCastException if at least one metadata object don't implements a metadata
     *     interface of the expected package.
     * @see AbstractMetadata#equals
     */
    public boolean shallowEquals(
            final Object metadata1, final Object metadata2, final boolean skipNulls)
            throws ClassCastException {
        if (metadata1 == metadata2) {
            return true;
        }
        if (metadata1 == null || metadata2 == null) {
            return false;
        }
        final PropertyAccessor accessor = getAccessor(metadata1.getClass());
        if (!accessor.type.equals(getType(metadata2.getClass()))) {
            return false;
        }
        return accessor.shallowEquals(metadata1, metadata2, skipNulls);
    }

