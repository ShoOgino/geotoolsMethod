    /**
     * Sets a value for the specified metadata. We do not expect any checked exception to be thrown.
     *
     * @param getter The method to use for fetching the previous value.
     * @param setter The method to use for setting the new value.
     * @param metadata The metadata object to query.
     * @param arguments The argument to give to the method to be invoked.
     * @throws ClassCastException if at least one element of the {@code arguments} array is not of
     *     the expected type.
     */
    private static void set(
            final Method getter,
            final Method setter,
            final Object metadata,
            final Object... arguments)
            throws ClassCastException {
        final Class<?>[] paramTypes = setter.getParameterTypes();
        for (int i = 0; i < paramTypes.length; i++) {
            final Object argument = arguments[i];
            if (argument == null) {
                continue; // Null argument (which is valid): nothing to do.
            }
            final Class<?> paramType = paramTypes[i];
            if (Classes.primitiveToWrapper(paramType).isInstance(argument)) {
                continue; // Argument is of the expected type: nothing to do.
            }
            /*
             * If an argument is not of the expected type, tries to convert it.
             * We handle two cases:
             *
             *   - Strings to be converted to Number, File, URL, etc.
             *   - Singleton to be added into an existing collection.
             *
             * We check for the collection case first in order to extract the element
             * type, which will be used for String conversions (if applicable) later.
             * The collections are handled in one of the two ways below:
             *
             *   - If the user gives a collection, the user's collection replaces any
             *     previous one. The content of the previous collection is discarted.
             *
             *   - If the user gives a singleton, the single value is added to existing
             *     collection (if any). The previous values are not discarted. This
             *     allow for incremental filling of an attribute.
             */
            final Collection<?> addTo;
            final Class<?> elementType;
            if (Collection.class.isAssignableFrom(paramType) && !(argument instanceof Collection)) {
                // Expected a collection but got a singleton.
                addTo = (Collection) get(getter, metadata);
                if (addTo instanceof CheckedCollection) {
                    elementType = ((CheckedCollection) addTo).getElementType();
                } else {
                    Class<?> c = Classes.boundOfParameterizedAttribute(setter);
                    if (c == null) {
                        c = Classes.boundOfParameterizedAttribute(getter);
                        if (c == null) {
                            c = Object.class;
                        }
                    }
                    elementType = c;
                }
            } else {
                addTo = null;
                elementType = paramType;
            }
            /*
             * Handles the strings in a special way (converting to URI, URL, File,
             * Number, etc.). If there is no known way to parse the string, or if
             * the parsing failed, an exception is thrown.
             */
            Object parsed = null;
            Exception failure = null;
            if (elementType.isInstance(argument)) {
                parsed = argument;
            } else if (argument instanceof CharSequence) {
                final String text = argument.toString();
                if (InternationalString.class.isAssignableFrom(elementType)) {
                    parsed = new SimpleInternationalString(text);
                } else if (File.class.isAssignableFrom(elementType)) {
                    parsed = new File(text);
                } else if (URL.class.isAssignableFrom(elementType))
                    try {
                        parsed = new URL(text);
                    } catch (MalformedURLException e) {
                        failure = e;
                    }
                else if (URI.class.isAssignableFrom(elementType))
                    try {
                        parsed = new URI(text);
                    } catch (URISyntaxException e) {
                        failure = e;
                    }
                else
                    try {
                        parsed = Classes.valueOf(elementType, text);
                    } catch (RuntimeException e) {
                        // Include IllegalArgumentException and NumberFormatException
                        failure = e;
                    }
            }
            /*
             * Checks if there is no known conversion, or if the conversion failed. In the later
             * case the parse failure is saved as the cause. We still throw a ClassCastException
             * since we get here because the argument was not of the expected type.
             */
            if (parsed == null) {
                final ClassCastException e =
                        new ClassCastException(
                                Errors.format(
                                        ErrorKeys.ILLEGAL_CLASS_$2,
                                        argument.getClass(),
                                        elementType));
                e.initCause(failure);
                throw e;
            }
            /*
             * We now have an object of the appropriate type. If this is a singleton to be added in
             * an existing collection, add it now and set the new value to the whole collection. In
             * the later case, we rely on ModifiableMetadata.copyCollection(...) optimization for
             * detecting that the new collection is the same instance than the old one so there is
             * nothing to do. We could exit from the method, but let it goes in case the user define
             * (or override) the 'setFoo(...)' method in an other way.
             */
            if (addTo != null) {
                addUnsafe(addTo, parsed);
                parsed = addTo;
            }
            arguments[i] = parsed;
        }
        try {
            setter.invoke(metadata, arguments);
        } catch (IllegalAccessException e) {
            // Should never happen since 'setters' should contains only public methods.
            throw new AssertionError(e);
        } catch (InvocationTargetException e) {
            final Throwable cause = e.getTargetException();
            if (cause instanceof RuntimeException) {
                throw (RuntimeException) cause;
            }
            if (cause instanceof Error) {
                throw (Error) cause;
            }
            throw new UndeclaredThrowableException(cause);
        }
    }

