    /**
     * Performs a translation using the "Resample" operation.
     *
     * @param grid the {@link GridCoverage2D} to apply the translation on.
     * @throws NoninvertibleTransformException If a "grid to CRS" transform is not invertible.
     */
    private void doTranslation(GridCoverage2D grid) throws NoninvertibleTransformException {
        final int transX = -253;
        final int transY = -456;
        final double scaleX = 0.04;
        final double scaleY = -0.04;
        final ParameterBlock block =
                new ParameterBlock()
                        .addSource(grid.getRenderedImage())
                        .add((float) transX)
                        .add((float) transY);
        RenderedImage image = JAI.create("Translate", block);
        assertEquals("Incorrect X translation", transX, image.getMinX());
        assertEquals("Incorrect Y translation", transY, image.getMinY());

        /*
         * Create a grid coverage from the translated image but with the same envelope.
         * Consequently, the 'gridToCoordinateSystem' should be translated by the same
         * amount, with the opposite sign.
         */
        AffineTransform expected = getAffineTransform(grid);
        assertNotNull(expected);
        expected = new AffineTransform(expected); // Get a mutable instance.
        final GridCoverageFactory factory = CoverageFactoryFinder.getGridCoverageFactory(null);
        grid =
                factory.create(
                        "Translated",
                        image,
                        grid.getEnvelope(),
                        grid.getSampleDimensions(),
                        new GridCoverage2D[] {grid},
                        grid.getProperties());
        expected.translate(-transX, -transY);
        assertTransformEquals(expected, getAffineTransform(grid));

        /*
         * Apply the "Resample" operation with a specific 'gridToCoordinateSystem' transform.
         * The envelope is left unchanged. The "Resample" operation should compute automatically
         * new image bounds.
         */
        final AffineTransform at = AffineTransform.getScaleInstance(scaleX, scaleY);
        final MathTransform tr = ProjectiveTransform.create(at);
        // account for the half pixel correction between the two spaces since we are talking raster
        // here but the resample will talk model!
        final MathTransform correctedTransform =
                PixelTranslation.translate(tr, PixelInCell.CELL_CORNER, PixelInCell.CELL_CENTER);
        final GridGeometry2D geometry = new GridGeometry2D(null, correctedTransform, null);
        final GridCoverage2D newGrid =
                (GridCoverage2D)
                        Operations.DEFAULT.resample(
                                grid, grid.getCoordinateReferenceSystem(), geometry, null);
        assertEquals(correctedTransform, getAffineTransform(newGrid));
        image = newGrid.getRenderedImage();
        expected.preConcatenate(at.createInverse());
        final Point point = new Point(transX, transY);
        assertSame(point, expected.transform(point, point)); // Round toward neareast integer
    }

