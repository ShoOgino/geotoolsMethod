    /**
     * Returns a grid coverage filled with random values.
     *
     * @param crs The coverage coordinate reference system.
     * @return A random coverage.
     */
    protected static GridCoverage2D getRandomCoverage(final CoordinateReferenceSystem crs) {
        /*
         * Some constants used for the construction and tests of the grid coverage.
         */
        final double PIXEL_SIZE = .25; // Pixel size (in degrees). Used in transformations.
        final int BEGIN_VALID = 3; // The minimal valid index for quantitative category.
        /*
         * Constructs the grid coverage. We will assume that the grid coverage use
         * (longitude,latitude) coordinates, pixels of 0.25 degrees and a lower
         * left corner at 10°W 30°N.
         */
        final GridCoverage2D coverage; // The final grid coverage.
        final BufferedImage image; // The GridCoverage's data.
        final WritableRaster raster; // The image's data as a raster.
        final Rectangle2D bounds; // The GridCoverage's envelope.
        final GridSampleDimension band; // The only image's band.
        band =
                new GridSampleDimension(
                        "Temperature",
                        new Category[] {
                            new Category("No data", null, 0),
                            new Category("Land", null, 1),
                            new Category("Cloud", null, 2),
                            new Category("Temperature", null, BEGIN_VALID, 256)
                        },
                        SI.CELSIUS);
        image = new BufferedImage(120, 80, BufferedImage.TYPE_BYTE_INDEXED);
        raster = image.getRaster();
        for (int i = raster.getWidth(); --i >= 0; ) {
            for (int j = raster.getHeight(); --j >= 0; ) {
                raster.setSample(i, j, 0, random.nextInt(256));
            }
        }
        bounds =
                new Rectangle2D.Double(
                        -10, 30, PIXEL_SIZE * image.getWidth(), PIXEL_SIZE * image.getHeight());
        final GeneralEnvelope envelope = new GeneralEnvelope(crs);
        envelope.setRange(0, bounds.getMinX(), bounds.getMaxX());
        envelope.setRange(1, bounds.getMinY(), bounds.getMaxY());
        for (int i = envelope.getDimension(); --i >= 2; ) {
            final double min = 10 * i;
            envelope.setRange(i, min, min + 5);
        }
        final Hints hints = new Hints(Hints.TILE_ENCODING, "raw");
        final GridCoverageFactory factory = CoverageFactoryFinder.getGridCoverageFactory(hints);
        coverage =
                factory.create(
                        "Test", image, envelope, new GridSampleDimension[] {band}, null, null);
        assertEquals("raw", coverage.tileEncoding);
        /*
         * Grid coverage construction finished.  Now test it.
         */
        assertSame(
                coverage.getRenderedImage(),
                coverage.getRenderableImage(0, 1).createDefaultRendering());
        assertSame(image.getTile(0, 0), coverage.getRenderedImage().getTile(0, 0));
        /*
         * Compares data.
         */
        final int bandN = 0; // Band to test.
        double[] bufferCov = null;
        final double left = bounds.getMinX() + (0.5 * PIXEL_SIZE); // Includes translation to center
        final double upper =
                bounds.getMaxY() - (0.5 * PIXEL_SIZE); // Includes translation to center
        final Point2D.Double point = new Point2D.Double(); // Will maps to pixel center.
        for (int j = raster.getHeight(); --j >= 0; ) {
            for (int i = raster.getWidth(); --i >= 0; ) {
                point.x = left + PIXEL_SIZE * i;
                point.y = upper - PIXEL_SIZE * j;
                double r = raster.getSampleDouble(i, j, bandN);
                bufferCov = coverage.evaluate(point, bufferCov);
                assertEquals(r, bufferCov[bandN], EPS);
            }
        }
        return coverage;
    }

