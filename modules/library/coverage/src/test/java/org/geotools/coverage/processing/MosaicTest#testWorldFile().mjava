    // Test which takes an input file, extracts two coverages from it, shifts the first on the right
    // of the second one and then mosaics them.
    @Test
    public void testWorldFile() throws FileNotFoundException, IOException {
        // read the coverage
        GridCoverage2D test = readInputFile("sample0");
        // Envelope for the first half of the image
        ReferencedEnvelope re1 =
                new ReferencedEnvelope(10, 180, -90, 90, DefaultGeographicCRS.WGS84);
        // Coverage crop for extracting the first half of the image
        GridCoverage2D c1 = crop(test, new GeneralEnvelope(re1));
        // Envelope for the second half of the image
        ReferencedEnvelope re2 =
                new ReferencedEnvelope(-180, -10, -90, 90, DefaultGeographicCRS.WGS84);
        // Coverage crop for extracting the second half of the image
        GridCoverage2D c2 = crop(test, new GeneralEnvelope(re2));

        // Shift the first image on the right
        ReferencedEnvelope re3 =
                new ReferencedEnvelope(180, 350, -90, 90, DefaultGeographicCRS.WGS84);
        GridCoverage2D shifted =
                new GridCoverageFactory().create(c2.getName(), c2.getRenderedImage(), re3);
        // Envelope containing the bounding box for the two images
        ReferencedEnvelope reUnion =
                new ReferencedEnvelope(10, 350, -90, 90, DefaultGeographicCRS.WGS84);
        // Mosaic operation
        GridCoverage2D mosaic =
                mosaic(
                        sortCoverages(Arrays.asList(c1, shifted)),
                        new GeneralEnvelope(reUnion),
                        new Hints());

        // Ensure the mosaic Bounding box is equal to that expected
        Envelope2D expected = new Envelope2D(reUnion);
        assertEqualBBOX(expected, mosaic.getEnvelope2D());

        // Check that the final Coverage resolution is equal to that of the first coverage
        double finalRes = calculateResolution(mosaic);

        // Check that on the center of the image there is valid data
        DirectPosition point =
                new DirectPosition2D(
                        mosaic.getCoordinateReferenceSystem(),
                        expected.getCenterX(),
                        expected.getCenterY());
        double nodata = 0;
        double result = ((byte[]) mosaic.evaluate(point))[0];
        Assert.assertNotEquals(nodata, result, TOLERANCE);

        // Check that on the Upper Left border pixel there is valid data
        point =
                new DirectPosition2D(
                        mosaic.getCoordinateReferenceSystem(),
                        expected.getMinX() + finalRes,
                        expected.getMinY() + finalRes);
        result = ((byte[]) mosaic.evaluate(point))[0];
        Assert.assertNotEquals(nodata, result, TOLERANCE);

        // Check that on the Upper Right border pixel there is valid data
        point =
                new DirectPosition2D(
                        mosaic.getCoordinateReferenceSystem(),
                        expected.getMaxX() - finalRes,
                        expected.getMinY() + finalRes);
        result = ((byte[]) mosaic.evaluate(point))[0];
        Assert.assertNotEquals(nodata, result, TOLERANCE);

        // Coverage and RenderedImage disposal
        mosaic.dispose(true);
        disposeCoveragePlanarImage(mosaic);
    }

