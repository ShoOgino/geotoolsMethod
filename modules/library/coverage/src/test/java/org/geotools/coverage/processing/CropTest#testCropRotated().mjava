    /**
     * Tests the "Crop" operation when there exists a rotation in the world to grid transformation
     *
     * @throws TransformException if a transformation was required and failed.
     */
    @Test
    public void testCropRotated() throws TransformException {
        /*
         * Get the test coverage.
         */
        final GridCoverage2D source = coverage;
        /*
         * Get the grid-to-world and apply a transformation in order to get a
         * rotated coverage in the end.
         */
        final AffineTransform gridToCRS = AffineTransform.getRotateInstance(Math.PI / 4.0);
        gridToCRS.concatenate(getAffineTransform(source));
        final MathTransform tr = ProjectiveTransform.create(gridToCRS);
        CoordinateReferenceSystem crs = source.getCoordinateReferenceSystem();
        crs = new DefaultDerivedCRS("Rotated CRS", crs, tr, crs.getCoordinateSystem());
        final GridCoverage2D rotated = project(source, crs, null, null);
        /*
         * Preparing the crop. We want to get a rectangle that is locate at the
         * center of this coverage envelope that is large 1/4 f the original
         * width and tall 1/4 of the original height.
         */
        final CoverageProcessor processor = CoverageProcessor.getInstance();
        final Envelope oldEnvelope = rotated.getEnvelope();
        final GeneralEnvelope cropEnvelope =
                new GeneralEnvelope(
                        new double[] {
                            oldEnvelope.getMinimum(0) + oldEnvelope.getSpan(0) * 3 / 8,
                            oldEnvelope.getMinimum(1) + oldEnvelope.getSpan(1) * 3 / 8
                        },
                        new double[] {
                            oldEnvelope.getMinimum(0) + oldEnvelope.getSpan(0) * 5 / 8,
                            oldEnvelope.getMinimum(1) + oldEnvelope.getSpan(1) * 5 / 8
                        });
        cropEnvelope.setCoordinateReferenceSystem(oldEnvelope.getCoordinateReferenceSystem());
        /*
         * Do the crop without trying to conserve the envelope.
         */
        ParameterValueGroup param = processor.getOperation("CoverageCrop").getParameters();
        param.parameter("Source").setValue(rotated);
        param.parameter("Envelope").setValue(cropEnvelope);
        GridCoverage2D cropped = (GridCoverage2D) processor.doOperation(param);
        if (SHOW) {
            Viewer.show(coverage);
            Viewer.show(cropped);
        } else {
            // Force computation
            assertNotNull(PlanarImage.wrapRenderedImage(cropped.getRenderedImage()).getTiles());
            assertNotNull(PlanarImage.wrapRenderedImage(coverage.getRenderedImage()).getTiles());
        }
        RenderedImage raster = cropped.getRenderedImage();
        assertEquals(111, raster.getMinX());
        assertEquals(116, raster.getMinY());
        assertEquals(228, raster.getWidth());
        assertEquals(228, raster.getHeight());
        assertEquals(
                rotated.getGridGeometry().getGridToCRS2D(),
                cropped.getGridGeometry().getGridToCRS2D());
        /*
         * Get the roi and test it against the crop area
         */
        Object property = CoverageUtilities.getROIProperty(cropped);
        assertNotNull(property);
        assertTrue(property instanceof ROI);
        ROI roi = (ROI) property;
        assertEquals(
                new Rectangle(
                        raster.getMinX(), raster.getMinY(), raster.getWidth(), raster.getHeight()),
                roi.getBounds());
    }

