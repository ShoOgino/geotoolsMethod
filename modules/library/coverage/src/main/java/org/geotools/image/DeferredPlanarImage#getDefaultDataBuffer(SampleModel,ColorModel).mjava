    /**
     * Returns a databuffer for the specified sample model. If the image use an
     * {@link IndexColorModel} and a {@linkplain IndexColorModel#getTransparentPixel
     * transparent pixel} is defined, then raster sample values are initilized to
     * the transparent pixel.
     */
    private static synchronized DataBuffer getDefaultDataBuffer(final SampleModel sampleModel,
                                                                final ColorModel  colorModel)
    {
        int fill = 0;
        int box  = 0;
        if (colorModel instanceof IndexColorModel) {
            final IndexColorModel colors = (IndexColorModel)colorModel;
            fill = ColorUtilities.getTransparentPixel(colors);
            if (BOX_THICKNESS>0 && Math.min(sampleModel.getWidth(), sampleModel.getHeight())>=64) {
                box = ColorUtilities.getColorIndex(colors, Color.DARK_GRAY, fill);
            } else {
                // Avoid drawing the box if tiles are too small.
                box = fill;
            }
        }
        final Entry entry = new Entry(sampleModel, fill, box);
        if (buffers == null) {
            buffers = new WeakValueHashMap<Entry,DataBuffer>();
        }
        DataBuffer buffer = (DataBuffer) buffers.get(entry);
        if (buffer != null) {
            return buffer;
        }
        /*
         * No suitable data buffer existed prior to this call. Create a new one and fill it
         * with the transparent color. Note that no filling is needed if the transparent value
         * is 0, since the data buffer is already initialized to 0.
         */
        buffer = sampleModel.createDataBuffer();
        if (fill > 0) {
            for (int bank=buffer.getNumBanks(); --bank>=0;) {
                fill(buffer, bank, fill);
            }
        }
        /*
         * Draw a box around the tile. This is just a visual clue about tile location.
         * Current implementation draw a box only for type byte with a single band.
         */
        if (BOX_THICKNESS>0 && box!=fill) {
            if (sampleModel.getNumBands()==1) {
                final int width = sampleModel.getWidth();
                int thickness = BOX_THICKNESS;
                int offset = (width+1)*thickness;
                switch (buffer.getDataType()) {
                    case DataBuffer.TYPE_BYTE: {
                        final byte[] array = ((DataBufferByte)buffer).getData(0);
                        Arrays.fill(array, 0, offset, (byte)box);
                        Arrays.fill(array, array.length-offset, array.length, (byte)box);
                        thickness *= 2;
                        while ((offset += width) < array.length) {
                            Arrays.fill(array, offset-thickness, offset, (byte)box);
                        }
                        break;
                    }
                }
            }
        }
        buffers.put(entry, buffer);
        return buffer;
    }

