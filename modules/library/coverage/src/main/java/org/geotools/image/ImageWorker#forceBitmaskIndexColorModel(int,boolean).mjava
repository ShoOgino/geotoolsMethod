    /**
     * Reduces the color model to {@linkplain IndexColorModel index color model} with {@linkplain Transparency#OPAQUE opaque} or
     * {@linkplain Transparency#BITMASK bitmask} transparency. If the current {@linkplain #image} already uses a suitable color model, then this
     * method do nothing.
     * 
     * @param suggestedTransparent A suggested pixel index to define as the transparent pixel. *
     * @param errorDiffusion Tells if I should use {@link ErrorDiffusionDescriptor} or {@link OrderedDitherDescriptor} JAi operations. errorDiffusion
     * @return this {@link ImageWorker}.
     * 
     * @see #isIndexed
     * @see #isTranslucent
     * @see #forceIndexColorModel
     * @see #forceIndexColorModelForGIF
     */
    public final ImageWorker forceBitmaskIndexColorModel(int suggestedTransparent,
            final boolean errorDiffusion) {
        final ColorModel cm = image.getColorModel();
        if (cm instanceof IndexColorModel) {
            final IndexColorModel oldCM = (IndexColorModel) cm;
            switch (oldCM.getTransparency()) {
            case Transparency.OPAQUE: {
                // Suitable color model. There is nothing to do.
                return this;
            }
            case Transparency.BITMASK: {
                if (oldCM.getTransparentPixel() == suggestedTransparent) {
                    // Suitable color model. There is nothing to do.
                    return this;
                }
                break;
            }
            default: {
                break;
            }
            }

            // check if we already have a pixel fully transparent
            final int transparentPixel = ColorUtilities.getTransparentPixel(oldCM);
            /*
             * The index color model need to be replaced. Creates a lookup table mapping from the old pixel values to new pixels values, with
             * transparent colors mapped to the new transparent pixel value. The lookup table uses TYPE_BYTE or TYPE_USHORT, which are the two only
             * types supported by IndexColorModel.
             */
            final int mapSize = oldCM.getMapSize();
            if (transparentPixel < 0)
                suggestedTransparent = suggestedTransparent <= mapSize ? mapSize + 1
                        : suggestedTransparent;
            else
                suggestedTransparent = transparentPixel;
            final int newSize = Math.max(mapSize, suggestedTransparent);
            final int newPixelSize = ColorUtilities.getBitCount(newSize);
            if (newPixelSize > 16)
                throw new IllegalArgumentException(
                        "Unable to create index color model with more than 65536 elements");
            final LookupTable lookupTable;
            if (newPixelSize <= 8) {
                final byte[] table = new byte[mapSize];
                for (int i = 0; i < mapSize; i++) {
                    table[i] = (byte) ((oldCM.getAlpha(i) == 0) ? suggestedTransparent : i);
                }
                lookupTable = LookupTableFactory
                        .create(table, image.getSampleModel().getDataType());
            } else {
                final short[] table = new short[mapSize];
                for (int i = 0; i < mapSize; i++) {
                    table[i] = (short) ((oldCM.getAlpha(i) == 0) ? suggestedTransparent : i);
                }
                lookupTable = LookupTableFactory.create(table, true);
            }
            /*
             * Now we need to perform the look up transformation. First of all we create the new color model with a bitmask transparency using the
             * transparency index specified to this method. Then we perform the lookup operation in order to prepare for the gif image.
             */
            final byte[][] rgb = new byte[3][newSize];
            oldCM.getReds(rgb[0]);
            oldCM.getGreens(rgb[1]);
            oldCM.getBlues(rgb[2]);
            final IndexColorModel newCM = new IndexColorModel(newPixelSize, newSize, rgb[0],
                    rgb[1], rgb[2], suggestedTransparent);
            final RenderingHints hints = getRenderingHints();
            final ImageLayout layout = getImageLayout(hints);
            layout.setColorModel(newCM);
            // we should not transform on color map here
            hints.put(JAI.KEY_TRANSFORM_ON_COLORMAP, Boolean.FALSE);
            hints.put(JAI.KEY_IMAGE_LAYOUT, layout);

            // ParameterBlock definition
            ParameterBlock pb = new ParameterBlock();
            pb.setSource(image, 0);
            pb.set(lookupTable, 0);
            pb.set(roi, 2);
            pb.set(nodata, 3);
            if (isNoDataNeeded()) {
                if (background != null && background.length > 0) {
                    pb.set(background[0], 1);
                }
            }

            image = JAI.create("Lookup", pb, hints);
            // New parameterblock for format operation
            pb = new ParameterBlock();
            pb.setSource(image, 0);
            int dataType = image.getSampleModel().getDataType();
            pb.set(dataType, 0);
            image = JAI.create("Format", pb, hints);
            // Converting NoData Range
            setNoData(RangeFactory.convert(nodata, dataType));
        } else {
            // force component color model first
            forceComponentColorModel(true);
            /*
             * The image is not indexed.
             */
            if (cm.hasAlpha()) {
                // Getting the alpha channel.
                tileCacheEnabled(false);
                int numBands = getNumBands();
                final RenderingHints hints = getRenderingHints();

                // ParameterBlock creation
                ParameterBlock pb = new ParameterBlock();
                pb.setSource(image, 0);
                pb.set(new int[] { --numBands }, 0);
                final RenderedOp alphaChannel = JAI.create("BandSelect", pb, hints);
                retainBands(numBands);
                forceIndexColorModel(errorDiffusion);
                tileCacheEnabled(true);

                /*
                 * Adding transparency if needed, which means using the alpha channel to build a new color model. The method call below implies
                 * 'forceColorSpaceRGB()' and 'forceIndexColorModel()' method calls.
                 */
                addTransparencyToIndexColorModel(alphaChannel, false, suggestedTransparent,
                        errorDiffusion);
            } else
                forceIndexColorModel(errorDiffusion);
        }
        // All post conditions for this method contract.
        assert isIndexed();
        assert !isTranslucent();
        return this;
    }

