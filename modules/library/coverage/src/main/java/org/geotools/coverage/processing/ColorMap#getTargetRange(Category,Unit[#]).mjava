    /**
     * Returns the range of sample values for the given category, or {@code null} if none.
     * This range is computed from the {@linkplain #getRange relative or geophysics range}.
     *
     * @param  category The category for which to compute the range.
     * @param  units The category units, usually {@link GridSampleDimension#getUnits}.
     * @return The range, or {@code null} if none. The lower index is always inclusive
     *         and the upper index is always exclusive.
     */
    private NumberRange getTargetRange(final Category category, final Unit<?> units) {
        NumberRange scale = getRange(category.getName());
        if (scale == null) {
            if (category.isQuantitative()) {
                scale = getRange(ANY_QUANTITATIVE_CATEGORY);
            }
            if (scale == null) {
                return null;
            }
        }
        double  minimum     = scale.getMinimum();
        double  maximum     = scale.getMaximum();
        boolean minIncluded = scale.isMinIncluded();
        boolean maxIncluded = scale.isMaxIncluded();
        if (scale instanceof MeasurementRange) {
            try {
                scale = ((MeasurementRange) scale).convertTo(units);
            } catch (ConversionException e) {
                Logging.unexpectedException(CoverageProcessor.LOGGER, ColorMap.class, "recolor", e);
                return null; // This is allowed by this method contract.
            }
            MathTransform1D tr = category.getSampleToGeophysics();
            if (tr != null) try {
                tr = tr.inverse();
                minimum = tr.transform(minimum);
                maximum = tr.transform(maximum);
            } catch (TransformException e) {
                Logging.unexpectedException(CoverageProcessor.LOGGER, ColorMap.class, "recolor", e);
                return null; // This is allowed by this method contract.
            }
        } else {
            final NumberRange range = category.getRange();
            final double lower  = range.getMinimum();
            final double extent = range.getMaximum() - lower;
            minimum     = (minimum / 100) * extent + lower;
            maximum     = (maximum / 100) * extent + lower;
            minIncluded &= range.isMinIncluded();
            maxIncluded &= range.isMaxIncluded();
        }
        final int lower, upper;
        if (minimum > maximum) {
            lower = round(maximum,  maxIncluded);
            upper = round(minimum, !minIncluded);
        } else {
            lower = round(minimum,  minIncluded);
            upper = round(maximum, !maxIncluded);
        }
        return NumberRange.create(lower, true, upper, false);
    }

