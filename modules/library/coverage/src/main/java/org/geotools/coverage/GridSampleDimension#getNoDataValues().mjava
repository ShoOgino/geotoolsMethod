    /**
     * Returns the values to indicate "no data" for this sample dimension. The default
     * implementation deduces the "no data" values from the list of categories supplied at
     * construction time.
     *
     * @return The values to indicate no data values for this sample dimension, or {@code null} if
     *     not applicable.
     * @throws IllegalStateException if some qualitative categories use a range of non-integer
     *     values.
     */
    @Override
    public double[] getNoDataValues() throws IllegalStateException {
        if (!hasQuantitative) {
            return null;
        }
        int count = 0;
        double[] padValues = null;
        final int size = categories.size();
        for (int i = 0; i < size; i++) {
            final Category category = categories.get(i);
            if (category.getName().equals(Category.NODATA.getName())) {
                final double min = category.minimum;
                final double max = category.maximum;
                if (Double.isNaN(min) && Double.isNaN(max)) {
                    return new double[] {min};
                } else if (Math.abs(min - max) < DELTA) {
                    return new double[] {min};
                } else {
                    return new double[] {min, max};
                }
            }
            if (!category.isQuantitative()) {
                final double min = category.minimum;
                final double max = category.maximum;
                if (!Double.isNaN(min) || !Double.isNaN(max)) {
                    if (padValues == null) {
                        padValues = new double[size - i];
                    }
                    if (count >= padValues.length) {
                        padValues = XArray.resize(padValues, count * 2);
                    }
                    padValues[count++] = min;
                    /*
                     * The "no data" value has been extracted. Now, check if we have a range
                     * of "no data" values instead of a single one for this category.  If we
                     * have a single value, it can be of any type. But if we have a range,
                     * then it must be a range of integers (otherwise we can't expand it).
                     */
                    if (max != min) {
                        int lower = (int) min;
                        int upper = (int) max;
                        if (lower != min
                                || upper != max
                                || !Classes.isInteger(category.getRange().getElementClass())) {
                            throw new IllegalStateException(
                                    Errors.format(ErrorKeys.NON_INTEGER_CATEGORY));
                        }
                        final int requiredLength = count + (upper - lower);
                        if (requiredLength > padValues.length) {
                            padValues = XArray.resize(padValues, requiredLength * 2);
                        }
                        while (++lower <= upper) {
                            padValues[count++] = lower;
                        }
                    }
                }
            }
        }
        if (padValues != null) {
            padValues = XArray.resize(padValues, count);
        }
        return padValues;
    }

