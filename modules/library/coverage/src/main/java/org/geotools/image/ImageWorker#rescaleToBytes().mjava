    /**
     * Rescales the {@linkplain #image} such that it uses 8 bits. If the image already uses 8 bits, then this method does nothing. Otherwise this
     * method computes the minimum and maximum values for each band, {@linkplain RescaleDescriptor rescale} them in the range {@code [0 .. 255]} and
     * force the resulting image to {@link DataBuffer#TYPE_BYTE TYPE_BYTE}.
     * 
     * @return This ImageWorker
     * 
     * @see #isBytes
     * @see RescaleDescriptor
     */
    public final ImageWorker rescaleToBytes() {

        if (isBytes()) {
            // Already using bytes - nothing to do.
            return this;
        }

        // this is to support 16 bits IndexColorModel
        forceComponentColorModel(true, true);

        final double[][] extrema = getExtremas();
        final int length = extrema[0].length;
        final double[] scale = new double[length];
        final double[] offset = new double[length];
        final double destNodata = (background != null && background.length > 0) ? background[0] : ((nodata != null && !nodata.contains(0)) ? 0d: Double.NaN);

        boolean computeRescale = false;
        for (int i = 0; i < length; i++) {
            final double delta = extrema[1][i] - extrema[0][i];
            if (Math.abs(delta) > 1E-6 // maximum and minimum does not coincide
                    && ((extrema[1][i] - 255 > 1E-6) // the maximum is greater than 255
                    || (extrema[0][i] < -1E-6))) // the minimum is smaller than 0
            {
                // we need to rescale
                computeRescale = true;

                // rescale factors
                scale[i] = 255 / delta;
                offset[i] = -scale[i] * extrema[0][i];
            } else {
                // we do not rescale explicitly bu in case we have to, we relay on the clamping capabilities of the format operator
                scale[i] = 1;
                offset[i] = 0;
            }
        }
        final RenderingHints hints = getRenderingHints(DataBuffer.TYPE_BYTE);
        if (computeRescale) {
            ParameterBlock pb = new ParameterBlock();
            pb.setSource(image, 0); // The source image.
            pb.set(scale, 0); // The per-band constants to multiply by.
            pb.set(offset, 1); // The per-band offsets to be added.
            pb.set(roi, 2); // ROI
            pb.set(nodata, 3); // NoData range
            if (isNoDataNeeded() && !Double.isNaN(destNodata)) {
                pb.set(destNodata, 5);
            }

            image = JAI.create("Rescale", pb, hints);
        } else {
            ParameterBlock pb = new ParameterBlock();
            pb.setSource(image, 0); // The source image.
            pb.set(DataBuffer.TYPE_BYTE, 0); // The destination image data type (BYTE)

            image = JAI.create("Format", pb, hints);
            setNoData(RangeFactory.convert(nodata, DataBuffer.TYPE_BYTE));
        }
        invalidateStatistics(); // Extremas are no longer valid.

        // All post conditions for this method contract.
        assert isBytes();
        return this;
    }

