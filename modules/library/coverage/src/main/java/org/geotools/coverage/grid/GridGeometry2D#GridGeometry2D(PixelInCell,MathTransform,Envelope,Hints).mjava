    /**
     * Constructs a new grid geometry from an envelope and a {@linkplain MathTransform math
     * transform}. According OGC specification, the math transform should map {@linkplain
     * PixelInCell#CELL_CENTER pixel center}. But in Java2D/JAI conventions, the transform is rather
     * expected to maps {@linkplain PixelInCell#CELL_CORNER pixel corner}. The convention to follow
     * can be specified by the {@code anchor} argument.
     *
     * @param anchor {@link PixelInCell#CELL_CENTER CELL_CENTER} for OGC conventions or {@link
     *     PixelInCell#CELL_CORNER CELL_CORNER} for Java2D/JAI conventions.
     * @param gridToCRS The math transform which allows for the transformations from grid
     *     coordinates to real world earth coordinates. May be {@code null}, but this is not
     *     recommended.
     * @param envelope The envelope (including CRS) of a grid coverage, or {@code null} if none.
     * @param hints An optional set of hints controlling the {@link DimensionFilter} to be used for
     *     deriving the {@link MathTransform2D} instance from the given {@code gridToCRS} transform.
     * @throws MismatchedDimensionException if the math transform and the envelope doesn't have
     *     consistent dimensions.
     * @throws IllegalArgumentException if the math transform can't transform coordinates in the
     *     domain of the grid range.
     * @since 2.5
     */
    public GridGeometry2D(
            final PixelInCell anchor,
            final MathTransform gridToCRS,
            final Envelope envelope,
            final Hints hints)
            throws MismatchedDimensionException, IllegalArgumentException {
        super(anchor, gridToCRS, envelope);
        final int[] dimensions = new int[4];
        gridToCRS2D = getMathTransform2D(this.gridToCRS, gridRange, dimensions, hints);
        gridFromCRS2D = inverse(gridToCRS2D);
        gridDimensionX = dimensions[0];
        gridDimensionY = dimensions[1];
        axisDimensionX = dimensions[2];
        axisDimensionY = dimensions[3];
        crs2D = createCRS2D();
        if (PixelInCell.CELL_CORNER.equals(anchor)) {
            cornerToCRS2D = getMathTransform2D(gridToCRS, gridRange, dimensions, hints);
        }
        assert isValid() : this;
    }

