    /**
     * Constructs a new grid geometry from an envelope and a {@linkplain MathTransform math
     * transform}. According OGC specification, the math transform should map {@linkplain
     * PixelInCell#CELL_CENTER pixel center}. But in Java2D/JAI conventions, the transform
     * is rather expected to maps {@linkplain PixelInCell#CELL_CORNER pixel corner}. The
     * convention to follow can be specified by the {@code anchor} argument.
     *
     * <p>
     * It is worth to point a few guidelines for the usage of the gridMaxInclusive parameter.
     * In case we are using this contructor for a reprojection it might be worth using a <code>false</code>
     * value for this parameter since we would not force to create a new raster that might be slightly bigger than 
     * the original one, causing problems with black or nodata collars appearing after a resample.
     * In case we are trying to build a source raster area to be used at reading time, in that case we may want to provide 
     * <code>true</code> for gridMaxInclusive since we may want to read an area that is slightly bigger than what we need
     * to be sure we actually reading something.
     * 
     * @param anchor    {@link PixelInCell#CELL_CENTER CELL_CENTER} for OGC conventions or
     *                  {@link PixelInCell#CELL_CORNER CELL_CORNER} for Java2D/JAI conventions.
     * @param gridToCRS The math transform which allows for the transformations from grid
     *                  coordinates to real world earth coordinates. May be {@code null},
     *                  but this is not recommended.
     * @param envelope  The envelope (including CRS) of a grid coverage, or {@code null} if none.
     * @param gridMaxInclusive Tells us whether or not the resulting gridRange max values should be
     *                  inclusive or not. See notes above.
     * @param preserveGridToCRS Tells us whether we should try to preserve the the gridToCRS or the envelope 
     *                  most part of the time we won't be able to preserve both for our purposes.
     *
     * @throws MismatchedDimensionException if the math transform and the envelope doesn't have
     *         consistent dimensions.
     * @throws IllegalArgumentException if the math transform can't transform coordinates
     *         in the domain of the grid range.
     *
     * @since 2.7
     */
    public GeneralGridGeometry(final PixelInCell   anchor,
                               final MathTransform gridToCRS,
                               final Envelope      envelope,
                               final boolean 	   gridMaxInclusive,
                               final boolean 	   preserveGridToCRS)
            throws MismatchedDimensionException, IllegalArgumentException
    {
        this.gridToCRS = PixelTranslation.translate(gridToCRS, anchor, PixelInCell.CELL_CENTER);
        if (PixelInCell.CELL_CORNER.equals(anchor)) {
            cornerToCRS = gridToCRS;
        }
        else
        	 cornerToCRS =PixelTranslation.translate(gridToCRS, anchor, PixelInCell.CELL_CORNER);
        if (envelope == null) {
            this.envelope  = null;
            this.gridRange = null;
            return;
        }
        this.envelope = new GeneralEnvelope(envelope);
        if (gridToCRS == null) {
            this.gridRange = null;
            return;
        }
        final GeneralEnvelope transformed;
        try {
            transformed = org.geotools.referencing.CRS.transform(cornerToCRS.inverse(), envelope);
        } catch (TransformException exception) {
            throw new IllegalArgumentException(Errors.format(ErrorKeys.BAD_TRANSFORM_$1,
                    Classes.getClass(gridToCRS)), exception);
        }
        
        // making this inclusive may cause problems when we use for warping of something since we might try to include more data 
        // than we actually havein the source imagery
        gridRange = new GeneralGridEnvelope(transformed, PixelInCell.CELL_CORNER,gridMaxInclusive);
        
       
        //
        // CORRECTIONS
        //
        // do we need to ajust the gridToCRS or the envelope?
        if(preserveGridToCRS)
        {
        	//preserve firdToCrs
        	GeneralEnvelope tempEnvelope;
			try {
				tempEnvelope = CRS.transform(getGridToCRS(),toEnvelope(gridRange));
			} catch (Throwable e) {
				throw new RuntimeException(e);
			} 
			tempEnvelope.setCoordinateReferenceSystem(envelope.getCoordinateReferenceSystem());
			this.envelope=tempEnvelope;
        }else
        {
        	// preserve envelope
        	if(gridToCRS!=null){

                // all we need is a simple scale and translate to take care of the fact that we might have approximated a bit the 
                // raster area
                final double xScale=transformed.getSpan(0)/gridRange.getSpan(0);
                final double yScale=transformed.getSpan(1)/gridRange.getSpan(1);    
                final double xTrans=transformed.getMinimum(0)-xScale*gridRange.getLow(0);
                final double yTrans=transformed.getMinimum(1)-yScale*gridRange.getLow(1);
	        	final AffineTransform newTr=new AffineTransform(xScale,0,0,yScale,xTrans,yTrans);
	        	newTr.preConcatenate((AffineTransform)this.cornerToCRS);
				this.cornerToCRS=
	        			ProjectiveTransform.create(
	        					newTr
	        			);
	        	
				
	        	this.gridToCRS=PixelTranslation.translate(cornerToCRS, PixelInCell.CELL_CORNER, PixelInCell.CELL_CENTER);
	        	
		        // Now 'assertsEnabled' is set to the correct value
		        if(assertsEnabled){
			        try {
			        	final MathTransform tr=cornerToCRS;
			        	if(!(tr instanceof AffineTransform))
			        		return;
			        	final AffineTransform transform=(AffineTransform)tr;
			        	final double scale= Math.min(XAffineTransform.getScaleX0(transform), XAffineTransform.getScaleY0(transform));
						final GeneralEnvelope tempEnvelope = CRS.transform(tr,toEnvelope(gridRange));
						tempEnvelope.setCoordinateReferenceSystem(envelope.getCoordinateReferenceSystem());
						if(LOGGER.isLoggable(Level.FINE) && !tempEnvelope.equals(envelope,scale*1E-3,true)) {
						    LOGGER.log(Level.FINE, "Unable to preserve the envelope for this GridGeometry, expected " + envelope + ", actual " + tempEnvelope);
						}
					} catch (Throwable e) {
						throw new RuntimeException(e);
					}
		        }				
				
				
        	}
        }
        

    }

