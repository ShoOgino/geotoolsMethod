	private static void disposePlanarImageChain(PlanarImage pi, Set<PlanarImage> visited) {
        List<?> sinks = pi.getSinks();
        // check all the sinks (the image might be in the middle of a chain)
        if(sinks != null) {
            for (Object sink: sinks) {
                if(sink instanceof PlanarImage && !visited.contains(sink))
                    disposePlanarImageChain((PlanarImage) sink, visited);
                else if(sink instanceof BufferedImage) {
                    ((BufferedImage) sink).flush();
                }
            }
        }
        // dispose the image itself
        disposeSinglePlanarImage(pi);
        visited.add(pi);
        
        // check the image sources
        List<?> sources = pi.getSources();
        if(sources != null) {
            for (Object child : sources) {
                if(child instanceof PlanarImage && !visited.contains(child))
                    disposePlanarImageChain((PlanarImage) child, visited);
                else if(child instanceof BufferedImage) {
                    ((BufferedImage) child).flush();
                }
            }
        }
        
        // ImageRead might also hold onto a image input stream that we have to close
        if(pi instanceof RenderedOp) {
            RenderedOp op = (RenderedOp) pi;
            for(Object param : op.getParameterBlock().getParameters()) {
                if(param instanceof ImageInputStream) {
                    ImageInputStream iis = (ImageInputStream) param;
                    try {
                        iis.close();
                    } catch(Throwable e) {
                        // fine, we tried
                    	if(LOGGER.isLoggable(Level.FINE)){
                    		LOGGER.log(Level.FINE, e.getLocalizedMessage());
                    	}
                    }
                } else if (param instanceof ImageReader) {
                    ImageReader reader = (ImageReader) param;
                    reader.dispose();
                }
            }
        }
    }

