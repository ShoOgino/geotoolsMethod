    /**
     * Returns the math transform for two dimensions of the specified transform. This methods search
     * for the grid dimensions in the given grid range having a length greater than 1. The
     * corresponding CRS dimensions are inferred from the transform itself.
     *
     * @param gridRange The grid range, or {@code null} if unknown.
     * @param transform The transform, or {@code null} if none.
     * @param axis An array of length 4 initialized to 0. This is the array where to store {@link
     *     #gridDimensionX}, {@link #gridDimensionY}, {@link #axisDimensionX} and {@link
     *     #axisDimensionY} values. This argument is actually a workaround for a Java language
     *     limitation (no multiple return values). If we could, we would have returned directly the
     *     arrays computed in the body of this method.
     * @param hints An optional set of hints for {@link DimensionFilter} creation.
     * @return The {@link MathTransform2D} part of {@code transform}, or {@code null} if and only if
     *     {@code gridToCRS} was null..
     * @throws IllegalArgumentException if the 2D part is not separable.
     */
    private static MathTransform2D getMathTransform2D(
            final MathTransform transform,
            final GridEnvelope gridRange,
            final int[] axis,
            final Hints hints)
            throws IllegalArgumentException {
        if (transform == null || transform instanceof MathTransform2D) {
            axis[1] = axis[3] = 1; // Identity: (0,1) --> (0,1)
            return (MathTransform2D) transform;
        }
        /*
         * Finds the axis for the two dimensional parts. We infer them from the grid range.
         * If no grid range were specified, then we assume that they are the 2 first dimensions.
         */
        final DimensionFilter filter = DimensionFilter.getInstance(hints);
        if (gridRange != null) {
            final int dimension = gridRange.getDimension();
            for (int i = 0; i < dimension; i++) {
                if (gridRange.getSpan(i) > 1) {
                    filter.addSourceDimension(i);
                }
            }
        } else {
            filter.addSourceDimensionRange(0, 2);
        }
        Exception cause = null;
        int[] dimensions = filter.getSourceDimensions();
        /*
         * Select a math transform that operate only on the two dimensions choosen above.
         * If such a math transform doesn't have exactly 2 output dimensions, then select
         * the same output dimensions than the input ones.
         */
        MathTransform candidate;
        if (dimensions.length == 2) {
            axis[0] = dimensions[0]; // gridDimensionX
            axis[1] = dimensions[1]; // gridDimensionY
            try {
                candidate = filter.separate(transform);
                if (candidate.getTargetDimensions() != 2) {
                    filter.clear();
                    filter.addSourceDimensions(dimensions);
                    filter.addTargetDimensions(dimensions);
                    candidate = filter.separate(transform);
                }
                dimensions = filter.getTargetDimensions();
                axis[2] = dimensions[0]; // axisDimensionX
                axis[3] = dimensions[1]; // axisDimensionY
                try {
                    return (MathTransform2D) candidate;
                } catch (ClassCastException exception) {
                    cause = exception;
                }
            } catch (FactoryException exception) {
                cause = exception;
            }
        }
        throw new IllegalArgumentException(
                Errors.format(ErrorKeys.NO_TRANSFORM2D_AVAILABLE), cause);
    }

