    /**
     * Interpolates at the specified position. If {@code fallback!=null}, then {@code dest}
     * <strong>must</strong> have been initialized with {@code super.evaluate(...)} prior to
     * invoking this method.
     *
     * @param x The x position in pixel's coordinates.
     * @param y The y position in pixel's coordinates.
     * @param dest The destination array, or null.
     * @param band The first band's index to interpolate.
     * @param bandUp The last band's index+1 to interpolate.
     * @return {@code null} if point is outside grid coverage.
     */
    private synchronized float[] interpolate(
            final double x, final double y, float[] dest, int band, final int bandUp) {
        final double x0 = Math.floor(x);
        final double y0 = Math.floor(y);
        final int ix = (int) x0;
        final int iy = (int) y0;
        if (!(ix >= xmin && ix < xmax && iy >= ymin && iy < ymax)) return null;

        /*
         * Create buffers, if not already created.
         */
        float[][] samples = floats;
        if (samples == null) {
            final int rowCount = interpolation.getHeight();
            final int colCount = interpolation.getWidth();
            floats = samples = new float[rowCount][];
            for (int i = 0; i < rowCount; i++) {
                samples[i] = new float[colCount];
            }
        }
        if (dest == null) {
            dest = new float[bandUp];
        }
        // ROI Check
        if (hasROI && !roiBounds.contains(ix, iy) && !roi.contains(ix, iy)) {
            // Outside the ROI. fill it with background values
            Arrays.fill(dest, (float) background);
            return dest;
        }
        /*
         * Builds up a RectIter and use it for interpolating all bands.
         * There is very few points, so the cost of creating a RectIter
         * may be important. But it seems to still lower than query tiles
         * many time (which may involve more computation than necessary).
         */
        bounds.x = ix - left;
        bounds.y = iy - top;
        final RectIter iter =
                RectIterFactory.create(image.getExtendedData(bounds, this.borderExtender), bounds);
        boolean[][] gaps = hasNoData ? new boolean[samples.length][samples[0].length] : null;
        for (; band < bandUp; band++) {
            iter.startLines();
            int j = 0;
            do {
                iter.startPixels();
                final boolean[] nodLine = hasNoData ? gaps[j] : null;
                final float[] row = samples[j++];
                int i = 0;
                do {
                    float sampleFloat = iter.getSampleFloat(band);
                    // NoData Check
                    if (hasNoData && !nodata.contains(sampleFloat)) {
                        nodLine[i] = true;
                    }
                    row[i++] = sampleFloat;
                } while (!iter.nextPixelDone());
                assert i == row.length;
            } while (!iter.nextLineDone());
            assert j == samples.length;
            // If has NoData the gas must be filled
            boolean result = fixNoData(samples, gaps);
            if (!result) {
                // Totally nodata. fill it with background values
                Arrays.fill(dest, (float) background);
                return dest;
            }
            float dx = (float) (x - x0);
            if (dx == 1) dx = ONE_EPSILON;
            float dy = (float) (y - y0);
            if (dy == 1) dy = ONE_EPSILON;
            final float value = interpolation.interpolate(samples, dx, dy);
            if (Float.isNaN(value)) {
                if (fallback == this) continue; // 'dest' was set by 'super.evaluate(...)'.
                if (fallback != null) {
                    fallback.interpolate(x, y, dest, band, band + 1);
                    continue;
                }
                // If no fallback was specified, then 'dest' is not required to
                // have been initialized. It may contains random value.  Set it
                // to the NaN value...
            }
            dest[band] = value;
        }
        return dest;
    }

