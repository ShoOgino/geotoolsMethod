    /**
     * Reformats the {@linkplain ColorModel color model} to a {@linkplain ComponentColorModel
     * component color model} preserving transparency. This is used especially in order to go from
     * {@link PackedColorModel} to {@link ComponentColorModel}, which seems to be well accepted from
     * {@code PNGEncoder} and {@code TIFFEncoder}. The omitAlphaOnExpand param allows to explicity
     * avoid producing an alpha band when expanding an {@link IndexColorModel} to {@link
     * ComponentColorModel}. This may be useful when preparing an Image for JPEG encoding which do
     * not support alpha band, avoiding the need of a BandSelect right after the color expansion.
     * Note that this flag has only effect when expanding from {@link IndexColorModel} so alpha is
     * preserved if input colorModel is already a ComponentColorModel.
     *
     * <p>This code is adapted from jai-interests mailing list archive.
     *
     * @return this {@link ImageWorker}.
     * @see FormatDescriptor
     */
    public final ImageWorker forceComponentColorModel(
            boolean checkTransparent, boolean optimizeGray, boolean omitAlphaOnExpand) {
        final ColorModel cm = image.getColorModel();
        if (cm instanceof ComponentColorModel) {
            // Already a component color model - nothing to do.
            return this;
        }
        // shortcut for index color model
        if (cm instanceof IndexColorModel) {
            final IndexColorModel icm = (IndexColorModel) cm;
            final SampleModel sm = this.image.getSampleModel();
            final int datatype = sm.getDataType();
            Range noData = getNoData();
            final boolean gray =
                    ColorUtilities.isGrayPalette(icm, checkTransparent)
                            && optimizeGray
                            && noData == null;
            final boolean alpha = (icm.hasAlpha() || noData != null) && !omitAlphaOnExpand;
            /*
             * If the image is grayscale, retain only the needed bands.
             */
            final int numDestinationBands = gray ? (alpha ? 2 : 1) : (alpha ? 4 : 3);
            LookupTable lut = null;

            switch (datatype) {
                case DataBuffer.TYPE_BYTE:
                    {
                        final byte[][] data = new byte[numDestinationBands][256];
                        icm.getReds(data[0]);
                        if (numDestinationBands >= 2)
                            // remember to optimize for grayscale images
                            if (!gray) icm.getGreens(data[1]);
                            else icm.getAlphas(data[1]);
                        if (numDestinationBands >= 3) icm.getBlues(data[2]);
                        if (numDestinationBands == 4) {
                            icm.getAlphas(data[3]);
                        }
                        if (icm.getMapSize() < 256) {
                            Color bgColor = getBackgroundColor();
                            if (bgColor == null) {
                                bgColor = Color.BLACK;
                            }
                            byte r = (byte) (bgColor.getRed() & 0xFF);
                            byte g = (byte) (bgColor.getRed() & 0xFF);
                            byte b = (byte) (bgColor.getBlue() & 0xFF);
                            byte a = (byte) (bgColor.getAlpha() & 0xFF);
                            for (int i = icm.getMapSize(); i < 256; i++) {
                                data[0][i] = r;
                                if (numDestinationBands >= 2) {
                                    // remember to optimize for grayscale images
                                    if (!gray) {
                                        data[1][i] = g;
                                    } else {
                                        data[1][i] = a;
                                    }
                                }
                                if (numDestinationBands >= 3) {
                                    data[2][i] = b;
                                }
                                if (numDestinationBands == 4) {
                                    data[3][i] = a;
                                }
                            }
                        }
                        if (noData != null
                                && (numDestinationBands == 2 || numDestinationBands == 4)) {
                            int noDataValue = noData.getMin().intValue();
                            for (int i = 0; i < 256; i++) {
                                if (i == noDataValue) {
                                    if (numDestinationBands == 2 && gray) {
                                        data[1][i] = 0;
                                    } else if (numDestinationBands == 4) {
                                        data[3][i] = 0;
                                    }
                                }
                            }
                        }
                        lut = LookupTableFactory.create(data, datatype);
                    }
                    break;

                case DataBuffer.TYPE_USHORT:
                    {
                        final int mapSize = icm.getMapSize();
                        final short[][] data = new short[numDestinationBands][mapSize];
                        for (int i = 0; i < mapSize; i++) {
                            data[0][i] = (short) icm.getRed(i);
                            if (numDestinationBands >= 2)
                                // remember to optimize for grayscale images
                                if (!gray) data[1][i] = (short) icm.getGreen(i);
                                else data[1][i] = (short) icm.getAlpha(i);
                            if (numDestinationBands >= 3) data[2][i] = (short) icm.getBlue(i);
                            if (numDestinationBands == 4) {
                                data[3][i] = (short) icm.getAlpha(i);
                            }
                        }
                        lut = LookupTableFactory.create(data, datatype == DataBuffer.TYPE_USHORT);
                    }
                    break;

                default:
                    throw new IllegalArgumentException(
                            Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, "datatype", datatype));
            }

            // did we initialized the LUT?
            if (lut == null)
                throw new IllegalStateException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, "lut"));
            /*
             * Get the default hints, which usually contains only informations about tiling. If the user override the rendering hints with an explicit
             * color model, keep the user's choice.
             */
            final RenderingHints hints = getRenderingHints();
            final ImageLayout layout;
            final Object candidate = hints.get(JAI.KEY_IMAGE_LAYOUT);
            if (candidate instanceof ImageLayout) {
                layout = (ImageLayout) candidate;
            } else {
                layout = new ImageLayout(image);
                hints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT, layout));
            }

            int[] bits = new int[numDestinationBands];
            // bits per component
            for (int i = 0; i < numDestinationBands; i++) bits[i] = sm.getSampleSize(i);
            final ComponentColorModel destinationColorModel =
                    new ComponentColorModel(
                            numDestinationBands >= 3
                                    ? ColorSpace.getInstance(ColorSpace.CS_sRGB)
                                    : ColorSpace.getInstance(ColorSpace.CS_GRAY),
                            bits,
                            alpha,
                            cm.isAlphaPremultiplied(),
                            alpha ? Transparency.TRANSLUCENT : Transparency.OPAQUE,
                            datatype);
            final SampleModel destinationSampleModel =
                    destinationColorModel.createCompatibleSampleModel(
                            image.getWidth(), image.getHeight());
            layout.setColorModel(destinationColorModel);
            layout.setSampleModel(destinationSampleModel);

            // ParameterBlock definition
            ParameterBlock pb = new ParameterBlock();
            pb.setSource(image, 0);
            pb.set(lut, 0);
            pb.set(roi, 2);
            pb.set(nodata, 3);
            if (isNoDataNeeded()) {
                if (background != null && background.length > 0) {
                    pb.set(background[0], 1);
                }
            }

            image = JAI.create("Lookup", pb, hints);

        } else {
            // Most of the code adapted from jai-interests is in 'getRenderingHints(int)'.
            final int type =
                    (cm instanceof DirectColorModel)
                            ? DataBuffer.TYPE_BYTE
                            : image.getSampleModel().getTransferType();
            final RenderingHints hints = getRenderingHints(type);
            ParameterBlock pb = new ParameterBlock();
            pb.setSource(image, 0); // The source image.
            pb.set(type, 0);

            image = JAI.create("Format", pb, hints);
            setNoData(RangeFactory.convert(nodata, type));
        }
        invalidateStatistics();

        // All post conditions for this method contract.
        assert image.getColorModel() instanceof ComponentColorModel;
        return this;
    }

