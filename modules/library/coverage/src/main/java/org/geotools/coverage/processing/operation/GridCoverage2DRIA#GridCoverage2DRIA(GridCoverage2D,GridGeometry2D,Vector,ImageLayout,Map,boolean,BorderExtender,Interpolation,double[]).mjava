    protected GridCoverage2DRIA(final GridCoverage2D src, final GridGeometry2D dst,
            final Vector sources, final ImageLayout layout, final Map configuration,
            final boolean cobbleSources, final BorderExtender extender, final Interpolation interp,
            final double[] nodata) {

        super(sources, layout, configuration, cobbleSources, extender, interp, nodata);

        this.src = src;
        this.dst = dst;

        // === Take one for all all the transformation we need to pass from
        // model, sample, src, target and viceversa.
        g2wd = dst.getGridToCRS2D(PixelOrientation.UPPER_LEFT);

        try {
            w2gd = g2wd.inverse();
        } catch (org.opengis.referencing.operation.NoninvertibleTransformException e) {
            throw new IllegalArgumentException("Can't compute destination W2G", e);
        }

        g2ws = src.getGridGeometry().getGridToCRS2D(PixelOrientation.UPPER_LEFT);

        try {
            w2gs = g2ws.inverse();
        } catch (org.opengis.referencing.operation.NoninvertibleTransformException e) {
            throw new IllegalArgumentException("Can't compute source W2G", e);
        }

        try {
            CoordinateReferenceSystem sourceCRS = src.getCoordinateReferenceSystem2D();
            CoordinateReferenceSystem targetCRS = dst.getCoordinateReferenceSystem2D();

            src2dstCRSTransform = CRS.findMathTransform(sourceCRS, targetCRS, true);
            dst2srcCRSTransform = src2dstCRSTransform.inverse();
        } catch (FactoryException e) {
            throw new IllegalArgumentException("Can't create a transform between CRS", e);
        } catch (NoninvertibleTransformException e) {
            throw new IllegalArgumentException("Can't create a transform between CRS", e);
        }

    }

