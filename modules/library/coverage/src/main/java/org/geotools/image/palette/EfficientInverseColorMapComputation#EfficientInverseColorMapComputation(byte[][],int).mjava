	/**
	 * {@link EfficientInverseColorMapComputation} that allows us to specify the
	 * number of bits we are going to save from the quantization.
	 * 
	 * @param rgbColorMap
	 * @param quantizationBits
	 */
	public EfficientInverseColorMapComputation(byte[][] rgbColorMap,
			final int quantizationBits) {
		colorMap = rgbColorMap;
		bits = quantizationBits;
		truncationBits = 8 - bits;
		blueQuantizationMask = (1 << bits) - 1;
		greenQuantizationMask = (blueQuantizationMask << bits);
		redQuantizationMask = (greenQuantizationMask << bits);
		final int maximumQuantizationValue = 1 << bits;
		final int numberOfColors = colorMap[0].length;
		mapBuf = new byte[maximumQuantizationValue * maximumQuantizationValue* maximumQuantizationValue];
		if(mapBuf.length<=0)
			throw new IllegalArgumentException("Illegal number of quantization colors");
		final int[] distBuf = new int[maximumQuantizationValue* maximumQuantizationValue * maximumQuantizationValue];

		final int x = (1 << truncationBits);
		final int xsqr = x * x;
		final int txsqr = xsqr + xsqr;

		// /////////////////////////////////////////////////////////////////////
		//
		// This code visits every cell in the inverse color map for each
		// representative color.
		//
		// /////////////////////////////////////////////////////////////////////
		for (int i = 0; i < numberOfColors; ++i) {

			// //
			//
			// Get the representative color components
			//
			// //
			final int red = colorMap[0][i] & 0xFF;
			final int green = colorMap[1][i] & 0xFF;
			final int blue = colorMap[2][i] & 0xFF;

			// //
			//
			// Distances are measured to the center of each quantized cell, so
			// x/2 is used as the starting point. This is due to the fact that
			// we quantize by performing right shift.
			//
			// //
			final int x_ = x / 2;
			int rdist = red - x_;
			int gdist = green - x_;
			int bdist = blue - x_;
			// distance
			rdist = rdist * rdist + gdist * gdist + bdist * bdist;

			final int rinc = 2 * (xsqr - (red << truncationBits));
			final int ginc = 2 * (xsqr - (green << truncationBits));
			final int binc = 2 * (xsqr - (blue << truncationBits));

			// //
			//
			// Going to check for all the quantized space
			//
			// //
			for (int r = 0, rxx = rinc, rgbI = 0; r < maximumQuantizationValue; rdist += rxx, ++r, rxx += txsqr) {
				gdist = rdist;
				for (int g = 0, gxx = ginc; g < maximumQuantizationValue; gdist += gxx, ++g, gxx += txsqr) {
					bdist = gdist;
					for (int b = 0, bxx = binc; b < maximumQuantizationValue; bdist += bxx, ++b, ++rgbI, bxx += txsqr) {
						if (i == 0 || distBuf[rgbI] > bdist) {
							distBuf[rgbI] = bdist;
							mapBuf[rgbI] = (byte) i;
						}
					}
				}
			}
		}
	}

