    /**
     * {@link EfficientInverseColorMapComputation} that allows us to specify the number of bits we
     * are going to save from the quantization.
     */
    public EfficientInverseColorMapComputation(byte[][] rgbColorMap, final int quantizationBits) {
        colorMap = rgbColorMap;
        bits = quantizationBits;
        truncationBits = 8 - bits;
        blueQuantizationMask = (1 << bits) - 1;
        greenQuantizationMask = (blueQuantizationMask << bits);
        redQuantizationMask = (greenQuantizationMask << bits);
        final int maximumQuantizationValue = 1 << bits;
        final int numberOfColors = colorMap[0].length;
        mapBuf =
                new byte
                        [maximumQuantizationValue
                                * maximumQuantizationValue
                                * maximumQuantizationValue];
        if (mapBuf.length <= 0)
            throw new IllegalArgumentException("Illegal number of quantization colors");
        final int[] distBuf =
                new int
                        [maximumQuantizationValue
                                * maximumQuantizationValue
                                * maximumQuantizationValue];

        final int x = (1 << truncationBits);
        final int xsqr = x * x;
        final int txsqr = xsqr + xsqr;

        // /////////////////////////////////////////////////////////////////////
        //
        // This code visits every cell in the inverse color map for each
        // representative color.
        //
        // /////////////////////////////////////////////////////////////////////
        for (int i = 0; i < numberOfColors; ++i) {

            // //
            //
            // Get the representative color components
            //
            // //
            final int red = colorMap[0][i] & 0xFF;
            final int green = colorMap[1][i] & 0xFF;
            final int blue = colorMap[2][i] & 0xFF;

            // //
            //
            // Distances are measured to the center of each quantized cell, so
            // x/2 is used as the starting point. This is due to the fact that
            // we quantize by performing right shift.
            //
            // //
            final int x_ = x / 2;
            int rdist = red - x_;
            int gdist = green - x_;
            int bdist = blue - x_;
            // distance
            rdist = rdist * rdist + gdist * gdist + bdist * bdist;

            final int rinc = 2 * (xsqr - (red << truncationBits));
            final int ginc = 2 * (xsqr - (green << truncationBits));
            final int binc = 2 * (xsqr - (blue << truncationBits));

            // //
            //
            // Going to check for all the quantized space
            //
            // //
            for (int r = 0, rxx = rinc, rgbI = 0;
                    r < maximumQuantizationValue;
                    rdist += rxx, ++r, rxx += txsqr) {
                gdist = rdist;
                for (int g = 0, gxx = ginc;
                        g < maximumQuantizationValue;
                        gdist += gxx, ++g, gxx += txsqr) {
                    bdist = gdist;
                    for (int b = 0, bxx = binc;
                            b < maximumQuantizationValue;
                            bdist += bxx, ++b, ++rgbI, bxx += txsqr) {
                        if (i == 0 || distBuf[rgbI] > bdist) {
                            distBuf[rgbI] = bdist;
                            mapBuf[rgbI] = (byte) i;
                        }
                    }
                }
            }
        }
    }

