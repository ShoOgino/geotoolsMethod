    /**
     * Gets a lookup factory
     *
     * @param sourceType The source data type. Should be one of {@link DataBuffer} constants.
     * @param targetType The target data type. Should be one of {@link DataBuffer} constants.
     * @param transforms The math transforms to apply.
     * @return The lookup table, or {@code null} if this method can't build a lookup table for the
     *     supplied parameters.
     * @throws TransformException if a transformation failed.
     */
    public static LookupTableJAI create(
            final int sourceType, final int targetType, final MathTransform1D[] transforms)
            throws TransformException {
        /*
         * Argument check. Null values are legal but can't be processed by this method.
         */
        final int nbands = transforms.length;
        for (MathTransform1D transform : transforms) {
            if (transform == null) {
                return null;
            }
        }
        synchronized (pool) {
            /*
             * Checks if a table is already available in the cache. Since tables may be 64 kb big,
             * sharing tables may save a significant amount of memory if there is many images.
             */
            final LookupTableFactory key =
                    new LookupTableFactory(sourceType, targetType, transforms);
            LookupTableJAI table = pool.get(key);
            if (table != null) {
                return table;
            }
            /*
             * Computes the table's size according the source datatype. For datatype 'short' (signed
             * or unsigned), we will create the table only if the target datatype is 'byte' in order
             * to avoid to use too much memory for the table. The memory consumed for a table from
             * source datatype 'short' to target datatype 'byte' is 64 ko.
             */
            final int length;
            final int offset;
            switch (sourceType) {
                default:
                    {
                        return null;
                    }
                case DataBuffer.TYPE_BYTE:
                    {
                        length = 0x100;
                        offset = 0;
                        break;
                    }
                case DataBuffer.TYPE_SHORT:
                case DataBuffer.TYPE_USHORT:
                    {
                        if (targetType != DataBuffer.TYPE_BYTE) {
                            // Avoid to use too much memory for the table.
                            return null;
                        }
                        length = 0x10000;
                        offset = (sourceType == DataBuffer.TYPE_SHORT) ? Short.MIN_VALUE : 0;
                        break;
                    }
            }
            /*
             * Builds the table according the target datatype.
             */
            switch (targetType) {
                default:
                    {
                        return null;
                    }
                case DataBuffer.TYPE_DOUBLE:
                    {
                        final double[][] data = new double[nbands][];
                        final double[] buffer = new double[length];
                        for (int i = length; --i >= 0; ) {
                            buffer[i] = i;
                        }
                        for (int i = nbands; --i >= 0; ) {
                            final double[] array = (i == 0) ? buffer : buffer.clone();
                            transforms[i].transform(array, 0, array, 0, array.length);
                            data[i] = array;
                        }
                        table = new LookupTableJAI(data, offset);
                        break;
                    }
                case DataBuffer.TYPE_FLOAT:
                    {
                        final float[][] data = new float[nbands][];
                        final float[] buffer = new float[length];
                        for (int i = length; --i >= 0; ) {
                            buffer[i] = i;
                        }
                        for (int i = transforms.length; --i >= 0; ) {
                            final float[] array = (i == 0) ? buffer : buffer.clone();
                            transforms[i].transform(array, 0, array, 0, length);
                            data[i] = array;
                        }
                        table = new LookupTableJAI(data, offset);
                        break;
                    }
                case DataBuffer.TYPE_INT:
                    {
                        final int[][] data = new int[nbands][];
                        for (int i = nbands; --i >= 0; ) {
                            final MathTransform1D tr = transforms[i];
                            final int[] array = new int[length];
                            for (int j = length; --j >= 0; ) {
                                array[j] =
                                        (int)
                                                min(
                                                        max(
                                                                round(tr.transform(j + offset)),
                                                                Integer.MIN_VALUE),
                                                        Integer.MAX_VALUE);
                            }
                            data[i] = array;
                        }
                        table = new LookupTableJAI(data, offset);
                        break;
                    }
                case DataBuffer.TYPE_SHORT:
                case DataBuffer.TYPE_USHORT:
                    {
                        final int minimum, maximum;
                        if (targetType == DataBuffer.TYPE_SHORT) {
                            minimum = Short.MIN_VALUE;
                            maximum = Short.MAX_VALUE;
                        } else {
                            minimum = 0;
                            maximum = 0xFFFF;
                        }
                        final short[][] data = new short[nbands][];
                        for (int i = nbands; --i >= 0; ) {
                            final MathTransform1D tr = transforms[i];
                            final short[] array = new short[length];
                            for (int j = length; --j >= 0; ) {
                                array[j] =
                                        (short)
                                                min(
                                                        max(
                                                                round(tr.transform(j + offset)),
                                                                minimum),
                                                        maximum);
                            }
                            data[i] = array;
                        }
                        table = new LookupTableJAI(data, offset, minimum != 0);
                        break;
                    }
                case DataBuffer.TYPE_BYTE:
                    {
                        final byte[][] data = new byte[nbands][];
                        for (int i = nbands; --i >= 0; ) {
                            final MathTransform1D tr = transforms[i];
                            final byte[] array = new byte[length];
                            for (int j = length; --j >= 0; ) {
                                array[j] =
                                        (byte) min(max(round(tr.transform(j + offset)), 0), 0xFF);
                            }
                            data[i] = array;
                        }
                        table = new LookupTableJAI(data, offset);
                        break;
                    }
            }
            pool.put(key, table);
            return table;
        }
    }

