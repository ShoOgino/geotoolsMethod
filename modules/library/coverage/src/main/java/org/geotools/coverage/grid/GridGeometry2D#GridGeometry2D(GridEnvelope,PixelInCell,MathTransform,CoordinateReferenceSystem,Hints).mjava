    /**
     * Constructs a new grid geometry from a math transform. This constructor is similar to <code>
     * {@linkplain #GridGeometry2D(GridEnvelope, MathTransform, CoordinateReferenceSystem)
     * GridGeometry2D}(gridRange, gridToCRS, crs)</code> with the addition of an explicit anchor and
     * an optional set of hints giving more control on the {@link MathTransform2D} to be inferred
     * from the <var>n</var>-dimensional transform.
     *
     * <p>The {@code anchor} argument tells whatever the {@code gridToCRS} transform maps
     * {@linkplain PixelInCell#CELL_CENTER cell center} (OGC convention) or {@linkplain
     * PixelInCell#CELL_CORNER cell corner} (Java2D/JAI convention). At the opposite of the
     * constructor expecting a {@link PixelOrientation} argument, the translation (if any) applies
     * to every dimensions, not just the ones mapping the 2D part.
     *
     * @param gridRange The valid coordinate range of a grid coverage, or {@code null} if none.
     * @param anchor Whatever the {@code gridToCRS} transform maps {@linkplain
     *     PixelInCell#CELL_CENTER cell center} (OGC convention) or {@linkplain
     *     PixelInCell#CELL_CORNER cell corner} (Java2D/JAI convention).
     * @param gridToCRS The math transform which allows for the transformations from grid
     *     coordinates to real world earth coordinates.
     * @param crs The coordinate reference system for the "real world" coordinates, or {@code null}
     *     if unknown. This CRS is given to the {@linkplain #getEnvelope envelope}.
     * @param hints An optional set of hints controlling the {@link DimensionFilter} to be used for
     *     deriving the {@link MathTransform2D} instance from the given {@code gridToCRS} transform.
     * @throws MismatchedDimensionException if the math transform and the CRS don't have consistent
     *     dimensions.
     * @throws IllegalArgumentException if the math transform can't transform coordinates in the
     *     domain of the specified grid range.
     * @since 2.5
     */
    public GridGeometry2D(
            final GridEnvelope gridRange,
            final PixelInCell anchor,
            final MathTransform gridToCRS,
            final CoordinateReferenceSystem crs,
            final Hints hints)
            throws MismatchedDimensionException, IllegalArgumentException {
        super(gridRange, anchor, gridToCRS, crs);
        final int[] dimensions;
        dimensions = new int[4];
        gridToCRS2D = getMathTransform2D(super.gridToCRS, gridRange, dimensions, hints);
        gridFromCRS2D = inverse(gridToCRS2D);
        gridDimensionX = dimensions[0];
        gridDimensionY = dimensions[1];
        axisDimensionX = dimensions[2];
        axisDimensionY = dimensions[3];
        crs2D = createCRS2D();
        if (PixelInCell.CELL_CORNER.equals(anchor)) {
            cornerToCRS2D = getMathTransform2D(gridToCRS, gridRange, dimensions, hints);
        }
        assert isValid() : this;
    }

