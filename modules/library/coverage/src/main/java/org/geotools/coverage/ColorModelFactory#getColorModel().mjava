    /** Constructs the color model. */
    private ColorModel getColorModel() {
        double minimum = 0;
        double maximum = 1;
        final int categoryCount = categories.length;
        if (categoryCount != 0) {
            minimum = categories[0].minimum;
            for (int i = categoryCount; --i >= 0; ) {
                final double value = categories[i].maximum;
                if (!Double.isNaN(value)) {
                    maximum = value;
                    break;
                }
            }
        }
        if (type != DataBuffer.TYPE_BYTE && type != DataBuffer.TYPE_USHORT) {
            // If the requested type is any type not supported by IndexColorModel,
            // fallback on a generic (but very slow!) color model.
            final int transparency = Transparency.OPAQUE;
            final ColorSpace colors = new ScaledColorSpace(visibleBand, numBands, minimum, maximum);
            // This is the J2SE implementation of color model. It should be our preferred one.
            // In JAI 1.1 we had to use JAI implementation instead of J2SE's one because
            // javax.media.jai.iterator.RectIter didn't work with J2SE's DataBuffer
            // when the data type is float or double.
            return new ComponentColorModel(colors, false, false, transparency, type);
        }
        if (numBands == 1 && categoryCount == 0) {
            // Construct a gray scale palette.
            final ColorSpace cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);
            final int[] nBits = {DataBuffer.getDataTypeSize(type)};
            return new ComponentColorModel(cs, nBits, false, true, Transparency.OPAQUE, type);
        }
        /*
         * Computes the number of entries required for the color palette.
         * We take the upper range value of the last non-NaN category.
         */
        final int mapSize = ((int) Math.round(maximum)) + 1;
        final int[] ARGB = new int[mapSize];
        /*
         * Interpolates the colors in the color palette. Colors that do not fall
         * in the range of a category will be set to a transparent color.
         */
        for (final Category category : categories) {
            ColorUtilities.expand(
                    category.getColors(),
                    ARGB,
                    (int) Math.round(category.minimum),
                    (int) Math.round(category.maximum) + 1);
        }
        return ColorUtilities.getIndexColorModel(ARGB, numBands, visibleBand);
    }

