    /**
     * Converts the image to a GIF-compliant image. This method has been created in order to convert
     * the input image to a form that is compatible with the GIF model. It first remove the
     * information about transparency since the error diffusion and the error dither operations are
     * unable to process images with more than 3 bands. Afterwards the image is processed with an
     * error diffusion operator in order to reduce the number of bands from 3 to 1 and the number of
     * color to 216. A suitable layout is used for the final image via the {@linkplain
     * #getRenderingHints rendering hints} in order to take into account the different layout model
     * for the final image.
     *
     * <p><strong>Tip:</strong> For optimizing writing GIF, we need to create the image untiled.
     * This can be done by invoking <code>
     * {@linkplain #setRenderingHint setRenderingHint}({@linkplain
     * #TILING_ALLOWED}, Boolean.FALSE)</code> first.
     *
     * @param errorDiffusion Tells if I should use {@link ErrorDiffusionDescriptor} or {@link
     *     OrderedDitherDescriptor} JAi operations.
     * @return this {@link ImageWorker}.
     * @see #isIndexed
     * @see #forceIndexColorModel
     * @see #forceBitmaskIndexColorModel
     */
    public final ImageWorker forceIndexColorModelForGIF(final boolean errorDiffusion) {
        /*
         * Checking the color model to see if we need to convert it back to color model. We might also need to reformat the image in order to get it
         * to 8 bits samples.
         */
        ColorModel cm = image.getColorModel();
        if (cm instanceof PackedColorModel) {
            forceComponentColorModel();
            cm = image.getColorModel();
        }
        if (!(cm instanceof IndexColorModel) || cm.getPixelSize() > 8) rescaleToBytes();
        /*
         * Getting the alpha channel and separating from the others bands. If the initial image had no alpha channel (more specifically, if it is
         * either opaque or a bitmask) we proceed without doing anything since it seems that GIF encoder in such a case works fine. If we need to
         * create a bitmask, we will use the last index value allowed (255) as the transparent pixel value.
         */
        if (isTranslucent()) {
            forceBitmaskIndexColorModel(255, errorDiffusion);
        } else {
            forceIndexColorModel(errorDiffusion);
        }
        // All post conditions for this method contract.
        // assert isBytes(); // could be less, like binary, 4 bits
        assert isIndexed();
        assert !isTranslucent();
        return this;
    }

