        /**
         * Private method for resampling the {@link GridCoverage2D}s to the same resolution imposed by the {@link GridGeometry2D} object.
         * 
         * @param sources
         * @param alphas
         * @param external
         * @param parameters
         * @return
         */
        private static ResampledRasters resampleCoverages(GridCoverage2D[] sources,
                GridCoverage2D[] alphas, GridGeometry2D external, ParameterValueGroup parameters,
                Hints hints) {
            // Number of the sources to use
            int numSources = sources.length;

            // Creation of an array of the RenderedImages to use
            RenderedImage[] rasters = new RenderedImage[numSources];

            // Selection of the GridToWorld transformation associated to the External GG2D
            MathTransform g2w = external.getGridToCRS2D(PixelOrientation.UPPER_LEFT);
            // Initial null value for NoData
            double[] nodata = null;

            // Check if the output nodata value is set as parameter
            Object outputNodata = parameters.parameter(OUTNODATA_NAME).getValue();
            if (outputNodata != null && outputNodata instanceof double[]) {
                nodata = ((double[]) outputNodata);
            }
            // Checking if the external alpha bands are defined
            boolean hasAlpha = alphas != null && alphas.length > 0;
            PlanarImage[] alphaArray = new PlanarImage[numSources];
            // Cycle around the various sources
            for (int i = 0; i < numSources; i++) {
                // For each source, create a new GridGeometry which at the same resolution of the imposed one
                GridCoverage2D coverage = sources[i];
                GridGeometry2D inputGG = coverage.getGridGeometry();

                // Check if the transform from one gridGeometry to the other is an Identity transformation
                MathTransform g2wS = inputGG.getGridToCRS2D(PixelOrientation.UPPER_LEFT);
                MathTransform w2gD = external.getCRSToGrid2D(PixelOrientation.UPPER_LEFT);
                // Creation of a Concatenated transformation in order to check if the final transformation from
                // source space to the final space is an identity.
                MathTransform concatenated = ConcatenatedTransform.create(g2wS, w2gD);

                // No operation must be done if the transformation is an Identity
                if (concatenated != null && concatenated.isIdentity()) {
                    RenderedImage renderedImage = coverage.getRenderedImage();
                    rasters[i] = renderedImage;
                    // Add the alpha band
                    if (hasAlpha && alphas[i] != null) {
                        checkAlpha(coverage, alphas[i]);
                        alphaArray[i] = PlanarImage.wrapRenderedImage(alphas[i].getRenderedImage());
                    }
                } else {
                    // New GridGeometry
                    GridGeometry2D newGG = new GridGeometry2D(PixelInCell.CELL_CORNER, g2w,
                            inputGG.getEnvelope(), GeoTools.getDefaultHints());
                    try {
                        // Transformation of the input envelope in the Raster Space
                        GeneralEnvelope transformed = CRS.transform(
                                g2w.inverse(), inputGG.getEnvelope());
                        // Rounding of the bounds
                        Rectangle rect = transformed.toRectangle2D().getBounds();
                        // Creation of a new GridEnvelope to set for the new GridGeometry
                        GridEnvelope2D gEnv2 = new GridEnvelope2D(rect);
                        // Creation of the new GridGeometry
                        newGG = new GridGeometry2D(gEnv2, inputGG.getEnvelope());
                    } catch (InvalidGridGeometryException e) {
                        throw new CoverageProcessingException(e);
                    } catch (NoninvertibleTransformException e) {
                        throw new CoverageProcessingException(e);
                    } catch (TransformException e) {
                        throw new CoverageProcessingException(e);
                    }
                    // Initialization of the nodata value
                    double[] fillValue = null;
                    // Selection of the nodata value
                    if (nodata == null) {
                        fillValue = CoverageUtilities.getBackgroundValues(coverage);
                    } else {
                        fillValue = nodata;
                    }

                    // Resample to the new resolution
                    rasters[i] = GridCoverage2DRIA.create(coverage, newGG, fillValue, hints);
                    // Resample also the alpha band
                    if (hasAlpha && alphas[i] != null) {
                        checkAlpha(coverage, alphas[i]);
                        RenderedImage al = GridCoverage2DRIA.create(alphas[i], newGG,
                                new double[1], hints);
                        alphaArray[i] = PlanarImage.wrapRenderedImage(al);
                    }
                }
            }

            // Create the final object containing the final GridGeometry and the resampled RenderedImages
            ResampledRasters rr = new ResampledRasters();
            rr.setFinalGeometry(external);
            rr.setRasters(rasters);
            rr.setAlphas(alphaArray);
            return rr;
        }

