        /**
         * Private method for resampling the {@link GridCoverage2D}s to the same resolution imposed by the {@link GridGeometry2D} object.
         * 
         * @param sources
         * @param alphas
         * @param external
         * @param parameters
         * @return
         */
        private static ResampledRasters resampleCoverages(GridCoverage2D[] sources,
                GridCoverage2D[] alphas, GridGeometry2D external, ParameterValueGroup parameters,
                Hints hints) {
            // Number of the sources to use
            int numSources = sources.length;

            // Creation of an array of the RenderedImages to use
            RenderedImage[] rasters = new RenderedImage[numSources];
            // Creation of an array of background values
            double[] backgrounds = new double[numSources];
            // Creation of an array of rois
            ROI[] rois = new ROI[numSources];
            // Creation of an array of NoData
            boolean hasNoDataProp = false;

            // Selection of the GridToWorld transformation associated to the External GG2D
            MathTransform g2w = external.getGridToCRS2D(PixelOrientation.UPPER_LEFT);
            // Initial null value for NoData
            double[] nodata = null;

            // Check if the output nodata value is set as parameter
            Object outputNodata = parameters.parameter(OUTNODATA_NAME).getValue();
            if (outputNodata != null && outputNodata instanceof double[]) {
                nodata = ((double[]) outputNodata);
            }
            // Checking if the external alpha bands are defined
            boolean hasAlpha = alphas != null && alphas.length > 0;
            PlanarImage[] alphaArray = new PlanarImage[numSources];

            // Cycle around the various sources
            for (int i = 0; i < numSources; i++) {
                // For each source, create a new GridGeometry which at the same resolution of the imposed one
                GridCoverage2D coverage = sources[i];
                GridGeometry2D inputGG = coverage.getGridGeometry();

                // Check if the transform from one gridGeometry to the other is an Identity transformation
                MathTransform g2wS = inputGG.getGridToCRS2D(PixelOrientation.UPPER_LEFT);
                MathTransform w2gD = external.getCRSToGrid2D(PixelOrientation.UPPER_LEFT);
                // Creation of a Concatenated transformation in order to check if the final transformation from
                // source space to the final space is an identity.
                MathTransform concatenated = ConcatenatedTransform.create(g2wS, w2gD);

                // No operation must be done if the transformation is an Identity
                if (concatenated != null && concatenated.isIdentity()) {
                    RenderedImage renderedImage = coverage.getRenderedImage();
                    rasters[i] = renderedImage;
                    // Get ROI from the coverage
                    rois[i] = CoverageUtilities.getROIProperty(coverage);
                    // Add the alpha band
                    if (hasAlpha && alphas[i] != null) {
                        checkAlpha(coverage, alphas[i]);
                        alphaArray[i] = PlanarImage.wrapRenderedImage(alphas[i].getRenderedImage());
                        // Mask alpha band with ROI in order to see ROI during Mosaic operation
                        if (rois[i] != null) {
                            ImageWorker w = new ImageWorker(alphaArray[i]);
                            // Expand ROI Image to alpha size
                            ImageWorker w1 = new ImageWorker(rois[i].getAsImage());
                            ImageLayout layout = new ImageLayout();
                            layout.setMinX(alphaArray[i].getMinX());
                            layout.setMinY(alphaArray[i].getMinY());
                            layout.setWidth(alphaArray[i].getWidth());
                            layout.setHeight(alphaArray[i].getHeight());
                            w1.setRenderingHint(JAI.KEY_IMAGE_LAYOUT, layout);
                            w1.translate(0f, 0f, null);
                            // Mask Alpha
                            w.mask(w1.getRenderedImage(), false, 0);
                        }
                    }
                    double fillValue = CoverageUtilities.getBackgroundValues(coverage)[0];
                    backgrounds[i] = fillValue;
                    // Get NoData as property if present
                    NoDataContainer noDataProperty = CoverageUtilities.getNoDataProperty(coverage);
                    hasNoDataProp |= noDataProperty != null;
                } else {
                    // New GridGeometry
                    GridGeometry2D newGG = new GridGeometry2D(PixelInCell.CELL_CORNER, g2w,
                            inputGG.getEnvelope(), GeoTools.getDefaultHints());
                    try {
                        // Transformation of the input envelope in the Raster Space
                        GeneralEnvelope transformed = CRS.transform(
                                g2w.inverse(), inputGG.getEnvelope());
                        // Rounding of the bounds
                        Rectangle rect = transformed.toRectangle2D().getBounds();
                        // Creation of a new GridEnvelope to set for the new GridGeometry
                        GridEnvelope2D gEnv2 = new GridEnvelope2D(rect);
                        // Creation of the new GridGeometry
                        newGG = new GridGeometry2D(gEnv2, inputGG.getEnvelope());
                    } catch (InvalidGridGeometryException e) {
                        throw new CoverageProcessingException(e);
                    } catch (NoninvertibleTransformException e) {
                        throw new CoverageProcessingException(e);
                    } catch (TransformException e) {
                        throw new CoverageProcessingException(e);
                    }
                    // Initialization of the nodata value
                    double[] fillValue = null;
                    // Selection of the nodata value
                    if (nodata == null) {
                        fillValue = CoverageUtilities.getBackgroundValues(coverage);
                    } else {
                        fillValue = nodata;
                    }

                    // Resample to the new resolution
                    rasters[i] = GridCoverage2DRIA.create(coverage, newGG, fillValue, hints, CoverageUtilities.getROIProperty(coverage));
                    // Resample also the alpha band
                    if (hasAlpha && alphas[i] != null) {
                        checkAlpha(coverage, alphas[i]);
                        RenderedImage al = GridCoverage2DRIA.create(alphas[i], newGG,
                                new double[1], hints, CoverageUtilities.getROIProperty(coverage));
                        alphaArray[i] = PlanarImage.wrapRenderedImage(al);
                    }
                    backgrounds[i] = fillValue[0];
                    // Resample to the new resolution
                    GridCoverage2DRIA.GridCoverage2DRIAPropertyGenerator propertyGenerator = new GridCoverage2DRIA.GridCoverage2DRIAPropertyGenerator();
                    Object property = propertyGenerator.getProperty("roi", rasters[i]);
                    ROI roi = (property != null && property instanceof ROI ) ? (ROI) property : null;
                    rois[i] = roi;
                    // Get NoData as property if present
                    NoDataContainer noDataProperty = CoverageUtilities.getNoDataProperty(coverage);
                    hasNoDataProp |= noDataProperty != null;
                }
            }

            // Create the final object containing the final GridGeometry and the resampled RenderedImages
            ResampledRasters rr = new ResampledRasters();
            rr.setFinalGeometry(external);
            rr.setRasters(rasters);
            rr.setAlphas(alphaArray);
            rr.setBackgrounds(backgrounds);
            rr.setRois(rois);
            rr.setHasNoData(hasNoDataProp);
            return rr;
        }

