        /**
         * Private method for resampling the {@link GridCoverage2D}s to the same resolution imposed
         * by the {@link GridGeometry2D} object.
         */
        private static ResampledRasters resampleCoverages(
                GridCoverage2D[] sources,
                GridCoverage2D[] alphas,
                GridGeometry2D external,
                ParameterValueGroup parameters,
                Hints hints) {
            // Number of the sources to use
            int numSources = sources.length;

            // Creation of an array of the RenderedImages to use
            RenderedImage[] rasters = new RenderedImage[numSources];
            // Creation of an array of background values
            double[] backgrounds = new double[numSources];
            // Creation of an array of rois
            ROI[] rois = new ROI[numSources];
            // Creation of an array of NoData
            boolean hasNoDataProp = false;

            // Selection of the GridToWorld transformation associated to the External GG2D
            MathTransform g2w = external.getGridToCRS2D(PixelOrientation.UPPER_LEFT);
            // Initial null value for NoData
            double[] nodata = null;

            // Check if the output nodata value is set as parameter
            Object outputNodata = parameters.parameter(OUTNODATA_NAME).getValue();
            if (outputNodata != null && outputNodata instanceof double[]) {
                nodata = ((double[]) outputNodata);
            }
            // Checking if the external alpha bands are defined
            boolean hasAlpha = alphas != null && alphas.length > 0;
            PlanarImage[] alphaArray = new PlanarImage[numSources];

            // Cycle around the various sources
            for (int i = 0; i < numSources; i++) {
                // For each source, create a new GridGeometry which at the same resolution of the
                // imposed one
                GridCoverage2D coverage = sources[i];
                GridGeometry2D inputGG = coverage.getGridGeometry();

                // Check if the transform from one gridGeometry to the other is an Identity
                // transformation
                MathTransform g2wS = inputGG.getGridToCRS2D(PixelOrientation.UPPER_LEFT);
                MathTransform w2gD = external.getCRSToGrid2D(PixelOrientation.UPPER_LEFT);
                // Creation of a Concatenated transformation in order to check if the final
                // transformation from
                // source space to the final space is an identity.
                MathTransform concatenated = ConcatenatedTransform.create(g2wS, w2gD);

                // No operation must be done if the transformation is an Identity
                if (concatenated != null && concatenated.isIdentity()) {
                    RenderedImage renderedImage = coverage.getRenderedImage();
                    rasters[i] = renderedImage;
                    // Get ROI from the coverage
                    rois[i] = CoverageUtilities.getROIProperty(coverage);
                    // Add the alpha band
                    if (hasAlpha && alphas[i] != null) {
                        checkAlpha(coverage, alphas[i]);
                        alphaArray[i] = PlanarImage.wrapRenderedImage(alphas[i].getRenderedImage());
                        // Mask alpha band with ROI in order to see ROI during Mosaic operation
                        if (rois[i] != null) {
                            ImageWorker w = new ImageWorker(alphaArray[i]);
                            // Expand ROI Image to alpha size
                            ImageWorker w1 = new ImageWorker(rois[i].getAsImage());
                            ImageLayout layout = new ImageLayout();
                            layout.setMinX(alphaArray[i].getMinX());
                            layout.setMinY(alphaArray[i].getMinY());
                            layout.setWidth(alphaArray[i].getWidth());
                            layout.setHeight(alphaArray[i].getHeight());
                            w1.setRenderingHint(JAI.KEY_IMAGE_LAYOUT, layout);
                            w1.translate(0f, 0f, null);
                            // Mask Alpha
                            w.mask(w1.getRenderedImage(), false, 0);
                        }
                    }
                    double fillValue = CoverageUtilities.getBackgroundValues(coverage)[0];
                    backgrounds[i] = fillValue;
                    // Get NoData as property if present
                    NoDataContainer noDataProperty = CoverageUtilities.getNoDataProperty(coverage);
                    hasNoDataProp |= noDataProperty != null;
                } else {
                    // New GridGeometry
                    GridGeometry2D newGG =
                            new GridGeometry2D(
                                    PixelInCell.CELL_CORNER,
                                    g2w,
                                    inputGG.getEnvelope(),
                                    GeoTools.getDefaultHints());
                    try {
                        // Transformation of the input envelope in the Raster Space
                        GeneralEnvelope transformed =
                                CRS.transform(g2w.inverse(), inputGG.getEnvelope());
                        // Rounding of the bounds
                        Rectangle rect = transformed.toRectangle2D().getBounds();
                        // Creation of a new GridEnvelope to set for the new GridGeometry
                        GridEnvelope2D gEnv2 = new GridEnvelope2D(rect);
                        // Creation of the new GridGeometry
                        newGG = new GridGeometry2D(gEnv2, inputGG.getEnvelope());
                    } catch (InvalidGridGeometryException e) {
                        throw new CoverageProcessingException(e);
                    } catch (NoninvertibleTransformException e) {
                        throw new CoverageProcessingException(e);
                    } catch (TransformException e) {
                        throw new CoverageProcessingException(e);
                    }
                    // Initialization of the nodata value
                    double[] fillValue = null;
                    // Selection of the nodata value
                    if (nodata == null) {
                        fillValue = CoverageUtilities.getBackgroundValues(coverage);
                    } else {
                        fillValue = nodata;
                    }

                    if (newGG.equals(coverage.getGridGeometry())) {
                        rasters[i] = coverage.getRenderedImage();
                        if (hasAlpha && alphas[i] != null) {
                            alphaArray[i] =
                                    PlanarImage.wrapRenderedImage(alphas[i].getRenderedImage());
                        }
                    } else {
                        rasters[i] =
                                GridCoverage2DRIA.create(
                                        coverage,
                                        newGG,
                                        fillValue,
                                        hints,
                                        CoverageUtilities.getROIProperty(coverage));
                        // Resample also the alpha band
                        if (hasAlpha && alphas[i] != null) {
                            checkAlpha(coverage, alphas[i]);
                            RenderedImage al =
                                    GridCoverage2DRIA.create(
                                            alphas[i],
                                            newGG,
                                            new double[1],
                                            hints,
                                            CoverageUtilities.getROIProperty(coverage));
                            alphaArray[i] = PlanarImage.wrapRenderedImage(al);
                        }
                    }

                    backgrounds[i] = fillValue[0];
                    // Resample to the new resolution
                    ROI roi;
                    if (rasters[i] instanceof GridCoverage2DRIA) {
                        GridCoverage2DRIA.GridCoverage2DRIAPropertyGenerator propertyGenerator =
                                new GridCoverage2DRIA.GridCoverage2DRIAPropertyGenerator();
                        Object property = propertyGenerator.getProperty("roi", rasters[i]);
                        roi = (property != null && property instanceof ROI) ? (ROI) property : null;
                    } else {
                        Object property = rasters[i].getProperty("roi");
                        roi = (property != null && property instanceof ROI) ? (ROI) property : null;
                    }
                    rois[i] = roi;
                    // Get NoData as property if present
                    NoDataContainer noDataProperty = CoverageUtilities.getNoDataProperty(coverage);
                    hasNoDataProp |= noDataProperty != null;
                }
            }

            // Create the final object containing the final GridGeometry and the resampled
            // RenderedImages
            ResampledRasters rr = new ResampledRasters();
            rr.setFinalGeometry(external);
            rr.setRasters(rasters);
            rr.setAlphas(alphaArray);
            rr.setBackgrounds(backgrounds);
            rr.setRois(rois);
            rr.setHasNoData(hasNoDataProp);
            return rr;
        }

