    /**
     * Writes outs the image contained into this {@link ImageWorker} as a JPEG using the provided
     * destination , compression and compression rate.
     *
     * <p>The destination object can be anything providing that we have an {@link
     * ImageOutputStreamSpi} that recognizes it.
     *
     * @param destination where to write the internal {@link #image} as a JPEG.
     * @param compression algorithm.
     * @param compressionRate percentage of compression.
     * @param nativeAcc should we use native acceleration.
     * @return this {@link ImageWorker}.
     * @throws IOException In case an error occurs during the search for an {@link
     *     ImageOutputStream} or during the eoncding process.
     */
    public final void writeJPEG(
            final Object destination,
            final String compression,
            final float compressionRate,
            final boolean nativeAcc)
            throws IOException {
        // Reformatting this image for jpeg.
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Encoding input image to write out as JPEG.");
        }

        // go to component color model if needed
        ColorModel cm = image.getColorModel();
        final boolean hasAlpha = cm.hasAlpha();
        forceComponentColorModel();
        cm = image.getColorModel();

        // rescale to 8 bit
        rescaleToBytes();
        cm = image.getColorModel();

        // remove transparent band
        final int numBands = image.getSampleModel().getNumBands();
        if (hasAlpha) {
            retainBands(numBands - 1);
        }

        // Getting a writer.
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Getting a JPEG writer and configuring it.");
        }
        ImageWriter writer = null;
        if (nativeAcc && CODEC_LIB_AVAILABLE && IMAGEIO_JPEG_IMAGE_WRITER_SPI != null) {
            try {
                writer = IMAGEIO_JPEG_IMAGE_WRITER_SPI.createWriterInstance();
            } catch (Exception e) {
                if (LOGGER.isLoggable(Level.INFO)) {
                    LOGGER.log(Level.INFO, "Unable to instantiate CLIB JPEG ImageWriter", e);
                }
                writer = null;
            }
        }
        // in case we want the JDK one or in case the native one is not at hand we use the JDK one
        if (writer == null) {
            if (JDK_JPEG_IMAGE_WRITER_SPI == null) {
                throw new IllegalStateException(
                        Errors.format(
                                ErrorKeys.ILLEGAL_CLASS_$2, "Unable to find JDK JPEG Writer"));
            }
            writer = JDK_JPEG_IMAGE_WRITER_SPI.createWriterInstance();
        }

        // Compression is available on both lib
        final ImageWriteParam iwp = writer.getDefaultWriteParam();
        final ImageOutputStream outStream = ImageIOExt.createImageOutputStream(image, destination);
        if (outStream == null) {
            throw new IIOException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, "stream"));
        }

        iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
        iwp.setCompressionType(compression); // Lossy compression.
        iwp.setCompressionQuality(compressionRate); // We can control quality here.
        if (iwp instanceof JPEGImageWriteParam) {
            final JPEGImageWriteParam param = (JPEGImageWriteParam) iwp;
            param.setOptimizeHuffmanTables(true);
            try {
                param.setProgressiveMode(JPEGImageWriteParam.MODE_DEFAULT);
            } catch (UnsupportedOperationException e) {
                throw new IOException(e);
            }
        }

        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Writing out...");
        }

        try {

            writer.setOutput(outStream);
            // the JDK writer has problems with images that do not start at minx==miny==0
            // while the clib writer has issues with tiled images
            if ((!nativeAcc && (image.getMinX() != 0 || image.getMinY() != 0))
                    || (nativeAcc && (image.getNumXTiles() > 1 || image.getNumYTiles() > 1))) {
                final BufferedImage finalImage =
                        new BufferedImage(
                                image.getColorModel(),
                                ((WritableRaster) image.getData())
                                        .createWritableTranslatedChild(0, 0),
                                image.getColorModel().isAlphaPremultiplied(),
                                null);

                writer.write(null, new IIOImage(finalImage, null, null), iwp);
            } else {
                writer.write(null, new IIOImage(image, null, null), iwp);
            }
        } finally {
            try {
                writer.dispose();
            } catch (Throwable e) {
                if (LOGGER.isLoggable(Level.FINEST))
                    LOGGER.log(Level.FINEST, e.getLocalizedMessage(), e);
            }
            try {
                outStream.close();
            } catch (Throwable e) {
                if (LOGGER.isLoggable(Level.FINEST))
                    LOGGER.log(Level.FINEST, e.getLocalizedMessage(), e);
            }
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Writing out... Done!");
            }
        }
    }

