	/**
	 * Interpolates at the specified position. If {@code fallback!=null},
	 * then {@code dest} <strong>must</strong> have been initialized with
	 * {@code super.evaluate(...)} prior to invoking this method.
	 *
	 * @param x      The x position in pixel's coordinates.
	 * @param y      The y position in pixel's coordinates.
	 * @param dest   The destination array, or null.
	 * @param band   The first band's index to interpolate.
	 * @param bandUp The last band's index+1 to interpolate.
	 * @return {@code null} if point is outside grid coverage.
	 */
	private synchronized int[] interpolate(final double x, final double y,
	                                       int[] dest, int band, final int bandUp)
	{
	    final double x0 = Math.floor(x);
	    final double y0 = Math.floor(y);
	    final int    ix = (int)x0;
	    final int    iy = (int)y0;
	    if (!(ix>=xmin && ix<xmax && iy>=ymin && iy<ymax)) 
	    	return null;
	    /*
	     * Creates buffers, if not already created.
	     */
	    int[][] samples = ints;
	    if (samples == null) {
	        final int rowCount = interpolation.getHeight();
	        final int colCount = interpolation.getWidth();
	        ints = samples = new int[rowCount][];
	        for (int i=0; i<rowCount; i++) {
	            samples[i] = new int[colCount];
	        }
	    }
	    if (dest == null) {
	        dest = new int[bandUp];
	    }
	       // ROI Check
            if (hasROI && !roiBounds.contains(ix, iy) && !roi.contains(ix, iy)) {
                // Outside the ROI. fill it with background values
                Arrays.fill(dest, (int)background);
                return dest;
            }
	    /*
	     * Builds up a RectIter and use it for interpolating all bands.
	     * There is very few points, so the cost of creating a RectIter
	     * may be important. But it seems to still lower than query tiles
	     * many time (which may involve more computation than necessary).
	     */
	    bounds.x = ix - left;
	    bounds.y = iy - top;
	    final RectIter iter = RectIterFactory.create(image.getExtendedData(bounds, this.borderExtender), bounds);
	    boolean[][] gaps = hasNoData ? new boolean[samples.length][samples[0].length] : null;
	    for (; band<bandUp; band++) {
	        iter.startLines();
	        int j=0; do {
	            iter.startPixels();
	            final boolean[] nodLine=hasNoData ? gaps[j] : null;
	            final int[] row=samples[j++];
	            int i=0; do {
	                int sample = iter.getSample(band);
                        // NoData Check
                        if(hasNoData && !nodata.contains(sample)){
                            nodLine[i] = true;
                        }
                        row[i++] = sample;
	            }
	            while (!iter.nextPixelDone());
	            assert i==row.length;
	        }
	        while (!iter.nextLineDone());
	        assert j == samples.length;
	               // If has NoData the gas must be filled
                boolean result = fixNoData(samples, gaps);
                if (!result) {
                    // Totally nodata. fill it with background values
                    Arrays.fill(dest, (int)background);
                    return dest;
                }
	        final int xfrac = (int) ((x-x0) * (1 << interpolation.getSubsampleBitsH()));
	        final int yfrac = (int) ((y-y0) * (1 << interpolation.getSubsampleBitsV()));
	        dest[band] = interpolation.interpolate(samples, xfrac, yfrac);
	    }
	    return dest;
	}

