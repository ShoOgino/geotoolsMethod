    /**
     * A tile is about to be updated (it is either about to be grabbed for writing,
     * or it is being released from writing).
     */
    private void fireTileUpdate(final int tileX, final int tileY, final boolean willBeWritable) {
        final TileObserver[] observers = this.observers; // Avoid the need for synchronisation.
        if (observers != null) {
            final int length = observers.length;
            for (int i=0; i<length; i++) {
                try {
                    observers[i].tileUpdate(this, tileX, tileY, willBeWritable);
                } catch (final RuntimeException cause) {
                    /*
                     * An exception occured in the user code. Unfortunatly, we are probably not in
                     * the mean user thread (e.g. the Swing thread).  This method is often invoked
                     * from some JAI's worker thread, which we don't want to corrupt. Log a warning
                     * for the user and lets the JAI's worker thread continue its work.
                     */
                    String message = cause.getLocalizedMessage();
                    if (message == null) {
                        message = Classes.getShortClassName(cause);
                    }
                    final LogRecord record = new LogRecord(Level.WARNING, message);
                    record.setSourceClassName(observers[i].getClass().getName());
                    record.setSourceMethodName("tileUpdate");
                    record.setThrown(cause);
                    record.setLoggerName(LOGGER.getName());
                    LOGGER.log(record);
                }
            }
        }
    }

