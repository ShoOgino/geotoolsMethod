    /**
     * Creates a set of sample dimensions for the data backing the given iterator.
     *
     * @param name The name for data (e.g. "Elevation").
     * @param iterator The iterator through the raster data, or {@code null}.
     * @param model The image or raster sample model.
     * @param min The minimal value, or {@code null} for computing it automatically.
     * @param max The maximal value, or {@code null} for computing it automatically.
     * @param units The units of sample values, or {@code null} if unknow.
     * @param colors The colors to use for values from {@code min} to {@code max} for each bands, or
     *     {@code null} for a default color palette. If non-null, each arrays {@code colors[b]} may
     *     have any length; colors will be interpolated as needed.
     * @param dst The array where to store sample dimensions. The array length must matches the
     *     number of bands.
     * @param hints An optional set of rendering hints, or {@code null} if none. Those hints will
     *     not affect the sample dimensions to be created. The optional hint {@link
     *     Hints#SAMPLE_DIMENSION_TYPE} specifies the {@link SampleDimensionType} to be used at
     *     rendering time, which can be one of {@link SampleDimensionType#UBYTE UBYTE} or {@link
     *     SampleDimensionType#USHORT USHORT}.
     */
    private static void create(
            final CharSequence name,
            final RectIter iterator,
            final SampleModel model,
            double[] min,
            double[] max,
            final Unit<?> units,
            final Color[][] colors,
            final GridSampleDimension[] dst,
            final RenderingHints hints) {
        final int numBands = dst.length;
        if (min != null && min.length != numBands) {
            throw new IllegalArgumentException(
                    Errors.format(
                            ErrorKeys.NUMBER_OF_BANDS_MISMATCH_$3, numBands, min.length, "min[i]"));
        }
        if (max != null && max.length != numBands) {
            throw new IllegalArgumentException(
                    Errors.format(
                            ErrorKeys.NUMBER_OF_BANDS_MISMATCH_$3, numBands, max.length, "max[i]"));
        }
        if (colors != null && colors.length != numBands) {
            throw new IllegalArgumentException(
                    Errors.format(
                            ErrorKeys.NUMBER_OF_BANDS_MISMATCH_$3,
                            numBands,
                            colors.length,
                            "colors[i]"));
        }
        /*
         * Arguments are know to be valids. We now need to compute two ranges:
         *
         * STEP 1: Range of target (sample) values. This is computed in the following block.
         * STEP 2: Range of source (geophysics) values. It will be computed one block later.
         *
         * The target (sample) values will typically range from 0 to 255 or 0 to 65535, but the
         * general case is handled as well. If the source raster uses floating point
         * numbers, then a "nodata" category may be added in order to handle NaN values. If the
         * source raster use integer numbers instead, then we will rescale samples only if they
         * would not fit in the target data type.
         */
        final SampleDimensionType sourceType = TypeMap.getSampleDimensionType(model, 0);
        SampleDimensionType targetType = null;
        if (hints != null) {
            targetType = (SampleDimensionType) hints.get(Hints.SAMPLE_DIMENSION_TYPE);
        }
        if (targetType == null) {
            // Default to TYPE_BYTE for floating point images only; otherwise keep unchanged.
            targetType = sourceType;
        }
        // Default setting: no scaling
        NumberRange targetRange = TypeMap.getRange(targetType);
        Category[] categories = new Category[1];
        /*
         * Now, constructs the sample dimensions. We will inconditionnaly provides a "nodata"
         * category for floating point images targeting unsigned integers, since we don't know
         * if the user plan to have NaN values. Even if the current image doesn't have NaN values,
         * it could have NaN later if the image uses a writable raster.
         */
        final InternationalString n = SimpleInternationalString.wrap(name);
        for (int b = 0; b < numBands; b++) {
            final Color[] c = colors != null ? colors[b] : null;
            categories[0] = new Category(n, c, targetRange, true);
            dst[b] = new GridSampleDimension(name, categories, units);
        }
    }

