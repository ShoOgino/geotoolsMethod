    /**
     * Creates a set of sample dimensions for the data backing the given iterator.
     *
     * @param  name The name for data (e.g. "Elevation").
     * @param  iterator The iterator through the raster data, or {@code null}.
     * @param  model The image or raster sample model.
     * @param  min The minimal value, or {@code null} for computing it automatically.
     * @param  max The maximal value, or {@code null} for computing it automatically.
     * @param  units The units of sample values, or {@code null} if unknow.
     * @param  colors The colors to use for values from {@code min} to {@code max} for each bands,
     *         or {@code null} for a default color palette. If non-null, each arrays
     *         {@code colors[b]} may have any length; colors will be interpolated as needed.
     * @param  dst The array where to store sample dimensions. The array length must matches
     *         the number of bands.
     * @param  hints An optional set of rendering hints, or {@code null} if none.
     *         Those hints will not affect the sample dimensions to be created. However,
     *         they may affect the sample dimensions to be returned by
     *         <code>{@link #geophysics geophysics}(false)</code>, i.e.
     *         the view to be used at rendering time. The optional hint
     *         {@link Hints#SAMPLE_DIMENSION_TYPE} specifies the {@link SampleDimensionType}
     *         to be used at rendering time, which can be one of
     *         {@link SampleDimensionType#UBYTE UBYTE} or
     *         {@link SampleDimensionType#USHORT USHORT}.
     */
    private static void create(final CharSequence          name,
                               final RectIter              iterator,
                               final SampleModel           model,
                               double[]                    min,
                               double[]                    max,
                               final Unit<?>               units,
                               final Color[][]             colors,
                               final GridSampleDimension[] dst,
                               final RenderingHints        hints)
    {
        final int numBands = dst.length;
        if (min!=null && min.length != numBands) {
            throw new IllegalArgumentException(Errors.format(ErrorKeys.NUMBER_OF_BANDS_MISMATCH_$3,
                      numBands, min.length, "min[i]"));
        }
        if (max!=null && max.length != numBands) {
            throw new IllegalArgumentException(Errors.format(ErrorKeys.NUMBER_OF_BANDS_MISMATCH_$3,
                      numBands, max.length, "max[i]"));
        }
        if (colors!=null && colors.length != numBands) {
            throw new IllegalArgumentException(Errors.format(ErrorKeys.NUMBER_OF_BANDS_MISMATCH_$3,
                      numBands, colors.length, "colors[i]"));
        }
        /*
         * Arguments are know to be valids. We now need to compute two ranges:
         *
         * STEP 1: Range of target (sample) values. This is computed in the following block.
         * STEP 2: Range of source (geophysics) values. It will be computed one block later.
         *
         * The target (sample) values will typically range from 0 to 255 or 0 to 65535, but the
         * general case is handled as well. If the source (geophysics) raster uses floating point
         * numbers, then a "nodata" category may be added in order to handle NaN values. If the
         * source raster use integer numbers instead, then we will rescale samples only if they
         * would not fit in the target data type.
         */
        final SampleDimensionType sourceType = TypeMap.getSampleDimensionType(model, 0);
        final boolean          sourceIsFloat = TypeMap.isFloatingPoint(sourceType);
        SampleDimensionType targetType = null;
        if (hints != null) {
            targetType = (SampleDimensionType) hints.get(Hints.SAMPLE_DIMENSION_TYPE);
        }
        if (targetType == null) {
            // Default to TYPE_BYTE for floating point images only; otherwise keep unchanged.
            targetType = sourceIsFloat ? SampleDimensionType.UNSIGNED_8BITS : sourceType;
        }
        // Default setting: no scaling
        final boolean targetIsFloat = TypeMap.isFloatingPoint(targetType);
        NumberRange   targetRange   = TypeMap.getRange(targetType);
        Category[]    categories    = new Category[1];
        final boolean needScaling;
        if (targetIsFloat) {
            // Never rescale if the target is floating point numbers.
            needScaling = false;
        } else if (sourceIsFloat) {
            // Always rescale for "float to integer" conversions. In addition,
            // Use 0 value as a "no data" category for unsigned data type only.
            needScaling = true;
            if (!TypeMap.isSigned(targetType)) {
                categories    = new Category[2];
                categories[1] = Category.NODATA;
                targetRange   = TypeMap.getPositiveRange(targetType);
            }
        } else {
            // In "integer to integer" conversions, rescale only if
            // the target range is smaller than the source range.
            needScaling = !targetRange.contains(TypeMap.getRange(sourceType));
        }
        /*
         * Computes the minimal and maximal values, if not explicitely provided.
         * This information is required for determining the range of geophysics
         * values.
         */
        if (needScaling && (min==null || max==null)) {
            final boolean computeMin;
            final boolean computeMax;
            if (computeMin = (min == null)) {
                min = new double[numBands];
                Arrays.fill(min, Double.POSITIVE_INFINITY);
            }
            if (computeMax = (max == null)) {
                max = new double[numBands];
                Arrays.fill(max, Double.NEGATIVE_INFINITY);
            }
            int b = 0;
            iterator.startBands();
            if (!iterator.finishedBands()) do {
                iterator.startLines();
                if (!iterator.finishedLines()) do {
                    iterator.startPixels();
                    if (!iterator.finishedPixels()) do {
                        final double z = iterator.getSampleDouble();
                        if (computeMin && z<min[b]) min[b]=z;
                        if (computeMax && z>max[b]) max[b]=z;
                    } while (!iterator.nextPixelDone());
                } while (!iterator.nextLineDone());
                if (computeMin && computeMax) {
                    if (!(min[b] < max[b])) {
                        min[b] = 0;
                        max[b] = 1;
                    }
                }
                b++;
            } while (!iterator.nextBandDone());
        }
        /*
         * Now, constructs the sample dimensions. We will inconditionnaly provides a "nodata"
         * category for floating point images targeting unsigned integers, since we don't know
         * if the user plan to have NaN values. Even if the current image doesn't have NaN values,
         * it could have NaN later if the image uses a writable raster.
         */
        final InternationalString n = SimpleInternationalString.wrap(name);
        NumberRange sourceRange = TypeMap.getRange(sourceType);
        for (int b=0; b<numBands; b++) {
            final Color[] c = colors!=null ? colors[b] : null;
            if (needScaling) {
                sourceRange = NumberRange.create(min[b], max[b]).castTo(sourceRange.getElementClass());
                categories[0] = new Category(n, c, targetRange, sourceRange);
            } else {
                categories[0] = new Category(n, c, targetRange, LinearTransform1D.IDENTITY);
            }
            dst[b] = new GridSampleDimension(name,categories, units).geophysics(true);
        }
    }

