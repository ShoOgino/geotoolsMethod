    /**
     * Invoked by {@link #create} when a photographic view needs to be created. This method
     * reformats the {@linkplain ColorModel color model} to a {@linkplain ComponentColorModel
     * component color model} preserving transparency. The new color model is typically backed
     * by an RGB {@linkplain ColorSpace color space}, but not necessarly. It could be YMCB as well.
     */
    @SuppressWarnings("fallthrough")
    private static GridCoverage2D photographic(final GridCoverage2D coverage, final Hints userHints) {
        final RenderedImage image = coverage.getRenderedImage();
        final ColorModel cm = image.getColorModel();
        /*
         * If the image already use a component color model (not necessarly backed by
         * RGB color space - it could be CYMB as well), then there is nothing to do.
         */
        if (cm instanceof ComponentColorModel) {
            return coverage;
        }
        final int dataType;
        final ColorSpace cs;
        final LookupTableJAI lookup;
        /*
         * If the color model is indexed. Converts to RGB or gray scale using a single "Lookup"
         * operation. Color space will be RGB or GRAY, and type will be DataBuffer.TYPE_BYTE.
         */
        if (cm instanceof IndexColorModel) {
            final IndexColorModel icm = (IndexColorModel) cm;
            final int mapSize = icm.getMapSize();
            final byte data[][];
            if (ColorUtilities.isGrayPalette(icm, false)) {
                final byte[] gray = new byte[mapSize];
                icm.getGreens(gray);
                if (icm.hasAlpha()) {
                    final byte[] alpha = new byte[mapSize];
                    icm.getAlphas(alpha);
                    data = new byte[][] { gray, alpha };
                } else {
                    data = new byte[][] { gray };
                }
                cs = ColorSpace.getInstance(ColorSpace.CS_GRAY);
            } else {
                data = new byte[cm.getNumComponents()][mapSize];
                switch (data.length) {
                    default: // Should not occurs, but keep as a paranoiac check.
                    case 4:  icm.getAlphas(data[3]);
                    case 3:  icm.getBlues (data[2]);
                    case 2:  icm.getGreens(data[1]);
                    case 1:  icm.getReds  (data[0]);
                    case 0:  break;
                }
                cs = icm.getColorSpace();
            }
            dataType = DataBuffer.TYPE_BYTE;
            lookup = new LookupTableJAI(data);
        } else {
            lookup = null;
            cs = cm.getColorSpace();
            dataType = (cm instanceof DirectColorModel) ? DataBuffer.TYPE_BYTE :
                        image.getSampleModel().getTransferType();
        }
        /*
         * Gets the rendering hints to be given to the image operation.
         */
        final ColorModel  targetCM;
        final SampleModel targetSM;
        targetCM = new ComponentColorModel(cs,
                cm.hasAlpha(),               // If true, supports transparency.
                cm.isAlphaPremultiplied(),   // If true, alpha is premultiplied.
                cm.getTransparency(),        // What alpha values can be represented.
                dataType);                   // Type of primitive array used to represent pixel.
        targetSM = targetCM.createCompatibleSampleModel(image.getWidth(), image.getHeight());
        RenderingHints hints = ImageUtilities.getRenderingHints(image);
        if (hints == null) {
            hints = new RenderingHints(null);
        }
        ImageLayout layout = (ImageLayout) hints.get(JAI.KEY_IMAGE_LAYOUT);
        if (layout == null) {
            layout = new ImageLayout();
        }
        layout.setColorModel (targetCM);
        layout.setSampleModel(targetSM);
        hints.put(JAI.KEY_IMAGE_LAYOUT, layout);
        /*
         * Creates the image, than the coverage.
         */
        final RenderedOp view;
        if (lookup != null) {
            view = LookupDescriptor.create(image, lookup, hints);
        } else {
            view = FormatDescriptor.create(image, dataType, hints);
        }
        assert view.getColorModel() instanceof ComponentColorModel;
        return createView(coverage, view, null, 2, userHints);
    }

