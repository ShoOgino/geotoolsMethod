    /**
     * We have a user defined {@link ProjectedCRS}, let's try to parse it.
     *
     * @param linearUnit is the UoM that this {@link ProjectedCRS} will use. It could be null.
     * @return a user-defined {@link ProjectedCRS}.
     * @throws IOException
     * @throws FactoryException
     */
    private ProjectedCRS createUserDefinedPCS(
            final GeoTiffIIOMetadataDecoder metadata, Unit<?> linearUnit) throws Exception {

        //
        // At the top level a user-defined PCRS is made by
        // <ol>
        // <li>PCSCitationGeoKey (NAME)
        // <li>ProjectionGeoKey
        // <li>GeographicTypeGeoKey
        // </ol>
        //
        //

        //
        // GEOGRAPHIC CRS is the baseCRS for the projection
        //
        final GeographicCRS baseCRS = createGeographicCoordinateReferenceSystem(metadata);

        //
        // NAME of the user defined projected coordinate reference system.
        //
        String pcsCitationGeoKey = metadata.getGeoKey(GeoTiffPCSCodes.PCSCitationGeoKey);
        String projectedCrsName = pcsCitationGeoKey;
        if (projectedCrsName == null) {
            projectedCrsName = "unnamed".intern();
        } else {
            projectedCrsName = cleanName(projectedCrsName);
        }

        //
        // PROJECTION geo key for this projected coordinate reference system.
        // get the projection code for this PCRS to build it from the GCS.
        //
        // In case i is user defined it requires:
        // PCSCitationGeoKey
        // ProjCoordTransGeoKey
        // ProjLinearUnitsGeoKey
        //
        final String projCode = metadata.getGeoKey(GeoTiffPCSCodes.ProjectionGeoKey);
        boolean projUserDefined = false;
        if (projCode == null || projCode.equals(GeoTiffConstants.GTUserDefinedGeoKey_String)) {
            projUserDefined = true;
        }

        // is it user defined?
        final Conversion conversionFromBase;
        String projectionName = null;
        final ParameterValueGroup parameters;
        final MathTransform transform;
        if (projUserDefined) {
            String citationName = metadata.getGeoKey(GeoTiffGCSCodes.GTCitationGeoKey);
            if ((projectedCrsName == null || "unnamed".equalsIgnoreCase(projectedCrsName))
                    && citationName != null) {
                // Fallback on GTCitation
                projectedCrsName = citationName;
            }
            // A user defined projection is made up by
            // <ol>
            // <li>PCSCitationGeoKey (NAME)
            // <li>ProjCoordTransGeoKey
            // <li>ProjLinearUnitsGeoKey
            // </ol>
            // NAME of this projection coordinate transformation
            // getting user defined parameters
            projectionName = pcsCitationGeoKey;
            if (projectionName == null) {
                // Fall back on citation
                projectionName = citationName != null ? citationName : "unnamed";
            }

            // //
            //
            // getting default parameters for this projection and filling them
            // with the values found
            // inside the geokeys list.
            //
            // //
            parameters = createUserDefinedProjectionParameter(projectionName, metadata);
            if (parameters == null) {
                throw new GeoTiffException(
                        metadata,
                        "GeoTiffMetadata2CRSAdapter::createUserDefinedPCS:Projection is not supported.",
                        null);
            }
            // set the remaining parameters.
            refineParameters(baseCRS, parameters);

            // create math transform
            transform = mtFactory.createParameterizedTransform(parameters);

            // create the conversion from base, aka the projection transform
            conversionFromBase =
                    new DefiningConversion(
                            Collections.singletonMap("name", cleanName(projectionName)),
                            new DefaultOperationMethod(transform),
                            transform);
        } else {
            // create the conversion from EPSG code
            conversionFromBase =
                    (Conversion)
                            this.allAuthoritiesFactory.createCoordinateOperation(
                                    new StringBuilder("EPSG:").append(projCode).toString());

            // prepare the parameters
            parameters = conversionFromBase.getParameterValues();

            refineParameters(baseCRS, parameters);

            // create math transform
            transform = mtFactory.createParameterizedTransform(parameters);
        }

        //
        // PROJECTED CRS
        //
        // //
        //
        // I am putting particular attention on the management of the unit
        // of measure since it seems that very often people change the unit
        // of measure to feet even if the standard UoM for the request
        // projection is M.
        //
        // ///
        if (projUserDefined) {

            // user defined projection

            // standard unit of measure
            if (linearUnit != null && linearUnit.equals(SI.METRE)) {
                return new DefaultProjectedCRS(
                        java.util.Collections.singletonMap("name", projectedCrsName),
                        conversionFromBase,
                        baseCRS,
                        transform,
                        DefaultCartesianCS.PROJECTED);
            }

            // unit of measure is not standard
            return new DefaultProjectedCRS(
                    java.util.Collections.singletonMap("name", projectedCrsName),
                    conversionFromBase,
                    baseCRS,
                    transform,
                    DefaultCartesianCS.PROJECTED.usingUnit(linearUnit));
        }

        // standard projection
        if (linearUnit != null && !linearUnit.equals(SI.METRE)) {
            return new DefaultProjectedCRS(
                    Collections.singletonMap("name", projectedCrsName),
                    conversionFromBase,
                    baseCRS,
                    transform,
                    DefaultCartesianCS.PROJECTED.usingUnit(linearUnit));
        }
        return new DefaultProjectedCRS(
                Collections.singletonMap("name", projectedCrsName),
                conversionFromBase,
                baseCRS,
                transform,
                DefaultCartesianCS.PROJECTED);
    }

