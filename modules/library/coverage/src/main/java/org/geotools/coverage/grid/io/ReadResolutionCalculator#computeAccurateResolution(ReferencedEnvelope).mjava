    /**
     * Compute the resolutions through a more accurate logic: Compute the resolution in 9 points,
     * the corners of the requested area and the middle points and take the better one. This will
     * provide better results for cases where there is a lot more deformation on a subregion
     * (top/bottom/sides) of the requested bbox with respect to others.
     * 
     * @return
     * @throws TransformException
     * @throws NoninvertibleTransformException
     * @throws FactoryException
     */
    private double[] computeAccurateResolution(ReferencedEnvelope readBBox)
            throws TransformException, NoninvertibleTransformException, FactoryException {
        if (!CRS.equalsIgnoreMetadata(readBBox.getCoordinateReferenceSystem(),
                requestedBBox.getCoordinateReferenceSystem())) {
            readBBox = readBBox.transform(requestedBBox.getCoordinateReferenceSystem(), true);
        }
        double resX = XAffineTransform.getScaleX0(requestedGridToWorld);
        double resY = XAffineTransform.getScaleY0(requestedGridToWorld);
        GeneralEnvelope cropBboxTarget = CRS.transform(readBBox,
                requestedBBox.getCoordinateReferenceSystem());
        final int NPOINTS = 36;
        double[] points = new double[NPOINTS * 2];
        for (int i = 0; i < 3; i++) {
            double x;
            if (i == 0) {
                x = cropBboxTarget.getMinimum(0) + resX / 2;
            } else if (i == 1) {
                x = cropBboxTarget.getMedian(0);
            } else {
                x = cropBboxTarget.getMaximum(0) - resX / 2;
            }
            for (int j = 0; j < 3; j++) {
                double y;
                if (j == 0) {
                    y = cropBboxTarget.getMinimum(1) + resY / 2;
                } else if (j == 1) {
                    y = cropBboxTarget.getMedian(1);
                } else {
                    y = cropBboxTarget.getMaximum(1) - resY / 2;
                }

                int k = (i * 3 + j) * 8;
                points[k] = x - resX / 2;
                points[k + 1] = y;
                points[k + 2] = x + resX / 2;
                points[k + 3] = y;
                points[k + 4] = x;
                points[k + 5] = y - resY / 2;
                points[k + 6] = x;
                points[k + 7] = y + resY / 2;
            }
        }
        destinationToSourceTransform.transform(points, 0, points, 0, NPOINTS);

        double minDistance = Double.MAX_VALUE;
        for (int i = 0; i < points.length && minDistance > 0; i += 4) {
            double dx = points[i + 2] - points[i];
            double dy = points[i + 3] - points[i + 1];
            double d = Math.sqrt(dx * dx + dy * dy);
            if (d < minDistance) {
                minDistance = d;
            } 
        }

        // reprojection can turn a segment into a zero lenght one, in that case, fall back on
        // the full resolution in that case
        double minDistanceX = Math.max(minDistance, fullResolution[0]);
        double minDistanceY = Math.max(minDistance, fullResolution[1]);
        return new double[] {minDistanceX, minDistanceY};
    }

