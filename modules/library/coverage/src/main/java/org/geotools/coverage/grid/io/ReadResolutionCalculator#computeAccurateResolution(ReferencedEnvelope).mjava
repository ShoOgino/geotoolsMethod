    /**
     * Compute the resolutions through a more accurate logic: Compute the resolution in 9 points,
     * the corners of the requested area and the middle points and take the better one. This will
     * provide better results for cases where there is a lot more deformation on a subregion
     * (top/bottom/sides) of the requested bbox with respect to others.
     *
     * @return
     * @throws TransformException
     * @throws NoninvertibleTransformException
     * @throws FactoryException
     */
    private double[] computeAccurateResolution(ReferencedEnvelope readBBox)
            throws TransformException, NoninvertibleTransformException, FactoryException {
        final boolean isReprojected =
                !CRS.equalsIgnoreMetadata(
                        readBBox.getCoordinateReferenceSystem(),
                        requestedBBox.getCoordinateReferenceSystem());
        if (isReprojected) {
            readBBox = readBBox.transform(requestedBBox.getCoordinateReferenceSystem(), true);
        }
        double resX = XAffineTransform.getScaleX0(requestedGridToWorld);
        double resY = XAffineTransform.getScaleY0(requestedGridToWorld);
        GeneralEnvelope cropBboxTarget =
                CRS.transform(readBBox, requestedBBox.getCoordinateReferenceSystem());
        final int NPOINTS = 36;
        double[] points = new double[NPOINTS * 2];
        for (int i = 0; i < 3; i++) {
            double x;
            if (i == 0) {
                x = cropBboxTarget.getMinimum(0) + resX / 2;
            } else if (i == 1) {
                x = cropBboxTarget.getMedian(0);
            } else {
                x = cropBboxTarget.getMaximum(0) - resX / 2;
            }
            for (int j = 0; j < 3; j++) {
                double y;
                if (j == 0) {
                    y = cropBboxTarget.getMinimum(1) + resY / 2;
                } else if (j == 1) {
                    y = cropBboxTarget.getMedian(1);
                } else {
                    y = cropBboxTarget.getMaximum(1) - resY / 2;
                }

                int k = (i * 3 + j) * 8;
                points[k] = x - resX / 2;
                points[k + 1] = y;
                points[k + 2] = x + resX / 2;
                points[k + 3] = y;
                points[k + 4] = x;
                points[k + 5] = y - resY / 2;
                points[k + 6] = x;
                points[k + 7] = y + resY / 2;
            }
        }
        destinationToSourceTransform.transform(points, 0, points, 0, NPOINTS);

        double minDistance = Double.MAX_VALUE;
        for (int i = 0; i < points.length && minDistance > 0; i += 4) {
            double dx = points[i + 2] - points[i];
            double dy = points[i + 3] - points[i + 1];
            double d = Math.sqrt(dx * dx + dy * dy);
            if (d < minDistance) {
                minDistance = d;
            }
        }

        // reprojection can turn a segment into a zero length one
        double fullRes[] = new double[] {fullResolution[0], fullResolution[1]};
        if (isReprojected && isFullResolutionInRequestedCRS) {
            // Create a full resolution's one pixel bbox and reproject it to
            // retrieve full resolution in read CRS
            double x0 = requestedBBox.getMedian(0);
            double y0 = requestedBBox.getMedian(1);
            double x1 = x0 + fullRes[0];
            double y1 = y0 + fullRes[1];
            GeneralEnvelope envelope =
                    new GeneralEnvelope(new double[] {x0, y0}, new double[] {x1, y1});
            envelope = CRS.transform(destinationToSourceTransform, envelope);
            GridToEnvelopeMapper mapper =
                    new GridToEnvelopeMapper(new GridEnvelope2D(0, 0, 1, 1), envelope);
            AffineTransform transform = mapper.createAffineTransform();
            fullRes[0] = XAffineTransform.getScaleX0(transform);
            fullRes[1] = XAffineTransform.getScaleY0(transform);
        }
        // fall back on the full resolution when zero length
        double minDistanceX = Math.max(fullRes[0] / maxOversamplingFactor, minDistance);
        double minDistanceY = Math.max(fullRes[1] / maxOversamplingFactor, minDistance);
        return new double[] {minDistanceX, minDistanceY};
    }

