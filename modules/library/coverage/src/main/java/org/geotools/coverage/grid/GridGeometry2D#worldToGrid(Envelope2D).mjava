    /**
     * Transforms a rectangle represented by an Envelope2D object from world
     * to grid coordinates. If the envelope contains a {@code CoordinateReferenceSystem},
     * it <b>must</b> be the same as that of this coverage, otherwise an exception
     * is thrown.
     * <p>
     * The {@code GridEnvelope2D} returned contains the range of cells whose centers
     * lie inside the input {@code Envelope2D}
     * <p>
     * Users needing more control over the nature of the conversion can access
     * the {@linkplain MathsTransform} provided by
     * {@linkplain GridGeometry2D#getCRSToGrid2D(PixelOrientation)}
     * which is accessed via {@linkplain #getGridGeometry()}.
     *
     * @param  env The envelope in world coordinate system.
     * @return The corresponding rectangle in the grid coordinate system as a new
     *         {@code GridEnvelope2D} object
     *
     * @throws IllegalArgumentException if the coordinate reference system of the
     *         envelope is not {@code null} and does not match that of the coverage
     *
     * @throws InvalidGridGeometryException if a two-dimensional inverse
     *         transform is not available for this grid geometry.
     *
     * @throws TransformException if the transformation failed.
     *
     * @since 2.6
     */
    public final GridEnvelope2D worldToGrid(final Envelope2D envelope)
            throws TransformException, InvalidGridGeometryException {

        // get the upper left corner transform (this is cached by the
        // GridGeometry2D object)
        MathTransform2D mt = getCRSToGrid2D(PixelOrientation.UPPER_LEFT);

        CoordinateReferenceSystem sourceCRS = envelope.getCoordinateReferenceSystem();
        if (sourceCRS != null) {
            CoordinateReferenceSystem targetCRS = getCoordinateReferenceSystem();
            if (!CRS.equalsIgnoreMetadata(sourceCRS, targetCRS)) {
                throw new IllegalArgumentException(
                        Errors.format(ErrorKeys.ILLEGAL_COORDINATE_SYSTEM_FOR_CRS_$2,
                                      sourceCRS, targetCRS));
            }
        }

        Point2D lc = toPoint2D(envelope.getLowerCorner());
        Point lcGrid = new Point();
        mt.transform(lc, lcGrid);

        Point2D uc = toPoint2D(envelope.getUpperCorner());
        Point ucGrid = new Point();
        mt.transform(uc, ucGrid);

        GridEnvelope2D gridEnv = new GridEnvelope2D(
                Math.min(lcGrid.x, ucGrid.x),
                Math.min(lcGrid.y, ucGrid.y),
                Math.abs(lcGrid.x - ucGrid.x),
                Math.abs(lcGrid.y - ucGrid.y));

        return gridEnv;
    }

