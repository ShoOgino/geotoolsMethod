    /**
     * Transforms a rectangle represented by an Envelope2D object from world to grid coordinates. If
     * the envelope contains a {@code CoordinateReferenceSystem}, it <b>must</b> be the same as that
     * of this coverage, otherwise an exception is thrown.
     *
     * <p>The {@code GridEnvelope2D} returned contains the range of cells whose centers lie inside
     * the input {@code Envelope2D}
     *
     * <p>Users needing more control over the nature of the conversion can access the {@linkplain
     * MathsTransform} provided by {@linkplain GridGeometry2D#getCRSToGrid2D(PixelOrientation)}
     * which is accessed via {@linkplain #getGridGeometry()}.
     *
     * @param envelope The envelope in world coordinate system.
     * @return The corresponding rectangle in the grid coordinate system as a new {@code
     *     GridEnvelope2D} object
     * @throws IllegalArgumentException if the coordinate reference system of the envelope is not
     *     {@code null} and does not match that of the coverage
     * @throws InvalidGridGeometryException if a two-dimensional inverse transform is not available
     *     for this grid geometry.
     * @throws TransformException if the transformation failed.
     * @since 2.6
     */
    public final GridEnvelope2D worldToGrid(final Envelope2D envelope)
            throws TransformException, InvalidGridGeometryException {

        // get the upper left corner transform (this is cached by the
        // GridGeometry2D object)
        MathTransform2D mt = getCRSToGrid2D(PixelOrientation.UPPER_LEFT);

        CoordinateReferenceSystem sourceCRS = envelope.getCoordinateReferenceSystem();
        if (sourceCRS != null) {
            CoordinateReferenceSystem targetCRS = getCoordinateReferenceSystem();
            if (!CRS.equalsIgnoreMetadata(sourceCRS, targetCRS)) {
                throw new IllegalArgumentException(
                        Errors.format(
                                ErrorKeys.ILLEGAL_COORDINATE_SYSTEM_FOR_CRS_$2,
                                sourceCRS,
                                targetCRS));
            }
        }

        Point2D lc = toPoint2D(envelope.getLowerCorner());
        Point lcGrid = new Point();
        mt.transform(lc, lcGrid);

        Point2D uc = toPoint2D(envelope.getUpperCorner());
        Point ucGrid = new Point();
        mt.transform(uc, ucGrid);

        GridEnvelope2D gridEnv =
                new GridEnvelope2D(
                        Math.min(lcGrid.x, ucGrid.x),
                        Math.min(lcGrid.y, ucGrid.y),
                        Math.abs(lcGrid.x - ucGrid.x),
                        Math.abs(lcGrid.y - ucGrid.y));

        return gridEnv;
    }

