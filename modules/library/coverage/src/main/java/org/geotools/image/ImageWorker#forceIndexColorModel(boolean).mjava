    /**
     * Reduces the color model to {@linkplain IndexColorModel index color model}. If the current {@linkplain #image} already uses an
     * {@linkplain IndexColorModel index color model}, then this method do nothing. Otherwise, the current implementation performs a ditering on the
     * original color model. Note that this operation loose the alpha channel.
     * <p>
     * This for the moment should work only with opaque images, with non opaque images we just remove the alpha band in order to build an
     * {@link IndexColorModel}. This is one because in general it could be very difficult to decide the final transparency for each pixel given the
     * complexity if the algorithms for obtaining an {@link IndexColorModel}.
     * <p>
     * If an {@link IndexColorModel} with a single transparency index is enough for you, we advise you to take a look at
     * {@link #forceIndexColorModelForGIF(boolean)} methdo.
     * 
     * @see #isIndexed
     * @see #forceBitmaskIndexColorModel
     * @see #forceIndexColorModelForGIF
     * @see OrderedDitherDescriptor
     */
    public final ImageWorker forceIndexColorModel(final boolean error) {
        final ColorModel cm = image.getColorModel();
        if (cm instanceof IndexColorModel) {
            // Already an index color model - nothing to do.
            return this;
        }
        tileCacheEnabled(false);
        if (getNumBands() % 2 == 0)
            retainBands(getNumBands() - 1);
        forceColorSpaceRGB();
        final RenderingHints hints = getRenderingHints();
        if (error) {
            // error diffusion
            final KernelJAI ditherMask = KernelJAI.ERROR_FILTER_FLOYD_STEINBERG;
            final LookupTableJAI colorMap = ColorCube.BYTE_496;

            // Creation of the ParameterBlock
            ParameterBlock pb = new ParameterBlock();
            // Setting source
            pb.setSource(image, 0);
            // Setting parameters
            pb.set(colorMap, 0);
            pb.set(ditherMask, 1);
            pb.set(roi, 2);
            pb.set(nodata, 3);
            if (isNoDataNeeded()) {
                if (background != null && background.length > 0) {
                    int dest = (int) background[0];
                    pb.set(dest, 4);
                }
            }

            image = JAI.create("ErrorDiffusion", pb, hints);
        } else {
            // ordered dither
            final KernelJAI[] ditherMask = KernelJAI.DITHER_MASK_443;
            final ColorCube colorMap = ColorCube.BYTE_496;

            // Creation of the ParameterBlock
            ParameterBlock pb = new ParameterBlock();
            // Setting source
            pb.setSource(image, 0);
            // Setting parameters
            pb.set(colorMap, 0);
            pb.set(ditherMask, 1);
            pb.set(roi, 2);
            pb.set(nodata, 3);
            if (isNoDataNeeded()) {
                if (background != null && background.length > 0) {
                    int dest = (int) background[0];
                    pb.set(dest, 4);
                }
            }

            image = JAI.create("OrderedDither", pb, hints);
        }
        tileCacheEnabled(true);
        invalidateStatistics();

        // All post conditions for this method contract.
        assert isIndexed();
        return this;
    }

