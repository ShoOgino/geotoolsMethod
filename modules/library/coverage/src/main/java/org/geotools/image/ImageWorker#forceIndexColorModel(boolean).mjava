    /**
     * Reduces the color model to {@linkplain IndexColorModel index color model}.
     * If the current {@linkplain #image} already uses an
     * {@linkplain IndexColorModel index color model}, then this method do
     * nothing. Otherwise, the current implementation performs a ditering on the
     * original color model. Note that this operation loose the alpha channel.
     * <p>
     * This for the moment should work only with opaque images, with non opaque
     * images we just remove the alpha band in order to build an
     * {@link IndexColorModel}. This is one because in general it could be very
     * difficult to decide the final transparency for each pixel given the
     * complexity if the algorithms for obtaining an {@link IndexColorModel}.
     * <p>
     * If an {@link IndexColorModel} with a single transparency index is enough
     * for you, we advise you to take a look at
     * {@link #forceIndexColorModelForGIF(boolean)} methdo.
     *
     * @see #isIndexed
     * @see #forceBitmaskIndexColorModel
     * @see #forceIndexColorModelForGIF
     * @see OrderedDitherDescriptor
     */
    public final ImageWorker forceIndexColorModel(final boolean error) {
        final ColorModel cm = image.getColorModel();
        if (cm instanceof IndexColorModel) {
            // Already an index color model - nothing to do.
            return this;
        }
        tileCacheEnabled(false);
		if (getNumBands() % 2 == 0)
			retainBands(getNumBands() - 1);
		forceColorSpaceRGB();
		final RenderingHints hints = getRenderingHints();
		if (error) {
			// color quantization
			// final RenderedOp temp = ColorQuantizerDescriptor.create(image,
			// ColorQuantizerDescriptor.MEDIANCUT, new Integer(254),
			// new Integer(200), null, new Integer(1), new Integer(1),
			// getRenderingHints());
			// final ImageLayout layout= new ImageLayout();
			// layout.setColorModel(temp.getColorModel());
			// hints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT,layout));

			// error diffusion
			final KernelJAI ditherMask = KernelJAI.ERROR_FILTER_FLOYD_STEINBERG;
			final LookupTableJAI colorMap = ColorCube.BYTE_496;
			// (LookupTableJAI) temp.getProperty("JAI.LookupTable");
			image = ErrorDiffusionDescriptor.create(image, colorMap,
					ditherMask, hints);
		} else {
			// ordered dither
			final KernelJAI[] ditherMask = KernelJAI.DITHER_MASK_443;
			final ColorCube colorMap = ColorCube.BYTE_496;
			image = OrderedDitherDescriptor.create(image, colorMap, ditherMask,
					hints);
		}
        tileCacheEnabled(true);
        invalidateStatistics();

        // All post conditions for this method contract.
        assert isIndexed();
        return this;
    }

