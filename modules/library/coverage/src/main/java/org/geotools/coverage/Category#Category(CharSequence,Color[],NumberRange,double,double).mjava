    /**
     * Constructs a quantitative category for sample values in the specified range.
     * Sample values are converted into geophysics values using the following linear
     * equation:
     *
     * <center><var>x</var><code>&nbsp;=&nbsp;{@linkplain GridSampleDimension#getOffset()
     * offset}&nbsp;+&nbsp;{@linkplain GridSampleDimension#getScale()
     * scale}&times;</code><var>s</var></center>
     *
     * @param  name    The category name as a {@link String} or {@link InternationalString} object.
     * @param  colors  A set of colors for this category. This array may have any length;
     *                 colors will be interpolated as needed. An array of length 1 means
     *                 that an uniform color should be used for all sample values. An array
     *                 of length 0 or a {@code null} array means that some default colors
     *                 should be used (usually a gradient from opaque black to opaque white).
     * @param  sampleValueRange The range of sample values for this category. Element class
     *                 is usually {@link Integer}, but {@link Float} and {@link Double} are
     *                 accepted as well.
     * @param  scale   The {@link GridSampleDimension#getScale() scale} value which is
     *                 multiplied to sample values for this category.
     * @param  offset  The {@link GridSampleDimension#getOffset() offset} value to add
     *                 to sample values for this category.
     *
     * @throws IllegalArgumentException if {@code lower} is not smaller than {@code upper},
     *         or if {@code scale} or {@code offset} are not real numbers.
     */
    public Category(final CharSequence name,
                    final Color[]     colors,
                    final NumberRange sampleValueRange,
                    final double      scale,
                    final double      offset) throws IllegalArgumentException
    {
        this(name, colors, sampleValueRange, createLinearTransform(scale, offset));
        try {
            assert Double.doubleToLongBits(transform.derivative(0)) == Double.doubleToLongBits(scale);
            assert Double.doubleToLongBits(transform.transform (0)) == Double.doubleToLongBits(offset);
        } catch (TransformException exception) {
            throw new AssertionError(exception);
        }
        if (Double.isNaN(scale) || Double.isInfinite(scale)) {
            throw new IllegalArgumentException(Errors.format(ErrorKeys.BAD_COEFFICIENT_$2, "scale", scale));
        }
        if (Double.isNaN(offset) || Double.isInfinite(offset)) {
            throw new IllegalArgumentException(Errors.format(ErrorKeys.BAD_COEFFICIENT_$2, "offset", offset));
        }
    }

