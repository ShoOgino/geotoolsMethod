    /**
     * Constructs a grid coverage with the specified {@linkplain GridGeometry2D grid geometry} and
     * {@linkplain GridSampleDimension sample dimensions}. The {@linkplain Envelope envelope}
     * (including the {@linkplain CoordinateReferenceSystem coordinate reference system}) is
     * inferred from the grid geometry.
     *
     * <p>This constructor accepts an optional set of properties. Keys are {@link String} objects
     * ({@link javax.media.jai.util.CaselessStringKey} are accepted as well), while values may be
     * any {@link Object}.
     *
     * @param name The grid coverage name.
     * @param image The image.
     * @param gridGeometry The grid geometry (must contains an {@linkplain
     *     GridGeometry2D#getEnvelope envelope} with its {@linkplain
     *     GridGeometry2D#getCoordinateReferenceSystem coordinate reference system} and a
     *     "{@linkplain GridGeometry2D#getGridToCoordinateSystem grid to CRS}" transform).
     * @param bands Sample dimensions for each image band, or {@code null} for default sample
     *     dimensions. If non-null, then this array's length must matches the number of bands in
     *     {@code image}.
     * @param sources The sources for this grid coverage, or {@code null} if none.
     * @param properties The set of properties for this coverage, or {@code null} none.
     * @param hints An optional set of hints, or {@code null} if none.
     * @throws IllegalArgumentException If the number of bands differs from the number of sample
     *     dimensions.
     * @since 2.5
     */
    protected GridCoverage2D(
            final CharSequence name,
            final PlanarImage image,
            GridGeometry2D gridGeometry,
            final GridSampleDimension[] bands,
            final GridCoverage[] sources,
            final Map<?, ?> properties,
            final Hints hints)
            throws IllegalArgumentException {
        super(name, gridGeometry.getCoordinateReferenceSystem(), sources, image, properties);
        this.image = image;
        /*
         * Wraps the user-supplied sample dimensions into instances of RenderedSampleDimension. This
         * process will creates default sample dimensions if the user supplied null values. Those
         * default will be inferred from image type (integers, floats...) and range of values. If
         * an inconsistency is found in user-supplied sample dimensions, an IllegalArgumentException
         * is thrown.
         */
        sampleDimensions = new GridSampleDimension[image.getNumBands()];
        RenderedSampleDimension.create(name, image, bands, sampleDimensions);
        /*
         * Computes the grid range if it was not explicitly provided. The range will be inferred
         * from the image size, if needed. The envelope computation (if needed) requires a valid
         * 'gridToCRS' transform in the GridGeometry object. In any case, the envelope must be
         * non-empty and its dimension must matches the coordinate reference system's dimension.
         */
        final int dimension = crs.getCoordinateSystem().getDimension();
        if (!gridGeometry.isDefined(GridGeometry2D.GRID_RANGE_BITMASK)) {
            final GridEnvelope r = new GeneralGridEnvelope(image, dimension);
            if (gridGeometry.isDefined(GridGeometry2D.GRID_TO_CRS_BITMASK)) {
                gridGeometry =
                        new GridGeometry2D(
                                r,
                                PIXEL_IN_CELL,
                                gridGeometry.getGridToCRS(PIXEL_IN_CELL),
                                crs,
                                hints);
            } else {
                /*
                 * If the math transform was not explicitly specified by the user, then it will be
                 * computed from the envelope. In this case, some heuristic rules are used in order
                 * to decide if we should reverse some axis directions or swap axis.
                 */
                gridGeometry = new GridGeometry2D(r, gridGeometry.getEnvelope());
            }
        } else {
            /*
             * Makes sure that the 'gridToCRS' transform is defined.
             * An exception will be thrown otherwise.
             */
            gridGeometry.getGridToCRS();
        }
        this.gridGeometry = gridGeometry;
        assert gridGeometry.isDefined(
                GridGeometry2D.CRS_BITMASK
                        | GridGeometry2D.ENVELOPE_BITMASK
                        | GridGeometry2D.GRID_RANGE_BITMASK
                        | GridGeometry2D.GRID_TO_CRS_BITMASK);
        /*
         * Last argument checks. The image size must be consistent with the grid range
         * and the envelope must be non-empty.
         */
        final String error = GridGeometry2D.checkConsistency(image, gridGeometry);
        if (error != null) {
            throw new IllegalArgumentException(error);
        }
        if (dimension <= Math.max(gridGeometry.axisDimensionX, gridGeometry.axisDimensionY)
                || !(gridGeometry.envelope.getSpan(gridGeometry.axisDimensionX) > 0)
                || !(gridGeometry.envelope.getSpan(gridGeometry.axisDimensionY) > 0)) {
            throw new IllegalArgumentException(Errors.format(ErrorKeys.EMPTY_ENVELOPE));
        }
    }

