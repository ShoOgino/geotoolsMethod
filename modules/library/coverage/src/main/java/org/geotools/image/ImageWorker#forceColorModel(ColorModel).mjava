    /** Forces the provided {@link ColorModel} via the JAI ColorConvert operation. */
    private void forceColorModel(final ColorModel cm) {

        final ImageLayout2 il = new ImageLayout2(image);
        il.setColorModel(cm);
        il.setSampleModel(cm.createCompatibleSampleModel(image.getWidth(), image.getHeight()));
        final RenderingHints oldRi = this.getRenderingHints();
        final RenderingHints newRi = (RenderingHints) oldRi.clone();
        newRi.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT, il));
        setRenderingHints(newRi);

        // Setting the parameter blocks
        ParameterBlock pb = new ParameterBlock();
        pb.setSource(image, 0);
        pb.set(cm, 0);
        pb.set(roi, 1);
        pb.set(nodata, 2);
        if (isNoDataNeeded()) {
            if (background != null && background.length > 0) {
                // Elaborating the final NoData value
                if (background.length != cm.getNumColorComponents()) {
                    throw new IllegalArgumentException("Wrong DestinationNoData value defined");
                }
                pb.set(background, 3);
                ColorSpace in = image.getColorModel().getColorSpace();
                ColorSpace out = cm.getColorSpace();
                float[] output = new float[background.length];
                for (int i = 0; i < background.length; i++) {
                    output[i] = (float) background[i];
                }
                float[] toXYZ = in.toCIEXYZ(output);
                float[] fromXYZ = out.fromCIEXYZ(toXYZ);
                // We must set the new NoData value
                setNoData(RangeFactory.create(fromXYZ[0], fromXYZ[0]));
            }
        }

        image = JAI.create("ColorConvert", pb, getRenderingHints());

        // restore RI
        this.setRenderingHints(oldRi);

        // invalidate stats
        invalidateStatistics();
    }

