        /**
         * Creates a rendered image using a given render context. This method will uses an "{@link
         * ImageFunctionDescriptor ImageFunction}" operation if possible (i.e. if the area of
         * interect is rectangular and the affine transform contains only translation and scale
         * coefficients).
         *
         * @param context The render context to use to produce the rendering.
         * @return A rendered image containing the rendered data
         */
        public RenderedImage createRendering(final RenderContext context) {
            final AffineTransform crsToGrid = context.getTransform();
            final Shape area = context.getAreaOfInterest();
            /*
             * Computes the grid bounds for the coverage bounds (or the area of interest).
             * The default implementation of Rectangle uses Math.floor and Math.ceil for
             * computing a box which contains fully the Rectangle2D. But in our particular
             * case, we really want to round toward the nearest integer.
             */
            final Rectangle2D bounds =
                    XAffineTransform.transform(
                            crsToGrid, (area != null) ? area.getBounds2D() : this.bounds, null);
            final int xmin = (int) Math.round(bounds.getMinX());
            final int ymin = (int) Math.round(bounds.getMinY());
            final int xmax = (int) Math.round(bounds.getMaxX());
            final int ymax = (int) Math.round(bounds.getMaxY());
            final Rectangle gridBounds = new Rectangle(xmin, ymin, xmax - xmin, ymax - ymin);
            /*
             * Computes some properties of the image to be created.
             */
            final Dimension tileSize = ImageUtilities.toTileSize(gridBounds.getSize());
            final GridSampleDimension band =
                    GridSampleDimension.wrap(getSampleDimension(VISIBLE_BAND));
            final ColorModel colorModel =
                    band.getColorModel(VISIBLE_BAND, getNumSampleDimensions());
            final SampleModel sampleModel =
                    colorModel.createCompatibleSampleModel(tileSize.width, tileSize.height);
            /*
             * If the image can be created using the ImageFunction operation, do it.
             * It allow JAI to defer the computation until a tile is really requested.
             */
            final PlanarImage image;
            if ((area == null || area instanceof Rectangle2D)
                    && crsToGrid.getShearX() == 0
                    && crsToGrid.getShearY() == 0) {
                RenderingHints hints =
                        new RenderingHints(
                                JAI.KEY_IMAGE_LAYOUT,
                                new ImageLayout()
                                        .setMinX(gridBounds.x)
                                        .setMinY(gridBounds.y)
                                        .setTileWidth(tileSize.width)
                                        .setTileHeight(tileSize.height)
                                        .setSampleModel(sampleModel)
                                        .setColorModel(colorModel));
                image =
                        new ImageWorker()
                                .setRenderingHints(hints)
                                .function(
                                        this,
                                        gridBounds.width,
                                        gridBounds.height,
                                        (float) (1 / crsToGrid.getScaleX()),
                                        (float) (1 / crsToGrid.getScaleY()),
                                        (float) crsToGrid.getTranslateX(),
                                        (float) crsToGrid.getTranslateY())
                                .getPlanarImage();
                //                        ImageFunctionDescriptor.create(this, // The functional
                // description
                //                        gridBounds.width,                    // The image width
                //                        gridBounds.height,                   // The image height
                //                        (float) (1/crsToGrid.getScaleX()),   // The X scale factor
                //                        (float) (1/crsToGrid.getScaleY()),   // The Y scale factor
                //                        (float) crsToGrid.getTranslateX(),   // The X translation
                //                        (float) crsToGrid.getTranslateY(),   // The Y translation
                //                        new RenderingHints(JAI.KEY_IMAGE_LAYOUT, new ImageLayout()
                //                                .setMinX       (gridBounds.x)
                //                                .setMinY       (gridBounds.y)
                //                                .setTileWidth  (tileSize.width)
                //                                .setTileHeight (tileSize.height)
                //                                .setSampleModel(sampleModel)
                //                                .setColorModel (colorModel)));
            } else {
                /*
                 * Creates immediately a rendered image using a given render context. This block
                 * is run when the image can't be created with JAI's ImageFunction operator, for
                 * example because the affine transform swap axis or because there is an area of
                 * interest.
                 */
                // Clones the coordinate point in order to allow multi-thread
                // invocation.
                final GeneralDirectPosition coordinate = new GeneralDirectPosition(this.coordinate);
                final TiledImage tiled =
                        new TiledImage(
                                gridBounds.x,
                                gridBounds.y,
                                gridBounds.width,
                                gridBounds.height,
                                0,
                                0,
                                sampleModel,
                                colorModel);
                final Point2D.Double point2D = new Point2D.Double();
                final int numBands = tiled.getNumBands();
                final double[] samples = new double[numBands];
                final double[] padNaNs = new double[numBands];
                Arrays.fill(padNaNs, Double.NaN);
                final WritableRectIter iterator = RectIterFactory.createWritable(tiled, gridBounds);
                if (!iterator.finishedLines())
                    try {
                        int y = gridBounds.y;
                        do {
                            iterator.startPixels();
                            if (!iterator.finishedPixels()) {
                                int x = gridBounds.x;
                                do {
                                    point2D.x = x;
                                    point2D.y = y;
                                    crsToGrid.inverseTransform(point2D, point2D);
                                    if (area == null || area.contains(point2D)) {
                                        coordinate.ordinates[xAxis] = point2D.x;
                                        coordinate.ordinates[yAxis] = point2D.y;
                                        iterator.setPixel(evaluate(coordinate, samples));
                                    } else {
                                        iterator.setPixel(padNaNs);
                                    }
                                    x++;
                                } while (!iterator.nextPixelDone());
                                assert (x == gridBounds.x + gridBounds.width);
                                y++;
                            }
                        } while (!iterator.nextLineDone());
                        assert (y == gridBounds.y + gridBounds.height);
                    } catch (NoninvertibleTransformException exception) {
                        throw new IllegalArgumentException(
                                Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$1, "context"), exception);
                    }
                image = tiled;
            }
            /*
             * Adds a 'gridToCRS' property to the image. This is an important
             * information for constructing a GridCoverage from this image later.
             */
            try {
                image.setProperty("gridToCRS", crsToGrid.createInverse());
            } catch (NoninvertibleTransformException exception) {
                // Can't add the property. Too bad, the image has been created
                // anyway. Maybe the user know what he is doing...
                Logging.unexpectedException(Renderable.class, "createRendering", exception);
            }
            return image;
        }

