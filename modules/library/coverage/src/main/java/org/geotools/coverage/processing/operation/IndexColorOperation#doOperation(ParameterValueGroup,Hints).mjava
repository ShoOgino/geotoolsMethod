    /**
     * Performs the color transformation. This method invokes the {@link #transformColormap
     * transformColormap(...)} method with current RGB colormap, the source {@link SampleDimension}
     * and the supplied parameters.
     *
     * @param parameters The parameters.
     * @param hints Rendering hints (ignored in this implementation).
     * @throws IllegalArgumentException if the candidate image do not use an {@link
     *     IndexColorModel}.
     */
    public Coverage doOperation(final ParameterValueGroup parameters, final Hints hints) {
        final GridCoverage2D source = (GridCoverage2D) parameters.parameter("Source").getValue();
        final GridCoverage2D visual = source;
        final RenderedImage image = visual.getRenderedImage();
        final GridSampleDimension[] bands = visual.getSampleDimensions();
        final int visibleBand = CoverageUtilities.getVisibleBand(image);
        ColorModel model = image.getColorModel();
        boolean colorChanged = false;
        for (int i = 0; i < bands.length; i++) {
            /*
             * Extracts the ARGB codes from the IndexColorModel and invokes the
             * transformColormap(...) method, which needs to be defined by subclasses.
             */
            GridSampleDimension band = bands[i];
            final ColorModel candidate =
                    (i == visibleBand) ? image.getColorModel() : band.getColorModel();
            if (!(candidate instanceof IndexColorModel)) {
                // Current implementation supports only sources that use an index color model.
                throw new IllegalArgumentException(
                        Errors.format(
                                ErrorKeys.ILLEGAL_CLASS_$2,
                                Classes.getClass(candidate),
                                IndexColorModel.class));
            }
            final IndexColorModel colors = (IndexColorModel) candidate;
            final int mapSize = colors.getMapSize();
            final int[] ARGB = new int[mapSize];
            colors.getRGBs(ARGB);
            band = transformColormap(ARGB, i, band, parameters);
            /*
             * Checks if there is any change, either as a new GridSampleDimension instance or in
             * the ARGB array. Note that if the new GridSampleDimension is equals to the old one,
             * then the new one will be discarted since the old one is more likely to be a shared
             * instance.
             */
            if (!bands[i].equals(band)) {
                bands[i] = band;
                colorChanged = true;
            } else if (!colorChanged) {
                for (int j = 0; j < mapSize; j++) {
                    if (ARGB[j] != colors.getRGB(j)) {
                        colorChanged = true;
                        break;
                    }
                }
            }
            /*
             * If we changed the color of the visible band, then create immediately a new
             * color model for this band. The new color model will be given later to the
             * image operator.
             */
            if (colorChanged && (i == visibleBand)) {
                model = ColorUtilities.getIndexColorModel(ARGB, bands.length, visibleBand);
            }
        }
        if (!colorChanged) {
            return source;
        }
        /*
         * Gives the color model to the image layout and creates a new image using the Null
         * operation, which merely propagates its first source along the operation chain
         * unmodified (except for the ColorModel given in the layout in this case).
         */
        final ImageLayout layout = new ImageLayout().setColorModel(model);
        final RenderedImage newImage =
                new NullOpImage(image, layout, null, OpImage.OP_COMPUTE_BOUND);
        final GridCoverage2D target =
                CoverageFactoryFinder.getGridCoverageFactory(GeoTools.getDefaultHints())
                        .create(
                                visual.getName(),
                                newImage,
                                visual.getCoordinateReferenceSystem2D(),
                                visual.getGridGeometry().getGridToCRS(),
                                bands,
                                new GridCoverage[] {visual},
                                null);

        return target;
    }

