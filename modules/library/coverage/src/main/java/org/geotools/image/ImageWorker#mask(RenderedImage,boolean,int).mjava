    /**
     * Applies the specified mask over the current {@linkplain #image}. The mask should be {@linkplain #binarize() binarized} - if it is not, this
     * method will do it itself. Then, for every pixels in the mask with value equals to {@code maskValue}, the corresponding pixel in the
     * {@linkplain #image} will be set to the specified {@code newValue}.
     * <p>
     * <strong>Note:</strong> current implementation force the color model to an {@linkplain IndexColorModel indexed} one. Future versions may avoid
     * this change.
     * 
     * @param mask The mask to apply, as a {@linkplain #binarize() binarized} image.
     * @param maskValue The mask value to search for ({@code false} for 0 or {@code true} for 1).
     * @param newValue The new value for every pixels in {@linkplain #image} corresponding to {@code maskValue} in the mask.
     * 
     * @return this {@link ImageWorker}.
     * 
     * @todo This now should work only if {@code newValue} is 255 and {@code maskValue} is {@code false}.
     */
    public final ImageWorker mask(RenderedImage mask, final boolean maskValue, int newValue) {

        /*
         * Make sure that the underlying image is indexed.
         */
        tileCacheEnabled(false);
        forceIndexColorModel(true);
        final RenderingHints hints = new RenderingHints(JAI.KEY_TILE_CACHE, null);

        /*
         * special case for newValue == 255 && !maskValue.
         */
        if (newValue == 255 && !maskValue) {
            /*
             * Build a lookup table in order to make the transparent pixels equal to 255 and all the others equal to 0.
             */
            final byte[] lutData = new byte[256];
            // mapping all the non-transparent pixels to opaque
            Arrays.fill(lutData, (byte) 0);
            // for transparent pixels
            lutData[0] = (byte) 255;
            final LookupTable lut = LookupTableFactory.create(lutData, mask.getSampleModel()
                    .getDataType());

            // ParameterBlock definition
            ParameterBlock pb = new ParameterBlock();
            pb.setSource(mask, 0);
            pb.set(lut, 0);
            if (background != null && background.length > 0) {
                pb.set(background[0], 1);
            }
            pb.set(roi, 2);

            mask = JAI.create("Lookup", pb, hints);

            // mask = LookupDescriptor.create(mask, lut, hints);

            /*
             * Adding to the other image exploiting the implict clamping
             */
            pb = new ParameterBlock();
            pb.setSource(image, 0);
            pb.setSource(mask, 1);
            if (JAIExt.isJAIExtOperation(ALGEBRIC_OP_NAME)) {
                prepareAlgebricOperation(Operator.SUM, pb, roi, nodata, true);
                image = JAI.create(ALGEBRIC_OP_NAME, pb, getRenderingHints());
            } else {
                image = JAI.create("Add", pb, getRenderingHints());
            }
            // image = AddDescriptor.create(image, mask, getRenderingHints());
            tileCacheEnabled(true);
            invalidateStatistics();
            return this;
        } else {
            // general case

            // it has to be binary
            if (!isBinary())
                binarize();

            // Split between JAI and JAI-EXT operations
            boolean algebricJAIExt = JAIExt.isJAIExtOperation(ALGEBRIC_OP_NAME);
            boolean opConstJAIExt = JAIExt.isJAIExtOperation(OPERATION_CONST_OP_NAME);

            ParameterBlock pb;
            // now if we mask with 1 we have to invert the mask
            RenderingHints renderingHints = new RenderingHints(JAI.KEY_REPLACE_INDEX_COLOR_MODEL,
                    Boolean.FALSE);
            if (maskValue) {
                pb = new ParameterBlock();
                pb.setSource(mask, 0);
                if (algebricJAIExt) {
                    prepareAlgebricOperation(Operator.NOT, pb, roi, null, false);
                    mask = JAI.create(ALGEBRIC_OP_NAME, pb, renderingHints);
                } else {
                    mask = JAI.create("Not", pb, renderingHints);
                }
            }
            // and with the image to zero the interested pixels
            tileCacheEnabled(false);
            pb = new ParameterBlock();
            pb.setSource(mask, 0);
            pb.setSource(image, 1);
            if (algebricJAIExt) {
                prepareAlgebricOperation(Operator.AND, pb, roi, nodata, true);
                image = JAI.create(ALGEBRIC_OP_NAME, pb, getRenderingHints());
            } else {
                image = JAI.create("And", pb, getRenderingHints());
            }
            // image = AndDescriptor.create(mask, image, getRenderingHints());

            // add the new value to the mask
            pb = new ParameterBlock();
            pb.setSource(mask, 0);
            if (opConstJAIExt) {
                prepareOpConstOperation(Operator.SUM, new double[] { newValue }, pb, roi, null,
                        false);
                image = JAI.create(OPERATION_CONST_OP_NAME, pb, renderingHints);
            } else {
                image = JAI.create("AddConst", pb, renderingHints);
            }
            // mask = AddConstDescriptor.create(mask, new double[] { newValue }, renderingHints);

            // add the mask to the image to mask with the new value
            pb = new ParameterBlock();
            pb.setSource(mask, 0);
            pb.setSource(image, 1);
            if (algebricJAIExt) {
                prepareAlgebricOperation(Operator.SUM, pb, roi, nodata, true);
                image = JAI.create(ALGEBRIC_OP_NAME, pb, getRenderingHints());
            } else {
                image = JAI.create("Add", pb, getRenderingHints());
            }
            // image = AddDescriptor.create(mask, image, getRenderingHints());
            tileCacheEnabled(true);
            invalidateStatistics();
            return this;
        }
    }

