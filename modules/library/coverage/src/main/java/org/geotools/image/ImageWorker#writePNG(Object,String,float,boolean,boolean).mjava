    /**
     * Writes outs the image contained into this {@link ImageWorker} as a PNG
     * using the provided destination, compression and compression rate.
     * <p>
     * The destination object can be anything providing that we have an
     * {@link ImageOutputStreamSpi} that recognizes it.
     *
     * @param destination
     *            where to write the internal {@link #image} as a PNG.
     * @param compression
     *            algorithm.
     * @param compressionRate
     *            percentage of compression.
     * @param nativeAcc
     *            should we use native acceleration.
     * @param paletted
     *            should we write the png as 8 bits?
     * @return this {@link ImageWorker}.
     * @throws IOException
     *             In case an error occurs during the search for an
     *             {@link ImageOutputStream} or during the eoncding process.
     *
     * @todo Current code doesn't check if the writer already accepts the provided destination.
     *       It wraps it in a {@link ImageOutputStream} inconditionnaly.
     */
    public final void writePNG(final Object destination, final String compression,
                               final float compressionRate, final boolean nativeAcc,
                               final boolean paletted)
            throws IOException
    {
        // Reformatting this image for PNG.
        final boolean hasPalette = image.getColorModel() instanceof IndexColorModel;
        final boolean hasColorModel = hasPalette?false:image.getColorModel() instanceof ComponentColorModel;
        if (paletted && !hasPalette) {
            // we have to reduce colors
            forceIndexColorModelForGIF(true);
        } else {
            if(!hasColorModel && !hasPalette) {
                if(LOGGER.isLoggable(Level.FINER)){
                    LOGGER.fine("Forcing input image to be compatible with PNG: No palette, no component color model");
                }
                // png supports gray, rgb, rgba and paletted 8 bit, but not, for example, double and float values, or 16 bits palettes
                forceComponentColorModel();
            }
        }
        
        // PNG does not support all kinds of index color models
        if(hasPalette) {
            IndexColorModel icm = (IndexColorModel) image.getColorModel();
            // PNG supports palettes with up to 256 colors, beyond that we have to expand to RGB 
            if(icm.getMapSize() > 256) {
                if(LOGGER.isLoggable(Level.FINER)){
                    LOGGER.fine("Forcing input image to be compatible with PNG: Palette with > 256 color is not supported.");
                }
                forceComponentColorModel(true, true);
                rescaleToBytes();
            }
        }        
        
        if(LOGGER.isLoggable(Level.FINE)){
            LOGGER.fine("Encoded input image for png writer");
        }

        // Getting a writer.
        if(LOGGER.isLoggable(Level.FINE)){
            LOGGER.fine("Getting a writer");
        }
        ImageWriter writer=null;
        ImageWriterSpi originatingProvider = null;
        // ImageIO
        if(nativeAcc){
            if(CLIB_PNG_IMAGE_WRITER_SPI!=null){
                // let me check if the native writer can encode this image
                if(CLIB_PNG_IMAGE_WRITER_SPI.canEncodeImage(new ImageTypeSpecifier(image))){
                    writer= CLIB_PNG_IMAGE_WRITER_SPI.createWriterInstance();
                    originatingProvider=CLIB_PNG_IMAGE_WRITER_SPI;

                } else {
                    LOGGER.fine("The ImageIO PNG native encode cannot encode this image!");
                    writer=null;
                    originatingProvider=null;
                }
            }else{
                LOGGER.fine("Unable to use Native ImageIO PNG writer.");
            }
        }

        // move on with the writer quest
        if(!nativeAcc||writer==null){

            final Iterator<ImageWriter> it = ImageIO.getImageWriters(new ImageTypeSpecifier(image),"PNG");
            if (!it.hasNext()) {
                throw new IllegalStateException(Errors.format(ErrorKeys.NO_IMAGE_WRITER));
            }
            while(it.hasNext()){
                writer = it.next();
                originatingProvider = writer.getOriginatingProvider();
                // check that this is not the native one
                if (CLIB_PNG_IMAGE_WRITER_SPI!=null&&
                        originatingProvider.getClass().equals(CLIB_PNG_IMAGE_WRITER_SPI.getClass())){
                    if(it.hasNext()){
                        writer = it.next();
                        originatingProvider = writer.getOriginatingProvider();
                    }else{
                        LOGGER.fine("Unable to use PNG writer different than ImageIO CLib one");
                    }
                }
                
                // let me check if the native writer can encode this image (paranoiac checks this was already performed by the ImageIO search
                if(!originatingProvider.canEncodeImage(new ImageTypeSpecifier(image))){
                    LOGGER.fine("The following encoder cannot encode this image: "+originatingProvider.getClass().getCanonicalName());
                    
                    // kk, last resort reformat the image
                    forceComponentColorModel(true, true);
                    rescaleToBytes();
                    if(!originatingProvider.canEncodeImage(image)){
                        LOGGER.severe("Unable to find a valid PNG Encoder!");
                    }
                }                
            }
        }
        
        // do we have a writer?
        if(writer==null){
            throw new IllegalStateException("Unable to find a valid PNG Encoder!");
        }
        LOGGER.fine("Using ImageIO Writer with SPI: "+originatingProvider.getClass().getCanonicalName());

        // Getting a stream.
        LOGGER.fine("Setting write parameters for this writer");

        ImageWriteParam iwp = null;
        final ImageOutputStream memOutStream = ImageIOExt.createImageOutputStream(image, destination);
        if(memOutStream==null){
            throw new IIOException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1,"stream"));        
        }
        if (CLIB_PNG_IMAGE_WRITER_SPI!=null&&originatingProvider.getClass().equals(CLIB_PNG_IMAGE_WRITER_SPI.getClass()))
        {
            // Compressing with native.
            LOGGER.fine("Writer is native");
            iwp = writer.getDefaultWriteParam();
            // Define compression mode
            iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
            // best compression
            iwp.setCompressionType(compression);
            // we can control quality here
            iwp.setCompressionQuality(compressionRate);
            // destination image type
            iwp.setDestinationType(new ImageTypeSpecifier(image.getColorModel(), image.getSampleModel()));
        } else {
            // Compressing with pure Java.
            LOGGER.fine("Writer is NOT native");

            // Instantiating PNGImageWriteParam
            iwp = new PNGImageWriteParam();
            // Define compression mode
            iwp.setCompressionMode(ImageWriteParam.MODE_DEFAULT);
        }
        LOGGER.fine("About to write png image");
        try{
                writer.setOutput(memOutStream);
                writer.write(null, new IIOImage(image, null, null), iwp);
        }
        finally{
                try{
                        writer.dispose();
                }catch (Throwable e) {
                        if(LOGGER.isLoggable(Level.FINEST))
                                        LOGGER.log(Level.FINEST,e.getLocalizedMessage(),e);
                        }
                try{
                        memOutStream.close();
                }catch (Throwable e) {
                        if(LOGGER.isLoggable(Level.FINEST))
                                        LOGGER.log(Level.FINEST,e.getLocalizedMessage(),e);
                        }               
            
            
        }
    }

