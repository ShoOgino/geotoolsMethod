    /**
     * Writes outs the image contained into this {@link ImageWorker} as a PNG using the provided
     * destination, compression and compression rate.
     *
     * <p>The destination object can be anything providing that we have an {@link
     * ImageOutputStreamSpi} that recognizes it.
     *
     * @param destination where to write the internal {@link #image} as a PNG.
     * @param compression algorithm.
     * @param compressionRate percentage of compression.
     * @param nativeAcc should we use native acceleration.
     * @param paletted should we write the png as 8 bits?
     * @return this {@link ImageWorker}.
     * @throws IOException In case an error occurs during the search for an {@link
     *     ImageOutputStream} or during the eoncding process.
     * @todo Current code doesn't check if the writer already accepts the provided destination. It
     *     wraps it in a {@link ImageOutputStream} inconditionnaly.
     */
    public final void writePNG(
            final Object destination,
            final String compression,
            final float compressionRate,
            final boolean nativeAcc,
            final boolean paletted)
            throws IOException {
        // Reformatting this image for PNG.
        final boolean hasPalette = image.getColorModel() instanceof IndexColorModel;
        final boolean hasColorModel =
                hasPalette ? false : image.getColorModel() instanceof ComponentColorModel;
        if (paletted && !hasPalette) {
            // we have to reduce colors
            forceIndexColorModelForGIF(true);
        } else {
            if (!hasColorModel && !hasPalette) {
                if (LOGGER.isLoggable(Level.FINER)) {
                    LOGGER.fine(
                            "Forcing input image to be compatible with PNG: No palette, no component color model");
                }
                // png supports gray, rgb, rgba and paletted 8 bit, but not, for example, double and
                // float values, or 16 bits palettes
                forceComponentColorModel();
            }
        }

        // PNG does not support all kinds of index color models
        if (hasPalette) {
            IndexColorModel icm = (IndexColorModel) image.getColorModel();
            // PNG supports palettes with up to 256 colors, beyond that we have to expand to RGB
            if (icm.getMapSize() > 256) {
                if (LOGGER.isLoggable(Level.FINER)) {
                    LOGGER.fine(
                            "Forcing input image to be compatible with PNG: Palette with > 256 color is not supported.");
                }
                rescaleToBytes();
                if (paletted) {
                    forceIndexColorModelForGIF(true);
                }
            }
        }

        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Encoded input image for png writer");
        }

        // Getting a writer.
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Getting a writer");
        }
        ImageWriter writer = null;
        ImageWriterSpi originatingProvider = null;
        // ImageIO
        if (nativeAcc) {
            if (CLIB_PNG_IMAGE_WRITER_SPI != null) {
                // let me check if the native writer can encode this image
                if (CLIB_PNG_IMAGE_WRITER_SPI.canEncodeImage(new ImageTypeSpecifier(image))) {
                    writer = CLIB_PNG_IMAGE_WRITER_SPI.createWriterInstance();
                    originatingProvider = CLIB_PNG_IMAGE_WRITER_SPI;

                } else {
                    LOGGER.fine("The ImageIO PNG native encode cannot encode this image!");
                    writer = null;
                    originatingProvider = null;
                }
            } else {
                LOGGER.fine("Unable to use Native ImageIO PNG writer.");
            }
        }

        // move on with the writer quest
        if (!nativeAcc || writer == null) {

            final Iterator<ImageWriter> it =
                    ImageIO.getImageWriters(new ImageTypeSpecifier(image), "PNG");
            if (!it.hasNext()) {
                throw new IllegalStateException(Errors.format(ErrorKeys.NO_IMAGE_WRITER));
            }
            while (it.hasNext()) {
                writer = it.next();
                originatingProvider = writer.getOriginatingProvider();
                // check that this is not the native one
                if (CLIB_PNG_IMAGE_WRITER_SPI != null
                        && originatingProvider
                                .getClass()
                                .equals(CLIB_PNG_IMAGE_WRITER_SPI.getClass())) {
                    if (it.hasNext()) {
                        writer = it.next();
                        originatingProvider = writer.getOriginatingProvider();
                    } else {
                        LOGGER.fine("Unable to use PNG writer different than ImageIO CLib one");
                    }
                }

                // let me check if the native writer can encode this image (paranoiac checks this
                // was already performed by the ImageIO search
                if (originatingProvider.canEncodeImage(new ImageTypeSpecifier(image))) {
                    break; // leave loop
                }

                // clean
                writer = null;
                originatingProvider = null;
            }
        }

        // ok, last resort use the JDK one and reformat the image
        if (writer == null) {
            List providers =
                    com.sun.media.imageioimpl.common.ImageUtil.getJDKImageReaderWriterSPI(
                            IIORegistry.getDefaultInstance(), "PNG", false);
            if (providers == null || providers.isEmpty()) {
                throw new IllegalStateException("Unable to find JDK Png encoder!");
            }
            originatingProvider = (ImageWriterSpi) providers.get(0);
            writer = originatingProvider.createWriterInstance();

            // kk, last resort reformat the image
            forceComponentColorModel(true, true);
            rescaleToBytes();
            if (!originatingProvider.canEncodeImage(image)) {
                throw new IllegalArgumentException(
                        "Unable to find a valid PNG Encoder! And believe me, we tried hard!");
            }
        }

        LOGGER.fine(
                "Using ImageIO Writer with SPI: "
                        + originatingProvider.getClass().getCanonicalName());

        // Getting a stream.
        LOGGER.fine("Setting write parameters for this writer");

        ImageWriteParam iwp = null;
        final ImageOutputStream memOutStream =
                ImageIOExt.createImageOutputStream(image, destination);
        if (memOutStream == null) {
            throw new IIOException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1, "stream"));
        }
        if (CLIB_PNG_IMAGE_WRITER_SPI != null
                && originatingProvider.getClass().equals(CLIB_PNG_IMAGE_WRITER_SPI.getClass())) {
            // Compressing with native.
            LOGGER.fine("Writer is native");
            iwp = writer.getDefaultWriteParam();
            // Define compression mode
            iwp.setCompressionMode(ImageWriteParam.MODE_EXPLICIT);
            // best compression
            iwp.setCompressionType(compression);
            // we can control quality here
            iwp.setCompressionQuality(compressionRate);
            // destination image type
            iwp.setDestinationType(
                    new ImageTypeSpecifier(image.getColorModel(), image.getSampleModel()));
        } else {
            // Compressing with pure Java.
            LOGGER.fine("Writer is NOT native");

            // Instantiating PNGImageWriteParam
            iwp = new PNGImageWriteParam();
            // Define compression mode
            iwp.setCompressionMode(ImageWriteParam.MODE_DEFAULT);
        }
        LOGGER.fine("About to write png image");
        try {
            writer.setOutput(memOutStream);
            writer.write(null, new IIOImage(image, null, null), iwp);
        } finally {
            try {
                writer.dispose();
            } catch (Throwable e) {
                if (LOGGER.isLoggable(Level.FINEST))
                    LOGGER.log(Level.FINEST, e.getLocalizedMessage(), e);
            }
            try {
                memOutStream.close();
            } catch (Throwable e) {
                if (LOGGER.isLoggable(Level.FINEST))
                    LOGGER.log(Level.FINEST, e.getLocalizedMessage(), e);
            }
        }
    }

