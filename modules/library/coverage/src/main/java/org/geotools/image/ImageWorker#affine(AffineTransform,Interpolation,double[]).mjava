    /**
     * Performs an affine transform on the image, applying optimization such as affine removal in case the affine is an identity, affine merging if
     * the affine is applied on top of another affine, and using optimized operations for integer translates
     * 
     * @param tx
     * @param interpolation
     * @param bgValues
     * @return
     */
    public ImageWorker affine(AffineTransform tx, Interpolation interpolation, double[] bgValues) {
        // identity elimination -> check the tx params against the image size to see if
        // any if likely to actually move the image by at least one pixel
        int size = Math.max(image.getWidth(), image.getHeight());
        boolean hasScaleX = Math.abs(tx.getScaleX() - 1) * size > RS_EPS;
        boolean hasScaleY = Math.abs(tx.getScaleY() - 1) * size > RS_EPS;
        boolean hasShearX = Math.abs(tx.getShearX()) * size > RS_EPS;
        boolean hasShearY = Math.abs(tx.getShearY()) * size > RS_EPS;
        boolean hasTranslateX = Math.abs(tx.getTranslateX()) > RS_EPS;
        boolean hasTranslateY = Math.abs(tx.getTranslateY()) > RS_EPS;
        if (!hasScaleX && !hasScaleY && !hasShearX && !hasShearY && !hasTranslateX
                && !hasTranslateY) {
            return this;
        }

        // apply defaults to allow for comparisong
        ParameterListDescriptor pld = new AffineDescriptor()
                .getParameterListDescriptor(RenderedRegistryMode.MODE_NAME);
        if (interpolation == null) {
            interpolation = (Interpolation) pld.getParamDefaultValue("interpolation");
        }
        if (bgValues == null) {
            if (background == null || background.length <= 0) {
                bgValues = (double[]) pld.getParamDefaultValue("backgroundValues");
            } else {
                bgValues = background;
            }
        }
        // Setting the new backgroung values
        background = bgValues;

        // affine over affine/scale?
        RenderedImage source = image;
        if (image instanceof RenderedOp) {
            RenderedOp op = (RenderedOp) image;

            Object mtProperty = op.getProperty("MathTransform");
            Object sourceBoundsProperty = op.getProperty("SourceBoundingBox");
            String opName = op.getOperationName();

            // check if we can do a warp-affine reduction
            if (WARP_REDUCTION_ENABLED && "Warp".equals(opName)
                    && mtProperty instanceof MathTransform2D
                    && sourceBoundsProperty instanceof Rectangle) {
                try {
                    // we can merge the affine into the warp
                    MathTransform2D originalTransform = (MathTransform2D) mtProperty;
                    MathTransformFactory factory = ReferencingFactoryFinder
                            .getMathTransformFactory(null);
                    MathTransform affineMT = factory
                            .createAffineTransform(new org.geotools.referencing.operation.matrix.AffineTransform2D(
                                    tx));
                    MathTransform2D chained = (MathTransform2D) factory
                            .createConcatenatedTransform(affineMT.inverse(), originalTransform);

                    // setup the warp builder
                    Double tolerance = (Double) getRenderingHint(Hints.RESAMPLE_TOLERANCE);
                    if (tolerance == null) {
                        tolerance = (Double) Hints.getSystemDefault(Hints.RESAMPLE_TOLERANCE);
                    }
                    if (tolerance == null) {
                        tolerance = 0.333;
                    }

                    // setup a warp builder that is not gong to use too much memory
                    WarpBuilder wb = new WarpBuilder(tolerance);
                    wb.setMaxPositions(4 * 1024 * 1024);

                    // compute the target bbox the same way the affine would have to have a 1-1 match
                    ParameterBlock pb = new ParameterBlock();
                    pb.setSource(source, 0);
                    pb.set(tx, 0);
                    pb.set(interpolation, 1);
                    pb.set(bgValues, 2);
                    pb.set(roi, 3);
                    pb.set(true, 5);
                    pb.set(nodata, 6);
                    if(isNoDataNeeded() && bgValues != null && bgValues.length > 0){
                        setNoData(RangeFactory.create(bgValues[0], bgValues[0]));
                    }
                    RenderedOp at = JAI.create("Affine", pb, commonHints);

                    // commonHints);
                    Rectangle targetBB = at.getBounds();
                    at.dispose();
                    Rectangle sourceBB = (Rectangle) sourceBoundsProperty;

                    // warp
                    Rectangle mappingBB;
                    if (source.getProperty("ROI") instanceof ROI) {
                        // Due to a limitation in JAI we need to make sure the
                        // mapping bounding box covers both source and target bounding box
                        // otherwise the warped roi image layout won't be computed properly
                        mappingBB = sourceBB.union(targetBB);
                    } else {
                        mappingBB = targetBB;
                    }
                    Warp warp = wb.buildWarp(chained, mappingBB);

                    // do the switch only if we get a warp that is as fast as the original one
                    Warp sourceWarp = (Warp) op.getParameterBlock().getObjectParameter(0);
                    if (warp instanceof WarpGrid
                            || warp instanceof WarpAffine
                            || !(sourceWarp instanceof WarpGrid || sourceWarp instanceof WarpAffine)) {
                        // and then the JAI Operation
                        PlanarImage sourceImage = op.getSourceImage(0);
                        final ParameterBlock paramBlk = new ParameterBlock().addSource(sourceImage);
                        Object property = sourceImage.getProperty("ROI");
                        if ((property == null) || property.equals(java.awt.Image.UndefinedProperty)
                                || !(property instanceof ROI)) {
                            paramBlk.add(warp).add(interpolation).add(bgValues);
                            paramBlk.set(nodata, 4);
                            if(isNoDataNeeded() && bgValues != null && bgValues.length > 0){
                                setNoData(RangeFactory.create(bgValues[0], bgValues[0]));
                            }
                        } else {
                            // Intersect ROIs
                            ROI newROI = null;
                            if (roi != null) {
                                newROI = roi.intersect((ROI) property);
                            } else {
                                newROI = (ROI) property;
                            }
                            setROI(newROI);
                            paramBlk.add(warp).add(interpolation).add(bgValues).add(newROI)
                                    .add(nodata);
                            if((isNoDataNeeded() || newROI != null) && bgValues != null && bgValues.length > 0){
                                setNoData(RangeFactory.create(bgValues[0], bgValues[0]));
                            }
                        }


                        // force in the image layout, this way we get exactly the same
                        // as the affine we're eliminating
                        Hints localHints = new Hints(commonHints);
                        localHints.remove(JAI.KEY_IMAGE_LAYOUT);
                        ImageLayout il = new ImageLayout();
                        il.setMinX(targetBB.x);
                        il.setMinY(targetBB.y);
                        il.setWidth(targetBB.width);
                        il.setHeight(targetBB.height);
                        
                        il.setTileHeight(op.getTileHeight());
                        il.setTileWidth(op.getTileWidth());
                        il.setTileGridXOffset(0);
                        il.setTileGridYOffset(0);
                        localHints.put(JAI.KEY_IMAGE_LAYOUT, il);

                        RenderedOp result = JAI.create("Warp", paramBlk, localHints);
                        result.setProperty("MathTransform", chained);
                        image = result;
                        // getting the new ROI property
                        PropertyGenerator gen = new WarpDescriptor().getPropertyGenerators(RenderedRegistryMode.MODE_NAME)[0];
                        Object prop = gen.getProperty("roi", image);
                        if(prop != null && prop instanceof ROI){
                            setROI((ROI) prop);
                        }
                        return this;
                    }
                } catch (Exception e) {
                    LOGGER.log(
                            Level.WARNING,
                            "Failed to squash warp and affine into a single operation, chaining them instead",
                            e);
                    // move on
                }
            }

            // see if we can merge affine with other affine types then
            if ("Affine".equals(opName)) {
                ParameterBlock paramBlock = op.getParameterBlock();
                RenderedImage sSource = paramBlock.getRenderedSource(0);

                AffineTransform sTx = (AffineTransform) paramBlock.getObjectParameter(0);
                Interpolation sInterp = (Interpolation) paramBlock.getObjectParameter(1);
                double[] sBgValues = (double[]) paramBlock.getObjectParameter(2);
                
                Range nodata = null;
                ROI r = null;
                boolean similarROI = true;
                // Minor checks on ROI and NoData
                if(paramBlock.getNumParameters() > 3){
                    nodata = (Range) paramBlock.getObjectParameter(6);
                    r = (ROI)paramBlock.getObjectParameter(3);
                    if(r != null){
                        try {
                            AffineTransform inverse = sTx.createInverse();
                            ROI newROI = this.roi != null ? this.roi.transform(inverse) : null;
                            similarROI = newROI != null && newROI.intersects(r.getBounds());
                        } catch (NoninvertibleTransformException e) {
                            LOGGER.log(Level.SEVERE, e.getMessage(), e);
                        }

                    }
                }

                if ((sInterp == interpolation && Arrays.equals(sBgValues, bgValues))
                        && ((nodata == null || nodata.equals(this.nodata)) && (r == null || similarROI))) {
                    // we can replace it
                    AffineTransform concat = new AffineTransform(tx);
                    concat.concatenate(sTx);
                    tx = concat;
                    source = sSource;
                    if(similarROI && r != null){
                        try {
                            AffineTransform inverse = sTx.createInverse();
                            ROI newROI = this.roi != null ? this.roi.transform(inverse) : null;
                            this.roi = newROI.intersect(r);
                        } catch (NoninvertibleTransformException e) {
                            LOGGER.log(Level.SEVERE, e.getMessage(), e);
                        }
                    }
                }
            } else if ("Scale".equals(opName)) {
                ParameterBlock paramBlock = op.getParameterBlock();
                RenderedImage sSource = paramBlock.getRenderedSource(0);

                float xScale = paramBlock.getFloatParameter(0);
                float yScale = paramBlock.getFloatParameter(1);
                float xTrans = paramBlock.getFloatParameter(2);
                float yTrans = paramBlock.getFloatParameter(3);
                Interpolation sInterp = (Interpolation) paramBlock.getObjectParameter(4);

                Range nodata = null;
                ROI r = null;
                boolean similarROI = true;
                // Minor checks on ROI and NoData
                if(paramBlock.getNumParameters() > 5){
                    nodata = (Range) paramBlock.getObjectParameter(7);
                    r = (ROI)paramBlock.getObjectParameter(5);
                    if(r != null){
                        try {
                            AffineTransform sTx = AffineTransform.getScaleInstance(xScale, yScale);
                            sTx.concatenate(AffineTransform.getTranslateInstance(xTrans, yTrans));
                            AffineTransform inverse = sTx.createInverse();
                            ROI newROI = this.roi != null ? this.roi.transform(inverse) : null;
                            similarROI = newROI != null && newROI.intersects(r.getBounds());
                        } catch (NoninvertibleTransformException e) {
                            LOGGER.log(Level.SEVERE, e.getMessage(), e);
                        }
                    }
                }

                if (sInterp == interpolation && ((nodata == null || nodata.equals(this.nodata)) && (r == null || similarROI))) {
                    // we can replace it
                    AffineTransform concat = new AffineTransform(tx);
                    concat.concatenate(new AffineTransform(xScale, 0, 0, yScale, xTrans, yTrans));
                    tx = concat;
                    source = sSource;
                    if(similarROI && r != null){
                        try {
                            AffineTransform sTx = AffineTransform.getScaleInstance(xScale, yScale);
                            sTx.concatenate(AffineTransform.getTranslateInstance(xTrans, yTrans));
                            AffineTransform inverse = sTx.createInverse();
                            ROI newROI = this.roi != null ? this.roi.transform(inverse) : null;
                            this.roi = newROI.intersect(r);
                        } catch (NoninvertibleTransformException e) {
                            LOGGER.log(Level.SEVERE, e.getMessage(), e);
                        }
                    }
                }
            }
        }

        // check again params, we might have combined two transformations sets
        hasScaleX = Math.abs(tx.getScaleX() - 1) * size > RS_EPS;
        hasScaleY = Math.abs(tx.getScaleY() - 1) * size > RS_EPS;
        hasShearX = Math.abs(tx.getShearX()) * size > RS_EPS;
        hasShearY = Math.abs(tx.getShearY()) * size > RS_EPS;
        hasTranslateX = Math.abs(tx.getTranslateX()) > RS_EPS;
        hasTranslateY = Math.abs(tx.getTranslateY()) > RS_EPS;
        boolean intTranslateX = Math.abs((tx.getTranslateX() - Math.round(tx.getTranslateX()))) < RS_EPS;
        boolean intTranslateY = Math.abs((tx.getTranslateY() - Math.round(tx.getTranslateY()))) < RS_EPS;

        // did it become a identity after the combination?
        if (!hasScaleX && !hasScaleY && !hasShearX && !hasShearY && !hasTranslateX
                && !hasTranslateY) {
            this.image = source;
            return this;
        }
        ParameterBlock pb = new ParameterBlock();
        pb.setSource(source, 0);
        if (!hasShearX && !hasShearY) {
            if (!hasScaleX && !hasScaleY && intTranslateX && intTranslateY) {
                // this will do an integer translate, but to get there we need to remove the image layout
                Hints localHints = new Hints(commonHints);
                localHints.remove(JAI.KEY_IMAGE_LAYOUT);
                pb.set(1.0f, 0);
                pb.set(1.0f, 1);
                pb.set((float) Math.round(tx.getTranslateX()), 2);
                pb.set((float) Math.round(tx.getTranslateY()), 3);
                pb.set(interpolation, 4);
                pb.set(roi, 5);
                pb.set(nodata, 7);
                if (isNoDataNeeded()) {
                    if (background != null && background.length > 0) {
                        pb.set(background, 8);
                        // We must set the new NoData value
                        setNoData(RangeFactory.create(background[0], background[0]));
                    }
                }
                image = JAI.create("Scale", pb, localHints);
                // getting the new ROI property
                if(roi != null){
                    PropertyGenerator gen = new ScaleDescriptor().getPropertyGenerators(RenderedRegistryMode.MODE_NAME)[0];
                    Object prop = gen.getProperty("roi", image);
                    if(prop != null && prop instanceof ROI){
                        setROI((ROI) prop);
                    }
                }

            } else {
                // generic scale
                pb.set((float) tx.getScaleX(), 0);
                pb.set((float) tx.getScaleY(), 1);
                pb.set((float) tx.getTranslateX(), 2);
                pb.set((float) tx.getTranslateY(), 3);
                pb.set(interpolation, 4);
                pb.set(roi, 5);
                pb.set(nodata, 7);
                if (isNoDataNeeded()) {
                    if (background != null && background.length > 0) {
                        pb.set(background, 8);
                        // We must set the new NoData value
                        setNoData(RangeFactory.create(background[0], background[0]));
                    }
                }
                image = JAI.create("Scale", pb, commonHints);
                if (roi != null) {
                    PropertyGenerator gen = new ScaleDescriptor()
                            .getPropertyGenerators(RenderedRegistryMode.MODE_NAME)[0];
                    Object prop = gen.getProperty("roi", image);
                    if (prop != null && prop instanceof ROI) {
                        setROI((ROI) prop);
                    }
                }
            }
        } else {
            pb.set(tx, 0);
            pb.set(interpolation, 1);
            pb.set(bgValues, 2);
            pb.set(roi, 3);
            pb.set(true, 5);
            pb.set(nodata, 6);
            if (isNoDataNeeded()) {
                if (bgValues != null && bgValues.length > 0) {
                    // We must set the new NoData value
                    setNoData(RangeFactory.create(bgValues[0], bgValues[0]));
                }
            }
            image = JAI.create("Affine", pb, commonHints);
            if (roi != null) {
                PropertyGenerator gen = new AffineDescriptor()
                        .getPropertyGenerators(RenderedRegistryMode.MODE_NAME)[0];
                Object prop = gen.getProperty("roi", image);
                if (prop != null && prop instanceof ROI) {
                    setROI((ROI) prop);
                }
            }
        }
        return this;
    }

