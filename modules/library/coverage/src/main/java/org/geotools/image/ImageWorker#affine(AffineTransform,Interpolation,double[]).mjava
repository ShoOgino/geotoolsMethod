    /**
     * Performs an affine transform on the image, applying optimization such as affine removal in case the affine is an identity, affine merging if
     * the affine is applied on top of another affine, and using optimized operations for integer translates
     * 
     * @param tx
     * @param interpolation
     * @param bgValues
     * @return
     */
    public ImageWorker affine(AffineTransform tx, Interpolation interpolation, double[] bgValues) {
        // identity elimination -> check the tx params against the image size to see if
        // any if likely to actually move the image by at least one pixel
        int size = Math.max(image.getWidth(), image.getHeight());
        boolean hasScaleX = Math.abs(tx.getScaleX() - 1) * size > RS_EPS;
        boolean hasScaleY = Math.abs(tx.getScaleY() - 1) * size > RS_EPS;
        boolean hasShearX = Math.abs(tx.getShearX()) * size > RS_EPS;
        boolean hasShearY = Math.abs(tx.getShearY()) * size > RS_EPS;
        boolean hasTranslateX = Math.abs(tx.getTranslateX()) > RS_EPS;
        boolean hasTranslateY = Math.abs(tx.getTranslateY()) > RS_EPS;
        if (!hasScaleX && !hasScaleY && !hasShearX && !hasShearY && !hasTranslateX
                && !hasTranslateY) {
            return this;
        }

        // apply defaults to allow for comparisong
        ParameterListDescriptor pld = getOperationDescriptor("affine").getParameterListDescriptor(RenderedRegistryMode.MODE_NAME);
        if (interpolation == null) {
            interpolation = (Interpolation) pld.getParamDefaultValue("interpolation");
        }
        if (bgValues == null) {
            if (background == null || background.length <= 0) {
                bgValues = (double[]) pld.getParamDefaultValue("backgroundValues");
            } else {
                bgValues = background;
            }
        }
        // Setting the new backgroung values
        background = bgValues;

        // affine over affine/scale?
        RenderedImage source = image;
        if (image instanceof RenderedOp) {
            RenderedOp op = (RenderedOp) image;

            Object mtProperty = op.getProperty("MathTransform");
            Object sourceBoundsProperty = op.getProperty("SourceBoundingBox");
            String opName = op.getOperationName();

            // check if we can do a warp-affine reduction
            final ParameterBlock sourceParamBlock = op.getParameterBlock();
            if (WARP_REDUCTION_ENABLED && "Warp".equals(opName)
                    && mtProperty instanceof MathTransform2D
                    && sourceBoundsProperty instanceof Rectangle) {
                try {
                    // we can merge the affine into the warp
                    MathTransform2D originalTransform = (MathTransform2D) mtProperty;
                    MathTransformFactory factory = ReferencingFactoryFinder
                            .getMathTransformFactory(null);
                    MathTransform affineMT = factory
                            .createAffineTransform(new org.geotools.referencing.operation.matrix.AffineTransform2D(
                                    tx));
                    MathTransform2D chained = (MathTransform2D) factory
                            .createConcatenatedTransform(affineMT.inverse(), originalTransform);

                    // setup the warp builder
                    Double tolerance = (Double) getRenderingHint(Hints.RESAMPLE_TOLERANCE);
                    if (tolerance == null) {
                        tolerance = (Double) Hints.getSystemDefault(Hints.RESAMPLE_TOLERANCE);
                    }
                    if (tolerance == null) {
                        tolerance = 0.333;
                    }

                    // setup a warp builder that is not gong to use too much memory
                    WarpBuilder wb = new WarpBuilder(tolerance);
                    wb.setMaxPositions(4 * 1024 * 1024);

                    // compute the target bbox the same way the affine would have to have a 1-1 match
                    ParameterBlock pb = new ParameterBlock();
                    pb.setSource(source, 0);
                    pb.set(tx, 0);
                    pb.set(interpolation, 1);
                    pb.set(bgValues, 2);
                    pb.set(roi, 3);
                    pb.set(true, 5);
                    pb.set(nodata, 6);
                    RenderedOp at = JAI.create("Affine", pb, getRenderingHints());
                    updateNoData(bgValues, image);

                    // commonHints);
                    Rectangle targetBB = at.getBounds();
                    int tileWidth = at.getTileWidth();
                    int tileHeight = at.getTileHeight();
                    ImageUtilities.disposeSinglePlanarImage(at);
                    Rectangle sourceBB = (Rectangle) sourceBoundsProperty;

                    // warp
                    Rectangle mappingBB;
                    if (source.getProperty("ROI") instanceof ROI) {
                        // Due to a limitation in JAI we need to make sure the
                        // mapping bounding box covers both source and target bounding box
                        // otherwise the warped roi image layout won't be computed properly
                        mappingBB = sourceBB.union(targetBB);
                    } else {
                        mappingBB = targetBB;
                    }
                    Warp warp = wb.buildWarp(chained, mappingBB);

                    // do the switch only if we get a warp that is as fast as the original one
                    Warp sourceWarp = (Warp) sourceParamBlock.getObjectParameter(0);
                    if (warp instanceof WarpGrid
                            || warp instanceof WarpAffine
                            || !(sourceWarp instanceof WarpGrid || sourceWarp instanceof WarpAffine)) {
                        // and then the JAI Operation
                        PlanarImage sourceImage = op.getSourceImage(0);
                        final ParameterBlock paramBlk = new ParameterBlock().addSource(sourceImage);
                        Object property = sourceImage.getProperty("ROI");
                        // Boolean indicating if optional ROI may be reprojected back to the initial image
                        boolean canProcessROI = true;
                        // Boolean indicating if NoData are the same as for the source operation or are not present
                        Range oldNoData = (Range) (sourceParamBlock.getNumParameters() > 3 ? sourceParamBlock.getObjectParameter(4) : null);
                        boolean hasSameNodata = (oldNoData == null && nodata == null) || (oldNoData != null && nodata != null && oldNoData.equals(nodata));
                        if (((property == null) || property.equals(java.awt.Image.UndefinedProperty)
                                || !(property instanceof ROI))) {
                            paramBlk.add(warp).add(interpolation).add(bgValues);
                            if (oldNoData != null) {
                                paramBlk.set(oldNoData, 4);
                            }
                            // Try to reproject ROI after Warp
                            ROI newROI = null;
                            if (roi != null) {
                                ROI reprojectedROI = roi;
                                try {
                                    MathTransform inverse = originalTransform.inverse();
                                    if (inverse instanceof AffineTransform) {
                                        AffineTransform inv = (AffineTransform) inverse;
                                        newROI = reprojectedROI.transform(inv);
                                    }
                                } catch (Exception e) {
                                    if (LOGGER.isLoggable(Level.WARNING)) {
                                        LOGGER.log(
                                                Level.WARNING,
                                                "Unable to compute the inverse of the new ROI provided",
                                                e);
                                    }
                                    // Skip Warp Affine reduction
                                    canProcessROI = false;
                                }
                            }

                            if (newROI != null) {
                                setROI(newROI);
                                paramBlk.set(newROI, 3);
                            }
                        } else {
                            // Intersect ROIs
                            ROI newROI = null;
                            if (roi != null) {
                                // Try to reproject ROI after Warp
                                ROI reprojectedROI = roi;
                                try {
                                    MathTransform inverse = originalTransform.inverse();
                                    if (inverse instanceof AffineTransform) {
                                        AffineTransform inv = (AffineTransform) inverse;
                                        reprojectedROI = reprojectedROI.transform(inv);
                                        newROI = reprojectedROI.intersect((ROI) property);
                                    }
                                } catch (Exception e) {
                                    if (LOGGER.isLoggable(Level.WARNING)) {
                                        LOGGER.log(
                                                Level.WARNING,
                                                "Unable to compute the inverse of the new ROI provided",
                                                e);
                                    }
                                    // Skip Warp Affine reduction
                                    canProcessROI = false;
                                }
                            } else {
                                newROI = (ROI) property;
                            }
                            setROI(newROI);
                            paramBlk.add(warp).add(interpolation).add(newROI);
                            if (oldNoData != null) {
                                paramBlk.set(oldNoData, 4);
                            }
                        }
                        
                        // handle background values
                        if (bgValues == null && sourceParamBlock.getNumParameters() > 2) {
                            bgValues = (double[]) sourceParamBlock.getObjectParameter(2);
                        }
                        if (bgValues != null) {
                            paramBlk.set(bgValues, 2);
                        }

                        // Checks if ROI can be processed
                        if (canProcessROI && hasSameNodata){
                            // force in the image layout, this way we get exactly the same
                            // as the affine we're eliminating
                            Hints localHints = new Hints(getRenderingHints());
                            localHints.remove(JAI.KEY_IMAGE_LAYOUT);
                            ImageLayout il = new ImageLayout();
                            il.setMinX(targetBB.x);
                            il.setMinY(targetBB.y);
                            il.setWidth(targetBB.width);
                            il.setHeight(targetBB.height);

                            il.setTileHeight(tileWidth);
                            il.setTileWidth(tileHeight);
                            il.setTileGridXOffset(0);
                            il.setTileGridYOffset(0);
                            localHints.put(JAI.KEY_IMAGE_LAYOUT, il);

                            RenderedOp result = JAI.create("Warp", paramBlk, localHints);
                            result.setProperty("MathTransform", chained);
                            image = result;
                            // getting the new ROI property
                            Object prop = result.getProperty("roi");
                            if (prop != null && prop instanceof ROI){
                                setROI((ROI) prop);
                            } else {
                                setROI(null);
                            }
                            return this;
                        }
                    }
                } catch (Exception e) {
                    LOGGER.log(
                            Level.WARNING,
                            "Failed to squash warp and affine into a single operation, chaining them instead",
                            e);
                    // move on
                }
            }

            // see if we can merge affine with other affine types then
            if ("Affine".equals(opName)) {
                ParameterBlock paramBlock = sourceParamBlock;
                RenderedImage sSource = paramBlock.getRenderedSource(0);

                AffineTransform sTx = (AffineTransform) paramBlock.getObjectParameter(0);
                Interpolation sInterp = (Interpolation) paramBlock.getObjectParameter(1);
                double[] sBgValues = (double[]) paramBlock.getObjectParameter(2);
                
                Range nodata = null;
                ROI r = null;
                boolean similarROI = true;
                boolean hasSameNodata = true;
                // Minor checks on ROI and NoData
                if(paramBlock.getNumParameters() > 3){
                    nodata = (Range) paramBlock.getObjectParameter(6);
                    r = (ROI)paramBlock.getObjectParameter(3);
                    if(r != null){
                        try {
                            AffineTransform inverse = sTx.createInverse();
                            ROI newROI = this.roi != null ? this.roi.transform(inverse) : null;
                            similarROI = newROI != null && newROI.intersects(r.getBounds());
                        } catch (NoninvertibleTransformException e) {
                            LOGGER.log(Level.SEVERE, e.getMessage(), e);
                        }
                        hasSameNodata = nodata == null
                                || (sBgValues != null && this.nodata != null && sBgValues.length > 0 && sBgValues[0] == this.nodata
                                        .getMin().doubleValue());
                    }
                }

                if ((sInterp == interpolation && Arrays.equals(sBgValues, bgValues))
                        && ((nodata == null || hasSameNodata) && (r == null || similarROI))) {
                    // we can replace it
                    AffineTransform concat = new AffineTransform(tx);
                    concat.concatenate(sTx);
                    tx = concat;
                    source = sSource;
                    if(similarROI && r != null){
                        try {
                            AffineTransform inverse = sTx.createInverse();
                            ROI newROI = this.roi != null ? this.roi.transform(inverse) : null;
                            this.roi = newROI.intersect(r);
                        } catch (NoninvertibleTransformException e) {
                            LOGGER.log(Level.SEVERE, e.getMessage(), e);
                        }
                    }
                    if (hasSameNodata && nodata != null) {
                        setNoData(nodata);
                    }
                }
            } else if (SCALE_NAME.equals(opName)||SCALE2_NAME.equals(opName)) {
                boolean isScale2 = SCALE2_NAME.equals(opName);
                ParameterBlock paramBlock = sourceParamBlock;
                RenderedImage sSource = paramBlock.getRenderedSource(0);

                double[] scalingParams =  getScalingParams(paramBlock, isScale2);
                Interpolation sInterp = (Interpolation) paramBlock.getObjectParameter(4);

                Range nodata = null;
                ROI r = null;
                boolean similarROI = true;
                boolean hasSameNodata =true;
                // Minor checks on ROI and NoData
                final int numParameters = paramBlock.getNumParameters();
                if (numParameters > 5){
                    r = (ROI) paramBlock.getObjectParameter(5);
                    nodata = numParameters > 7 ? (Range) paramBlock.getObjectParameter(7) : null;
                    // The background may haven't been set
                    double[] sBgValues = numParameters > 8 ? (double[]) paramBlock.getObjectParameter(8) : null;
                    if (r != null) {
                        try {
                            ROI newROI = computeScaledROI(scalingParams);
                            similarROI = newROI != null && newROI.intersects(r.getBounds());
                        } catch (NoninvertibleTransformException e) {
                            LOGGER.log(Level.SEVERE, e.getMessage(), e);
                        }
                    }
                    hasSameNodata  = nodata == null
                            || (sBgValues != null && this.nodata != null && sBgValues.length > 0 && sBgValues[0] == this.nodata
                                    .getMin().doubleValue());
                }

                if (sInterp == interpolation && ((nodata == null || hasSameNodata) && (r == null || similarROI))) {
                    // we can replace it
                    AffineTransform concat = new AffineTransform(tx);
                    concat.concatenate(new AffineTransform(scalingParams[0], 0, 0, scalingParams[1], 
                            scalingParams[2], scalingParams[3]));
                    tx = concat;
                    source = sSource;
                    if(similarROI && r != null){
                        try {
                            ROI newROI = computeScaledROI(scalingParams);
                            this.roi = newROI.intersect(r);
                        } catch (NoninvertibleTransformException e) {
                            LOGGER.log(Level.SEVERE, e.getMessage(), e);
                        }
                    }
                    if (hasSameNodata && nodata != null) {
                        setNoData(nodata);
                    }
                }
            }
        }

        // check again params, we might have combined two transformations sets
        hasScaleX = Math.abs(tx.getScaleX() - 1) * size > RS_EPS;
        hasScaleY = Math.abs(tx.getScaleY() - 1) * size > RS_EPS;
        hasShearX = Math.abs(tx.getShearX()) * size > RS_EPS;
        hasShearY = Math.abs(tx.getShearY()) * size > RS_EPS;
        hasTranslateX = Math.abs(tx.getTranslateX()) > RS_EPS;
        hasTranslateY = Math.abs(tx.getTranslateY()) > RS_EPS;
        boolean intTranslateX = Math.abs((tx.getTranslateX() - Math.round(tx.getTranslateX()))) < RS_EPS;
        boolean intTranslateY = Math.abs((tx.getTranslateY() - Math.round(tx.getTranslateY()))) < RS_EPS;
        boolean nonNegativeScaleX = tx.getScaleX() >= 0;
        boolean nonNegativeScaleY = tx.getScaleY() >= 0;

        // did it become a identity after the combination?
        if (!hasScaleX && !hasScaleY && !hasShearX && !hasShearY && !hasTranslateX
                && !hasTranslateY) {
            this.image = source;
            return this;
        }
        ParameterBlock pb = new ParameterBlock();
        pb.setSource(source, 0);
        if (!hasShearX && !hasShearY && nonNegativeScaleX && nonNegativeScaleY) {
            if (!hasScaleX && !hasScaleY && intTranslateX && intTranslateY) {
                // this will do an integer translate, but to get there we need to remove the image
                // layout
                Hints localHints = new Hints(getRenderingHints());
                localHints.remove(JAI.KEY_IMAGE_LAYOUT);
                double [] scalingParams = new double [] {
                        1.0, 1.0, Math.round(tx.getTranslateX()), Math.round(tx.getTranslateY())};
                scale(pb, scalingParams, interpolation, localHints);
                updateNoData(background, image);
                updateROI(false, SCALE_OP_NAME);
            } else {
                // generic scale
                double [] scalingParams = new double [] {
                        tx.getScaleX(), tx.getScaleY(), tx.getTranslateX(), tx.getTranslateY()};
                scale(pb, scalingParams, interpolation, getRenderingHints());
                updateNoData(background, image);
                updateROI(false, SCALE_OP_NAME);
            }
        } else {
            pb.set(tx, 0);
            pb.set(interpolation, 1);
            pb.set(bgValues, 2);
            pb.set(roi, 3);
            pb.set(true, 5);
            pb.set(nodata, 6);
            image = JAI.create("Affine", pb, getRenderingHints());
            updateNoData(bgValues, image);
            updateROI(false, "Affine");
        }
        return this;
    }

