    /**
     * Constructs a new grid geometry from a grid range and a math transform. The arguments are
     * passed unchanged to the {@linkplain GeneralGridGeometry#GeneralGridGeometry(GridEnvelope,
     * MathTransform, CoordinateReferenceSystem) super-class constructor}. However, they must
     * obey to the following additional constraints:
     * <p>
     * <ul>
     *   <li>Only two dimensions in the grid range can have a
     *       {@linkplain GridEnvelope#getSpan span} larger than 1.</li>
     * </ul>
     *
     * @param  gridRange The valid coordinate range of a grid coverage, or {@code null} if none.
     *         The lowest valid grid coordinate is zero for {@link java.awt.image.BufferedImage},
     *         but may be non-zero for arbitrary {@link java.awt.image.RenderedImage}. A grid with
     *         512 cells can have a minimum coordinate of 0 and maximum of 512, with 511 as the
     *         highest valid index.
     * @param  gridToCRS The math transform which allows for the transformations
     *         from grid coordinates (pixel's <em>center</em>) to real world earth coordinates.
     * @param  crs The coordinate reference system for the "real world" coordinates, or {@code null}
     *         if unknown. This CRS is given to the {@linkplain #getEnvelope envelope}.
     *
     * @throws MismatchedDimensionException if the math transform and the CRS don't have
     *         consistent dimensions.
     * @throws IllegalArgumentException if {@code gridRange} has more than 2 dimensions with
     *         a {@linkplain GridEnvelope#getSpan span} larger than 1, or if the math transform
     *         can't transform coordinates in the domain of the specified grid range.
     *
     * @since 2.2
     */
    public GridGeometry2D(final GridEnvelope        gridRange,
                          final MathTransform       gridToCRS,
                          final CoordinateReferenceSystem crs)
            throws IllegalArgumentException, MismatchedDimensionException
    {
        this(gridRange, PixelInCell.CELL_CENTER, gridToCRS, crs, null);
    }

