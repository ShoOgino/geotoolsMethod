    /**
     * Crops the image to the specified bounds. Will use an internal operation that ensures the tile
     * cache and tile scheduler hints are used, and will perform operation elimination in case the
     * crop is doing nothing, or in case the crop is performed over another crop
     *
     * @param x
     * @param y
     * @param width
     * @param height
     * @return
     */
    public ImageWorker crop(float x, float y, float width, float height) {
        // no op elimination
        if (image.getMinX() == x
                && image.getMinY() == y
                && image.getWidth() == width
                && image.getHeight() == height) {
            return this;
        }

        // crop over crop
        RenderedImage source = image;
        if (image instanceof RenderedOp) {
            RenderedOp op = (RenderedOp) image;
            if ("Crop".equals(op.getOperationName()) || "GTCrop".equals(op.getOperationName())) {
                ParameterBlock paramBlock = op.getParameterBlock();
                source = paramBlock.getRenderedSource(0);

                float sx = paramBlock.getFloatParameter(0);
                float sy = paramBlock.getFloatParameter(1);
                float sWidth = paramBlock.getFloatParameter(2);
                float sHeight = paramBlock.getFloatParameter(3);

                Rectangle2D.Float sourceBounds = new Rectangle2D.Float(sx, sy, sWidth, sHeight);
                Rectangle2D.Float bounds = new Rectangle.Float(x, y, width, height);
                Rectangle2D intersection = bounds.createIntersection(sourceBounds);

                x = (float) intersection.getMinX();
                y = (float) intersection.getMinY();
                width = (float) intersection.getWidth();
                height = (float) intersection.getHeight();
            }
        }

        ParameterBlock pb = new ParameterBlock();
        pb.setSource(source, 0);
        pb.set(x, 0);
        pb.set(y, 1);
        pb.set(width, 2);
        pb.set(height, 3);
        pb.set(roi, 4);
        pb.set(nodata, 5);
        if (isNoDataNeeded()) {
            double destinationNoData =
                    nodata != null
                            ? nodata.getMin().doubleValue()
                            : (background != null && background.length > 0)
                                    ? background[0]
                                    : Double.NaN;
            if (!Double.isNaN(destinationNoData)) {
                pb.set(new double[] {destinationNoData}, 6);
            }
        }

        image = JAI.create("Crop", pb, commonHints);
        invalidateStatistics();
        return this;
    }

