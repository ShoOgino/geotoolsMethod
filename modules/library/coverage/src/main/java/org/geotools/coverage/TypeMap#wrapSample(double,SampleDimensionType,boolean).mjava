    /**
     * Wraps the specified value into a number of the specified data type. If the value can't fit in
     * the specified type, then a wider type is choosen unless {@code allowWidening} is {@code
     * false}.
     *
     * @param value The value to wrap in a {@link Number} object.
     * @param type A constant from the {@link SampleDimensionType} code list.
     * @param allowWidening {@code true} if this method is allowed to returns a wider type than the
     *     usual one for the specified {@code type}.
     * @return The value as a {@link Number}.
     * @throws IllegalArgumentException if {@code type} is not a recognized constant.
     * @throws IllegalArgumentException if {@code allowWidening} is {@code false} and the specified
     *     {@code value} can't fit in the specified sample type.
     */
    @SuppressWarnings("fallthrough")
    public static Number wrapSample(
            final double value, final SampleDimensionType type, final boolean allowWidening)
            throws IllegalArgumentException {
        /*
         * Note about 'ordinal' computation: We would like to switch on SampleDimensionType
         * ordinal values. But the compiler requires constant values, and doesn't recognize
         * SampleDimensionType ordinal as such. As a workaround, we use the sample size (in
         * bits) with the following convention: negative value if signed, and offset by 16
         * bits if floating point numbers.
         */
        final TypeMap map = map(type);
        int ordinal = map.size;
        if (map.real) {
            ordinal <<= 16;
        } else if (map.signed) {
            ordinal = -ordinal;
        }
        switch (ordinal) {
            case 1: // Fall through
            case 2: // Fall through
            case 4: // Fall through
            case -8:
                {
                    final byte candidate = (byte) value;
                    if (candidate == value) {
                        return Byte.valueOf(candidate);
                    }
                    if (!allowWidening) break;
                    // Fall through
                }
            case 8: // Fall through
            case -16:
                {
                    final short candidate = (short) value;
                    if (candidate == value) {
                        return Short.valueOf(candidate);
                    }
                    if (!allowWidening) break;
                    // Fall through
                }
            case 16: // Fall through
            case -32:
                {
                    final int candidate = (int) value;
                    if (candidate == value) {
                        return Integer.valueOf(candidate);
                    }
                    if (!allowWidening) break;
                    // Fall through
                }
            case 32:
                {
                    final long candidate = (long) value;
                    if (candidate == value) {
                        return Long.valueOf(candidate);
                    }
                    if (!allowWidening) break;
                    // Fall through
                }
            case (32 << 16):
                {
                    if (!allowWidening || Math.abs(value) <= Float.MAX_VALUE) {
                        return Float.valueOf((float) value);
                    }
                    // Fall through
                }
            case (64 << 16):
                {
                    return Double.valueOf(value);
                }
            default:
                {
                    throw new IllegalArgumentException(
                            Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, "type", type));
                }
        }
        throw new IllegalArgumentException(
                Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, "value", value));
    }

