	/**
     * Create the grid to world (or raster to model) transformation for this
     * source respecting ALWAYS the OGC {@link PixelInCell#CELL_CENTER}
     * convention for the {@link ImageDatum} of the underlying {@link ImageCRS}.
     * 
     * @see <a
     *      href="http://lists.maptools.org/pipermail/geotiff/2006-January/000213.html">this
     *      email post</a>
     * @param metadata
     *            containing the information to build the {@link MathTransform}
     *            for going from grid to world.
     * 
     * @throws GeoTiffException
     */
    public static MathTransform getRasterToModel(final GeoTiffIIOMetadataDecoder metadata) throws GeoTiffException {
        
    	// checks
    	Utilities.ensureNonNull("metadata", metadata);

		//
		// Load initials
		//
		final boolean hasTiePoints = metadata.hasTiePoints();
		final boolean hasPixelScales = metadata.hasPixelScales();
		final boolean hasModelTransformation = metadata.hasModelTrasformation();
		
		// decide raster type
		int rasterType = getGeoKeyAsInt(GeoTiffConstants.GTRasterTypeGeoKey,metadata);
		// geotiff spec says that PixelIsArea is the default
		if (rasterType == GeoTiffConstants.UNDEFINED){
		    rasterType = GeoTiffConstants.RasterPixelIsArea;
		}
		
		// prepare final transform
		MathTransform xform = null;
		if (hasTiePoints && hasPixelScales) {
			
			//
			// we use tie points and pixel scales to build the grid to world
			//
			// model space
			final TiePoint[] tiePoints = metadata.getModelTiePoints();
			final PixelScale pixScales = metadata.getModelPixelScales();

	    	
	    	// logging
	    	if(LOGGER.isLoggable(Level.FINE)){
	    		final StringBuilder builder= new StringBuilder();
	    		builder.append("Logging tiePoints:").append("\n");
	    		for(TiePoint t: tiePoints){
	    			builder.append( t.toString()).append("\n");
	    		}
	    		builder.append("Logging pixScales:").append("\n");
	    		builder.append(pixScales.toString()).append("\n");
	    		LOGGER.log(Level.FINE, builder.toString());
	    	}

			
			// here is the matrix we need to build
			final GeneralMatrix gm = new GeneralMatrix(3);
			final double scaleRaster2ModelLongitude = pixScales.getScaleX();
			final double scaleRaster2ModelLatitude = -pixScales.getScaleY();
			// "raster" space 
			final double tiePointColumn = tiePoints[0].getValueAt(0)+ (rasterType == GeoTiffConstants.RasterPixelIsArea ? - 0.5: 0); 
			
			// coordinates
			// (indicies)
			final double tiePointRow = tiePoints[0].getValueAt(1)+ (rasterType == GeoTiffConstants.RasterPixelIsArea ? - 0.5: 0);

			// compute an "offset and scale" matrix
			gm.setElement(0, 0, scaleRaster2ModelLongitude);
			gm.setElement(1, 1, scaleRaster2ModelLatitude);
			gm.setElement(0, 1, 0);
			gm.setElement(1, 0, 0);

			gm.setElement(0, 2, tiePoints[0].getValueAt(3) - (scaleRaster2ModelLongitude * tiePointColumn));
			gm.setElement(1, 2, tiePoints[0].getValueAt(4) - (scaleRaster2ModelLatitude * tiePointRow));

			// make it a LinearTransform
			xform = ProjectiveTransform.create(gm);

		} else if (hasModelTransformation) {

	    	
			AffineTransform modelTransformation = metadata.getModelTransformation();
			if(modelTransformation==null){
				throw new GeoTiffException(metadata, "Null modelTransformation", null);
			}
	    	// logging
	    	if(LOGGER.isLoggable(Level.FINE)){
	    		final StringBuilder builder= new StringBuilder();
	    		builder.append("Logging ModelTransformation:").append("\n");
	    		builder.append( modelTransformation.toString()).append("\n");
	    		LOGGER.log(Level.FINE, builder.toString());
	    	}
			if (rasterType == GeoTiffConstants.RasterPixelIsArea) {
				final AffineTransform tempTransform = new AffineTransform(modelTransformation);
				tempTransform.concatenate(PixelIsArea2PixelIsPoint);
				xform = ProjectiveTransform.create(tempTransform);

			} else {
				assert rasterType == GeoTiffConstants.RasterPixelIsPoint;
				xform = ProjectiveTransform.create(modelTransformation);

			}
		} else{			
			throw new GeoTiffException(metadata,"Unknown Raster to Model configuration.", null);
		}

		
		// final check, is this invertible at all?
		try{
			xform.inverse();
		}catch(Exception e){
			if(LOGGER.isLoggable(Level.FINE)){
				LOGGER.log(Level.FINE,"Invalid model transformation found!\n"+e.getLocalizedMessage(),e);
			}
			
			return null;
		}
		return xform;
	}

