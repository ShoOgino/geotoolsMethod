	/**
	 * Interpolate at the specified position. If {@code fallback!=null},
	 * then {@code dest} <strong>must</strong> have been initialized with
	 * {@code super.evaluate(...)} prior to invoking this method.
	 *
	 * @param x      The x position in pixel's coordinates.
	 * @param y      The y position in pixel's coordinates.
	 * @param dest   The destination array, or null.
	 * @param band   The first band's index to interpolate.
	 * @param bandUp The last band's index+1 to interpolate.
	 * @return {@code null} if point is outside grid coverage.
	 */
	private synchronized double[] interpolate(final double x, final double y,
	                                          double[] dest, int band, final int bandUp)
	{
	    final double x0 = Math.floor(x);
	    final double y0 = Math.floor(y);
	    final int    ix = (int)x0;
	    final int    iy = (int)y0;
	    if (!(ix>=xmin && ix<=xmax && iy>=ymin && iy<=ymax)) 
	        return null;
	    
	    /*
	     * Creates buffers, if not already created.
	     */
	    double[][] samples = doubles;
	    if (samples == null) {
	        final int rowCount = interpolation.getHeight();
	        final int colCount = interpolation.getWidth();
	        doubles = samples = new double[rowCount][];
	        for (int i=0; i<rowCount; i++) {
	            samples[i] = new double[colCount];
	        }
	    }
	    if (dest == null) {
	        dest = new double[bandUp];
	    }
	    /*
	     * Builds up a RectIter and use it for interpolating all bands.
	     * There is very few points, so the cost of creating a RectIter
	     * may be important. But it seems to still lower than query tiles
	     * many time (which may involve more computation than necessary).
	     */
	    bounds.x = ix - left;
	    bounds.y = iy - top;
	    final RectIter iter = RectIterFactory.create(image.getExtendedData(bounds, this.borderExtender), bounds);
	    for (; band<bandUp; band++) {
	        iter.startLines();
	        int j=0; do {
	            iter.startPixels();
	            final double[] row=samples[j++];
	            int i=0; do {
	                row[i++] = iter.getSampleDouble(band);
	            }
	            while (!iter.nextPixelDone());
	            assert i == row.length;
	        }
	        while (!iter.nextLineDone());
	        assert j == samples.length;
	        float dx = (float)(x-x0); if (dx==1) dx=ONE_EPSILON;
	        float dy = (float)(y-y0); if (dy==1) dy=ONE_EPSILON;
	        final double value = interpolation.interpolate(samples, dx, dy);
	        if (Double.isNaN(value)) {
	            if (fallback == this) continue; // 'dest' was set by 'super.evaluate(...)'.
	            if (fallback != null) {
	                fallback.interpolate(x, y, dest, band, band+1);
	                continue;
	            }
	            // If no fallback was specified, then 'dest' is not required to
	            // have been initialized. It may contains random value.  Set it
	            // to the NaN value...
	        }
	        dest[band] = value;
	    }
	    return dest;
	}

