    /**
     * Retrieves a best guess for the sample value to use for background,
     * inspecting the categories of the provided {@link GridCoverage2D}.
     *
     * @param coverage to use for guessing background values.
     * @return an array of double values to use as a background.
     */
	public static double[] getBackgroundValues(GridCoverage2D coverage) {
		
		//minimal checks
		if(coverage==null){
			throw new NullPointerException(Errors.format(ErrorKeys.NULL_PARAMETER_$2, "coverage","GridCoverage2D"));
		}
		
		// try to get the GC_NODATA double value from the coverage property
		final Object noData=coverage.getProperty("GC_NODATA");
		if(noData!=null&& noData instanceof Number){
			return new double[]{((Double)noData).doubleValue()};
		}
		
        ////
		//
		// Try to gather no data values from the sample dimensions
		// and, if not available, we try to suggest them from the sample
		// dimension type
		//
		////
        final GridSampleDimension[] sampleDimensions = coverage.getSampleDimensions();
        final double[] background = new double[sampleDimensions.length];
        
        boolean found=false;
        final int dataType = coverage.getRenderedImage().getSampleModel().getDataType();
        for (int i=0; i<background.length; i++) {
        	// try to use the no data category if preset
        	final List<Category> categories = sampleDimensions[i].getCategories();
        	if(categories!=null&&categories.size()>0){
        		for(Category category:categories){
        			if(category.getName().equals(NODATA)){
        				background[i]=category.getRange().getMinimum();
        				found=true;
        				break;
        			}
        		}
        	}
        	
        	if(!found){
        		// we don't have a proper no data value, let's try to suggest something 
        		// meaningful fro mthe data type for this coverage
            	background[i]=suggestNoDataValue(dataType).doubleValue();
        	}
        	
//          SG 25112012, removed this automagic behavior        	
//            final NumberRange<?> range = sampleDimensions[i].getBackground().getRange();
//            final double min = range.getMinimum();
//            final double max = range.getMaximum();
//            if (range.isMinIncluded()) {
//                background[i] = min;
//            } else if (range.isMaxIncluded()) {
//                background[i] = max;
//            } else {
//                background[i] = 0.5 * (min + max);
//            }
        }
        return background;
    }

