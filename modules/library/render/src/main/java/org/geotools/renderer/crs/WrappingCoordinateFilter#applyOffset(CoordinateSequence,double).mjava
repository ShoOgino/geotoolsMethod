    private void applyOffset(CoordinateSequence cs, double offset) {
        final double maxWrap = wrapLimit * 1.9;
        double lastX = cs.getX(0);
        for (int i = 0; i < cs.size(); i++) {
            final double x = cs.getX(i);
            final double distance = Math.abs(x - lastX);
            // heuristic: an object crossing the dateline is not as big as the world, if it
            // is, it's probably something like Antarctica that does not need coordinate rewrapping
            if (distance > wrapLimit) {
                boolean wraps = distance < maxWrap;
                // if we fail here, revert to more expensive calculation if
                // we have a reverse transform
                // this is analagous to the technique mentioned here:
                // http://trac.osgeo.org/mapserver/ticket/15
                if (!wraps && mt != null) {
                    // convert back to projected coordinates
                    double[] src = new double[]{lastX, cs.getY(i - 1), x, cs.getY(i)};
                    double[] dest = new double[4];
                    try {
                        mt.transform(src, 0, dest, 0, 2);
                        // find the midpoint coordinate
                        src[0] = Math.min(dest[0], dest[2]) + Math.abs(dest[2] - dest[0]) / 2;
                        src[1] = Math.min(dest[1], dest[3]) + Math.abs(dest[3] - dest[1]) / 2;
                        // and convert back again
                        mt.inverse().transform(src, 0, dest, 0, 1);
                        // if the midpoint isn't between the two end points, it's a wrap
                        wraps = !(dest[0] > Math.min(lastX, x) && dest[0] < Math.max(lastX, x));
                    } catch (TransformException ex) {
                        Logging.getLogger("org.geotools.rendering").log(Level.WARNING,
                                "Unable to perform transform to detect dateline wrapping", ex);
                    }
                }
                // toggle between offset
                if (wraps) {
                    if (offset != 0) {
                        offset = 0;
                    } else {
                        offset = wrapLimit * 2;
                    }
                }
            }

            if (offset != 0)
                cs.setOrdinate(i, 0, x + offset);
            
            lastX = x;
        }
    }

