	/**
	 * Performs a gamma correction operation on the input image.
	 * 
	 * @param inputImage the input {@link RenderedImage} to work on.
	 * @param hints {@link Hints} to control the contrast enhancement process.
	 * @return a {@link RenderedImage} on which a gamma correction has been performed.
	 */
	private RenderedImage performGammaCorrection(
			final RenderedImage inputImage,
			final Hints hints) {
		//note that we should work on a single band
		assert inputImage.getSampleModel().getNumBands() == 1:inputImage;
		
		final int dataType=inputImage.getSampleModel().getDataType();
		RenderedImage result=inputImage;
		if (!Double.isNaN(gammaValue) && Math.abs(gammaValue - 1.0) > 1E-6) {
			if (dataType == DataBuffer.TYPE_BYTE) {

				////
				//
				// Byte case, use lookup to optimize
				// 
				////
				final byte[] lut = new byte[256];
				for (int i = 1; i < lut.length; i++)
					lut[i] = (byte) (255.0 * Math.pow(i / 255.0, gammaValue) + 0.5d);

				// apply the operation now
				final LookupTableJAI lookup = new LookupTableJAI(lut);
				final ParameterBlock pb = new ParameterBlock();
				pb.addSource(inputImage);
				pb.add(lookup);
				result = JAI.create("lookup", pb, hints);
			}
			else
			{
				////
				//
				// Generic case
				// 
				////
				//
				// STEP 1 do the extrema
				//
				////
				//step 1 do the extrema to get the statistics for this image
				final RenderedOp statistics = ExtremaDescriptor.create(inputImage,
						null, Integer.valueOf(1), Integer.valueOf(1), null,
						Integer.valueOf(1), null);
				final double[] minimum=(double[]) statistics.getProperty("minimum");
				final double[] maximum=(double[]) statistics.getProperty("maximum");
				final double scale  = (maximum[0]-minimum[0])/(MAX_VALUE-MIN_VALUE);
		                final double offset = minimum[0] - MIN_VALUE*scale;
				////
				//
				// STEP 2 do the gamma correction by using generic piecewise
				//
				////
				final DefaultPiecewiseTransform1DElement mainElement = DefaultPiecewiseTransform1DElement.create(
						"gamma-correction-transform", NumberRange.create(minimum[0],maximum[0]), 
						new MathTransform1DAdapter() {

									/*
									 * (non-Javadoc)
									 * @see org.opengis.referencing.operation.MathTransform1D#derivative(double)
									 */
									public double derivative(double value)
											throws TransformException {
										
										throw new UnsupportedOperationException(Errors.format(ErrorKeys.UNSUPPORTED_OPERATION_$1));
									}
									public boolean isIdentity() {
										return false;
									}
									/*
									 * (non-Javadoc)
									 * @see org.opengis.referencing.operation.MathTransform1D#transform(double)
									 */
									public double transform(double value)
											throws TransformException {
										value = (value-offset)/scale;
										return offset+Math.pow(value, gammaValue)*scale;
									}

						});
				
				final PiecewiseTransform1D<DefaultPiecewiseTransform1DElement>  transform = new DefaultPiecewiseTransform1D<DefaultPiecewiseTransform1DElement> (
						new DefaultPiecewiseTransform1DElement[] {mainElement},0);

					final ParameterBlockJAI pbj = new ParameterBlockJAI(
							GenericPiecewise.OPERATION_NAME);
					pbj.addSource(inputImage);
					pbj.setParameter("Domain1D", transform);
					pbj.setParameter("bandIndex", Integer.valueOf(0));
					result = JAI.create(
							GenericPiecewise.OPERATION_NAME, pbj);
			}
		}
		assert result.getSampleModel().getNumBands() == 1:result;
		return result;
	}

