    /**
     * Generate a {@link ColorMap} object, by updating the ColorMapEntries quantities on top of the min and max values reported here.
     * @param min
     * @param max
     * @return
     */
    public ColorMap generateColorMap(double min, double max) {
        final int numEntries = entries.length;
        final double range = max - min;
        boolean intervals = false;

        // Preliminar check on intervals vs ramp
        for (int i = 0; i < numEntries - 2; i += 2) {
            if (Double.compare(entries[i + 1].percentage, entries[i + 2].percentage) == 0) {
                intervals = true;
            } else {
                intervals = false;
            }
        }
        ColorMap colorMap = new ColorMapImpl();

        // Adding transparent color entry before the min
        final double offset = 0 /* intervals ? 0 : 1E-2 */;
        double start = min - offset;
        ColorMapEntry startEntry = entries[0].getColorMapEntry(start);
        fillColorInEntry(startEntry, beforeColor);
        colorMap.addColorMapEntry(startEntry);

        if (intervals) {
            colorMap.setType(ColorMap.TYPE_INTERVALS);
            for (int i = 1; i < numEntries - 1; i += 2) {
                colorMap.addColorMapEntry(entries[i].getColorMapEntry(min, range));
            }
        } else {
            colorMap.setType(ColorMap.TYPE_RAMP);
            for (int i = 0; i < numEntries - 1; i ++) {
                colorMap.addColorMapEntry(entries[i].getColorMapEntry(min, range));
            }
        }
        colorMap.addColorMapEntry(entries[numEntries - 1].getColorMapEntry(max));

        // Adding transparent color entry after the max
        ColorMapEntry endEntry = entries[numEntries - 1].getColorMapEntry(max + offset);
        fillColorInEntry(endEntry, afterColor);
        colorMap.addColorMapEntry(endEntry);

        return colorMap;
    }

