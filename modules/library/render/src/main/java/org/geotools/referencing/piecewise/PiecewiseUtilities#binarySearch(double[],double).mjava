	/**
	 * Effectue une recherche bi-lin�aire de la valeur sp�cifi�e. Cette m�thode
	 * est semblable � {@link Arrays#binarySearch(double[],double)}, except�
	 * qu'elle peut distinguer diff�rentes valeurs de NaN.
	 * 
	 * Note: This method is not private in order to allows testing by {@link }.
	 */
	static int binarySearch(final double[] array, final double val) {
		int low = 0;
		int high = array.length - 1;
		final boolean keyIsNaN = Double.isNaN(val);
		while (low <= high) {
			final int mid = (low + high) >> 1;
			final double midVal = array[mid];
			if (midVal < val) { // Neither val is NaN, midVal is smaller
				low = mid + 1;
				continue;
			}
			if (midVal > val) { // Neither val is NaN, midVal is larger
				high = mid - 1;
				continue;
			}
			/*
			 * The following is an adaptation of evaluator's comments for bug
			 * #4471414
			 * (http://developer.java.sun.com/developer/bugParade/bugs/4471414.html).
			 * Extract from evaluator's comment:
			 * 
			 * [This] code is not guaranteed to give the desired results because
			 * of laxity in IEEE 754 regarding NaN values. There are actually
			 * two types of NaNs, signaling NaNs and quiet NaNs. Java doesn't
			 * support the features necessary to reliably distinguish the two.
			 * However, the relevant point is that copying a signaling NaN may
			 * (or may not, at the implementors discretion) yield a quiet NaN --
			 * a NaN with a different bit pattern (IEEE 754 6.2). Therefore, on
			 * IEEE 754 compliant platforms it may be impossible to find a
			 * signaling NaN stored in an array since a signaling NaN passed as
			 * an argument to binarySearch may get replaced by a quiet NaN.
			 */
			final long midRawBits = Double.doubleToRawLongBits(midVal);
			final long keyRawBits = Double.doubleToRawLongBits(val);
			if (midRawBits == keyRawBits) {
				return mid; // key found
			}
			final boolean midIsNaN = Double.isNaN(midVal);
			final boolean adjustLow;
			if (keyIsNaN) {
				// If (mid,key)==(!NaN, NaN): mid is lower.
				// If two NaN arguments, compare NaN bits.
				adjustLow = (!midIsNaN || midRawBits < keyRawBits);
			} else {
				// If (mid,key)==(NaN, !NaN): mid is greater.
				// Otherwise, case for (-0.0, 0.0) and (0.0, -0.0).
				adjustLow = (!midIsNaN && midRawBits < keyRawBits);
			}
			if (adjustLow)
				low = mid + 1;
			else
				high = mid - 1;
		}
		return -(low + 1); // key not found.
	}

