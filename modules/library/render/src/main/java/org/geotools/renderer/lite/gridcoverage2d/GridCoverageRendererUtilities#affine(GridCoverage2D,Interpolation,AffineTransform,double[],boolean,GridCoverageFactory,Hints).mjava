    /** Apply an affineTransformation to a GridCoverage */
    public static GridCoverage2D affine(
            GridCoverage2D coverage,
            Interpolation interpolation,
            AffineTransform affineTransform,
            double[] bkgValues,
            boolean useInputSampleDimensions,
            GridCoverageFactory gridCoverageFactory,
            Hints hints) {
        final RenderedImage finalImage = coverage.getRenderedImage();
        final GridGeometry2D gridGeometry = coverage.getGridGeometry();
        // I need to translate half of a pixel since in wms the envelope map
        // to the corners of the raster space not to the center of the pixels
        final MathTransform2D finalGCTransform =
                gridGeometry.getGridToCRS2D(PixelOrientation.UPPER_LEFT);
        if (!(finalGCTransform instanceof AffineTransform)) {
            throw new UnsupportedOperationException(
                    "Non-affine transformations not yet implemented"); // TODO
        }
        final AffineTransform finalGCgridToWorld =
                new AffineTransform((AffineTransform) finalGCTransform);

        // Getting NOData and ROI
        Range noData =
                CoverageUtilities.getNoDataProperty(coverage) != null
                        ? CoverageUtilities.getNoDataProperty(coverage).getAsRange()
                        : null;
        ROI roi = CoverageUtilities.getROIProperty(coverage);

        // //
        //
        // I am going to concatenate the final world to grid transform
        // with the grid to world transform of the input coverage.
        //
        // This way i right away position the coverage at the right place in the
        // area of interest for the device.
        //
        // //
        final AffineTransform finalRasterTransformation = (AffineTransform) affineTransform.clone();
        finalRasterTransformation.concatenate(finalGCgridToWorld);

        // paranoiac check to avoid that JAI freaks out when computing its internal
        // layout on images that are too small
        ImageLayout finalLayout =
                Scale2OpImage.layoutHelper(
                        finalImage,
                        (float) Math.abs(finalRasterTransformation.getScaleX()),
                        (float) Math.abs(finalRasterTransformation.getScaleY()),
                        (float) finalRasterTransformation.getTranslateX(),
                        (float) finalRasterTransformation.getTranslateY(),
                        interpolation,
                        null);
        if (finalLayout.getWidth(null) < 1 || finalLayout.getHeight(null) < 1) {
            if (LOGGER.isLoggable(java.util.logging.Level.FINE))
                LOGGER.fine("Unable to create a granuleDescriptor due to jai scale bug");
            return null;
        }

        RenderedImage im = null;

        ImageWorker iw = new ImageWorker(finalImage);
        iw.setRenderingHints(hints);
        iw.setROI(roi);
        iw.setNoData(noData);
        iw.affine(finalRasterTransformation, interpolation, bkgValues);
        im = iw.getRenderedImage();
        roi = iw.getROI();
        noData = iw.extractNoDataProperty(im);

        // recreate gridCoverage
        int numBands = im.getSampleModel().getNumBands();
        GridSampleDimension[] sd = new GridSampleDimension[numBands];
        for (int i = 0; i < numBands; i++) {
            sd[i] =
                    new GridSampleDimension(
                            useInputSampleDimensions
                                    ? coverage.getSampleDimension(i).getDescription()
                                    : TypeMap.getColorInterpretation(im.getColorModel(), i).name());
        }

        @SuppressWarnings("unchecked")
        Map<String, Object> properties = coverage.getProperties();
        if (properties == null) {
            properties = new HashMap<>();
        }
        CoverageUtilities.setNoDataProperty(properties, noData);
        CoverageUtilities.setROIProperty(properties, roi);

        // create a new grid coverage but preserve as much input as possible
        return gridCoverageFactory.create(
                coverage.getName(),
                im,
                new GridGeometry2D(
                        new GridEnvelope2D(PlanarImage.wrapRenderedImage(im).getBounds()),
                        coverage.getEnvelope()),
                sd,
                new GridCoverage[] {coverage},
                properties);
    }

