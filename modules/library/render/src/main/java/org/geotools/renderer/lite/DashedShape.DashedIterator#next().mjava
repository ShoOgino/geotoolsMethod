        public void next() {
            // have we exhausted the previous segment?
            if (segmentLength == 0) {
                if (!delegate.isDone()) {
                    prevCoords[0] = currCoords[0];
                    prevCoords[1] = currCoords[1];
                    lastType = delegate.currentSegment(currCoords);
                    dx = currCoords[0] - prevCoords[0];
                    dy = currCoords[1] - prevCoords[1];
                    segmentLength = (float) sqrt(pow(dx, 2) + pow(dy, 2));
                    segmentOffset = 0;
                    delegate.next();
                } else {
                    done = true;
                }
            }
            // if not done move along the dash array
            if (!done) {
                // we treat moveto as a lineto for simplicity, this will result
                // in a series of moveto instead of a single one. No big deal,
                // graphic stroking is not meant to be fast
                float dashResidual = dashOffsets[dashIndex] - dashOffset;
                float segmentResidual = segmentLength - segmentOffset;
                float residual = min(dashResidual, segmentResidual);
                if (abs(segmentLength) > EPS) {
                    dashedSegment[0] = dashedSegment[0] + dx * residual / segmentLength;
                    dashedSegment[1] = dashedSegment[1] + dy * residual / segmentLength;
                }
                // if the lastType is a line to we need to decide if we're pen down or pen
                // up depending on what of the dash segments we're in
                if (lastType == PathIterator.SEG_LINETO) {
                    dashedType = dashIndex % 2 == 0 ? PathIterator.SEG_LINETO
                            : PathIterator.SEG_MOVETO;
                } else {
                    dashedType = lastType;
                }

                // move forward
                dashOffset += residual;
                segmentOffset += residual;

                // move forward along the dash array
                if (abs(dashOffsets[dashIndex] - dashOffset) < EPS) {
                    dashIndex++;
                    if (dashIndex >= dashOffsets.length) {
                        dashIndex = 0;
                        dashOffset = 0;
                    }
                }

                // more forward along the segment
                if (abs(segmentOffset - segmentLength) < EPS) {
                    segmentLength = 0;
                    segmentOffset = 0;
                }
            }
        }

