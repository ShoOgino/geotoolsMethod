	/**
	 * Returns the first font associated to the feature that can be found on the
	 * current machine
	 * 
	 * @param feature
	 *            The feature whose font is to be found
	 * @param fonts
	 *            An array of fonts dependent of the feature, the first that is
	 *            found on the current machine is returned
	 * 
	 * @return The first of the specified fonts found on this machine or null if
	 *         none found
	 */
	private java.awt.Font getFont(Object feature, Font[] fonts) {
		if (fonts != null) {
			for (int k = 0; k < fonts.length; k++) {
				String requestedFont = evalToString(fonts[k].getFontFamily(),
						feature, null);
				java.awt.Font javaFont = FontCache.getDefaultInstance()
						.getFont(requestedFont);

				if (javaFont != null) {
					String reqStyle = evalToString(fonts[k].getFontStyle(),
							feature, null);

					int styleCode;
					if (fontStyleLookup.containsKey(reqStyle)) {
						styleCode = ((Integer) fontStyleLookup.get(reqStyle))
								.intValue();
					} else {
						styleCode = java.awt.Font.PLAIN;
					}

					String reqWeight = evalToString(fonts[k].getFontWeight(),
							feature, null);

					if ("Bold".equalsIgnoreCase(reqWeight)) {
						styleCode = styleCode | java.awt.Font.BOLD;
					}

					int size = evalToInt(fonts[k].getFontSize(), feature, 10);

					return javaFont.deriveFont(styleCode, size);
				}
			}
		}

		// if everything else fails fall back on a default font distributed
		// along with the jdk (default font size is 10 pixels by spec... here we
		// are using points thoughts)
		return new java.awt.Font("Serif", java.awt.Font.PLAIN, 12);
	}

