	/**
	 * Returns the domain element of the specified sample value. If no domain element fits,
	 * then this method returns {@code null}.
	 * 
	 * @param value
	 *            The value.
	 * @return The domain element of the supplied value, or {@code null}.
	 */
	public E findDomainElement(final double value) {

		int i = getDomainElementIndex(value);

		// //
		//
		// Checks
		//
		// //
		if (i < 0)
			return null;
		E domainElement1D;
		if (i > elements.length)
			return null;

		// //
		//
		// First of all let's check if we spotted a break point in out domains
		// element. If so the index we got is not an insertion point but it is
		// an actual domain element index. This happens when we catch precisely
		// a minimum element for a domain.
		//
		// //
		if (i < elements.length) {
			domainElement1D = elements[i];
			if (domainElement1D.contains(value))
				return  domainElement1D;
			// if the index was 0, unless we caught the smallest minimum we have
			// got something smaller than the leftmost domain
			if (i == 0)
				return null;
		}
		// //
		//
		// Ok, now we know that we did not precisely caught a minimum for a
		// domain, we therefore got an insertion point. This means that, unless
		// we have fallen into a gap we need to subtract 1 to check for
		// inclusion in the right domain.
		//
		// //
		domainElement1D = elements[i - 1];
		if (domainElement1D.contains(value))
			return  domainElement1D;

		// //
		//
		// Well, if we get here, we have definitely fallen into a gap or the
		// value is beyond the limits of the last domain, too bad....
		//
		// //
		assert i >= elements.length || hasGaps : value;
		return null;
	}

