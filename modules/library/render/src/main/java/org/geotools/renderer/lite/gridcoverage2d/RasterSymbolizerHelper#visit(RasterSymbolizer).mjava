    /*
     * (non-Javadoc)
     *
     * @see org.geotools.renderer.lite.gridcoverage2d.StyleVisitorAdapter#visit(org.geotools.styling.RasterSymbolizer)
     */
    @Override
    public void visit(RasterSymbolizer rs) {

        ColorMapUtilities.ensureNonNull("RasterSymbolizer", rs);

        // /////////////////////////////////////////////////////////////////////
        //
        // Create the various nodes we'll use for executing this
        // RasterSymbolizer
        //
        // /////////////////////////////////////////////////////////////////////
        // the source node for the internal chains
        // final RootNode sourceNode = new RootNode(sourceCoverage, adopt,
        // hints);

        CoverageProcessingNode prevNode = this.getSource(0);

        // /////////////////////////////////////////////////////////////////////
        //
        // CHANNEL SELECTION
        //
        // /////////////////////////////////////////////////////////////////////

        final ChannelSelectionNode csNode = new ChannelSelectionNode();
        CoverageProcessingNode currNode = csNode;

        currNode.addSource(prevNode);
        prevNode = currNode;

        final ChannelSelection cs = rs.getChannelSelection();
        csNode.visit(cs);

        // /////////////////////////////////////////////////////////////////////
        //
        // COLOR MAP
        //
        // /////////////////////////////////////////////////////////////////////

        final ColorMapNode cmNode = new ColorMapNode(this.getHints());
        currNode = cmNode;

        currNode.addSource(prevNode);
        prevNode.addSink(currNode);
        prevNode = currNode;

        final ColorMap cm = rs.getColorMap();
        cmNode.visit(cm);

        // /////////////////////////////////////////////////////////////////////
        //
        // CONTRAST ENHANCEMENT
        //
        // /////////////////////////////////////////////////////////////////////

        final ContrastEnhancementNode ceNode = new ContrastEnhancementNode(this.getHints());
        currNode = ceNode;

        currNode.addSource(prevNode);
        prevNode.addSink(currNode);
        prevNode = currNode;

        final ContrastEnhancement ce = rs.getContrastEnhancement();
        ceNode.visit(ce);

        // /////////////////////////////////////////////////////////////////////
        //
        // SHADED RELIEF
        //
        // /////////////////////////////////////////////////////////////////////

        final ShadedReliefNode srNode = new ShadedReliefNode(this.getHints());
        final ShadedRelief sr = rs.getShadedRelief();
        srNode.visit(sr);
        currNode = srNode;

        // TODO: Think about ContrastEnhancement and shadedRelief conflicts
        // signal them through an Exception
        boolean applyShadedRelief = !Double.isNaN(srNode.getReliefFactor());
        boolean applyContrastEnhancement = ceNode.getType() != null;
        if (applyShadedRelief && applyContrastEnhancement) {
            throw new IllegalArgumentException(
                    "ContrastEnhancement and ShadedRelief can't be applied at the same time. ");
        }

        if (applyShadedRelief) {
            // not the usual prev/curr links here, since SR does not need CE processing
            currNode.addSource(cmNode);
            prevNode.addSink(currNode);
            setSink(currNode);

        } else {

            setSink(prevNode);
        }

        /////////////////////////////////////////////////////////////////////
        //
        // OPACITY
        //
        /////////////////////////////////////////////////////////////////////
        final Expression op = rs.getOpacity();
        if (op != null) {
            final Number number = op.evaluate(null, Float.class);
            if (number != null) {
                opacity = number.floatValue();
            }
        }
    }

