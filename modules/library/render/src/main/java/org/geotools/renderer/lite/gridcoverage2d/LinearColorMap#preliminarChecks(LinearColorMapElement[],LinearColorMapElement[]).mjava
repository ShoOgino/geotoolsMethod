	/**
	 * Performing additional check on the provided domain elements in order to
	 * control that we don't have any strange overlap in the output values which
	 * could leave to strange color effect.
	 * 
	 * @param domainElements
	 *            to check.
	 * @param nodata
	 *            category if we have any.
	 * @return the original {@link LinearColorMapElement} if nothing went
	 *         wrong.
	 */
	private static void preliminarChecks(
			final LinearColorMapElement[] domainElements, 
			final LinearColorMapElement[] domainElementsToPreserve) {

		// /////////////////////////////////////////////////////////////////////
		//
		// Cycle on all the domain elements to preserve
		//
		// /////////////////////////////////////////////////////////////////////
		ColorMapUtilities.checkPreservingElements(domainElementsToPreserve);
		
		// /////////////////////////////////////////////////////////////////////
		//
		// Cycle on all the domain elements and compare them to all the others
		//
		// /////////////////////////////////////////////////////////////////////
		final int num = 
			domainElementsToPreserve != null ? 
				domainElements.length + domainElementsToPreserve.length
				: domainElements.length;
		for (int i = 0; i < num; i++) {
			final DefaultLinearPiecewiseTransform1DElement c0 = 
				i >= domainElements.length ? 
						(DefaultLinearPiecewiseTransform1DElement) domainElementsToPreserve[i- domainElements.length]:
							(DefaultLinearPiecewiseTransform1DElement) domainElements[i];
			final ColorMapTransformElement v0 = (ColorMapTransformElement) c0;
			final NumberRange<? extends Number> outRange0 = c0.getOutputRange();
			final Color[] colors0 = v0.getColors();
			final int minimum0 = (int) outRange0.getMinimum();
			final int maximum0 = (int) outRange0.getMaximum();
			// ////////////////////////////////////////////////////////////////
			//
			// Check the c0 categories with all the others
			//
			// ////////////////////////////////////////////////////////////////
			for (int j = 0; j < num; j++) {
				// don't check a category with itself.
				if (j == i)
					continue;
				// //
				//
				// We allow two LinearColorMapElement output ranges to overlap only if they
				// map to a single value and they use the same color for it.
				// Every other case is marked as an error either because it is
				// an error or because it was too hard to support.
				//
				// //
				final DefaultLinearPiecewiseTransform1DElement c1 = 
					j >= domainElements.length ? (
							DefaultLinearPiecewiseTransform1DElement) domainElementsToPreserve[j- domainElements.length]:
								(DefaultLinearPiecewiseTransform1DElement) domainElements[j];
				final ColorMapTransformElement v1 = (ColorMapTransformElement) c1;
				final NumberRange<? extends Number> outRange1 = c1.getOutputRange();
				if (outRange1.intersects(outRange0)) {
					
					// do they intersect?
					if(!outRange0.intersects(outRange1))
						continue;
					
					// they intersect!!!
					
			
					//check the values
					final int minimum1 = (int) outRange1.getMinimum();
					final int maximum1 = (int) outRange1.getMaximum();
					final Color[] colors1 = v1.getColors();
					if (minimum1==maximum0&&colors0[colors0.length-1].equals(colors1[0]))
						continue;

					if (minimum0==maximum1&&colors1[colors1.length-1].equals(colors0[0]))
						continue;

					throw new IllegalArgumentException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, c0, c1));
					// now check the colors

//					if (colors1.length != colors0.length)
//						throw new IllegalArgumentException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, new Integer(colors0.length), new Integer(colors1.length)));
//					if(!Arrays.equals(colors1, colors0))
//						throw new IllegalArgumentException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, new Integer(colors1.length), new Integer(colors1.length)));

//					if (colors1.length != 1)
//						throw new IllegalArgumentException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, new Integer(colors1.length), new Integer(1)));
//
//					if (!colors0[0].equals(colors1[0]))
//						throw new IllegalArgumentException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, colors0[0], colors1[0]));

				}
			}

		}
	}

