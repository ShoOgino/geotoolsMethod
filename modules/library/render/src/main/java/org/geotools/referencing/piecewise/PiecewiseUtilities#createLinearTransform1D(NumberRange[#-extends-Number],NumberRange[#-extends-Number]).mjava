	/**
	 * Create a linear transform mapping values from {@code sampleValueRange} to
	 * {@code geophysicsValueRange}.
	 */
	static MathTransform1D createLinearTransform1D(
			final NumberRange<? extends Number> sourceRange, final NumberRange<? extends Number> destinationRange) {
		final Class<? extends Number> sType = sourceRange.getElementClass();
		final Class<? extends Number> dType = destinationRange.getElementClass();
		/*
		 * First, find the direction of the adjustment to apply to the ranges if
		 * we wanted all values to be inclusives. Then, check if the adjustment
		 * is really needed: if the values of both ranges are inclusive or
		 * exclusive, then there is no need for an adjustment before computing
		 * the coefficient of a linear relation.
		 */
		int sMinInc = sourceRange.isMinIncluded() ? 0 : +1;
		int sMaxInc = sourceRange.isMaxIncluded() ? 0 : -1;
		int dMinInc = destinationRange.isMinIncluded() ? 0 : +1;
		int dMaxInc = destinationRange.isMaxIncluded() ? 0 : -1;

		/*
		 * Now, extracts the minimal and maximal values and computes the linear
		 * coefficients.
		 */
		final double minSource = doubleValue(sType, sourceRange.getMinValue(),
				sMinInc);
		final double maxSource = doubleValue(sType, sourceRange.getMaxValue(),
				sMaxInc);
		final double minDestination = doubleValue(dType, destinationRange
				.getMinValue(), dMinInc);
		final double maxDestination = doubleValue(dType, destinationRange
				.getMaxValue(), dMaxInc);

		// /////////////////////////////////////////////////////////////////
		//
		// optimizations
		//
		// /////////////////////////////////////////////////////////////////
		// //
		//
		// If the output range is a single value let's create a constant
		// transform
		//
		// //
		if (PiecewiseUtilities.compare(minDestination, maxDestination) == 0)
			return LinearTransform1D.create(0, minDestination);

		// //
		//
		// If the input range is a single value this transform ca be created
		// only if we map to another single value
		//
		// //
		if (PiecewiseUtilities.compare(minSource, maxSource) == 0)
			throw new IllegalArgumentException("Impossible to map a single value to a range.");

		double scale = (maxDestination - minDestination)
				/ (maxSource - minSource);
		// /////////////////////////////////////////////////////////////////
		//
		// Take into account the fact that the maxSample and the minSample can
		// be
		// similar hence we have a constant transformation.
		//
		// /////////////////////////////////////////////////////////////////
		if (Double.isNaN(scale))
			scale = 0;
		final double offset = minDestination - scale * minSource;
		return createLinearTransform1D(scale, offset);
	}

