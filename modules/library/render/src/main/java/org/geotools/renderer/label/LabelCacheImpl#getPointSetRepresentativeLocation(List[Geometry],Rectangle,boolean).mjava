    /**
     * 1. get a list of points from the input geometries that are inside the displayGeom NOTE: lines
     * and polygons are reduced to their centroids (you shouldnt really calling this with lines and
     * polys) 2. choose the most "central" of the points METRIC - choose anyone TODO: change metric
     * to be "closest to the centoid of the possible points"
     *
     * @param geoms list of Point or MultiPoint (any other geometry types are rejected
     * @param partialsEnabled true if we don't want to exclude points out of the displayArea
     * @return a point or null (if there's nothing to draw)
     */
    Point getPointSetRepresentativeLocation(
            List<Geometry> geoms, Rectangle displayArea, boolean partialsEnabled) {
        // points that are inside the displayGeometry
        ArrayList<Point> pts = new ArrayList<Point>();

        for (Geometry g : geoms) {
            if (!((g instanceof Point) || (g instanceof MultiPoint))) // handle
                // lines,polys, gc, etc..
                g = g.getCentroid(); // will be point
            if (g instanceof Point) {
                Point point = (Point) g;
                if (displayArea.contains(point.getX(), point.getY())
                        || partialsEnabled) // this is robust!
                pts.add(point); // possible label location
            } else if (g instanceof MultiPoint) {
                for (int t = 0; t < g.getNumGeometries(); t++) {
                    Point gg = (Point) g.getGeometryN(t);
                    if (displayArea.contains(gg.getX(), gg.getY()) || partialsEnabled)
                        pts.add(gg); // possible label location
                }
            }
        }
        if (pts.size() == 0) return null;

        // do better metric than this:
        return pts.get(0);
    }

