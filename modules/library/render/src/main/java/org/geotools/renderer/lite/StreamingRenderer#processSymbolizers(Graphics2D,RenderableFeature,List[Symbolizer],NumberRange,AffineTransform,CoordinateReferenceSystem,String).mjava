    /**
     * Applies each of a set of symbolizers in turn to a given feature.
     * <p>
     * This is an internal method and should only be called by processStylers.
     * </p>
     * @param currLayer 
     * 
     * @param graphics
     * @param drawMe
     *            The feature to be rendered
     * @param symbolizers
     *            An array of symbolizers which actually perform the rendering.
     * @param scaleRange
     *            The scale range we are working on... provided in order to make
     *            the style factory happy
     * @param shape
     * @param destinationCrs
     * @param layerId 
     * @throws TransformException
     * @throws FactoryException
     */
    private void processSymbolizers(final Graphics2D graphics,
            final RenderableFeature drawMe, final List<Symbolizer> symbolizers,
            NumberRange scaleRange, AffineTransform at,
            CoordinateReferenceSystem destinationCrs, String layerId)
            throws Exception {
        
        for (Symbolizer symbolizer : symbolizers) {

            // /////////////////////////////////////////////////////////////////
            //
            // RASTER
            //
            // /////////////////////////////////////////////////////////////////
            if (symbolizer instanceof RasterSymbolizer) {
                // grab the grid coverage
                GridCoverage2D coverage = null;
                boolean disposeCoverage = false;
                
                try {
                    // //
                    // It is a grid coverage
                    // //
                    final Object grid = gridPropertyName.evaluate(drawMe.content);
                    if (grid instanceof GridCoverage2D) {
                        coverage = (GridCoverage2D) grid;
                    } else if (grid instanceof GridCoverage2DReader) {
                        final Object params = paramsPropertyName.evaluate(drawMe.content);
                        GridCoverage2DReader reader = (GridCoverage2DReader) grid;
                        CoordinateReferenceSystem sourceCRS = reader.getCoordinateReferenceSystem();
                        GridGeometry2D readGG = getRasterGridGeometry(destinationCrs, sourceCRS);
                        coverage = readCoverage(reader, params, readGG);
                        disposeCoverage = true;
                        
                       
                        
                        
                        
                    }
                } catch (IllegalArgumentException e) {
                    LOGGER.log(Level.WARNING, e.getLocalizedMessage(), e);
                    fireErrorEvent(e);
                } catch (IOException e) {
                    LOGGER.log(Level.WARNING, e.getLocalizedMessage(), e);
                    fireErrorEvent(e);
                }
                
                if(coverage != null) {
                    requests.put(new RenderRasterRequest(graphics, coverage, disposeCoverage,
                            (RasterSymbolizer) symbolizer, destinationCrs, at));
                }
            } else {

                // /////////////////////////////////////////////////////////////////
                //
                // FEATURE
                //
                // /////////////////////////////////////////////////////////////////
                LiteShape2 shape = drawMe.getShape(symbolizer, at);
                if(shape == null) {
                    continue;
                }
                
                if (symbolizer instanceof TextSymbolizer && drawMe.content instanceof Feature) {
                    labelCache.put(layerId, (TextSymbolizer) symbolizer, (Feature) drawMe.content,
                            shape, scaleRange);
                } else {
                    Style2D style = styleFactory.createStyle(drawMe.content,
                            symbolizer, scaleRange);
                    
                    // clip to the visible area + the size of the symbolizer (with some extra 
                    // to make sure we get no artefacts from polygon new borders)
                    double size = RendererUtilities.getStyle2DSize(style);
                    // take into account the meta buffer to try and clip all geometries by the same
                    // amount
                    double clipBuffer = Math.max(size / 2, metaBuffer) + 10;
                    Envelope env = new Envelope(screenSize.getMinX(), screenSize.getMaxX(), screenSize.getMinY(), screenSize.getMaxY());
                    env.expandBy(clipBuffer);
                    final GeometryClipper clipper = new GeometryClipper(env);
                    Geometry g = clipper.clip(shape.getGeometry(), false);
                    if(g == null) 
                        continue;
                    if(g != shape.getGeometry()) {
                        shape = new LiteShape2(g, null, null, false);
                    }
                    
                    PaintShapeRequest paintShapeRequest = 
                        new PaintShapeRequest(graphics, shape, style, scaleDenominator);
                    if (symbolizer.hasOption("labelObstacle")) {
                        paintShapeRequest.setLabelObstacle(true);
                    }
                    requests.put(paintShapeRequest);
                }

            }
        }
        fireFeatureRenderedEvent(drawMe.content);
    }

