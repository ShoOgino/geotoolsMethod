    /**
     * Applies each feature type styler in turn to all of the features. This
     * perhaps needs some explanation to make it absolutely clear.
     * featureStylers[0] is applied to all features before featureStylers[1] is
     * applied. This can have important consequences as regards the painting
     * order.
     * <p>
     * In most cases, this is the desired effect. For example, all line features
     * may be rendered with a fat line and then a thin line. This produces a
     * 'cased' effect without any strange overlaps.
     * </p>
     * <p>
     * This method is internal and should only be called by render.
     * </p>
     * <p>
     * </p>
     * 
     * @param graphics
     *            DOCUMENT ME!
     * @param features
     *            An array of features to be rendered
     * @param featureStylers
     *            An array of feature stylers to be applied
     * @param at
     *            DOCUMENT ME!
     * @param destinationCrs -
     *            The destination CRS, or null if no reprojection is required
     * @param screenSize
     * @param layerId 
     * @throws IOException
     * @throws IllegalFilterException
     */
    final private void processStylers(final Graphics2D graphics,
            MapLayer currLayer, AffineTransform at,
            CoordinateReferenceSystem destinationCrs, Envelope mapArea,
            Rectangle screenSize, String layerId) throws Exception {

        /*
         * DJB: changed this a wee bit so that it now does the layer query AFTER
         * it has evaluated the rules for scale inclusion. This makes it so that
         * geometry columns (and other columns) will not be queried unless they
         * are actually going to be required. see geos-469
         */
        // /////////////////////////////////////////////////////////////////////
        //
        // Preparing feature information and styles
        //
        // /////////////////////////////////////////////////////////////////////
        final FeatureTypeStyle[] featureStylers = currLayer.getStyle().getFeatureTypeStyles();

        final FeatureSource featureSource =  currLayer.getFeatureSource();

        final CoordinateReferenceSystem sourceCrs;
        final NumberRange scaleRange = NumberRange.create(scaleDenominator,scaleDenominator);
        final ArrayList<LiteFeatureTypeStyle> lfts ;

        if ( featureSource != null ) {
            FeatureCollection features = null;
            final FeatureType schema = featureSource.getSchema();

            final GeometryDescriptor geometryAttribute = schema.getGeometryDescriptor();
            sourceCrs = geometryAttribute.getType().getCoordinateReferenceSystem();
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Processing " + featureStylers.length + " stylers for " +
                                currLayer.getFeatureSource().getSchema().getName());
            }

            lfts = createLiteFeatureTypeStyles(featureStylers,schema, graphics);
            if(lfts.size() == 0)
                return;
            
            applyUnitRescale(lfts);
            
            // classify by transformation
            List<List<LiteFeatureTypeStyle>> txClassified = new ArrayList<List<LiteFeatureTypeStyle>>();
            txClassified.add(new ArrayList<LiteFeatureTypeStyle>());
            Expression transformation = null;
            for (int i = 0; i < lfts.size(); i++) {
                LiteFeatureTypeStyle curr = lfts.get(i);
                if(i == 0) {
                    transformation = curr.transformation;
                } else if(!(transformation == curr.transformation) 
                        || (transformation != null && curr.transformation != null && 
                                !curr.transformation.equals(transformation))) {
                    txClassified.add(new ArrayList<LiteFeatureTypeStyle>());
                    
                }  
                txClassified.get(txClassified.size() - 1).add(curr);
            }
            
            // render groups by uniform transformation
            for (List<LiteFeatureTypeStyle> uniform : txClassified) {
                Expression transform = uniform.get(0).transformation;
                
                // ... assume we have to do the generalization, the query layer process will
                // turn down the flag if we don't 
                inMemoryGeneralization = true;
                Query query = getLayerQuery(currLayer, featureSource, schema,
                        uniform, mapArea, destinationCrs, sourceCrs, screenSize,
                        geometryAttribute, at);
                FeatureCollection rawFeatures;
                if(transformation != null) {
                    GridEnvelope2D ge = new GridEnvelope2D(screenSize);
                    ReferencedEnvelope re = new ReferencedEnvelope(mapArea, destinationCrs);
                    GridGeometry2D gridGeometry = new GridGeometry2D(ge, re);
                    rawFeatures = applyRenderingTransformation(transformation, featureSource, query,
                            gridGeometry);
                    if(rawFeatures == null) {
                        return;
                    }
                } else {
                    checkAttributeExistence(featureSource.getSchema(), query);
                    rawFeatures = featureSource.getFeatures(query);
                }
                features = prepFeatureCollection(rawFeatures, sourceCrs);            

                // finally, perform rendering
                if(isOptimizedFTSRenderingEnabled() && lfts.size() > 1) {
                    drawOptimized(graphics, currLayer, at, destinationCrs, layerId, null, features,
                            scaleRange, uniform);
                } else {
                    drawPlain(graphics, currLayer, at, destinationCrs, layerId, null, features,
                            scaleRange, uniform);
                }
            }
        } else {
            Collection collection = null;

            CollectionSource source = currLayer.getSource();
            collection = queryLayer( currLayer, currLayer.getSource() );

            sourceCrs = null;
            lfts = createLiteFeatureTypeStyles( featureStylers, source.describe(), graphics );
            applyUnitRescale(lfts);
            
            if (lfts.size() == 0) return; // nothing to do

            // finally, perform rendering
            if(isOptimizedFTSRenderingEnabled() && lfts.size() > 1) {
                drawOptimized(graphics, currLayer, at, destinationCrs, layerId, collection, null,
                        scaleRange, lfts);
            } else {
                drawPlain(graphics, currLayer, at, destinationCrs, layerId, collection, null,
                        scaleRange, lfts);
            }
        }
    }

