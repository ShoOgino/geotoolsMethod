    @Override
    public Geometry postProcess(MathTransform mt, Geometry geometry) {
        // First let's check if the geometry is undoubtedly not going to need
        // processing
        Envelope env = geometry.getEnvelopeInternal();
        final double width;
        final double reWidth;
        final boolean northEast = CRS.getAxisOrder(targetCRS) == CRS.AxisOrder.NORTH_EAST;
        if(northEast) {
            width = env.getHeight();
            reWidth = renderingEnvelope.getHeight();
        } else {
            width = env.getWidth();
            reWidth = renderingEnvelope.getWidth();
        }
        
        if (width < radius && renderingEnvelope.contains(env)
                && reWidth <= radius * 2) {
            return geometry;
        }

        // Check if the geometry has wrapped the dateline. Heuristic: we assume
        // anything larger than half of the world might have wrapped it, however,
        // if it's touching both datelines then don't wrap it, as it might be something
        // like antarctica
        if (datelineWrappingCheckEnabled && width > radius && width < radius * 2) {
            Geometry wrapped = (Geometry) geometry.clone();
            wrapped.apply(new WrappingCoordinateFilter(radius, radius * 2, mt, northEast));
            wrapped.geometryChanged();
            // did we un-wrap it?
            if (wrapped.getEnvelopeInternal().getWidth() < radius) {
                geometry = wrapped;
                env = geometry.getEnvelopeInternal();
            }
        }

        // The viewing area might contain the geometry multiple times due to
        // wrapping.
        // This is obvious for the geometries that wrapped the dateline, but the
        // viewing
        // area might be large enough to contain the same continent multiple
        // times (a-la Google Maps)
        List<Geometry> geoms = new ArrayList<Geometry>();
        Class geomType = null;

        // search the west-most location inside the current rendering envelope
        // (there may be many)
        double base, curr, lowLimit, highLimit;
        if(northEast) {
            base = env.getMinY();
            curr = env.getMinY();
            lowLimit = Math.max(renderingEnvelope.getMinY(), renderingEnvelope.getMedian(1) - maxWraps * radius * 2); 
            highLimit = Math.min(renderingEnvelope.getMaxY(), renderingEnvelope.getMedian(1) + maxWraps * radius * 2);
        } else {
            base = env.getMinX();
            curr = env.getMinX();
            lowLimit = Math.max(renderingEnvelope.getMinX(), renderingEnvelope.getMedian(0) - maxWraps * radius * 2); 
            highLimit = Math.min(renderingEnvelope.getMaxX(), renderingEnvelope.getMedian(0) + maxWraps * radius * 2);
        }
        while (curr > lowLimit) {
            curr -= radius * 2;
        }

        // clone and offset as necessary
        geomType = accumulate(geoms, geometry, geomType);
        while (curr <= highLimit) {
            double offset = curr - base;
            if (Math.abs(offset) < radius) {
                // in this case we can keep the original geometry, which is already in
            } else {
                // in all other cases we make a copy and offset it
                Geometry offseted = (Geometry) geometry.clone();
                offseted.apply(new OffsetOrdinateFilter(northEast ? 1 : 0, offset));
                offseted.geometryChanged();       
                geomType = accumulate(geoms, offseted, geomType);
            }

            curr += radius * 2;
        }
        
        // if we could not find any geom type we stumbled int an empty geom collection
        if(geomType == null) {
            return null;
        }
        
        // if we did not have to actually clone the geometries
        if(geoms.size() == 1) {
            return geoms.get(0);
        }

        // rewrap all the clones into a single geometry
        if (Point.class.equals(geomType)) {
            Point[] points = geoms.toArray(new Point[geoms.size()]);
            return geometry.getFactory().createMultiPoint(points);
        } else if (LineString.class.isAssignableFrom(geomType)) {
            LineString[] lines = geoms.toArray(new LineString[geoms.size()]);
            return geometry.getFactory().createMultiLineString(lines);
        } else if (Polygon.class.equals(geomType)) {
            Polygon[] polys = geoms.toArray(new Polygon[geoms.size()]);
            return geometry.getFactory().createMultiPolygon(polys);
        } else {
            return geometry.getFactory().createGeometryCollection(
                    geoms.toArray(new Geometry[geoms.size()]));
        }
    }

