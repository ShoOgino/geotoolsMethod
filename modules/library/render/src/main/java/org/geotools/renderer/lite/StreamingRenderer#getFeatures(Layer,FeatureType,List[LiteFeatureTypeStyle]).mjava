    FeatureCollection getFeatures(
            final Layer layer,
            final FeatureType schema,
            List<LiteFeatureTypeStyle> featureTypeStyles)
            throws IOException, FactoryException, NoninvertibleTransformException, SchemaException,
                    TransformException {
        final FeatureSource featureSource = layer.getFeatureSource();
        Expression transform = featureTypeStyles.get(0).transformation;

        // grab the source crs and geometry attribute
        final CoordinateReferenceSystem sourceCrs;
        final GeometryDescriptor geometryAttribute = schema.getGeometryDescriptor();
        if (geometryAttribute != null && geometryAttribute.getType() != null) {
            sourceCrs = geometryAttribute.getType().getCoordinateReferenceSystem();
        } else {
            sourceCrs = null;
        }

        // ... assume we have to do the generalization, the query layer process will
        // turn down the flag if we don't
        boolean hasTransformation = transform != null;
        Query styleQuery =
                getStyleQuery(
                        layer,
                        featureTypeStyles,
                        mapExtent,
                        destinationCrs,
                        sourceCrs,
                        screenSize,
                        geometryAttribute,
                        worldToScreenTransform,
                        hasTransformation);
        Query definitionQuery = getDefinitionQuery(layer, featureSource, sourceCrs);
        FeatureCollection features = null;
        if (hasTransformation) {
            // prepare the stage for the raster transformations
            GridGeometry2D gridGeometry = getRasterGridGeometry(destinationCrs, sourceCrs);
            // vector transformation wise, we have to account for two separate queries,
            // the one attached to the layer and then one coming from SLD.
            // The first source attributes, the latter talks tx output attributes
            // so they have to be applied before and after the transformation respectively
            RenderingTransformationHelper helper =
                    new RenderingTransformationHelper() {

                        @Override
                        protected GridCoverage2D readCoverage(
                                GridCoverage2DReader reader, Object params, GridGeometry2D readGG)
                                throws IOException {
                            GeneralParameterValue[] readParams = (GeneralParameterValue[]) params;
                            Interpolation interpolation = getRenderingInterpolation(layer);
                            GridCoverageReaderHelper helper;
                            try {
                                helper =
                                        new GridCoverageReaderHelper(
                                                reader,
                                                readGG.getGridRange2D(),
                                                ReferencedEnvelope.reference(
                                                        readGG.getEnvelope2D()),
                                                interpolation);
                                return helper.readCoverage(readParams);
                            } catch (InvalidGridGeometryException | FactoryException e) {
                                throw new IOException("Failure reading the coverage", e);
                            }
                        }
                    };

            Object result =
                    helper.applyRenderingTransformation(
                            transform,
                            featureSource,
                            definitionQuery,
                            styleQuery,
                            gridGeometry,
                            sourceCrs,
                            java2dHints);
            if (result == null) {
                return null;
            } else if (result instanceof FeatureCollection) {
                features = (FeatureCollection) result;
            } else if (result instanceof GridCoverage2D) {
                GridCoverage2D coverage = (GridCoverage2D) result;
                // we only avoid disposing if the input was a in memory GridCovereage2D
                if ((schema instanceof SimpleFeatureType
                        && !FeatureUtilities.isWrappedCoverage((SimpleFeatureType) schema))) {
                    coverage = new DisposableGridCoverage(coverage);
                }
                features = FeatureUtilities.wrapGridCoverage(coverage);
            } else if (result instanceof GridCoverage2DReader) {
                features =
                        FeatureUtilities.wrapGridCoverageReader(
                                (GridCoverage2DReader) result, null);
            } else {
                throw new IllegalArgumentException(
                        "Don't know how to handle the results of the transformation, "
                                + "the supported result types are FeatureCollection, GridCoverage2D "
                                + "and GridCoverage2DReader, but we got: "
                                + result.getClass());
            }
        } else {
            Query mixed = DataUtilities.mixQueries(definitionQuery, styleQuery, null);
            // mix the sort by, the style query takes precedence
            if (styleQuery.getSortBy() != null) {
                mixed.setSortBy(styleQuery.getSortBy());
            } else {
                mixed.setSortBy(definitionQuery.getSortBy());
            }
            checkAttributeExistence(featureSource.getSchema(), mixed);
            features = featureSource.getFeatures(mixed);
            features = RendererUtilities.fixFeatureCollectionReferencing(features, sourceCrs);
        }

        // HACK HACK HACK
        // For complex features, we need the targetCrs and version in scenario where we have
        // a top level feature that does not contain a geometry(therefore no crs) and has a
        // nested feature that contains geometry as its property.Furthermore it is possible
        // for each nested feature to have different crs hence we need to reproject on each
        // feature accordingly.
        // This is a Hack, this information should not be passed through feature type
        // appschema will need to remove this information from the feature type again
        if (!(features instanceof SimpleFeatureCollection)) {
            features.getSchema().getUserData().put("targetCrs", destinationCrs);
            features.getSchema().getUserData().put("targetVersion", "wms:getmap");
        }

        return features;
    }

