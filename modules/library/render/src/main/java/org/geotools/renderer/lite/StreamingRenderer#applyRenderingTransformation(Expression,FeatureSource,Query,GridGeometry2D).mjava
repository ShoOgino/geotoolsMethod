    FeatureCollection applyRenderingTransformation(Expression transformation,
            FeatureSource featureSource, Query query, GridGeometry2D gridGeometry) throws IOException, SchemaException, TransformException  {
        Object result = null;
        
        // check if it's a wrapper coverage or a wrapped reader
        FeatureType schema = featureSource.getSchema();
        boolean isRasterData = false;
        if(schema instanceof SimpleFeatureType) {
            SimpleFeatureType simpleSchema = (SimpleFeatureType) schema;
            GridCoverage2D coverage = null;
            if(FeatureUtilities.isWrappedCoverage(simpleSchema)) {
                isRasterData = true;
                throw new UnsupportedOperationException("Don't have support for plain coverages " +
                        "in rendering transformations now");
            } else if(FeatureUtilities.isWrappedCoverageReader(simpleSchema)) {
                isRasterData = true;
                GridGeometry2D readGG = gridGeometry;
                if(transformation instanceof RenderingTransformation) {
                    RenderingTransformation tx = (RenderingTransformation) transformation;
                    readGG = (GridGeometry2D) tx.invertGridGeometry(query, gridGeometry);
                    // TODO: override the read params and force this grid geometry, or something
                    // similar to this (like passing it as a param to readCoverage
                }
                Feature gridWrapper = featureSource.getFeatures().features().next();
                final Object params = paramsPropertyName.evaluate(gridWrapper);
                final AbstractGridCoverage2DReader reader = (AbstractGridCoverage2DReader) gridPropertyName.evaluate(gridWrapper);
                coverage = readCoverage(reader, params, readGG);
                
                // readers will return null if there is no coverage in the area
                if(coverage != null) {
                    // Crop will fail if we try to crop outside of the coverage area
                    GeneralEnvelope cropEnvelope = new GeneralEnvelope(mapExtent);
                    if(coverage.getEnvelope2D().intersects(cropEnvelope.toRectangle2D())) {
                        // the resulting coverage might be larger than the readGG envelope, shall we crop it?
                        final ParameterValueGroup param = CROP.getParameters();
                        param.parameter("Source").setValue(coverage);
                        param.parameter("Envelope").setValue(cropEnvelope);
                        coverage = (GridCoverage2D) PROCESSOR.doOperation(param);
                    } else {
                        coverage = null;
                    }
                    
                    if(coverage != null) {
                        // we might also need to scale the coverage to the desired resolution
                        MathTransform2D coverageTx = coverage.getGridGeometry().getGridToCRS2D();
                        if(coverageTx instanceof AffineTransform) {
                            AffineTransform coverageAt = (AffineTransform) coverageTx;
                            AffineTransform renderingAt = (AffineTransform) gridGeometry.getGridToCRS2D();
                            // we adjust the scale only if we have many more pixels than required (30% or more)
                            final double ratioX = coverageAt.getScaleX() / renderingAt.getScaleX();
                            final double ratioY = coverageAt.getScaleY() / renderingAt.getScaleY();
                            if(ratioX < 0.7 && ratioY < 0.7) {
                                // resolution is too different
                                final ParameterValueGroup param = SCALE.getParameters();
                                param.parameter("Source").setValue(coverage);
                                param.parameter("xScale").setValue(ratioX);
                                param.parameter("yScale").setValue(ratioY);
                                final Interpolation interpolation = (Interpolation) java2dHints.get(JAI.KEY_INTERPOLATION);
                                if(interpolation != null) {
                                    param.parameter("Interpolation").setValue(interpolation);
                                }

                                coverage = (GridCoverage2D) PROCESSOR.doOperation(param);
                            }
                        }
                    }
                    
                    if(coverage != null) {
                        // apply the transformation
                        result = transformation.evaluate(coverage);
                    } else {
                        result = null;
                    }
                }
            } 
        }
        
        if(result == null && !isRasterData) {
            // it's a transformation starting from vector data, let's see if we can optimize the query
            FeatureCollection originalFeatures;
            Query optimizedQuery = null;
            if(transformation instanceof RenderingTransformation) {
                RenderingTransformation tx = (RenderingTransformation) transformation;
                optimizedQuery = tx.invertQuery(query, gridGeometry);
            }
            // if we could not find an optimized query no other choice but to just limit
            // ourselves to the bbox, we don't know if the transformation alters/adds attributes :-(
            if(optimizedQuery == null) {
                 Envelope bounds = (Envelope) query.getFilter().accept(ExtractBoundsFilterVisitor.BOUNDS_VISITOR, null);
                 Filter bbox = new FastBBOX(filterFactory.property(""), bounds, filterFactory);
                 optimizedQuery = new Query(null, bbox);
                // optimizedQuery = query;
            }
            
            // grab the original features
            originalFeatures = featureSource.getFeatures(optimizedQuery);
            
            // transform them
            result = transformation.evaluate(originalFeatures);
        }
        
        // null safety, a transformation might be free to return null
        if(result == null) {
            return null;
        }
        
        // what did we get? raster or vector?
        if(result instanceof FeatureCollection) {
            // we need to apply the original query, but that uses the wrong type name and
            // likely the wrong attribute name for the default geometry
            final SimpleFeatureSource source = DataUtilities.source((FeatureCollection) result);
            SimpleFeatureType transformedSchema = source.getSchema();
            Query adapted = adaptQuery(query, transformedSchema, schema);
            checkAttributeExistence(transformedSchema, adapted);
            return source.getFeatures(adapted);
        } else if(result instanceof GridCoverage2D) {
            return FeatureUtilities.wrapGridCoverage((GridCoverage2D) result);
        } else if(result instanceof AbstractGridCoverage2DReader) {
            return FeatureUtilities.wrapGridCoverageReader((AbstractGridCoverage2DReader) result, null);
        } else {
            throw new IllegalArgumentException("Don't know how to handle the results of the transformation, " +
                    "the supported result types are FeatureCollection, GridCoverage2D " +
                    "and AbstractGridCoverage2DReader, but we got: " + result.getClass());
        }
    }

