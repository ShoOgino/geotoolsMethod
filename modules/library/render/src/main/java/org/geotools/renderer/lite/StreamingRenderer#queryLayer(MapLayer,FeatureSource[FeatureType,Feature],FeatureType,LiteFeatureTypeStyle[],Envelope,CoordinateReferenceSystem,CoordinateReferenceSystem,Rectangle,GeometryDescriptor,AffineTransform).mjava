    /**
     * Queries a given layer's features to be rendered based on the target
     * rendering bounding box.
     * <p>
     * If <code>optimizedDataLoadingEnabled</code> attribute has been set to
     * <code>true</code>, the following optimization will be performed in
     * order to limit the number of features returned:
     * <ul>
     * <li>Just the features whose geometric attributes lies within
     * <code>envelope</code> will be queried</li>
     * <li>The queried attributes will be limited to just those needed to
     * perform the rendering, based on the required geometric and non geometric
     * attributes found in the Layer's style rules</li>
     * <li>If a <code>Query</code> has been set to limit the resulting
     * layer's features, the final filter to obtain them will respect it. This
     * means that the bounding box filter and the Query filter will be combined,
     * also including maxFeatures from Query</li>
     * <li>At least that the layer's definition query explicitly says to
     * retrieve some attribute, no attributes will be requested from it, for
     * performance reasons. So it is desirable to not use a Query for filtering
     * a layer which includes attributes. Note that including the attributes in
     * the result is not necessary for the query's filter to get properly
     * processed. </li>
     * </ul>
     * </p>
     * <p>
     * <b>NOTE </b>: This is an internal method and should only be called by
     * <code>paint(Graphics2D, Rectangle, AffineTransform)</code>. It is
     * package protected just to allow unit testing it.
     * </p>
     * 
     * @param currLayer
     *            the actually processing layer for renderition
     * @param schema
     * @param source
     * @param envelope
     *            the spatial extent which is the target area of the rendering
     *            process
     * @param destinationCRS
     *            DOCUMENT ME!
     * @param sourceCrs
     * @param screenSize
     * @param geometryAttribute
     * @return the set of features resulting from <code>currLayer</code> after
     *         querying its feature source
     * @throws IllegalFilterException
     *             if something goes wrong constructing the bbox filter
     * @throws IOException
     * @see MapLayer#setQuery(org.geotools.data.Query)
     */
    /*
     * Default visibility for testing purposes
     */

    FeatureCollection<FeatureType, Feature> queryLayer(MapLayer currLayer, FeatureSource<FeatureType, Feature> source,
            FeatureType schema, LiteFeatureTypeStyle[] styles,
            Envelope mapArea, CoordinateReferenceSystem mapCRS,
            CoordinateReferenceSystem featCrs, Rectangle screenSize,
            GeometryDescriptor geometryAttribute,
            AffineTransform worldToScreenTransform)
            throws IllegalFilterException, IOException {
        FeatureCollection<FeatureType, Feature> results = null;
        Query query = new Query(Query.ALL);
        Query definitionQuery;
        final int length;
        Filter filter = null;

        // if map extent are not already expanded by a constant buffer, try to compute a layer
        // specific one based on stroke widths
        if(getRenderingBuffer() == 0) {
            int buffer = findRenderingBuffer(styles);
            if (buffer > 0) {
                mapArea = expandEnvelope(mapArea, worldToScreenTransform,
                        buffer);
                LOGGER.fine("Expanding rendering area by " + buffer 
                        + " pixels to consider stroke width");
            }
        }

        // build a list of attributes used in the rendering
        String[] attributes;
        if (styles == null) {
//            List<AttributeDescriptor> ats = schema.getAttributeDescriptors();
//            length = ats.size();
//            attributes = new String[length];
//            for (int t = 0; t < length; t++) {
//                attributes[t] = ats.get(t).getLocalName();
//            }
            attributes = null;
        } else {
            attributes = findStyleAttributes(styles, schema);
        }

        ReferencedEnvelope envelope = new ReferencedEnvelope(mapArea, mapCRS);
        if (isOptimizedDataLoadingEnabled()) {
            // see what attributes we really need by exploring the styles
            // for testing purposes we have a null case -->

            try {
                // Then create the geometry filters. We have to create one for
                // each geometric attribute used during the rendering as the
                // feature may have more than one and the styles could use non
                // default geometric ones
                List<ReferencedEnvelope> envelopes;
                if (projectionHandler != null) {
                    // update the envelope with the one eventually grown by the rendering buffer
                    projectionHandler.setRenderingEnvelope(envelope);
                    envelopes = projectionHandler.getQueryEnvelopes(featCrs);
                } else {
                    if (mapCRS != null && featCrs != null && !CRS.equalsIgnoreMetadata(featCrs, mapCRS)) {
                        envelopes = Collections.singletonList(envelope.transform(featCrs, true, 10));
                    } else {
                        envelopes = Collections.singletonList(envelope);
                    }
                }

                if(LOGGER.isLoggable(Level.FINE))
                    LOGGER.fine("Querying layer " + schema.getName() +  " with bbox: " + envelope);
                filter = createBBoxFilters(schema, attributes, envelopes);

                // now build the query using only the attributes and the
                // bounding box needed
                query = new Query(schema.getName().getLocalPart());
                query.setFilter(filter);
                query.setPropertyNames(attributes);
                processRuleForQuery(styles, query);

            } catch (Exception e) {
                fireErrorEvent(new Exception("Error transforming bbox", e));
                canTransform = false;
                query = new Query(schema.getName().getLocalPart());
                query.setPropertyNames(attributes);
                Envelope bounds = source.getBounds();
                if (bounds != null && envelope.intersects(bounds)) {
                    LOGGER.log(Level.WARNING, "Got a tranform exception while trying to de-project the current " +
                            "envelope, bboxs intersect therefore using envelope)", e);
                    filter = null;					
                    filter = createBBoxFilters(schema, attributes, Collections.singletonList(envelope));
                    query.setFilter(filter);
                } else {
                    LOGGER.log(Level.WARNING, "Got a tranform exception while trying to de-project the current " +
                            "envelope, falling back on full data loading (no bbox query)", e);
                    query.setFilter(Filter.INCLUDE);
                }
                processRuleForQuery(styles, query);

            }
        }

        // now, if a definition query has been established for this layer, be
        // sure to respect it by combining it with the bounding box one.
        // Currently this definition query is being set dynamically in geoserver
        // as per the user's filter, maxFeatures and startIndex WMS GetMap custom parameters
        definitionQuery = currLayer.getQuery();

        if (definitionQuery != Query.ALL) {
            if (query == Query.ALL) {
                query = new Query(definitionQuery);
            } else {
                query = new Query(DataUtilities.mixQueries(
                        definitionQuery, query, "liteRenderer"));
            }
        }
        query.setCoordinateSystem(featCrs);

        // prepare hints
        // ... basic one, we want fast and compact coordinate sequences and geometries optimized
        // for the collection of one item case (typical in shapefiles)
        LiteCoordinateSequenceFactory csFactory = new LiteCoordinateSequenceFactory();
        GeometryFactory gFactory = new SimpleGeometryFactory(csFactory);
        Hints hints = new Hints(Hints.JTS_COORDINATE_SEQUENCE_FACTORY, csFactory);
        hints.put(Hints.JTS_GEOMETRY_FACTORY, gFactory);
        hints.put(Hints.FEATURE_2D, Boolean.TRUE);
        
        // update the screenmaps
        try {
            CoordinateReferenceSystem crs = getNativeCRS(schema, Arrays.asList(attributes));
            if(crs != null) {
                Set<RenderingHints.Key> fsHints = source.getSupportedHints();
                
                MathTransform mt = buildFullTransform(crs, mapCRS, worldToScreenTransform);
                double[] spans = Decimator.computeGeneralizationDistances(mt.inverse(), screenSize, generalizationDistance);
                double distance = spans[0] < spans[1] ? spans[0] : spans[1];
                for (LiteFeatureTypeStyle fts : styles) {
                    if(fts.screenMap != null) {
                        fts.screenMap.setTransform(mt);
                        fts.screenMap.setSpans(spans[0], spans[1]);
                        if(fsHints.contains(Hints.SCREENMAP)) {
                            // replace the renderer screenmap with the hint, and avoid doing
                            // the work twice
                            hints.put(Hints.SCREENMAP, fts.screenMap);
                            fts.screenMap = null;
                        }
                    }
                }
            
                // ... if possible we let the datastore do the generalization
                if(fsHints.contains(Hints.GEOMETRY_SIMPLIFICATION)) {
                    // good, we don't need to perform in memory generalization, the datastore
                    // does it all for us
                    hints.put(Hints.GEOMETRY_SIMPLIFICATION, distance);
                    inMemoryGeneralization = false;
                } else if(fsHints.contains(Hints.GEOMETRY_DISTANCE)) {
                    // in this case the datastore can get us close, but we can still
                    // perform some in memory generalization
                    hints.put(Hints.GEOMETRY_DISTANCE, distance);
                }
            }
            
        } catch(Exception e) {
            LOGGER.log(Level.INFO, "Error computing the generalization hints", e);
        }

        if(query.getHints() == null) {
            query.setHints(hints);
        } else {
            query.getHints().putAll(hints);
        }

        // simplify the filter
        SimplifyingFilterVisitor simplifier = new SimplifyingFilterVisitor();
        Filter simplifiedFilter = (Filter) query.getFilter().accept(simplifier, null);
        query.setFilter(simplifiedFilter);

        return source.getFeatures(query);
    }

