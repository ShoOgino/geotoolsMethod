	/**
	 * @param inDomainElements
	 * @throws IllegalArgumentException
	 * @throws MissingResourceException
	 */
	@SuppressWarnings("unchecked")
    private void init(E[] inDomainElements)
			throws IllegalArgumentException, MissingResourceException {
	    
	    // /////////////////////////////////////////////////////////////////////
            //
            // input checks
            //
            // /////////////////////////////////////////////////////////////////////
            PiecewiseUtilities.ensureNonNull("DomainElement1D[]", inDomainElements);
            
		// @todo TODOCHECK ME
		if (inDomainElements == null)
		    this.elements = (E[])  new DefaultDomainElement1D[]{ new DefaultPassthroughPiecewiseTransform1DElement("p0")};
		else
		    this.elements =  inDomainElements.clone();

		// /////////////////////////////////////////////////////////////////////
		//
		// Sort the input elements.
		//
		// /////////////////////////////////////////////////////////////////////
		Arrays.sort(this.elements);

		// /////////////////////////////////////////////////////////////////////
		//
		// Construct the array of minimum values. During the loop, we make sure
		// there is no overlapping in input and output.
		//
		// /////////////////////////////////////////////////////////////////////
		hasGaps = false;
		minimums = new double[elements.length];
		for (int i = 0; i < elements.length; i++) {
			final DefaultDomainElement1D c = elements[i];
			final double inMinimum = minimums[i] = c.getInputMinimum();
			if (i != 0) {
				assert !(inMinimum < minimums[i - 1]) : inMinimum;
				// Use '!' to accept NaN.
				final DefaultDomainElement1D previous = elements[i - 1];
				if (PiecewiseUtilities.compare(inMinimum, previous
						.getInputMaximum()) <= 0) {
					PiecewiseUtilities.domainElementsOverlap(elements, i);
				}
				// Check if there is a gap between this domain element and the
				// previous one.
				if (!Double.isNaN(inMinimum)
						&& inMinimum != ((NumberRange<?>) previous.getRange()).getMaximum(false)) {
					hasGaps = true;
				}
			}
		}


		/*
		 * Search for what seems to be the "main" domain element. This loop looks for
		 * the quantitative domain element (if there is one) with the widest range of
		 * sample values.
		 */
		double range = 0;
		E main = null;
		for (int i = elements.length; --i >= 0;) {
			final E candidate = elements[i];
			if (Double.isInfinite(candidate.getInputMinimum())
					&& Double.isInfinite(candidate.getInputMaximum())) {
				range = Double.POSITIVE_INFINITY;
				main = candidate;
				continue;
			}
			final double candidateRange = candidate.getInputMaximum()
					- candidate.getInputMinimum();
			if (candidateRange >= range) {
				range = candidateRange;
				main = candidate;
			}

		}
		this.main = main;

		// postcondition
		assert PiecewiseUtilities.isSorted(elements);
	}

