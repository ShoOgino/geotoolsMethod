    protected GridCoverage execute() {
        assert getSources().size() <= 3;

        // /////////////////////////////////////////////////////////////////////
        //
        // Get the sources and see what we got to do. Note that if we have more
        // than once source we'll use only the first one but we'll
        //
        // /////////////////////////////////////////////////////////////////////
        final List<CoverageProcessingNode> sources = this.getSources();
        if (sources != null && !sources.isEmpty()) {
            // //
            //
            // only one source, let's forward it, nothing to do.
            //
            // //
            final int size = sources.size();
            final boolean hasAlpha = (alpha != null);
            if (size == 1 && !hasAlpha) {
                // returns the source if we don't need to restore the alpha channel
                return getSource(0).getOutput();
            }
            // //
            //
            // We can accept only 3 sources OR 1 source (when alpha need to be added)
            //
            // //
            if (size != 3 && size != 1) {
                throw new IllegalArgumentException(
                        Errors.format(
                                ErrorKeys.INVALID_NUMBER_OF_SOURCES_$1, Integer.valueOf(size)));
            }

            // /////////////////////////////////////////////////////////////////////
            //
            // we have at least two sources, let's merge them
            //
            // /////////////////////////////////////////////////////////////////////
            final Iterator<CoverageProcessingNode> it = sources.iterator();
            RenderedImage op = null;
            GridGeometry2D gridGeometry = null;
            ImageLayout layout = null;
            final Hints hints = getHints();
            final List<GridCoverage2D> sourceGridCoverages = new ArrayList<>();
            ImageWorker w = new ImageWorker();
            do {
                // //
                //
                // Get the source image and do the merge
                //
                // //
                final CoverageProcessingNode currentSourceNode = (CoverageProcessingNode) it.next();
                final GridCoverage2D currentSourceCoverage =
                        (GridCoverage2D) currentSourceNode.getOutput();
                sourceGridCoverages.add(currentSourceCoverage);
                final GridGeometry2D gg = (GridGeometry2D) currentSourceCoverage.getGridGeometry();
                if (gridGeometry == null) {
                    // get the envelope for the first source.
                    gridGeometry = gg;

                    // color model
                    final ColorSpace colorSpace =
                            (size == 1 && hasAlpha)
                                    ? ColorSpace.getInstance(ColorSpace.CS_GRAY)
                                    : ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB);
                    final int transparency =
                            hasAlpha ? Transparency.TRANSLUCENT : Transparency.OPAQUE;
                    final ComponentColorModel cm =
                            new ComponentColorModel(
                                    colorSpace,
                                    hasAlpha,
                                    false,
                                    transparency,
                                    currentSourceCoverage
                                            .getRenderedImage()
                                            .getSampleModel()
                                            .getDataType());
                    layout = new ImageLayout();
                    layout.setColorModel(cm);
                } else if (!gg.equals(gridGeometry))
                    throw new IllegalArgumentException(
                            Errors.format(ErrorKeys.MUST_SHARE_GRIDGEOMETRY_$1, "BandMerge"));

                // //
                //
                // Merge the current source with the results of the others
                // merges
                //
                // //
                if (op == null) {
                    op = currentSourceCoverage.getRenderedImage();
                    w.setImage(op);
                    w.setROI(CoverageUtilities.getROIProperty(currentSourceCoverage));
                    NoDataContainer container =
                            CoverageUtilities.getNoDataProperty(currentSourceCoverage);
                    w.setNoData(container != null ? container.getAsRange() : null);
                } else {
                    w.setRenderingHints(hints);
                    // ROI handling
                    ROI roi = w.getROI();
                    ROI roiProperty = CoverageUtilities.getROIProperty(currentSourceCoverage);
                    if (roi != null) {
                        if (roiProperty != null) {
                            roi = roi.intersect(roiProperty);
                        }

                    } else if (roiProperty != null) {
                        roi = roiProperty;
                    }

                    w.setROI(roi);
                    NoDataContainer container =
                            CoverageUtilities.getNoDataProperty(currentSourceCoverage);
                    w.addBand(
                            currentSourceCoverage.getRenderedImage(),
                            false,
                            false,
                            container != null ? container.getAsRange() : null);
                    // //
                    //
                    // Save the intermediate image
                    //
                    // //
                    op = w.getRenderedImage();
                    intermediateOps.add(op);
                }

            } while (it.hasNext());

            // /////////////////////////////////////////////////////////////////////
            //
            // let's now create the output coverage and
            //
            // /////////////////////////////////////////////////////////////////////
            if (layout != null) hints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT, layout));
            if (hasAlpha && !op.getColorModel().hasAlpha()) {
                // Only restore the alphaChannel if not already available
                w.addBand(alpha, false, true, null);
                op = w.getRenderedImage();
                intermediateOps.add(op);
            }
            op = w.format(op.getSampleModel().getDataType()).getRenderedImage();
            final GridSampleDimension[] sd =
                    new GridSampleDimension[op.getSampleModel().getNumBands()];
            for (int i = 0; i < sd.length; i++)
                sd[i] =
                        new GridSampleDimension(
                                TypeMap.getColorInterpretation(op.getColorModel(), i).name());

            // Defining NoData and ROI properties
            Map<String, Object> properties = new HashMap<>();
            CoverageUtilities.setNoDataProperty(properties, w.getNoData());
            CoverageUtilities.setROIProperty(properties, w.getROI());
            return getCoverageFactory()
                    .create(
                            "BandMerge",
                            op,
                            gridGeometry,
                            sd,
                            sourceGridCoverages.toArray(
                                    new GridCoverage[sourceGridCoverages.size()]),
                            properties);
        }
        throw new IllegalStateException(
                Errors.format(ErrorKeys.SOURCE_CANT_BE_NULL_$1, "BandMergeNode"));
    }

