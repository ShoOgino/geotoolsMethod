    /**
     * Gets a representative point and tries to place the label according to SLD. If a
     * maxDisplacement has been set and the default position does not work a search for a better
     * position is tried on concentric circles around the label up until the radius of the circle
     * becomes bigger than the max displacement
     */
    private boolean paintPointLabel(
            LabelPainter painter,
            AffineTransform tempTransform,
            Rectangle displayArea,
            LabelIndex glyphs)
            throws Exception {
        LabelCacheItem labelItem = painter.getLabel();
        // get the point onto the shape has to be painted
        Point point =
                getPointSetRepresentativeLocation(
                        labelItem.getGeoms(), displayArea, labelItem.isPartialsEnabled());
        if (point == null) return false;

        // prepare for the search loop
        TextStyle2D ts = labelItem.getTextStyle();
        AffineTransform tx = new AffineTransform(tempTransform);

        // if straight paint works we're good
        if (paintPointLabelInternal(painter, tx, displayArea, glyphs, labelItem, point, ts)) {
            return true;
        }

        // see if we have a search radius
        if (labelItem.maxDisplacement <= 0) {
            return false;
        }

        int[] displacementAngles = labelItem.getDisplacementAngles();

        // ... use at least a 2 pixel step, no matter what the label length is
        final double step = painter.getAscent() > 2 ? painter.getAscent() : 2;
        double radius =
                Math.sqrt(
                        ts.getDisplacementX() * ts.getDisplacementX()
                                + ts.getDisplacementY() * ts.getDisplacementY());

        // get a cloned text style that we can modify without issues
        TextStyle2D cloned = new TextStyle2D(ts);
        // ... and the closest quadrant angle that we'll use to start the search from
        int startAngle = getClosestStandardAngle(ts.getDisplacementX(), ts.getDisplacementY());
        int angle = startAngle;
        while (radius <= labelItem.maxDisplacement) {
            // check for special vertical displacement mode
            if (displacementAngles == null) {
                // the offset is used to generate a x, -x, 2x, -2x, 3x, -3x sequence
                for (int offset = 45; offset <= 360; offset = offset + 45) {
                    double dx = radius * Math.cos(Math.toRadians(angle));
                    double dy = radius * Math.sin(Math.toRadians(angle));

                    // using dx and dy would be easy but due to numeric approximations,
                    // it's actually very hard to get it right so we use the angle
                    double[] anchorPointCandidates;
                    // normalize the angle so that it's between 0 and 360
                    int normAngle = angle % 360;
                    if (normAngle < 0) normAngle = 360 + normAngle;
                    if (normAngle < 90 || normAngle > 270) {
                        anchorPointCandidates = RIGHT_ANCHOR_CANDIDATES;
                    } else if (normAngle > 90 && normAngle < 270) {
                        anchorPointCandidates = LEFT_ANCHOR_CANDIDATES;
                    } else {
                        anchorPointCandidates = MID_ANCHOR_CANDIDATES;
                    }

                    // try out various anchor point positions
                    for (int i = 0; i < anchorPointCandidates.length; i += 2) {
                        double ax = anchorPointCandidates[i];
                        double ay = anchorPointCandidates[i + 1];
                        cloned.setAnchorX(ax);
                        cloned.setAnchorY(ay);
                        cloned.setDisplacementX(dx);
                        cloned.setDisplacementY(dy);

                        tx = new AffineTransform(tempTransform);
                        if (paintPointLabelInternal(
                                painter, tx, displayArea, glyphs, labelItem, point, cloned))
                            return true;
                    }

                    // make sure we do the jumps back and forth to generate the proper sequence
                    if (angle <= startAngle) angle = angle + offset;
                    else angle = angle - offset;
                }
            } else {
                for (int offset : displacementAngles) {
                    angle = offset;
                    double dx = radius * Math.cos(Math.toRadians(angle));
                    double dy = radius * Math.sin(Math.toRadians(angle));

                    double[] anchorPointCandidates = new double[] {0.5, 0.5};
                    if (angle == DisplacementMode.NE.getAngle()) {
                        anchorPointCandidates = RIGHT_UP_ANCHOR_CANDIDATES;
                    } else if (angle == DisplacementMode.SE.getAngle()) {
                        anchorPointCandidates = RIGHT_DOWN_ANCHOR_CANDIDATES;
                    } else if (angle == DisplacementMode.N.getAngle()) {
                        anchorPointCandidates = VERTICAL_UP_ANCHOR_CANDIDATES;
                    } else if (angle == DisplacementMode.S.getAngle()) {
                        anchorPointCandidates = VERTICAL_DOWN_ANCHOR_CANDIDATES;
                    } else if (angle == DisplacementMode.NW.getAngle()) {
                        anchorPointCandidates = LEFT_UP_ANCHOR_CANDIDATES;
                    } else if (angle == DisplacementMode.SW.getAngle()) {
                        anchorPointCandidates = LEFT_DOWN_ANCHOR_CANDIDATES;
                    } else if (angle == DisplacementMode.E.getAngle()) {
                        anchorPointCandidates = HORIZONTAL_LEFT_ANCHOR_CANDIDATES;
                    } else if (angle == DisplacementMode.W.getAngle()) {
                        anchorPointCandidates = HORIZONTAL_RIGHT_ANCHOR_CANDIDATES;
                    }

                    // try out various anchor point positions
                    for (int i = 0; i < anchorPointCandidates.length; i += 2) {
                        double ax = anchorPointCandidates[i];
                        double ay = anchorPointCandidates[i + 1];
                        cloned.setAnchorX(ax);
                        cloned.setAnchorY(ay);
                        cloned.setDisplacementX(dx);
                        cloned.setDisplacementY(dy);
                        tx = new AffineTransform(tempTransform);
                        if (paintPointLabelInternal(
                                painter, tx, displayArea, glyphs, labelItem, point, cloned))
                            return true;
                    }
                }
            }

            // increase the radius and move forward
            radius += step;
        }

        // we tried, we failed...
        return false;
    }

