    public Shape getShape(Graphics2D graphics, Expression symbolUrl, Feature feature)
            throws Exception {
        String markUrl = symbolUrl.evaluate(feature, String.class);

        // if it does not start with the right prefix, it's not our business
        if (!markUrl.startsWith("ttf://"))
            return null;

        // if it does not match the expected format, complain before exiting
        if (!markUrl.matches("ttf://.+#.+")) {
            throw new IllegalArgumentException(
                    "Mark URL font found, but does not match the required "
                            + "structure font://<fontName>#<charNumber>, e.g., ttf://wingdigs#0x7B. You specified "
                            + markUrl);
        }
        String[] fontElements = markUrl.substring(6).split("#");

        // look up the font
        Font font = FontCache.getDefaultInsance().getFont(fontElements[0]);
        if (font == null) {
            throw new IllegalArgumentException("Unknown font " + fontElements[0]);
        }

        // get the symbol number
        String code = fontElements[1];
        char character;
        try {
            // see if a unicode escape sequence has been used
            if (code.startsWith("U+") || code.startsWith("\\u")) 
                code = "0x" + code.substring(2);
            
            // this will handle most numeric formats like decimal, hex and octal
            character = (char) Integer.decode(code).intValue();
            
            // handle charmap code reporting issues 
            if(!font.canDisplay(character))
                character = (char) (0xF000 | character);
            
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException(
                    "Invalid character specification " + fontElements[1], e);
        }

        // build the shape out of the font
        GlyphVector textGlyphVector = font.createGlyphVector(FONT_RENDER_CONTEXT,
                new char[] { (char) character });
        Shape s = textGlyphVector.getOutline();
        
        // have the shape be centered in the origin, and sitting in a square of side 1
        Rectangle2D bounds = s.getBounds2D();
        AffineTransform tx = new AffineTransform();
        double max = Math.max(bounds.getWidth(), bounds.getHeight());
        // all shapes are defined looking "upwards" (see ShapeMarkFactory or WellKnownMarkFactory)
        // but the fonts ones are flipped to compensate for the fact the y coords grow from top
        // to bottom on the screen. We have to flip the symbol so that it conforms to the
        // other marks convention
        tx.scale(1 / max, -1 / max);
        tx.translate(-bounds.getCenterX(), -bounds.getCenterY());
        ExplicitBoundsShape shape = new ExplicitBoundsShape(tx.createTransformedShape(s));
        shape.setBounds(new Rectangle2D.Double(-0.5,0.5,1.0,1.0));
        return shape;
    }

