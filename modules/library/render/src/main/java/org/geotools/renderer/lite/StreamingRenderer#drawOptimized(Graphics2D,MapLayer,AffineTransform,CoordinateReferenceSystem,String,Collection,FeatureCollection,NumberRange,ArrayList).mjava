    /**
     * Performs rendering so that the collection is scanned only once even in presence
     * of multiple feature type styles, using the in memory buffer for each feature type
     * style other than the first one (that uses the graphics provided by the user)s 
     */
    private void drawOptimized(final Graphics2D graphics, MapLayer currLayer, AffineTransform at,
            CoordinateReferenceSystem destinationCrs, String layerId, Collection collection,
            FeatureCollection features, final NumberRange scaleRange, final ArrayList lfts) {
        Iterator iterator = null;
        if( collection != null ) iterator = collection.iterator();        
        if( features != null ) iterator = features.iterator();

        if( iterator == null ) return; // nothing to do

        final LiteFeatureTypeStyle[] fts_array = (LiteFeatureTypeStyle[]) lfts
        .toArray(new LiteFeatureTypeStyle[lfts.size()]);

        try {
            boolean clone = isCloningRequired(currLayer, fts_array);
            RenderableFeature rf = new RenderableFeature(currLayer, clone);
            // loop exit condition tested inside try catch
            // make sure we test hasNext() outside of the try/cath that follows, as that
            // one is there to make sure a single feature error does not ruin the rendering
            // (best effort) whilst an exception in hasNext() + ignoring catch results in
            // an infinite loop
            while (iterator.hasNext() && !renderingStopRequested) { 
                try {
                    rf.setFeature(iterator.next());
                    // draw the feature on the main graphics and on the eventual extra image buffers
                    for (LiteFeatureTypeStyle liteFeatureTypeStyle : fts_array) {
                        rf.setScreenMap(liteFeatureTypeStyle.screenMap);
                        process(rf, liteFeatureTypeStyle, scaleRange, at, destinationCrs, layerId);

                    }
                } catch (Throwable tr) {
                    fireErrorEvent(tr);
                }
            }
            
            // submit the merge request
            requests.put(new MergeLayersRequest(graphics, fts_array));
        }catch(InterruptedException e) {
            fireErrorEvent(e);
        } finally {
            if( collection instanceof FeatureCollection ){
                FeatureCollection resource = (FeatureCollection ) collection;
                resource.close( iterator );
            } else if(features != null) {
                features.close( iterator );
            }
        } 
    }

