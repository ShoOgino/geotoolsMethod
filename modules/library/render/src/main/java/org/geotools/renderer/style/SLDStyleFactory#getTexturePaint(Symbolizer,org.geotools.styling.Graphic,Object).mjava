	/**
	 * DOCUMENT ME!
	 * 
	 * @param gr
	 *            DOCUMENT ME!
	 * @param feature
	 *            DOCUMENT ME!
	 * @return DOCUMENT ME!
	 */
	TexturePaint getTexturePaint(Symbolizer symbolizer, org.geotools.styling.Graphic gr, Object feature) {
		// -1 to have the image use its natural size if none was provided by the
		// user
		double graphicSize = evalToDouble(gr.getSize(), feature, -1);
		GraphicStyle2D gs = null;
		for (ExternalGraphic eg : gr.getExternalGraphics()) {
			gs = getGraphicStyle(eg, feature, graphicSize, 1);
			if (gs != null) {
				break;
			}
		}

		int iSizeX;
		int iSizeY;
		BufferedImage image = null;
		if (gs != null) {
			image = gs.getImage();
			iSizeX = image.getWidth() - gs.getBorder();
			iSizeY = image.getHeight() - gs.getBorder();
			if (LOGGER.isLoggable(Level.FINER)) {
				LOGGER.finer("got an image in graphic fill");
			}
		} else {
			if (LOGGER.isLoggable(Level.FINER)) {
				LOGGER.finer("going for the mark from graphic fill");
			}

			org.geotools.styling.Mark mark = getMark(gr, feature);

			if (mark == null) {
				return null;
			}

			// we need the shape to get to the aspect ratio information, since
			// this info isnt' on the mark.
			Shape shape = getShape(mark, feature);
			if (shape == null) {
				return null;
			}

			Rectangle2D shapeBounds = shape.getBounds2D();

			// The aspect ratio is the relation between the width and height of
			// this mark (x width units per y height units or width/height). The
			// aspect ratio is used to render non isometric sized marks (where
			// width != height). To discover the <code>width</code> of a non
			// isometric
			// mark, simply calculate <code>height * aspectRatio</code>, where
			// height is given by getSize().
			double shapeAspectRatio = (shapeBounds.getHeight() > 0 && shapeBounds
					.getWidth() > 0) ? shapeBounds.getWidth()
					/ shapeBounds.getHeight() : 1.0;

			double size = evalToDouble(gr.getSize(), feature, 16);
			final double sizeX = size * shapeAspectRatio; // apply the aspect
															// ratio to fix the
															// sample's width.
			final double sizeY = size;
			image = new BufferedImage((int) Math.ceil(sizeX * 3), (int) Math
					.ceil(sizeY * 3), BufferedImage.TYPE_INT_ARGB);
			Graphics2D g2d = image.createGraphics();
			g2d.setRenderingHints(renderingHints);
			double rotation = evalToDouble(gr.getRotation(), feature, 0.0);
			for (int i = -1; i < 2; i++) {
				for (int j = -1; j < 2; j++) {
					double tx = sizeX * 1.5 + sizeX * i;
					double ty = sizeY * 1.5 + sizeY * j;
					fillDrawMark(g2d, tx, ty, symbolizer, mark, size, rotation, feature);
				}
			}
			g2d.dispose();

			iSizeX = (int) Math.floor(sizeX);
			iSizeY = (int) Math.floor(sizeY);
			// updated to use the new sizes
			image = image.getSubimage(iSizeX, iSizeY, iSizeX, iSizeY); 
		}

		// do we have a graphic margin? (top,right,bottom,left order)
		int[] margin = voParser.getGraphicMargin(symbolizer, "graphic-margin");
		BufferedImage imageWithMargin;
		if(margin == null) {
		    imageWithMargin = image;
		} else {
		    int extraY = margin[0] + margin[2];
		    int extraX = margin[1] + margin[3];
		    int type = image.getType() == 0 ? BufferedImage.TYPE_4BYTE_ABGR : image.getType();
            imageWithMargin = new BufferedImage(image.getWidth() + extraY, image.getHeight() + extraX, type);
            int tx = margin[3];
            int ty = margin[0];
            AffineTransform at = AffineTransform.getTranslateInstance(tx, ty);
            Graphics2D graphics = imageWithMargin.createGraphics();
            graphics.drawRenderedImage(image, at);
            graphics.dispose();
		}
		
		Rectangle2D.Double rect = new Rectangle2D.Double(0.0, 0.0, imageWithMargin.getWidth(),
		        imageWithMargin.getHeight());
		TexturePaint imagePaint = new TexturePaint(imageWithMargin, rect);

		if (LOGGER.isLoggable(Level.FINER)) {
			LOGGER.finer("applied TexturePaint " + imagePaint);
		}

		return imagePaint;
	}

