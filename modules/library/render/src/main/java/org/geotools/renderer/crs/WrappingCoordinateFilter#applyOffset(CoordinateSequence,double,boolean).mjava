    private void applyOffset(CoordinateSequence cs, double offset, boolean ring) {
        final double maxWrap = wrapLimit * 1.9;
        double lastOrdinate = cs.getOrdinate(0, ordinateIdx);
        int last = ring ? cs.size() - 1 : cs.size(); 
        for (int i = 0; i < last; i++) {
            final double ordinate = cs.getOrdinate(i, ordinateIdx);
            final double distance = Math.abs(ordinate - lastOrdinate);
            // heuristic: an object crossing the dateline is not as big as the world, if it
            // is, it's probably something like Antarctica that does not need coordinate rewrapping
            if (distance > wrapLimit) {
                boolean wraps = distance < maxWrap;
                // if we fail here, revert to more expensive calculation if
                // we have a reverse transform
                // this is analagous to the technique mentioned here:
                // http://trac.osgeo.org/mapserver/ticket/15
                if (!wraps && mt != null) {
                    // convert back to projected coordinates
                    double[] src;
                    if(ordinateIdx == 0) {
                        src = new double[] {lastOrdinate, cs.getY(i - 1), ordinate, cs.getY(i)};
                    } else {
                        src = new double[] {cs.getX(i - i), lastOrdinate, cs.getX(i), ordinate};
                    }
                    double[] dest = new double[4];
                    try {
                        mt.transform(src, 0, dest, 0, 2);
                        // find the midpoint coordinate
                        src[0] = Math.min(dest[0], dest[2]) + Math.abs(dest[2] - dest[0]) / 2;
                        src[1] = Math.min(dest[1], dest[3]) + Math.abs(dest[3] - dest[1]) / 2;
                        // and convert back again
                        mt.inverse().transform(src, 0, dest, 0, 1);
                        // if the midpoint isn't between the two end points, it's a wrap
                        wraps = !(dest[ordinateIdx] > Math.min(lastOrdinate, ordinate) && dest[ordinateIdx] < Math.max(lastOrdinate, ordinate));
                    } catch (TransformException ex) {
                        Logging.getLogger("org.geotools.rendering").log(Level.WARNING,
                                "Unable to perform transform to detect dateline wrapping", ex);
                    }
                }
                // toggle between offset
                if (wraps) {
                    if (offset != 0) {
                        offset = 0;
                    } else {
                        offset = wrapLimit * 2;
                    }
                }
            }

            if (offset != 0)
                cs.setOrdinate(i, ordinateIdx, ordinate + offset);
            
            lastOrdinate = ordinate;
        }
        if(ring) {
            cs.setOrdinate(last, ordinateIdx, cs.getOrdinate(0, ordinateIdx));
        }
    }

