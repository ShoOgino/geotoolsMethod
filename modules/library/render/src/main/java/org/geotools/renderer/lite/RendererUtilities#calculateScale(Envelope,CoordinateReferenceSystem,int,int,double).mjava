    /**
     * Find the scale denominator of the map. Method: 1. find the diagonal distance (meters) 2. find
     * the diagonal distance (pixels) 3. find the diagonal distance (meters) -- use DPI 4. calculate
     * scale (#1/#2)
     *
     * <p>NOTE: return the scale denominator not the actual scale (1/scale = denominator)
     *
     * <p>TODO: (SLD spec page 28): Since it is common to integrate the output of multiple servers
     * into a single displayed result in the web-mapping environment, it is important that different
     * map servers have consistent behaviour with respect to processing scales, so that all of the
     * independent servers will select or deselect rules at the same scales. To insure consistent
     * behaviour, scales relative to coordinate spaces must be handled consistently between map
     * servers. For geographic coordinate systems, which use angular units, the angular coverage of
     * a map should be converted to linear units for computation of scale by using the circumference
     * of the Earth at the equator and by assuming perfectly square linear units. For linear
     * coordinate systems, the size of the coordinate space should be used directly without
     * compensating for distortions in it with respect to the shape of the real Earth.
     *
     * <p>NOTE: we are actually doing a a much more exact calculation, and accounting for non-square
     * pixels (which are allowed in WMS) ADDITIONAL NOTE from simboss: I added soe minor fixes. See
     * below.
     *
     * @param envelope
     * @param coordinateReferenceSystem
     * @param imageWidth
     * @param imageHeight
     * @param DPI screen dots per inch (OGC standard is 90)
     * @throws TransformException
     * @throws FactoryException
     * @deprecated
     */
    public static double calculateScale(
            Envelope envelope,
            CoordinateReferenceSystem coordinateReferenceSystem,
            int imageWidth,
            int imageHeight,
            double DPI)
            throws TransformException, FactoryException {

        final CoordinateReferenceSystem tempCRS = CRS.getHorizontalCRS(coordinateReferenceSystem);
        if (tempCRS == null)
            throw new TransformException(
                    Errors.format(
                            ErrorKeys.CANT_REDUCE_TO_TWO_DIMENSIONS_$1, coordinateReferenceSystem));
        // final CoordinateSystem tempCS = tempCRS.getCoordinateSystem();
        // final MathTransform preTransform;
        // if (tempCS.getAxis(0).getDirection().absolute().equals(
        // AxisDirection.NORTH)) {
        // preTransform = ProjectiveTransform.create(new AffineTransform(0, 1,
        // 1, 0, 0, 0));
        //
        // } else
        // preTransform = ProjectiveTransform.create(AffineTransform
        // .getTranslateInstance(0, 0));

        // DJB: be much wiser if the requested image is larger than the world
        // (this happens VERY OFTEN)
        // we first convert to WSG84 and check to see if we're outside the
        // 'world'
        // bbox
        final double[] cs = new double[4];
        final double[] csLatLong = new double[4];
        final Coordinate p1 = new Coordinate(envelope.getMinX(), envelope.getMinY());
        final Coordinate p2 = new Coordinate(envelope.getMaxX(), envelope.getMaxY());
        cs[0] = p1.x;
        cs[1] = p1.y;
        cs[2] = p2.x;
        cs[3] = p2.y;

        // transform the provided crs to WGS84 lon,lat
        final MathTransform transform =
                CRS.findMathTransform(tempCRS, DefaultGeographicCRS.WGS84, true);
        transform.transform(cs, 0, csLatLong, 0, 2);

        // in long/lat format
        if ((csLatLong[0] < -180)
                || (csLatLong[0] > 180)
                || (csLatLong[2] < -180)
                || (csLatLong[2] > 180)
                || (csLatLong[1] < -90)
                || (csLatLong[1] > 90)
                || (csLatLong[3] < -90)
                || (csLatLong[3] > 90)) {
            // we have a problem -- the bbox is outside the 'world' so distance
            // will fail we handle this by making a new measurement for a smaller portion
            // of the image - the portion thats inside the world.
            // If the request is outside the world then we need to throw an
            // error

            if ((csLatLong[0] > csLatLong[2]) || (csLatLong[1] > csLatLong[3]))
                throw new IllegalArgumentException("BBox is backwards");
            if (((csLatLong[0] < -180) || (csLatLong[0] > 180))
                    && ((csLatLong[2] < -180) || (csLatLong[2] > 180))
                    && ((csLatLong[1] < -90) || (csLatLong[1] > 90))
                    && ((csLatLong[3] < -90) || (csLatLong[3] > 90)))
                throw new IllegalArgumentException("World isn't in the requested bbox");

            // okay, all good. We need to find the world bbox intersect the
            // requested bbox then we're going to convert that back to the
            // original coordinate reference system and from there we can find
            // the (x1,y2) and (x2,y2) of this new bbox.
            // At that point we can do simple math to find the distance.

            final double[] newCsLatLong = new double[4]; // intersected with
            // the world bbox

            newCsLatLong[0] = Math.min(Math.max(csLatLong[0], -180), 180);
            newCsLatLong[1] = Math.min(Math.max(csLatLong[1], -90), 90);
            newCsLatLong[2] = Math.min(Math.max(csLatLong[2], -180), 180);
            newCsLatLong[3] = Math.min(Math.max(csLatLong[3], -90), 90);

            double[] origProject = new double[4];
            transform.transform(newCsLatLong, 0, origProject, 0, 2);

            // have the truncated bbox in the original projection, so we can
            // find the image (x,y) for the two points.
            double image_min_x =
                    (origProject[0] - envelope.getMinX()) / envelope.getWidth() * imageWidth;
            double image_max_x =
                    (origProject[2] - envelope.getMinX()) / envelope.getWidth() * imageWidth;

            double image_min_y =
                    (origProject[1] - envelope.getMinY()) / envelope.getHeight() * imageHeight;
            double image_max_y =
                    (origProject[3] - envelope.getMinY()) / envelope.getHeight() * imageHeight;

            double distance_ground =
                    JTS.orthodromicDistance(
                            new Coordinate(newCsLatLong[0], newCsLatLong[1]),
                            new Coordinate(newCsLatLong[2], newCsLatLong[3]),
                            DefaultGeographicCRS.WGS84);
            double pixel_distance =
                    Math.sqrt(
                            (image_max_x - image_min_x) * (image_max_x - image_min_x)
                                    + (image_max_y - image_min_y) * (image_max_y - image_min_y));
            double pixel_distance_m = pixel_distance / DPI * 2.54 / 100.0;
            return distance_ground / pixel_distance_m;
            // remember, this is the denominator, not the actual scale;
        }

        // simboss:
        // this way we never ran into problems with lat,lon lon,lat
        double diagonalGroundDistance =
                JTS.orthodromicDistance(
                        new Coordinate(csLatLong[0], csLatLong[1]),
                        new Coordinate(csLatLong[2], csLatLong[3]),
                        DefaultGeographicCRS.WGS84);
        // pythagorus theorm
        double diagonalPixelDistancePixels =
                Math.sqrt(imageWidth * imageWidth + imageHeight * imageHeight);
        double diagonalPixelDistanceMeters =
                diagonalPixelDistancePixels / DPI * 2.54 / 100; // 2.54 = cm/inch, 100= cm/m
        return diagonalGroundDistance / diagonalPixelDistanceMeters;
        // remember, this is the denominator, not the actual scale;
    }

