    /**
     * creates a list of LiteFeatureTypeStyles a) out-of-scale rules removed b)
     * incompatible FeatureTypeStyles removed
     * 
     * 
     * @param featureStylers
     * @param features
     * @throws Exception
     * @return ArrayList<LiteFeatureTypeStyle>
     */
    private ArrayList<LiteFeatureTypeStyle> createLiteFeatureTypeStyles(
            List<FeatureTypeStyle> featureStyles, FeatureType ftype,
            Graphics2D graphics) throws IOException {
        if (LOGGER.isLoggable(Level.FINE))
            LOGGER.fine("creating rules for scale denominator - "
                    + NumberFormat.getNumberInstance().format(scaleDenominator));
        ArrayList<LiteFeatureTypeStyle> result = new ArrayList<LiteFeatureTypeStyle>();

        LiteFeatureTypeStyle lfts;
        boolean foundComposite = false;
        for (FeatureTypeStyle fts : featureStyles) {
            if (isFeatureTypeStyleActive(ftype, fts)) {
                // DJB: this FTS is compatible with this FT.

                // get applicable rules at the current scale
                List[] splittedRules = splitRules(fts);
                List ruleList = splittedRules[0];
                List elseRuleList = splittedRules[1];

                // if none, skip it
                if ((ruleList.isEmpty()) && (elseRuleList.isEmpty()))
                    continue;

                // get the fts level composition, if any
                Composite composite = styleFactory.getComposite(fts.getOptions());
                foundComposite |= composite != null;

                // we can optimize this one and draw directly on the graphics, assuming
                // there is no composition
                if (!foundComposite && (result.isEmpty() || !isOptimizedFTSRenderingEnabled())) {
                    lfts = new LiteFeatureTypeStyle(graphics, ruleList,
                            elseRuleList, fts.getTransformation());
                } else {
                    lfts = new LiteFeatureTypeStyle(new DelayedBackbufferGraphic(graphics, screenSize), 
                            ruleList, elseRuleList, fts.getTransformation());
                }
                lfts.composite = composite;
                if (FeatureTypeStyle.VALUE_EVALUATION_MODE_FIRST.equals(fts.getOptions().get(
                        FeatureTypeStyle.KEY_EVALUATION_MODE))) {
                    lfts.matchFirst = true;
                }
                if (screenMapEnabled(lfts)) {
                    int renderingBuffer = getRenderingBuffer();
                    lfts.screenMap = new ScreenMap(screenSize.x - renderingBuffer, screenSize.y
                            - renderingBuffer, screenSize.width + renderingBuffer * 2,
                            screenSize.height + renderingBuffer * 2);
                }
                                                   
                result.add(lfts);
            }
        }

        return result;
    }

