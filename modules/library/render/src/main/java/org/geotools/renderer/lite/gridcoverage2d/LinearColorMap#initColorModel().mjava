	private synchronized void initColorModel() {
		if (colorModel == null) {
			// /////////////////////////////////////////////////////////////////////
			//
			//  STEP 1
			//
			/////
			// First of all let's create the palette for the standard values.
			// Afterward we look for the right values for the default color and
			// for the preserving values color if present since these could
			// reuse the same colors used for the standard values.
			//
			// /////////////////////////////////////////////////////////////////////

			// //
			//
			// Computes the number of entries required for the color
			// palette.
			// Note that in case the output range has non inclusive edges we
			// have already taken that into account when building the outMax
			// and outMin values hence we do not have to do that again.
			//
			// //
			BigInteger bits = new BigInteger("0");		
			final boolean preFilteringValuesPresent=preFilteringColor!=null;
			int elementsCount = standardElements.length+(preFilteringValuesPresent?1:0);
			int max=-1;
			for (int i = 0; i < elementsCount; i++) {
				final DefaultLinearPiecewiseTransform1DElement element = 
					i<standardElements.length?
							(DefaultLinearPiecewiseTransform1DElement) standardElements[i]:
							preFilteringElements[0];
				final int elementMin=(int) element.getOutputMinimum();
				final int elementMax=(int) element.getOutputMaximum();
				for (int k = elementMin; k <= elementMax; k++)
					bits = bits.setBit(k);
				max = (int) Math.max(max, elementMax);
			}
			//zero based indexing
			max++;
			
			// /////////////////////////////////////////////////////////////////////
			//
			// Interpolate the colors in the color palette for standard values
			//
			// /////////////////////////////////////////////////////////////////////
			int[] ARGB = new int[max];
			int outMax=0,outMin=0;
			for (int i = 0; i < elementsCount; i++) {
				// I know that all the categories here are both
				// ColorMapTransformElement and DefaultLinearPiecewiseTransform1DElement. The
				// eventual NoDtaCategory as well.
				final LinearColorMapElement element = i<standardElements.length? standardElements[i]:preFilteringElements[0];
				// //
				//
				// Check if this category overlap with another one as far as
				// the output value but with the same color. We already
				// checked that they had the same color. If this happens we
				// prevent the code from creating a new entry at the same
				// place with the same color, no rocket science going on
				// here!
				//
				// //
				outMin = (int) element.getOutputMinimum();
				outMax = (int) (element.getOutputMaximum());
				//NOTE the second element is exclusive!!!
				ColorUtilities.expand(element.getColors(), ARGB, outMin, outMax+1);
			}

			//create the prefiltering piecewise
			this.preFilteringPiecewise=preFilteringElements==null?null:new DefaultPiecewiseTransform1D<LinearColorMapElement>(preFilteringElements);
			
			// /////////////////////////////////////////////////////////////////////
			//
			//  STEP 2
			//
			/////
			// Now, if we do not have any default color we can proceed,
			// otherwise we got some work to do. First of all, we need to check
			// if the colors we are asked to use for the special cases are
			// already in use. In such a case we don't reserve another index in
			// the palette for them. Otherwise we have to add the new colors and
			// recreate the ASRGB array.
			//
			// /////////////////////////////////////////////////////////////////////
			final boolean lookForDefaultColor=defaultColor!=null;
			boolean defaultColorFound=!lookForDefaultColor;
			if(lookForDefaultColor){
				
				////
				//
				// Search in the color map if we have the requested colors
				//
				////
				int defaultColorIndex=-1;
				for(int i=0;i<ARGB.length;i++)
				{
					if(lookForDefaultColor&&defaultColorIndex==-1&&bits.testBit(i)&&ARGB[i]==defaultColor.getRGB())
					{
						defaultColorIndex=i;
						defaultColorFound=true;
						break;
					}

						
				}
				//now see what happened
				if(defaultColorFound)
					this.piecewise= new DefaultPiecewiseTransform1D<LinearColorMapElement>(this.standardElements,defaultColorIndex);
				else
				{
					//check the bit vector for the first place available
					int i=0;
					for(;i<max;i++)
						if(!bits.testBit(i))
							break;
					if(i==max){
						max=i==max?max+1:max;
						bits=bits.setBit(i);
						final int[] tempARGB = new int[max];
						System.arraycopy(ARGB, 0, tempARGB, 0, ARGB.length);
						tempARGB[tempARGB.length-1]=defaultColor.getRGB();
						ARGB=tempARGB;	
					}
					this.piecewise= new DefaultPiecewiseTransform1D<LinearColorMapElement>(this.standardElements,max);
				}

			}
			else
			{
				this.piecewise= new DefaultPiecewiseTransform1D<LinearColorMapElement>(this.standardElements);
			}
			
			colorModel = new IndexColorModel(ColorUtilities
					.getBitCount(max), max, ARGB, 0, ColorUtilities
					.getTransferType(max), bits);
		}
		
	}

