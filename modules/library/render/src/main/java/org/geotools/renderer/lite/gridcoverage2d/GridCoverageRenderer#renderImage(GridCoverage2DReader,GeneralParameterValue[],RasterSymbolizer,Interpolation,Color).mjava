    private RenderedImage renderImage(
            final GridCoverage2DReader reader,
            GeneralParameterValue[] readParams,
            final RasterSymbolizer symbolizer,
            final Interpolation interpolation,
            final Color background)
            throws FactoryException, IOException, TransformException {
        // see if we have a projection handler
        CoordinateReferenceSystem sourceCRS = reader.getCoordinateReferenceSystem();
        CoordinateReferenceSystem targetCRS = destinationEnvelope.getCoordinateReferenceSystem();

        // Check if reader supports band selection, and rearrange raster channels order in
        // symbolizer. Reader should have taken care o proper channel order, based on initial
        // symbolizer channel definition
        RasterSymbolizer finalSymbolizer = symbolizer;
        if (symbolizer != null && isBandsSelectionApplicable(reader, symbolizer)) {
            readParams = applyBandsSelectionParameter(reader, readParams, symbolizer);
            finalSymbolizer = setupSymbolizerForBandsSelection(symbolizer);
        }

        ProjectionHandler handler = null;
        List<GridCoverage2D> coverages;
        // read all the coverages we need, cut and whatnot
        GridCoverageReaderHelper rh =
                new GridCoverageReaderHelper(
                        reader,
                        destinationSize,
                        ReferencedEnvelope.reference(destinationEnvelope),
                        interpolation,
                        hints);
        // are we dealing with a remote service wrapped in a reader, one that can handle
        // reprojection
        // by itself?
        if (GridCoverageReaderHelper.isReprojectingReader(reader)) {
            GridCoverage2D coverage = rh.readCoverage(readParams);
            coverages = new ArrayList<>();
            coverages.add(coverage);
        } else {
            if (advancedProjectionHandlingEnabled) {
                handler =
                        ProjectionHandlerFinder.getHandler(
                                rh.getReadEnvelope(), sourceCRS, wrapEnabled);
                if (handler instanceof WrappingProjectionHandler) {
                    // raster data is monolithic and can cover the whole world, disable
                    // the geometry wrapping heuristic
                    ((WrappingProjectionHandler) handler).setDatelineWrappingCheckEnabled(false);
                }
            }
            coverages = rh.readCoverages(readParams, handler, gridCoverageFactory);
        }
        logCoverages("read", coverages);

        // establish the background values, and expand palettes if the bgcolor cannot be represented
        double[] bgValues = GridCoverageRendererUtilities.colorToArray(background);
        // If coverage is out of view area, coverages has size 1 but the first element is null
        if (!coverages.isEmpty() && coverages.get(0) != null) {
            ColorModel cm = coverages.get(0).getRenderedImage().getColorModel();
            if (cm instanceof IndexColorModel && background != null) {
                IndexColorModel icm = (IndexColorModel) cm;
                int idx = ColorUtilities.findColorIndex(background, icm);
                if (idx < 0) {
                    // not found, we have to expand
                    for (int i = 0; i < coverages.size(); i++) {
                        GridCoverage2D coverage = coverages.get(i);
                        ImageWorker iw = new ImageWorker(coverage.getRenderedImage());
                        iw.forceComponentColorModel();
                        GridCoverage2D expandedCoverage =
                                gridCoverageFactory.create(
                                        coverage.getName(),
                                        iw.getRenderedImage(),
                                        coverage.getGridGeometry(),
                                        null,
                                        new GridCoverage2D[] {coverage},
                                        coverage.getProperties());
                        coverages.set(i, expandedCoverage);
                    }
                }
            } else {
                bgValues = GridCoverageRendererUtilities.colorToArray(background);
            }
        }

        // if we need to reproject, we need to ensure that none of the pixels go out of
        // the projection valid area, not even slightly
        coverages =
                GridCoverageRendererUtilities.forceToValidBounds(
                        coverages, handler, bgValues, destinationCRS, hints);
        logCoverages("cropped", coverages);

        // reproject if needed
        List<GridCoverage2D> reprojectedCoverages =
                GridCoverageRendererUtilities.reproject(
                        coverages,
                        destinationCRS,
                        interpolation,
                        destinationEnvelope,
                        bgValues,
                        gridCoverageFactory,
                        hints);
        logCoverages("reprojected", reprojectedCoverages);

        // displace them if needed via a projection handler
        List<GridCoverage2D> displacedCoverages =
                GridCoverageRendererUtilities.displace(
                        reprojectedCoverages,
                        handler,
                        destinationEnvelope,
                        sourceCRS,
                        targetCRS,
                        gridCoverageFactory);

        GridCoverageRendererUtilities.removeNotIntersecting(
                displacedCoverages, destinationEnvelope);
        logCoverages("displaced", displacedCoverages);

        // symbolize each bit (done here to make sure we can perform the warp/affine reduction)
        List<GridCoverage2D> symbolizedCoverages = new ArrayList<>();
        if (finalSymbolizer != null) {
            for (GridCoverage2D displaced : displacedCoverages) {
                GridCoverage2D symbolized = symbolize(displaced, finalSymbolizer, bgValues);
                if (symbolized != null) {
                    symbolizedCoverages.add(symbolized);
                }
            }
        } else if (!coverages.isEmpty()
                && !CRS.equalsIgnoreMetadata(
                        coverages.get(0).getCoordinateReferenceSystem2D(), destinationCRS)) {
            // do the affine step to allow warp/affine merging, in order to best preserve rotations
            // in the warp in case of oversampling
            for (GridCoverage2D displaced : displacedCoverages) {
                final GridCoverage2D affined = affine(displaced, bgValues, symbolizer);
                if (affined != null) {
                    symbolizedCoverages.add(affined);
                }
            }
        } else {
            symbolizedCoverages.addAll(displacedCoverages);
        }

        logCoverages("symbolized", symbolizedCoverages);

        // Parameters used for taking into account an optional removal of the alpha band
        // and an optional reindexing after color expansion

        // if more than one coverage, mosaic
        GridCoverage2D mosaicked =
                GridCoverageRendererUtilities.mosaicSorted(
                        symbolizedCoverages, destinationEnvelope, bgValues, this.hints);

        // the mosaicking can cut off images that are just slightly out of the
        // request (effect of the read buffer + a request touching the actual data area)
        if (mosaicked == null) {
            return null;
        }

        // at this point, we might have a coverage that's still slightly larger
        // than the one requested, crop as needed
        GridCoverage2D cropped = crop(mosaicked, destinationEnvelope, false, bgValues);
        return getImageFromParentCoverage(cropped);
    }

