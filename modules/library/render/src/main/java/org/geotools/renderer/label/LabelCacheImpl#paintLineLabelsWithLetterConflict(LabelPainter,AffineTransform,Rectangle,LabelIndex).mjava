    // Modified version of paintLineLabels
    // We compute the Bounding box for each letters instead of the whole label
    // then we check each letters for collisions
    private boolean paintLineLabelsWithLetterConflict(
            LabelPainter painter,
            AffineTransform originalTransform,
            Rectangle displayArea,
            LabelIndex paintedBounds)
            throws Exception {
        final LabelCacheItem labelItem = painter.getLabel();
        List<LineString> lines =
                getLineSetRepresentativeLocation(
                        labelItem.getGeoms(),
                        displayArea,
                        labelItem.removeGroupOverlaps(),
                        labelItem.isPartialsEnabled());

        if (lines == null || lines.size() == 0) return false;

        // if we just want to label the longest line, remove the others
        if (!labelItem.labelAllGroup() && lines.size() > 1) {
            lines = Collections.singletonList(lines.get(0));
        }

        // pre compute some labelling params
        final Rectangle2D textBounds = painter.getFullLabelBounds();
        // ... use at least a 8 pixel step (curved processing is quite expensive), no matter what
        // the label length is
        final double step = painter.getLineHeight() > 8 ? painter.getLineHeight() : 8;
        // repetition distance, if any
        int labelDistance = labelItem.getRepeat();
        if (labelDistance > 0 && labelItem.isFollowLineEnabled()) {
            labelDistance += textBounds.getWidth();
        }
        // min distance, if any
        LabelIndex groupLabels = new LabelIndex();
        // Max displacement for the current label
        double labelOffset = labelItem.getMaxDisplacement();
        boolean allowOverruns = labelItem.allowOverruns();
        double maxAngleDelta = labelItem.getMaxAngleDelta();

        final int perpendicularOffset = painter.getLabel().getTextStyle().getPerpendicularOffset();
        OffsetCurveBuilder offsetBuilder = null;
        if (perpendicularOffset != 0) {
            offsetBuilder = new OffsetCurveBuilder(perpendicularOffset, 2);
        }
        int labelCount = 0;
        for (LineString line : lines) {
            // if we are following lines, use a simplified version of the line,
            // we don't want very small segments to influence the character
            // orientation
            if (labelItem.isFollowLineEnabled()) {
                line = decimateLineString(line, step);
                if (offsetBuilder != null) {
                    // offset the line and replace it
                    line = (LineString) offsetBuilder.offset(line);
                }
            }

            // max distance between candidate label points, if any
            final double lineStringLength = line.getLength();

            // if the line is too small compared to the label, don't label it
            // and exit right away, since the lines are sorted from longest to
            // shortest
            if ((!allowOverruns || labelItem.isFollowLineEnabled())
                    && line.getLength() < textBounds.getWidth()) {
                return labelCount > 0;
            }

            double[] labelPositions = buildLabelPositions(labelDistance, lineStringLength);

            // Ok, now we try to paint each of the labels in each position, and
            // we take into
            // account that we might have to displace the labels
            LineStringCursor cursor = new LineStringCursor(line);
            AffineTransform tx = new AffineTransform();
            boolean mightSkipLastLabel =
                    line.isClosed()
                            && (lineStringLength - ((labelPositions.length - 1) * labelDistance))
                                    < labelDistance;
            for (int i = 0; i < labelPositions.length; i++) {
                cursor.moveTo(labelPositions[i]);
                Coordinate centroid = cursor.getCurrentPosition();
                double currOffset = 0;

                // label displacement loop
                boolean painted = false;
                while (Math.abs(currOffset) <= (labelOffset * 2) && !painted) {
                    // reset transform and other computation parameters
                    tx.setToIdentity();
                    double maxAngleChange = 0;
                    boolean curved = false;

                    // the line ordinates where we presume the label will start
                    // and end (using full bounds,
                    // thus taking into account shield and halo)
                    double startOrdinate = cursor.getCurrentOrdinate() - textBounds.getWidth() / 2;
                    double endOrdinate = cursor.getCurrentOrdinate() + textBounds.getWidth() / 2;

                    // compute label bounds
                    if (labelItem.followLineEnabled) {
                        // curved label, but we might end up drawing a straight
                        // one as an optimization
                        maxAngleChange = cursor.getMaxAngleChange(startOrdinate, endOrdinate);
                        setupLineTransform(painter, cursor, centroid, tx, true);
                        curved = maxAngleChange >= MIN_CURVED_DELTA;
                    } else {
                        setupLineTransform(painter, cursor, centroid, tx, false);
                    }

                    GlyphVectorProcessor glyphVectorProcessor = null;
                    // List<AffineTransform> transforms = null;
                    // For curved labels, we want the glyph's bounding box
                    // to follow the line
                    if (curved) {
                        LineStringCursor oldCursor = new LineStringCursor(cursor);
                        glyphVectorProcessor = new GlyphVectorProcessor.Curved(painter, oldCursor);
                    } else {
                        glyphVectorProcessor = new GlyphVectorProcessor.Straight(painter, tx);
                    }

                    // We check each letters for collision
                    boolean collision = false;
                    collision =
                            glyphVectorProcessor.process(
                                    new GlyphProcessor.ConflictDetector(
                                            painter, displayArea, paintedBounds, groupLabels),
                                    true);

                    // If none of the glyphs intersects a bounding box,
                    // we paint the label
                    if (!collision) {
                        if (labelItem.isFollowLineEnabled()) {
                            // for curved labels we never paint in case of
                            // overrun
                            if ((startOrdinate > 0
                                    && endOrdinate <= cursor.getLineStringLength())) {
                                if (maxAngleChange <= maxAngleDelta) {
                                    // a max distance related to both the font size, but also having
                                    // a visual limit
                                    // of a couple of millimeters assuming 90dpi
                                    double maxDistance = Math.min(painter.getLineHeight() / 2, 7);
                                    // if straight segment connecting the start and end ordinate is
                                    // really close, paint as a straight label
                                    if (maxAngleChange == 0
                                            || cursor.getMaxDistanceFromStraightLine(
                                                            startOrdinate, endOrdinate)
                                                    < maxDistance) {
                                        painter.paintStraightLabel(tx);
                                    } else {
                                        painter.paintCurvedLabel(cursor);
                                    }
                                    painted = true;
                                }
                            }
                        } else {
                            // for straight labels, check overrun only if
                            // required
                            if ((allowOverruns
                                    || (startOrdinate > 0
                                            && endOrdinate <= cursor.getLineStringLength()))) {
                                painter.paintStraightLabel(tx);
                                painted = true;
                            }
                        }
                    }

                    // if we actually painted the label, add the envelope to the
                    // indexes and break out of the loop,
                    // otherwise move to the next candidate position in the
                    // displacement sequence
                    if (painted) {
                        labelCount++;

                        if (labelItem.isConflictResolutionEnabled()) {
                            if (DEBUG_CACHE_BOUNDS) {
                                painter.graphics.setStroke(new BasicStroke());
                                painter.graphics.setColor(Color.RED);
                                glyphVectorProcessor.process(
                                        new GlyphProcessor.BoundsPainter(painter));
                            }

                            // Add each glyph's bounding box to the index
                            glyphVectorProcessor.process(
                                    new GlyphProcessor.IndexAdder(painter, paintedBounds));
                        }

                        // do not paint the last label on a ring if we have painted its symmetric
                        // one and the residual space at the ends does not guarantee labelDistance
                        // between last and second to last
                        if ((i == labelPositions.length - 2) && painted && mightSkipLastLabel) {
                            i++;
                        }
                    } else {
                        // generate a sequence like s, -2s, 3s, -4s,...
                        // which will make the cursor alternate on
                        // mid + s, mid - s, mid + 2s, mid - 2s, mid + 3s,...
                        currOffset = nextOffset(currOffset, step);
                        cursor.moveRelative(currOffset);
                        cursor.getCurrentPosition(centroid);
                    }
                }
            }
        }
        return labelCount > 0;
    }

