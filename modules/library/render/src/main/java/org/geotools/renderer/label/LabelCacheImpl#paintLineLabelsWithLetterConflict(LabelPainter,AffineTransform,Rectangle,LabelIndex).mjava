    //Modified version of paintLineLabels
    //We compute the Bounding box for each letters instead of the whole label
    //then we check each letters for collisions
    private boolean paintLineLabelsWithLetterConflict(LabelPainter painter, AffineTransform originalTransform,
            Rectangle displayArea, LabelIndex paintedBounds) throws Exception {
        final LabelCacheItem labelItem = painter.getLabel();
        List<LineString> lines = getLineSetRepresentativeLocation(
                labelItem.getGeoms(), displayArea, labelItem.removeGroupOverlaps(),
                labelItem.isPartialsEnabled());

        if (lines == null || lines.size() == 0)
            return false;

        // if we just want to label the longest line, remove the others
        if (!labelItem.labelAllGroup() && lines.size() > 1) {
            lines = Collections.singletonList(lines.get(0));
        }

        // pre compute some labelling params
        final Rectangle2D textBounds = painter.getFullLabelBounds();
        // ... use at least a 8 pixel step (curved processing is quite expensive), no matter what the label length is
        final double step = painter.getLineHeight() > 8 ? painter.getLineHeight() : 8;
        int space = labelItem.getSpaceAround();
        // repetition distance, if any
        int labelDistance = labelItem.getRepeat();
        if(labelDistance > 0 && labelItem.isFollowLineEnabled()) {
            labelDistance += textBounds.getWidth();
        }
        // min distance, if any
        int minDistance = labelItem.getMinGroupDistance();
        LabelIndex groupLabels = new LabelIndex();
        // Max displacement for the current label
        double labelOffset = labelItem.getMaxDisplacement();
        boolean allowOverruns = labelItem.allowOverruns();
        double maxAngleDelta = labelItem.getMaxAngleDelta();

        int labelCount = 0;
        for (LineString line : lines) {
            // if we are following lines, use a simplified version of the line,
            // we don't want very small segments to influence the character
            // orientation
            if (labelItem.isFollowLineEnabled())
                line = decimateLineString(line, step);

            // max distance between candidate label points, if any
            final double lineStringLength = line.getLength();

            // if the line is too small compared to the label, don't label it
            // and exit right away, since the lines are sorted from longest to
            // shortest
            if ((!allowOverruns || labelItem.isFollowLineEnabled())
                    && line.getLength() < textBounds.getWidth()){
                return labelCount > 0;
            }

            // create the candidate positions for the labels over the line. If
            // we can place just one
            // label or we're not supposed to replicate them, create the mid
            // position, otherwise
            // create mid and then create the sequence of before and after
            // labels
            double[] labelPositions;
            if (labelDistance > 0 && labelDistance < lineStringLength / 2) {
                // one label in the middle, plus all the labels we can fit before/after on the two half lines
                final int positionCount = (int) ((lineStringLength / 2) / labelDistance) * 2 + 1;
                labelPositions = new double[positionCount];
                labelPositions[0] = lineStringLength / 2;
                double offset = labelDistance;
                for (int i = 1; i < labelPositions.length; i++) {
                    labelPositions[i] = labelPositions[i - 1] + offset;
                    // this will generate a sequence like s, -2s, 3s, -4s, ...
                    // which will make the cursor alternate on mid + s, mid - s,
                    // mid + 2s, mid - 2s, mid + 3s, ...
                    offset = nextOffset(offset, labelDistance);
                }
            } else {
                labelPositions = new double[1];
                labelPositions[0] = lineStringLength / 2;
            }

            // Ok, now we try to paint each of the labels in each position, and
            // we take into
            // account that we might have to displace the labels
            LineStringCursor cursor = new LineStringCursor(line);
            AffineTransform tx = new AffineTransform();
            for (int i = 0; i < labelPositions.length; i++) {
                cursor.moveTo(labelPositions[i]);
                Coordinate centroid = cursor.getCurrentPosition();
                double currOffset = 0;

                // label displacement loop
                boolean painted = false;
                while (Math.abs(currOffset) <= (labelOffset * 2) && !painted) {
                    // reset transform and other computation parameters
                    tx.setToIdentity();
                    double maxAngleChange = 0;
                    boolean curved = false;

                    // the line ordinates where we presume the label will start
                    // and end (using full bounds,
                    // thus taking into account shield and halo)
                    double startOrdinate = cursor.getCurrentOrdinate() - textBounds.getWidth() / 2;
                    double endOrdinate = cursor.getCurrentOrdinate() + textBounds.getWidth() / 2;

                    // compute label bounds
                    if (labelItem.followLineEnabled) {
                        // curved label, but we might end up drawing a straight
                        // one as an optimization
                        maxAngleChange = cursor.getMaxAngleChange(startOrdinate, endOrdinate);
                        setupLineTransform(painter, cursor, centroid, tx, true);
                        curved = maxAngleChange >= MIN_CURVED_DELTA;
                    } else {
                        setupLineTransform(painter, cursor, centroid, tx, false);
                    }

                    GlyphVectorProcessor glyphVectorProcessor = null;
                    //List<AffineTransform> transforms = null;
                    //For curved labels, we want the glyph's bounding box
                    //to follow the line
                    if (curved){
                        LineStringCursor oldCursor = new LineStringCursor(cursor);
                        glyphVectorProcessor = new GlyphVectorProcessor.Curved(painter, oldCursor);
                    } else {
                        glyphVectorProcessor = new GlyphVectorProcessor.Straight(painter, tx);
                    }

                    // We check each letters for collision
                    boolean collision = false;
                    collision = glyphVectorProcessor.process(new GlyphProcessor.ConflictDetector(painter,
                            displayArea, paintedBounds, groupLabels), true);

                    //If none of the glyphs intersects a bounding box,
                    //we paint the label
                    if (!collision) {
                        if (labelItem.isFollowLineEnabled()) {
                            // for curved labels we never paint in case of
                            // overrun
                            if ((startOrdinate > 0 && endOrdinate <= cursor.getLineStringLength())) {
                                if (maxAngleChange < maxAngleDelta) {
                                    // a max distance related to both the font size, but also having a visual limit
                                    // of a couple of millimeters assuming 90dpi
                                    double maxDistance = Math.min(painter.getLineHeight() / 2, 7);
                                    // if straight segment connecting the start and end ordinate is really close, paint as a straight label
                                    if (maxAngleChange == 0
                                            || cursor.getMaxDistanceFromStraightLine(startOrdinate,
                                            endOrdinate) < maxDistance) {
                                        painter.paintStraightLabel(tx);
                                    } else {
                                        painter.paintCurvedLabel(cursor);
                                    }
                                    painted = true;
                                }
                            }
                        } else {
                            // for straight labels, check overrun only if
                            // required
                            if ((allowOverruns || (startOrdinate > 0 && endOrdinate <= cursor
                                    .getLineStringLength()))) {
                                painter.paintStraightLabel(tx);
                                painted = true;
                            }
                        }
                    }

                    // if we actually painted the label, add the envelope to the
                    // indexes and break out of the loop,
                    // otherwise move to the next candidate position in the
                    // displacement sequence
                    if (painted) {
                        labelCount++;

                        if(labelItem.isConflictResolutionEnabled()) {
                            if(DEBUG_CACHE_BOUNDS) {
                                painter.graphics.setStroke(new BasicStroke());
                                painter.graphics.setColor(Color.RED);
                                glyphVectorProcessor.process(new GlyphProcessor.BoundsPainter(painter));
                            }

                            // Add each glyph's bounding box to the index
                            glyphVectorProcessor.process(new GlyphProcessor.IndexAdder(painter, paintedBounds));
                        }
                    } else {
                        // generate a sequence like s, -2s, 3s, -4s,...
                        // which will make the cursor alternate on
                        // mid + s, mid - s, mid + 2s, mid - 2s, mid + 3s,...
                        currOffset = nextOffset(currOffset, step);
                        cursor.moveRelative(currOffset);
                        cursor.getCurrentPosition(centroid);
                    }
                }
            }
        }
        return labelCount > 0;
    }

