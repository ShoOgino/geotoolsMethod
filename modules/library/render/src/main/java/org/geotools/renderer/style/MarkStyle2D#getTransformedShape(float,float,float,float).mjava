    /**
     * Returns a shape that can be used to draw the mark at the x, y coordinates with appropriated
     * rotation and size (according to the current style)
     *
     * @param x the x coordinate where the mark will be drawn
     * @param y the y coordinate where the mark will be drawn
     * @param baseRotation a custom rotation that will be applied before offsets
     * @param rotation the mark rotation
     * @return a shape that can be used to draw the mark
     */
    public Shape getTransformedShape(float x, float y, float baseRotation, float rotation) {
        if (shape != null) {
            Rectangle2D bounds = shape.getBounds2D();
            double shapeSize =
                    (maxMarkSizeEnabled
                            ? Math.max(bounds.getWidth(), bounds.getHeight())
                            : bounds.getHeight());
            double scale = size / shapeSize;
            TransformedShape ts = new TransformedShape();
            ts.shape = shape;
            // shapes are already centered, we need to displace them only if the anchor is not 0.5
            // 0.5
            float dx = displacementX;
            float dy = displacementY;
            if (baseRotation != 0) {
                ts.translate(x, y);
                ts.rotate(baseRotation);
                ts.translate(dx, dy);
            } else {
                ts.translate(x + dx, y + dy);
            }

            ts.rotate(rotation);
            dx = (float) (bounds.getWidth() * scale * (0.5 - anchorPointX));
            dy = (float) (bounds.getHeight() * scale * (anchorPointY - 0.5));
            ts.translate(dx, dy);
            // flip the symbol to take into account the screen orientation
            // where the y grows from top to bottom
            ts.scale(scale, -scale);

            return ts;
        } else {
            return null;
        }
    }

