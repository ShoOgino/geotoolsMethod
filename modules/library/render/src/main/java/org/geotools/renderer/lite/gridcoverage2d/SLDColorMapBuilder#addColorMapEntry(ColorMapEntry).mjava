    /**
     * Add a new {@link ColorMapEntry} to the list of {@link ColorMapEntry} we want to use for
     * building a {@link LinearColorMap}.
     *
     * <p>
     */
    public SLDColorMapBuilder addColorMapEntry(ColorMapEntry colorMapEntry) {
        ///////////////////////////////////////////////////////////////////////
        //
        // INITIAL CHECKS
        //
        ///////////////////////////////////////////////////////////////////////
        // Color map type must be already set.
        ColorMapUtilities.ensureNonNull("colorMapEntry", colorMapEntry);
        // Color map already created.
        checkIfColorMapCreated();
        // Color map type must be already set.
        // Number of domains must be already set.
        ColorMapUtilities.ensureNonNull("colorMapEntry", colorMapEntry);
        if (this.numberColorMapEntries == -1
                || linearColorMapType == -1
                || numberColorMapEntries < colormapElements.size() + 1)
            throw new IllegalStateException(Errors.format(ErrorKeys.ILLEGAL_STATE));

        ////
        //
        // Check that we already computed the number of colors for each range
        //
        /////
        init();

        ///////////////////////////////////////////////////////////////////////
        //
        // ACTUAL WORK
        //
        ///////////////////////////////////////////////////////////////////////
        ////
        //
        // Parse the provided  ColorMapEntry
        //
        /////
        // label
        String label = colorMapEntry.getLabel();
        label = label == null ? "ColorMapEntry" + this.colormapElements.size() : label;

        // quantity
        final double q = getQuantity(colorMapEntry);

        // color and opacity
        Color newColorValue = getColor(colorMapEntry);
        ColorMapUtilities.ensureNonNull("newColorValue", newColorValue);
        final double opacityValue = getOpacity(colorMapEntry);
        newColorValue =
                new Color(
                        newColorValue.getRed(),
                        newColorValue.getGreen(),
                        newColorValue.getBlue(),
                        (int) (opacityValue * 255 + 0.5));

        ////
        //
        // Create a specific domain for it
        //
        /////
        final boolean firstEntry = this.colormapElements.isEmpty();
        if (firstEntry) {

            ////
            //
            // if this is the first entry we are adding, we have a pretty special treatment for it
            // since it has to cover, depending on the colormap type a big part of the possible
            // values.
            //
            //
            ////

            switch (linearColorMapType) {
                case ColorMap.TYPE_RAMP:
                    colormapElements.add(
                            LinearColorMapElement.create(
                                    label,
                                    newColorValue,
                                    RangeFactory.create(Double.NEGATIVE_INFINITY, false, q, false),
                                    0));
                    break;
                case ColorMap.TYPE_VALUES:
                    colormapElements.add(LinearColorMapElement.create(label, newColorValue, q, 0));
                    break;
                case ColorMap.TYPE_INTERVALS:
                    colormapElements.add(
                            LinearColorMapElement.create(
                                    label,
                                    newColorValue,
                                    RangeFactory.create(Double.NEGATIVE_INFINITY, false, q, false),
                                    0));
                    break;
                default:
                    // should not happen
                    throw new IllegalArgumentException(
                            Errors.format(
                                    ErrorKeys.ILLEGAL_ARGUMENT_$2,
                                    "ColorMapTransform.type",
                                    Double.toString(opacityValue),
                                    Integer.valueOf(linearColorMapType)));
            }

        } else {
            ////
            //
            // this is NOT the first entry we are adding, hence we need to connect it to the
            // previous one.
            //
            //
            ////

            // Get the previous category
            final int newColorMapElementIndex = this.colormapElements.size();
            final LinearColorMapElement previous =
                    this.colormapElements.get(newColorMapElementIndex - 1);

            // //
            //
            // Build the new one.
            //
            // //
            double previousMax = previous.getRange().getMax().doubleValue();
            Color[] previousColors = previous.getColors();
            if (PiecewiseUtilities.compare(previousMax, q) != 0) {
                Range valueRange = RangeFactory.create(previousMax, true, q, false);

                switch (linearColorMapType) {
                    case ColorMap.TYPE_RAMP:
                        Color[] colors = {lastColorValue, newColorValue};
                        int previousMaximum = previous.getOutputRange().getMax().intValue();
                        // the piecewise machinery will complain if we have different colors
                        // on touching ranges, work around it by not including the previous
                        // max at the beginning of the range in case that happens (uses might
                        // want to have a sharp jump in a ramp, achieved by having two subseqent
                        // entries with the same value, but different color)
                        boolean minIncluded =
                                previousColors[previousColors.length - 1].equals(colors[0]);
                        Range sampleRange =
                                RangeFactory.create(
                                        previousMaximum,
                                        minIncluded,
                                        colorsPerColorMapElement + previousMaximum,
                                        false);
                        colormapElements.add(
                                LinearColorMapElement.create(
                                        label, colors, valueRange, sampleRange));
                        break;
                    case ColorMap.TYPE_VALUES:
                        colormapElements.add(
                                LinearColorMapElement.create(
                                        label, newColorValue, q, newColorMapElementIndex));
                        break;
                    case ColorMap.TYPE_INTERVALS:
                        colormapElements.add(
                                LinearColorMapElement.create(
                                        label, newColorValue, valueRange, newColorMapElementIndex));
                        break;
                    default:
                        throw new IllegalArgumentException(
                                Errors.format(
                                        ErrorKeys.ILLEGAL_ARGUMENT_$2,
                                        "ColorMapTransform.type",
                                        Double.toString(opacityValue),
                                        Integer.valueOf(linearColorMapType)));
                }
            }
        }
        lastColorValue = newColorValue;
        return this;
    }

