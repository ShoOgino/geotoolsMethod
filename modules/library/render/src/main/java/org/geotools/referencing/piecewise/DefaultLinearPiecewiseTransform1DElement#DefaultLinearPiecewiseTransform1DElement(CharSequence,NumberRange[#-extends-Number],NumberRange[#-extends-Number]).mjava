	/**
	 * Constructor.
	 * 
	 * @param name
	 *            for this {@link DefaultLinearPiecewiseTransform1DElement}.
	 * @param inRange
	 *            for this {@link DefaultLinearPiecewiseTransform1DElement}.
	 * @param outRange
	 *            for this {@link DefaultLinearPiecewiseTransform1DElement}.
	 */
	public DefaultLinearPiecewiseTransform1DElement(CharSequence name, NumberRange<? extends Number> inRange,
			NumberRange<? extends Number> outRange) {
		super(name, inRange);
		this.outputRange = outRange;
		// /////////////////////////////////////////////////////////////////////
		//
		// Checks
		//
		// /////////////////////////////////////////////////////////////////////
		// //
		//
		// the output class can only be integer
		//
		// //
		final Class<? extends Number> type = outRange.getElementClass();
		boolean minInc = outRange.isMinIncluded();
		boolean maxInc = outRange.isMaxIncluded();
		outputMinimum = PiecewiseUtilities.doubleValue(type, outRange
				.getMinValue(), minInc ? 0 : +1);
		outputMaximum = PiecewiseUtilities.doubleValue(type, outRange
				.getMaxValue(), maxInc ? 0 : -1);
		outputMinimumNaN = Double.isNaN(outputMinimum);
		outputMaximumNaN = Double.isNaN(outputMaximum);
		outputMinimumInfinite = Double.isInfinite(outputMinimum);
		outputMaximumInfinite = Double.isInfinite(outputMaximum);

		// //
		//
		// No open intervals for the output range
		//
		// //
		if (outputMinimumInfinite || outputMinimumInfinite) {
			throw new IllegalArgumentException(Errors.format(
					ErrorKeys.BAD_RANGE_$2, outputRange.getMinValue(),
					outputRange.getMaxValue()));
		}

		final int compareOutBounds = PiecewiseUtilities.compare(outputMinimum,
				outputMaximum);
		// //
		//
		// the output values are correctly ordered
		//
		// //
		if (compareOutBounds > 0) {
			throw new IllegalArgumentException(Errors.format(
					ErrorKeys.BAD_RANGE_$2, outputRange.getMinValue(),
					outputRange.getMaxValue()));
		}

		// //
		//
		// mapping NaN to a single value
		//
		// //
		if (isInputMaximumNaN() && isInputMinimumNaN())
			if (compareOutBounds == 0) {
				setTransform(LinearTransform1D.create(0, outputMinimum));
				setInverse(LinearTransform1D.create(outputMinimum, 0));
				return;
			} else
				throw new IllegalArgumentException(Errors.format(
						ErrorKeys.BAD_RANGE_$2, outputRange.getMinValue(),
						outputRange.getMaxValue()));

		// //
		//
		// Mapping an open interval to a single value, there is no way to map an
		// open interval to another interval!
		//
		// //
		if (isInputMaximumInfinite() || isInputMinimumInfinite())
			if (compareOutBounds == 0) {
				setTransform(PiecewiseUtilities.createLinearTransform1D(0,
						outputMinimum));
				setInverse(null);
				return;
			} else
				throw new IllegalArgumentException(Errors.format(
						ErrorKeys.BAD_RANGE_$2, outputRange.getMinValue(),
						outputRange.getMaxValue()));

		final MathTransform1D transform = PiecewiseUtilities.createLinearTransform1D(inRange,
				NumberRange.create(outputMinimum, outputMaximum));
		setTransform(transform);

		// //
		//
		// Checking the created transformation
		//
		// //
		assert transform instanceof LinearTransform1D;
		assert !Double.isNaN(((LinearTransform1D) transform).scale)
				&& !Double
						.isInfinite(((LinearTransform1D) transform).scale);

		// //
		//
		// Inverse
		//
		// //
		LinearTransform1D tempTransform = (LinearTransform1D) transform;
		final double scale = tempTransform.scale;
		if (Math.abs(scale) < 1E-6)
			if (PiecewiseUtilities.compare(getInputMaximum(), getInputMinimum()) == 0)
				setInverse(LinearTransform1D.create(0, getInputMinimum()));
			else
				setInverse(null);
		else
			try {
				setInverse((MathTransform1D) transform.inverse());
			} catch (NoninvertibleTransformException e) {
				if (LOGGER.isLoggable(Level.WARNING))
					LOGGER.log(Level.WARNING, e.getLocalizedMessage(), e);
			}
	}

