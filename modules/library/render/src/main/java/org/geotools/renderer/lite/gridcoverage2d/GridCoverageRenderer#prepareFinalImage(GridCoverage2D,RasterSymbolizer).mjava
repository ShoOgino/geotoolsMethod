    /**
     * Builds a (RenderedImage, AffineTransform) pair that can be used for rendering onto a
     * {@link Graphics2D} or as the basis to build a final image. Will return null if there is
     * nothing to render.
     * 
     * @param gridCoverage
     * @param symbolizer
     * @return
     * @throws FactoryException
     * @throws TransformException
     * @throws NoninvertibleTransformException
     */
    private GCpair prepareFinalImage(
            final GridCoverage2D gridCoverage,
            final RasterSymbolizer symbolizer
            )throws FactoryException, TransformException,NoninvertibleTransformException {

        // Initial checks
    	if(gridCoverage==null)
    		throw new NullPointerException(Errors.format(ErrorKeys.NULL_ARGUMENT_$1,"gridCoverage"));
    	
        if (LOGGER.isLoggable(Level.FINE))
            LOGGER.fine("Drawing coverage "+gridCoverage.toString());
        

        //
        // Getting information about the source coverage like the source CRS,
        // the source envelope and the source geometry.
        //
        final CoordinateReferenceSystem sourceCoverageCRS = gridCoverage.getCoordinateReferenceSystem2D();
        final GeneralEnvelope sourceCoverageEnvelope = (GeneralEnvelope) gridCoverage.getEnvelope();


        //
        // GET THE CRS MAPPING
        //
        // This step I instantiate the MathTransform for going from the source
        // crs to the destination crs.
        //
        // math transform from source to target crs
        final MathTransform sourceCRSToDestinationCRSTransformation = CRS.findMathTransform(sourceCoverageCRS, destinationCRS, true);
        final MathTransform destinationCRSToSourceCRSTransformation = sourceCRSToDestinationCRSTransformation.inverse();
        final boolean doReprojection = !sourceCRSToDestinationCRSTransformation.isIdentity();
        if (LOGGER.isLoggable(Level.FINE))
            LOGGER.fine("Transforming coverage envelope with transform "+destinationCRSToSourceCRSTransformation.toWKT());
        
        // //
        //
        // Do we need reprojection?
        //
        // //
        GeneralEnvelope destinationEnvelopeInSourceCRS;
        if (doReprojection) {
            // /////////////////////////////////////////////////////////////////////
            //
            // PHASE 1
            //
            // PREPARING THE REQUESTED ENVELOPE FOR LATER INTERSECTION
            //
            // /////////////////////////////////////////////////////////////////////

            // //
            //
            // Try to convert the destination envelope in the source crs. If
            // this fails we pass through WGS84 as an intermediate step
            //
            // //
            try {
                // convert the destination envelope to the source coverage
                // native crs in order to try and crop it. If we get an error we
                // try to
                // do this in two steps using WGS84 as a pivot. This introduces
                // some erros (it usually
                // increases the envelope we want to check) but it is still
                // useful.
                destinationEnvelopeInSourceCRS = new GeneralEnvelope(CRS.transform(
                        destinationEnvelope, sourceCoverageCRS));
            } catch (TransformException te) {
                // //
                //
                // Convert the destination envelope to WGS84 if needed for safer
                // comparisons later on with the original crs of this coverage.
                //
                // //
                final GeneralEnvelope destinationEnvelopeWGS84;
                if (!CRS.equalsIgnoreMetadata(destinationCRS,
                        DefaultGeographicCRS.WGS84)) {
                    // get a math transform to go to WGS84
                        destinationEnvelopeWGS84 = CRS.transform(
                                destinationEnvelope, DefaultGeographicCRS.WGS84);
                        destinationEnvelopeWGS84
                                .setCoordinateReferenceSystem(DefaultGeographicCRS.WGS84);

                } else {
                    destinationEnvelopeWGS84 = new GeneralEnvelope(
                            destinationEnvelope);
                }

                // //
                //
                // Convert the requested envelope from WGS84 to the source crs
                // for cropping the provided coverage.
                //
                // //
                if (!CRS.equalsIgnoreMetadata(sourceCoverageCRS, DefaultGeographicCRS.WGS84)) {
                    destinationEnvelopeInSourceCRS = CRS.transform(destinationEnvelopeWGS84,
                            DefaultGeographicCRS.WGS84);
                    destinationEnvelopeInSourceCRS
                            .setCoordinateReferenceSystem(DefaultGeographicCRS.WGS84);
                } else {
                    destinationEnvelopeInSourceCRS = new GeneralEnvelope(
                            destinationEnvelopeWGS84);
                }

            }
        } else
            destinationEnvelopeInSourceCRS = new GeneralEnvelope(destinationEnvelope);
        // /////////////////////////////////////////////////////////////////////
        //
        // NOW CHECKING THE INTERSECTION IN WGS84
        //
        // //
        //
        // If the two envelopes intersect each other in WGS84 we are
        // reasonably sure that they intersect
        //
        // /////////////////////////////////////////////////////////////////////
        final GeneralEnvelope intersectionEnvelope = new GeneralEnvelope(destinationEnvelopeInSourceCRS);
        intersectionEnvelope.intersect(sourceCoverageEnvelope);
        if (intersectionEnvelope.isEmpty()||intersectionEnvelope.isNull()) {
            if (LOGGER.isLoggable(Level.INFO)) {
                LOGGER.info("The destination envelope does not intersect the envelope of the source coverage.");
            }
            return null;
        }


        final Interpolation interpolation = (Interpolation) hints.get(JAI.KEY_INTERPOLATION);
        if (LOGGER.isLoggable(Level.FINE))
            LOGGER.fine("Using interpolation "+interpolation);
        final Hints localHints = this.hints.clone();
        if(interpolation instanceof InterpolationNearest){
            localHints.add(new RenderingHints(JAI.KEY_REPLACE_INDEX_COLOR_MODEL, Boolean.FALSE));
            localHints.add(new RenderingHints(JAI.KEY_TRANSFORM_ON_COLORMAP, Boolean.TRUE));
        }


        // /////////////////////////////////////////////////////////////////////
        //
        // CROPPING Coverage
        //
        // /////////////////////////////////////////////////////////////////////
        GridCoverage2D preResample=gridCoverage;
    	try{
		    preResample = getCroppedCoverage(gridCoverage, intersectionEnvelope, sourceCoverageCRS,localHints);
		    if (preResample == null) {
		        // nothing to render, the AOI does not overlap
		        if (LOGGER.isLoggable(Level.FINE))
		            LOGGER.fine("Skipping current coverage because cropped to an empty area");
                return null;
		    }
    	}catch (Throwable t) {
    		////
    		//
    		// If it happens that the crop fails we try to proceed since the crop does only an optimization. Things might
    		// work out anyway.
    		//
    		////
            if (LOGGER.isLoggable(Level.FINE))
                LOGGER.log(Level.FINE,"Crop Failed for reason: "+t.getLocalizedMessage(),t);
            preResample=gridCoverage;
		}
        if (DEBUG) {
            writeRenderedImage(preResample.geophysics(false).getRenderedImage(),"preresample");
        }
            
        
        // /////////////////////////////////////////////////////////////////////
        //
        // REPROJECTION if needed
        //
        // /////////////////////////////////////////////////////////////////////
        GridCoverage2D preSymbolizer;
        if (doReprojection) {
            preSymbolizer = resample(preResample, destinationCRS,interpolation == null ? new InterpolationNearest(): interpolation, destinationEnvelope,localHints);
            if (LOGGER.isLoggable(Level.FINE))
                LOGGER.fine("Reprojecting to crs "+ destinationCRS.toWKT());
        } else
            preSymbolizer = preResample;
        if (DEBUG) {
            writeRenderedImage(preSymbolizer.geophysics(false).getRenderedImage(),"preSymbolizer");
        }


        // ///////////////////////////////////////////////////////////////////
        //
        // RASTERSYMBOLIZER
        //
        // ///////////////////////////////////////////////////////////////////
        final GridCoverage2D symbolizerGC;
        final RenderedImage symbolizerImage;
        if (LOGGER.isLoggable(Level.FINE))
            LOGGER.fine(new StringBuilder("Raster Symbolizer ").toString());
        if (LOGGER.isLoggable(Level.FINE))
            LOGGER.fine(new StringBuffer("Raster Symbolizer ").toString());
        if(symbolizer!=null){
        	final RasterSymbolizerHelper rsp = new RasterSymbolizerHelper (preSymbolizer,this.hints);
        	rsp.visit(symbolizer);
        	symbolizerGC = (GridCoverage2D) rsp.getOutput();
        	symbolizerImage = symbolizerGC.geophysics(false).getRenderedImage();
    	} else {
            symbolizerGC = preSymbolizer;
            symbolizerImage = symbolizerGC.geophysics(false).getRenderedImage();
        }
        if (DEBUG) {
            writeRenderedImage(symbolizerImage,"postSymbolizer");
        }
        
        // ///////////////////////////////////////////////////////////////////
        // Apply opacity if needs be
        // TODO: move this into the RasterSymbolizerHelper
        // ///////////////////////////////////////////////////////////////////
        final RenderedImage finalImage;
        final GridCoverage2D finalGC;
        float opacity = getOpacity(symbolizer);
        if(opacity < 1) {
            ImageWorker ow = new ImageWorker(symbolizerImage);
            finalImage = ow.applyOpacity(opacity).getRenderedImage();
            
            final int numBands=finalImage.getSampleModel().getNumBands();
            final GridSampleDimension [] sd= new GridSampleDimension[numBands];
            for(int i=0;i<numBands;i++) {
                sd[i]= new GridSampleDimension(TypeMap.getColorInterpretation(finalImage.getColorModel(), i).name());
            }
            
            GridCoverageFactory factory = CoverageFactoryFinder.getGridCoverageFactory(hints);
            finalGC = factory.create(
                    "opacity_"+symbolizerGC.getName().toString(), 
                    finalImage,
                    symbolizerGC.getGridGeometry(),
                    sd,
                    new GridCoverage[]{symbolizerGC},
                    symbolizerGC.getProperties()
                    );
        } else {
            finalImage = symbolizerImage;
            finalGC = symbolizerGC;
        }
        
        // ///////////////////////////////////////////////////////////////////
        //
        // DRAW ME
        // I need the grid to world transform for drawing this grid coverage to
        // the display
        //
        // ///////////////////////////////////////////////////////////////////
        final GridGeometry2D recoloredCoverageGridGeometry = ((GridGeometry2D) finalGC.getGridGeometry());
        // I need to translate half of a pixel since in wms the envelope
        // map to the corners of the raster space not to the center of the
        // pixels.
        final MathTransform2D finalGCTransform=recoloredCoverageGridGeometry.getGridToCRS2D(PixelOrientation.UPPER_LEFT);
        if (!(finalGCTransform instanceof AffineTransform)) {
            throw new UnsupportedOperationException(
                    "Non-affine transformations not yet implemented"); // TODO
        }
        final AffineTransform finalGCgridToWorld = new AffineTransform((AffineTransform) finalGCTransform);


        // //
        //
        // I am going to concatenate the final world to grid transform for the
        // screen area with the grid to world transform of the input coverage.
        //
        // This way i right away position the coverage at the right place in the
        // area of interest for the device.
        //
        // //
        final AffineTransform clonedFinalWorldToGrid = (AffineTransform) finalWorldToGrid.clone();
        clonedFinalWorldToGrid.concatenate(finalGCgridToWorld);

        return new GCpair(clonedFinalWorldToGrid,finalGC);
    }            	

