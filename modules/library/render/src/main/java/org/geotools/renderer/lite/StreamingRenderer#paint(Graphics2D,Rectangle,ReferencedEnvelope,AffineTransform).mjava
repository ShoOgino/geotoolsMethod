    /**
     * Renders features based on the map layers and their styles as specified in the map context
     * using <code>setContext</code>.
     *
     * <p>This version of the method assumes that paint area, envelope and worldToScreen transform
     * are already computed. Use this method to avoid recomputation. <b>Note however that no check
     * is performed that they are really in sync!<b/>
     *
     * @param graphics The graphics object to draw to.
     * @param paintArea The size of the output area in output units (eg: pixels).
     * @param mapArea the map's visible area (viewport) in map coordinates. Its associate CRS is
     *     ALWAYS 2D
     * @param worldToScreen A transform which converts World coordinates to Screen coordinates.
     */
    public void paint(
            Graphics2D graphics,
            Rectangle paintArea,
            ReferencedEnvelope mapArea,
            AffineTransform worldToScreen) {
        // ////////////////////////////////////////////////////////////////////
        //
        // Check for null arguments, recompute missing ones if possible
        //
        // ////////////////////////////////////////////////////////////////////
        if (graphics == null) {
            LOGGER.severe("renderer passed null graphics argument");
            throw new NullPointerException("renderer requires graphics");
        } else if (paintArea == null) {
            LOGGER.severe("renderer passed null paintArea argument");
            throw new NullPointerException("renderer requires paintArea");
        } else if (mapArea == null) {
            LOGGER.severe("renderer passed null mapArea argument");
            throw new NullPointerException("renderer requires mapArea");
        } else if (worldToScreen == null) {
            worldToScreen = RendererUtilities.worldToScreenTransform(mapArea, paintArea);
            if (worldToScreen == null) return;
        }

        CoordinateReferenceSystem mapCRS = mapArea.getCoordinateReferenceSystem();
        if (CRS.getAxisOrder(mapCRS) == CRS.AxisOrder.NORTH_EAST) {
            try {
                // sanitize, having flipped axis causes slowdowns, the rendering
                // subsystem has to go from data to rendering to screen flipping axis order
                // twice when advanced projection handling is enabled
                Integer code = CRS.lookupEpsgCode(mapCRS, false);
                if (code != null) {
                    String srs = "EPSG:" + code;
                    CoordinateReferenceSystem earthNorthCRS = CRS.decode(srs, true);
                    mapArea =
                            new ReferencedEnvelope(
                                    mapArea.getMinY(),
                                    mapArea.getMaxY(),
                                    mapArea.getMinX(),
                                    mapArea.getMaxX(),
                                    earthNorthCRS);
                }

                // flip world to screen too
                worldToScreen =
                        new AffineTransform(
                                worldToScreen.getShearX(),
                                worldToScreen.getScaleX(),
                                worldToScreen.getScaleY(),
                                worldToScreen.getShearY(),
                                worldToScreen.getTranslateX(),
                                worldToScreen.getTranslateY());
            } catch (Exception e) {
                LOGGER.log(
                        Level.FINER,
                        "Failed to turn the requested bbox in east/north order, map rendering "
                                + "should work anyways, but pay a performance price");
            }
        }

        // ////////////////////////////////////////////////////////////////////
        //
        // Setting base information
        //
        // TODO the way this thing is built is a mess if you try to use it in a
        // multithreaded environment. I will fix this at the end.
        //
        // ////////////////////////////////////////////////////////////////////
        destinationCrs = mapArea.getCoordinateReferenceSystem();
        mapExtent = new ReferencedEnvelope(mapArea);
        this.screenSize = paintArea;
        this.worldToScreenTransform = worldToScreen;
        error = 0;
        if (java2dHints != null) graphics.setRenderingHints(java2dHints);
        // add the anchor for graphic fills
        Point2D textureAnchor =
                new Point2D.Double(
                        worldToScreenTransform.getTranslateX(),
                        worldToScreenTransform.getTranslateY());
        graphics.setRenderingHint(StyledShapePainter.TEXTURE_ANCHOR_HINT_KEY, textureAnchor);
        // reset the abort flag
        renderingStopRequested = false;

        // setup the graphic clip
        graphics.setClip(paintArea);

        // ////////////////////////////////////////////////////////////////////
        //
        // Managing transformations , CRSs and scales
        //
        // If we are rendering to a component which has already set up some form
        // of transformation then we can concatenate our transformation to it.
        // An example of this is the ZoomPane component of the swinggui module.
        // ////////////////////////////////////////////////////////////////////
        if (concatTransforms) {
            AffineTransform atg = graphics.getTransform();
            atg.concatenate(worldToScreenTransform);
            worldToScreenTransform = atg;
            graphics.setTransform(worldToScreenTransform);
        }

        // compute scale according to the user specified method
        scaleDenominator = computeScale(mapArea, paintArea, worldToScreenTransform, rendererHints);
        if (LOGGER.isLoggable(Level.FINE))
            LOGGER.fine("Computed scale denominator: " + scaleDenominator);
        //////////////////////////////////////////////////////////////////////
        //
        // Consider expanding the map extent so that a few more geometries
        // will be considered, in order to catch those outside of the rendering
        // bounds whose stroke is so thick that it countributes rendered area
        //
        //////////////////////////////////////////////////////////////////////
        int buffer = getRenderingBuffer();
        originalMapExtent = mapExtent;
        if (buffer > 0) {
            mapExtent =
                    new ReferencedEnvelope(
                            expandEnvelope(mapExtent, worldToScreen, buffer),
                            mapExtent.getCoordinateReferenceSystem());
        }

        // Setup the secondary painting thread
        requests = getRequestsQueue();
        painterThread = new PainterThread(requests);
        ExecutorService localThreadPool = threadPool;
        boolean localPool = false;
        if (localThreadPool == null) {
            localThreadPool = Executors.newSingleThreadExecutor();
            localPool = true;
        }
        Future painterFuture = localThreadPool.submit(painterThread);
        List<CompositingGroup> compositingGroups = null;
        try {
            if (mapContent == null) {
                throw new IllegalStateException(
                        "Cannot call paint, you did not set a MapContent in this renderer");
            }

            // re-organize the map content and generate the z group layers
            MapContent zGroupedMapContent = ZGroupLayerFactory.filter(mapContent);

            // split over multiple map contents, one per composition base
            compositingGroups =
                    CompositingGroup.splitOnCompositingBase(
                            graphics, paintArea, zGroupedMapContent);

            int layerCounter = 0;

            for (CompositingGroup compositingGroup : compositingGroups) {
                MapContent currentMapContent = compositingGroup.mapContent;
                Graphics2D compositingGraphic = compositingGroup.graphics;

                // ////////////////////////////////////////////////////////////////////
                //
                // Processing all the map layers in the context using the accompaining
                // styles
                //
                // ////////////////////////////////////////////////////////////////////

                labelCache.start();
                if (labelCache instanceof LabelCacheImpl) {
                    ((LabelCacheImpl) labelCache)
                            .setLabelRenderingMode(
                                    LabelRenderingMode.valueOf(getTextRenderingMethod()));
                }

                for (Layer layer : currentMapContent.layers()) {
                    try {
                        renderListeners.forEach(l -> l.layerStart(layer));
                    } catch (Exception e) {
                        fireErrorEvent(e);
                    }
                    layerCounter++;
                    String layerId = String.valueOf(layerCounter);
                    if (!layer.isVisible()) {
                        // Only render layer when layer is visible
                        continue;
                    }

                    if (renderingStopRequested) {
                        return;
                    }

                    labelCache.startLayer(layerId);
                    if (layer instanceof DirectLayer) {
                        RenderingRequest request =
                                new RenderDirectLayerRequest(
                                        compositingGraphic, (DirectLayer) layer);
                        try {
                            requests.put(request);
                        } catch (InterruptedException e) {
                            fireErrorEvent(e);
                        }
                    } else if (layer instanceof ZGroupLayer) {
                        try {
                            ZGroupLayer zGroup = (ZGroupLayer) layer;
                            zGroup.drawFeatures(compositingGraphic, this, layerId);
                        } catch (Throwable t) {
                            fireErrorEvent(t);
                        }
                    } else {
                        try {
                            // extract the feature type stylers from the style object
                            // and process them
                            processStylers(compositingGraphic, layer, layerId);
                        } catch (Throwable t) {
                            fireErrorEvent(t);
                        }
                    }

                    labelCache.endLayer(layerId, graphics, screenSize);
                    try {
                        requests.put(new RenderTimeStatisticsRequest(renderListeners, layer));
                    } catch (InterruptedException ex) {
                        fireErrorEvent(ex);
                    }
                }

                // have we been painting on a back buffer? If so, merge on the main graphic
                if (compositingGraphic instanceof DelayedBackbufferGraphic) {
                    RenderingRequest request =
                            new MargeCompositingGroupRequest(graphics, compositingGroup);
                    try {
                        requests.put(request);
                    } catch (InterruptedException e) {
                        fireErrorEvent(e);
                    }
                }
            }
        } finally {
            try {
                // clean up generated map contents (in finally block to ensure it's done regardless
                // of how we got here
                if (compositingGroups != null) {
                    for (CompositingGroup group : compositingGroups) {
                        MapContent groupContent = group.getMapContent();
                        if (groupContent != mapContent) {
                            groupContent.dispose();
                        }
                    }
                }
            } finally {
                try {
                    if (!renderingStopRequested) {
                        requests.put(new EndRequest());
                        painterFuture.get();
                    }
                } catch (Exception e) {
                    painterFuture.cancel(true);
                    fireErrorEvent(e);
                } finally {
                    if (localPool) {
                        localThreadPool.shutdown();
                    }
                }
            }
        }

        if (!renderingStopRequested) {
            renderListeners.forEach(l -> l.labellingStart());
            labelCache.end(graphics, paintArea);
            renderListeners.forEach(l -> l.labellingEnd());
        } else {
            labelCache.clear();
        }

        if (LOGGER.isLoggable(Level.FINE))
            LOGGER.fine(
                    new StringBuffer("Style cache hit ratio: ")
                            .append(styleFactory.getHitRatio())
                            .append(" , hits ")
                            .append(styleFactory.getHits())
                            .append(", requests ")
                            .append(styleFactory.getRequests())
                            .toString());
        if (error > 0) {
            LOGGER.warning(
                    new StringBuffer(
                                    "Number of Errors during paint(Graphics2D, AffineTransform) = ")
                            .append(error)
                            .toString());
        }
    }

