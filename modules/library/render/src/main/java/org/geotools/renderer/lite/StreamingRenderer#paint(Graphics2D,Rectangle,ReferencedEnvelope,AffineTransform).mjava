    /**
     * Renders features based on the map layers and their styles as specified in
     * the map context using <code>setContext</code>. <p/> This version of
     * the method assumes that paint area, envelope and worldToScreen transform
     * are already computed. Use this method to avoid recomputation. <b>Note
     * however that no check is performed that they are really in sync!<b/>
     * 
     * @param graphics
     *            The graphics object to draw to.
     * @param paintArea
     *            The size of the output area in output units (eg: pixels).
     * @param mapArea
     *            the map's visible area (viewport) in map coordinates. Its
     *            associate CRS is ALWAYS 2D
     * @param worldToScreen
     *            A transform which converts World coordinates to Screen
     *            coordinates.
     */
    public void paint(Graphics2D graphics, Rectangle paintArea,
            ReferencedEnvelope mapArea, AffineTransform worldToScreen) {
        // ////////////////////////////////////////////////////////////////////
        // 
        // Check for null arguments, recompute missing ones if possible
        //
        // ////////////////////////////////////////////////////////////////////
        if (graphics == null || paintArea == null) {
            LOGGER.severe("renderer passed null arguments");
            throw new NullPointerException("renderer passed null arguments");
        } else if (mapArea == null && paintArea == null) {
            LOGGER.severe("renderer passed null arguments");
            throw new NullPointerException("renderer passed null arguments");
        } else if (mapArea == null) {

            LOGGER.severe("renderer passed null arguments");
            throw new NullPointerException("renderer passed null arguments");
        } else if (worldToScreen == null) {
            worldToScreen = RendererUtilities.worldToScreenTransform(mapArea,
                    paintArea);
            if (worldToScreen == null)
                return;
        }
        
        // ////////////////////////////////////////////////////////////////////
        // 
        // Setting base information
        //
        // TODO the way this thing is built is a mess if you try to use it in a
        // multithreaded environment. I will fix this at the end.
        //
        // ////////////////////////////////////////////////////////////////////
        destinationCrs = mapArea.getCoordinateReferenceSystem();
        mapExtent = new ReferencedEnvelope(mapArea);
        this.screenSize = paintArea;
        this.worldToScreenTransform = worldToScreen;
        error = 0;
        if (java2dHints != null)
            graphics.setRenderingHints(java2dHints);
        // reset the abort flag
        renderingStopRequested = false;
        
        // setup the graphic clip
        graphics.setClip(paintArea);

        // ////////////////////////////////////////////////////////////////////
        //
        // Managing transformations , CRSs and scales
        //
        // If we are rendering to a component which has already set up some form
        // of transformation then we can concatenate our transformation to it.
        // An example of this is the ZoomPane component of the swinggui module.
        // ////////////////////////////////////////////////////////////////////
        if (concatTransforms) {
            AffineTransform atg = graphics.getTransform();
            atg.concatenate(worldToScreenTransform);
            worldToScreenTransform = atg;
            graphics.setTransform(worldToScreenTransform);
        }

        // compute scale according to the user specified method
        scaleDenominator = computeScale(mapArea, paintArea,worldToScreenTransform, rendererHints);
        if(LOGGER.isLoggable(Level.FINE))
            LOGGER.fine("Computed scale denominator: " + scaleDenominator);
        //////////////////////////////////////////////////////////////////////
        //
        // Consider expanding the map extent so that a few more geometries
        // will be considered, in order to catch those outside of the rendering
        // bounds whose stroke is so thick that it countributes rendered area
        //
        //////////////////////////////////////////////////////////////////////
        int buffer = getRenderingBuffer();
        originalMapExtent = mapExtent;
        if(buffer > 0) {
            mapExtent = new ReferencedEnvelope(expandEnvelope(mapExtent, worldToScreen, buffer), 
                    mapExtent.getCoordinateReferenceSystem()); 
        }

        // enable advanced projection handling with the updated map extent
        if(isAdvancedProjectionHandlingEnabled()) {
            // get the projection handler and set a tentative envelope
            projectionHandler = ProjectionHandlerFinder.getHandler(mapExtent, isMapWrappingEnabled());
        }
        
        // Setup the secondary painting thread
        requests = new ArrayBlockingQueue<RenderingRequest>(10000);
        PainterThread painterThread = new PainterThread(requests);
        ExecutorService localThreadPool = threadPool;
        boolean userProvidedPool = false;
        if(localThreadPool == null) {
            localThreadPool = Executors.newSingleThreadExecutor();
            userProvidedPool = true;
        }
        Future painterFuture = localThreadPool.submit(painterThread);
        try {
            // ////////////////////////////////////////////////////////////////////
            //
            // Processing all the map layers in the context using the accompaining
            // styles
            //
            // ////////////////////////////////////////////////////////////////////
            final MapLayer[] layers = context.getLayers();
            labelCache.start();
            if(labelCache instanceof LabelCacheImpl) {
                ((LabelCacheImpl) labelCache).setLabelRenderingMode(LabelRenderingMode.valueOf(getTextRenderingMethod()));
            }
            final int layersNumber = layers.length;
            MapLayer currLayer;
            for (int i = 0; i < layersNumber; i++) // DJB: for each layer (ie. one
            {
                currLayer = layers[i];
    
                if (!currLayer.isVisible()) {
                    // Only render layer when layer is visible
                    continue;
                }
    
                if (renderingStopRequested) {
                    return;
                }
                labelCache.startLayer(i+"");
                try {
    
                    // extract the feature type stylers from the style object
                    // and process them
                    processStylers(graphics, currLayer, worldToScreenTransform,
                            destinationCrs, mapExtent, screenSize, i+"");
                } catch (Throwable t) {
                    fireErrorEvent(t);
                }
    
                labelCache.endLayer(i+"", graphics, screenSize);
            }
        } finally {
            try {
                requests.put(new EndRequest());
                painterFuture.get();
            } catch(Exception e) {
                painterFuture.cancel(true);
                fireErrorEvent(e);
            } finally {
                if(userProvidedPool) {
                    localThreadPool.shutdown();
                }
            }
        }
        
        labelCache.end(graphics, paintArea);
    
        if (LOGGER.isLoggable(Level.FINE))
            LOGGER.fine(new StringBuffer("Style cache hit ratio: ").append(
                    styleFactory.getHitRatio()).append(" , hits ").append(
                            styleFactory.getHits()).append(", requests ").append(
                                    styleFactory.getRequests()).toString());
        if (error > 0) {
            LOGGER
            .warning(new StringBuffer(
            "Number of Errors during paint(Graphics2D, AffineTransform) = ")
            .append(error).toString());
        }
        
    }

