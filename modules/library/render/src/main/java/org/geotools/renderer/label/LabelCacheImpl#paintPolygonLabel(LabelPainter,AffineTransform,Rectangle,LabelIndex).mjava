    /**
     * returns the representative geometry (for further processing)
     *
     * <p>TODO: handle lineplacement for a polygon (perhaps we're supposed to grab the outside line
     * and label it, but spec is unclear)
     */
    private boolean paintPolygonLabel(
            LabelPainter painter,
            AffineTransform tempTransform,
            Rectangle displayArea,
            LabelIndex glyphs)
            throws Exception {
        LabelCacheItem labelItem = painter.getLabel();
        Polygon geom =
                getPolySetRepresentativeLocation(
                        labelItem.getGeoms(), displayArea, labelItem.isPartialsEnabled());
        if (geom == null) {
            return false;
        }

        Point centroid = RendererUtilities.getPolygonCentroid(geom);
        if (centroid == null) {
            return false;
        }

        // check we're inside, if not, use a different approach
        PreparedGeometry pg = PreparedGeometryFactory.prepare(geom);
        if (!pg.contains(centroid)) {
            // resort to sampling, computing the intersection is slow and
            // due invalid geometries can easily break with an exception
            Point central =
                    RendererUtilities.sampleForInternalPoint(geom, centroid, pg, gf, 5d, -1);
            if (central != null) {
                centroid = central;
            } else {
                return false;
            }
        }

        // compute the transformation used to position the label
        TextStyle2DExt textStyle = new TextStyle2DExt(labelItem);
        if (labelItem.getMaxDisplacement() > 0) {
            textStyle.setDisplacementX(0);
            textStyle.setDisplacementY(0);
            textStyle.setAnchorX(0.5);
            textStyle.setAnchorY(0.5);
        }

        AffineTransform tx = null;
        boolean allowShrinking =
                labelItem.getFontShrinkSizeMin() > DEFAULT_FONT_SHRINK_SIZE_MIN
                        && labelItem.getFontShrinkSizeMin() < textStyle.getFont().getSize();
        int shrinkSize =
                allowShrinking ? labelItem.getFontShrinkSizeMin() : textStyle.getFont().getSize();
        int textSize = textStyle.getFont().getSize();
        // if shrinking is allowed then try to paint polygon label. If no success reduce font size
        // by 1 unit and retry until fontShrinkSize is reached.
        while (textSize >= shrinkSize) {
            tx = new AffineTransform(tempTransform);
            LabelCacheItem labelItem2 = painter.getLabel();
            TextStyle2DExt textStyle2 = new TextStyle2DExt(labelItem2);
            if (labelItem2.getMaxDisplacement() > 0) {
                textStyle2.setDisplacementX(0);
                textStyle2.setDisplacementY(0);
                textStyle2.setAnchorX(0.5);
                textStyle2.setAnchorY(0.5);
            }
            labelItem2.setTextStyle(textStyle2);
            painter.setLabel(labelItem2);
            if (paintPolygonLabelInternal(
                    painter, tx, displayArea, glyphs, labelItem2, pg, centroid, textStyle2)) {
                return true;
            }
            textSize -= 1;
            if (allowShrinking) {
                Font font =
                        new Font(
                                textStyle2.getFont().getName(),
                                textStyle2.getFont().getStyle(),
                                textSize);
                textStyle2.setFont(font);
            }
        }

        int[] displacementAngles = labelItem.getDisplacementAngles();
        if (displacementAngles == null) {
            displacementAngles = DEFAULT_DISPLACEMENT_ANGLES;
        }

        painter.setLabel(labelItem);

        // ... use at least a 2 pixel step, no matter what the label length is
        final double step = painter.getAscent() > 2 ? painter.getAscent() : 2;
        double radius = step;
        Coordinate c = new Coordinate(centroid.getCoordinate());
        Coordinate cc = centroid.getCoordinate();
        Point testPoint = centroid.getFactory().createPoint(c);
        while (radius < labelItem.getMaxDisplacement()) {
            for (int angle : displacementAngles) {
                double dx = Math.cos(Math.toRadians(angle)) * radius;
                double dy = Math.sin(Math.toRadians(angle)) * radius;

                c.x = cc.x + dx;
                c.y = cc.y + dy;
                testPoint.geometryChanged();
                if (!pg.contains(testPoint)) continue;

                textStyle.setDisplacementX(dx);
                textStyle.setDisplacementY(dy);

                tx = new AffineTransform(tempTransform);
                if (paintPolygonLabelInternal(
                        painter, tx, displayArea, glyphs, labelItem, pg, centroid, textStyle))
                    return true;
            }

            radius += step;
        }

        return false;
    }

