    /**
     * Creates a new {@link GridCoverageRenderer} object.
     *
     * @param destinationCRS the CRS of the {@link GridCoverage2D} to render.
     * @param envelope delineating the area to be rendered.
     * @param screenSize at which we want to render the source {@link GridCoverage2D}.
     * @param worldToScreen if not <code>null</code> and if it contains a rotation, this Affine
     *     Transform is used directly to convert from world coordinates to screen coordinates.
     *     Otherwise, a standard {@link GridToEnvelopeMapper} is used to calculate the affine
     *     transform.
     * @param newHints {@link RenderingHints} to control this rendering process.
     */
    public GridCoverageRenderer(
            final CoordinateReferenceSystem destinationCRS,
            final Envelope envelope,
            final Rectangle screenSize,
            final AffineTransform worldToScreen,
            final RenderingHints newHints)
            throws TransformException, NoninvertibleTransformException {

        // ///////////////////////////////////////////////////////////////////
        //
        // Initialize this renderer
        //
        // ///////////////////////////////////////////////////////////////////
        this.destinationSize = screenSize;
        this.destinationCRS = destinationCRS;
        if (this.destinationCRS == null) {
            throw new TransformException(
                    Errors.format(ErrorKeys.CANT_SEPARATE_CRS_$1, this.destinationCRS));
        }
        destinationEnvelope =
                new GeneralEnvelope(new ReferencedEnvelope(envelope, this.destinationCRS));
        // ///////////////////////////////////////////////////////////////////
        //
        // FINAL DRAWING DIMENSIONS AND RESOLUTION
        // I am here getting the final drawing dimensions (on the device) and
        // the resolution for this rendererbut in the CRS of the source coverage
        // since I am going to compare this info with the same info for the
        // source coverage.
        //
        // ///////////////////////////////////////////////////////////////////

        // PHUSTAD : The gridToEnvelopeMapper does not handle rotated views.
        //
        if (worldToScreen != null && XAffineTransform.getRotation(worldToScreen) != 0.0) {
            finalWorldToGrid = new AffineTransform(worldToScreen);
            finalGridToWorld = finalWorldToGrid.createInverse();
        } else {
            final GridToEnvelopeMapper gridToEnvelopeMapper = new GridToEnvelopeMapper();
            gridToEnvelopeMapper.setPixelAnchor(PixelInCell.CELL_CORNER);
            gridToEnvelopeMapper.setGridRange(new GridEnvelope2D(destinationSize));
            gridToEnvelopeMapper.setEnvelope(destinationEnvelope);
            finalGridToWorld = new AffineTransform(gridToEnvelopeMapper.createAffineTransform());
            finalWorldToGrid = finalGridToWorld.createInverse();
        }

        //
        // HINTS Management
        //
        if (newHints != null) {
            this.hints.add(newHints);
        }
        // factory as needed
        this.gridCoverageFactory = CoverageFactoryFinder.getGridCoverageFactory(this.hints);

        // Interpolation
        if (hints.containsKey(JAI.KEY_INTERPOLATION)) {
            interpolation = (Interpolation) newHints.get(JAI.KEY_INTERPOLATION);
        } else {
            hints.add(new RenderingHints(JAI.KEY_INTERPOLATION, interpolation));
        }
        if (LOGGER.isLoggable(Level.FINE)) {
            LOGGER.fine("Rendering using interpolation " + interpolation);
        }
        setInterpolationHints();

        // Tile Size
        if (hints.containsKey(JAI.KEY_IMAGE_LAYOUT)) {
            final ImageLayout layout = (ImageLayout) hints.get(JAI.KEY_IMAGE_LAYOUT);
            //            // only tiles are valid at this stage?? TODO
            layout.unsetImageBounds();
            layout.unsetValid(ImageLayout.COLOR_MODEL_MASK & ImageLayout.SAMPLE_MODEL_MASK);
        }
        // this prevents users from overriding lenient hint
        this.hints.put(Hints.LENIENT_DATUM_SHIFT, Boolean.TRUE);

        // SG add hints for the border extender
        this.hints.add(
                new RenderingHints(
                        JAI.KEY_BORDER_EXTENDER,
                        BorderExtender.createInstance(BorderExtender.BORDER_COPY)));
    }

