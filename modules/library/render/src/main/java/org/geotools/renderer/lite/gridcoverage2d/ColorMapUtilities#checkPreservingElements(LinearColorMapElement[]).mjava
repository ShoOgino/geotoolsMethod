    /**
     * Check that all the output values for the various {@link
     * DefaultConstantPiecewiseTransformElement} are equal.
     *
     * @param preservingElements array of {@link DefaultConstantPiecewiseTransformElement}s.
     * @return the array of {@link DefaultConstantPiecewiseTransformElement}s if the check is
     *     successful.
     * @throws IllegalArgumentException in case the check is unsuccessful.
     */
    static DefaultPiecewiseTransform1DElement[] checkPreservingElements(
            LinearColorMapElement[] preservingElements) {
        if (preservingElements != null) {
            double outval = Double.NaN;
            Color color = null;
            for (int i = 0; i < preservingElements.length; i++) {
                // the no data element must be a linear transform mapping to a single value
                if (!(preservingElements[i] instanceof ConstantColorMapElement))
                    throw new IllegalArgumentException(
                            Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$1, preservingElements));
                final ConstantColorMapElement nc = (ConstantColorMapElement) preservingElements[i];
                if (nc.getColors().length != 1)
                    throw new IllegalArgumentException(
                            Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$1, nc.getColors()));
                if (i == 0) {
                    outval = nc.getOutputMaximum();
                    color = nc.getColors()[0];
                } else {
                    if (compare(outval, nc.getOutputMaximum()) != 0)
                        throw new IllegalArgumentException(
                                Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$1, nc.getColors()));
                    if (!color.equals(nc.getColors()[0]))
                        throw new IllegalArgumentException(
                                Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$1, nc.getColors()));
                }
            }
        }
        return preservingElements;
    }

