    @Override
    public Geometry postProcess(Geometry geometry) {
        // First let's check if the geometry is undoubtedly not going to need
        // processing
        Envelope env = geometry.getEnvelopeInternal();
        if (env.getWidth() < radius && renderingEnvelope.contains(env)
                && renderingEnvelope.getWidth() <= radius * 2)
            return geometry;

        // Check if the geometry has wrapped the dateline. Heuristic: we assume
        // anything larger than half of the world might have wrapped it, however,
        // if it's touching both datelines then don't wrap it, as it might be something
        // like antarctica
        if (env.getWidth() > radius && env.getWidth() < radius * 2) {
            geometry.apply(new WrappingCoordinateFilter(radius, radius * 2));
            geometry.geometryChanged();
            env = geometry.getEnvelopeInternal();
        }

        // The viewing area might contain the geometry multiple times due to
        // wrapping.
        // This is obvious for the geometries that wrapped the dateline, but the
        // viewing
        // area might be large enough to contain the same continent multiple
        // times (a-la Google Maps)
        List<Geometry> geoms = new ArrayList<Geometry>();
        Class geomType = null;

        // search the west-most location inside the current rendering envelope
        // (there may be many)
        double min = env.getMinX();
        double max = env.getMaxX();
        while (min > renderingEnvelope.getMinX()) {
            min -= radius * 2;
            max -= radius * 2;
        }
        while (max < renderingEnvelope.getMinX()) {
            min += radius * 2;
            max += radius * 2;
        }

        // clone and offset as necessary
        while (min <= renderingEnvelope.getMaxX()) {
            double offset = min - env.getMinX();
            if (Math.abs(offset) < radius) {
                // in this case we can keep the original geometry
                geomType = accumulate(geoms, geometry, geomType);
            } else {
                // in all other cases we make a copy and offset it
                Geometry offseted = (Geometry) geometry.clone();
                offseted.apply(new OffsetOrdinateFilter(0, offset));
                offseted.geometryChanged();
                geomType = accumulate(geoms, offseted, geomType);
            }

            min += radius * 2;
        }
        
        // if we could not find any geom type we stumbled int an empty geom collection
        if(geomType == null) {
            return null;
        }
        
        // if we did not have to actually clone the geometries
        if(geoms.size() == 1) {
            return geometry;
        }

        // rewrap all the clones into a single geometry
        if (Point.class.equals(geomType)) {
            Point[] points = (Point[]) geoms.toArray(new Point[geoms.size()]);
            return geometry.getFactory().createMultiPoint(points);
        } else if (LineString.class.isAssignableFrom(geomType)) {
            LineString[] lines = (LineString[]) geoms.toArray(new LineString[geoms.size()]);
            return geometry.getFactory().createMultiLineString(lines);
        } else if (Polygon.class.equals(geomType)) {
            Polygon[] polys = (Polygon[]) geoms.toArray(new Polygon[geoms.size()]);
            return geometry.getFactory().createMultiPolygon(polys);
        } else {
            return geometry.getFactory().createGeometryCollection(
                    (Geometry[]) geoms.toArray(new Geometry[geoms.size()]));
        }
    }

