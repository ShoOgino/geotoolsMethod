    private FeatureCollection getFeatures(final Layer layer, AffineTransform at,
            CoordinateReferenceSystem destinationCrs, Envelope mapArea, Rectangle screenSize,
            final MapLayer currLayer, final FeatureSource featureSource,
            final CoordinateReferenceSystem sourceCrs, 
            final FeatureType schema, final GeometryDescriptor geometryAttribute,
            List<LiteFeatureTypeStyle> featureTypeStyles) throws IOException, FactoryException,
                    NoninvertibleTransformException, SchemaException, TransformException {
        Expression transform = featureTypeStyles.get(0).transformation;
        
        // ... assume we have to do the generalization, the query layer process will
        // turn down the flag if we don't 
        inMemoryGeneralization = true;
        boolean hasTransformation = transform != null;
        Query styleQuery = getStyleQuery(featureSource, schema,
                featureTypeStyles, mapArea, destinationCrs, sourceCrs, screenSize,
                geometryAttribute, at, hasTransformation);
        Query definitionQuery = getDefinitionQuery(currLayer, featureSource, sourceCrs);
        FeatureCollection features = null;
        if(hasTransformation) {
            // prepare the stage for the raster transformations
            GridGeometry2D gridGeometry = getRasterGridGeometry(destinationCrs, sourceCrs);
            // vector transformation wise, we have to account for two separate queries,
            // the one attached to the layer and then one coming from SLD.
            // The first source attributes, the latter talks tx output attributes
            // so they have to be applied before and after the transformation respectively
            RenderingTransformationHelper helper = new RenderingTransformationHelper() {
                
                @Override
                protected GridCoverage2D readCoverage(GridCoverage2DReader reader, Object params, GridGeometry2D readGG) throws IOException {
                    GeneralParameterValue[] readParams = (GeneralParameterValue[]) params;
                    Interpolation interpolation = getRenderingInterpolation(layer);
                    GridCoverageReaderHelper helper;
                    try {
                        helper = new GridCoverageReaderHelper(reader,
                                readGG.getGridRange2D(),
                                ReferencedEnvelope.reference(readGG.getEnvelope2D()),
                                interpolation);
                        return helper.readCoverage(readParams);
                    } catch (InvalidGridGeometryException | FactoryException e) {
                        throw new IOException("Failure reading the coverage", e);
                    }

                }
            };
            
            Object result = helper.applyRenderingTransformation(transform, featureSource, definitionQuery, 
                    styleQuery, gridGeometry, sourceCrs, java2dHints);
            if(result == null) {
                return null;
            } else if (result instanceof FeatureCollection) {
                features = (FeatureCollection) result;
            } else if (result instanceof GridCoverage2D) {
                GridCoverage2D coverage = (GridCoverage2D) result;
                // we only avoid disposing if the input was a in memory GridCovereage2D
                if((schema instanceof SimpleFeatureType && !FeatureUtilities.isWrappedCoverage((SimpleFeatureType) schema))) {
                    coverage = new DisposableGridCoverage(coverage);
                }
                features = FeatureUtilities.wrapGridCoverage(coverage);
            } else if (result instanceof GridCoverage2DReader) {
                features = FeatureUtilities.wrapGridCoverageReader(
                        (GridCoverage2DReader) result, null);
            } else {
                throw new IllegalArgumentException(
                        "Don't know how to handle the results of the transformation, "
                                + "the supported result types are FeatureCollection, GridCoverage2D "
                                + "and GridCoverage2DReader, but we got: "
                                + result.getClass());
            }                    
        } else {
            Query mixed = DataUtilities.mixQueries(definitionQuery, styleQuery, null);
            checkAttributeExistence(featureSource.getSchema(), mixed);
            features = featureSource.getFeatures(mixed);
            features = RendererUtilities.fixFeatureCollectionReferencing(features, sourceCrs);
        }

        // HACK HACK HACK
        // For complex features, we need the targetCrs and version in scenario where we have
        // a top level feature that does not contain a geometry(therefore no crs) and has a
        // nested feature that contains geometry as its property.Furthermore it is possible
        // for each nested feature to have different crs hence we need to reproject on each
        // feature accordingly.
        // This is a Hack, this information should not be passed through feature type
        // appschema will need to remove this information from the feature type again
        if (!(features instanceof SimpleFeatureCollection)) {
            features.getSchema().getUserData().put("targetCrs", destinationCrs);
            features.getSchema().getUserData().put("targetVersion", "wms:getmap");
        }

        return features;
    }

