    /** Tells if geometry cloning is required or not */
    private boolean isCloningRequired(List<LiteFeatureTypeStyle> lfts) {
        // check if the features are detached, we can thus modify the geometries in place
        Layer layer = lfts.get(0).layer;

        final Set<Key> hints = layer.getFeatureSource().getSupportedHints();
        if (!hints.contains(Hints.FEATURE_DETACHED)) return true;

        // check if there is any conflicting geometry transformation.
        // No geometry transformations -> we can modify geometries in place
        // Just one geometry transformation over an attribute -> we can modify geometries in place
        // Two tx over the same attribute, or straight usage and a tx -> we have to preserve the
        // original geometry as well, thus we need cloning
        StyleAttributeExtractor extractor = new StyleAttributeExtractor();
        FeatureType featureType = layer.getFeatureSource().getSchema();
        Set<String> plainGeometries = new java.util.HashSet<>();
        Set<String> txGeometries = new java.util.HashSet<>();
        for (LiteFeatureTypeStyle lft : lfts) {
            for (Rule r : lft.ruleList) {
                for (Symbolizer s : r.symbolizers()) {
                    if (s.getGeometry() == null) {
                        String attribute =
                                featureType.getGeometryDescriptor().getName().getLocalPart();
                        if (txGeometries.contains(attribute)) return true;
                        plainGeometries.add(attribute);
                    } else if (s.getGeometry() instanceof PropertyName) {
                        String attribute = ((PropertyName) s.getGeometry()).getPropertyName();
                        if (txGeometries.contains(attribute)) return true;
                        plainGeometries.add(attribute);
                    } else {
                        Expression g = s.getGeometry();
                        extractor.clear();
                        g.accept(extractor, null);
                        Set<String> attributes = extractor.getAttributeNameSet();
                        for (String attribute : attributes) {
                            if (plainGeometries.contains(attribute)) return true;
                            if (txGeometries.contains(attribute)) return true;
                            txGeometries.add(attribute);
                        }
                    }
                }
            }
        }

        // check also that the rendered geometry is not used in any other filter or property of the
        // LFTS
        StyleAttributeExtractor extractorOther = new StyleAttributeExtractor();
        extractorOther.setSymbolizerGeometriesVisitEnabled(false);
        for (LiteFeatureTypeStyle lft : lfts) {
            for (Rule r : lft.ruleList) {
                if (r.getFilter() != null) {
                    r.getFilter().accept(extractorOther, null);
                }
                for (Symbolizer s : r.symbolizers()) {
                    s.accept(extractorOther);
                }
            }
        }
        Set<String> filterAndSymbolizerProperties =
                extractorOther
                        .getAttributes()
                        .stream()
                        .map(pn -> pn.getPropertyName())
                        .collect(Collectors.toSet());
        if (extractorOther.getDefaultGeometryUsed()
                && featureType.getGeometryDescriptor() != null) {
            String defaultGeometryName =
                    featureType.getGeometryDescriptor().getName().getLocalPart();
            filterAndSymbolizerProperties.add(defaultGeometryName);
        }
        return !Collections.disjoint(filterAndSymbolizerProperties, plainGeometries)
                || !Collections.disjoint(filterAndSymbolizerProperties, txGeometries);
    }

