    /**
     * When drawing in optimized mode a 32bit surface is created for each FeatureTypeStyle other
     * than the first in order to draw features in parallel while respecting the feature draw
     * ordering multiple FTS impose. This method allows to estimate how many megabytes will be
     * needed, in terms of back buffers, to draw the current {@link MapContent}, assuming the
     * feature type style optimizations are turned on (in the case they are off, no extra memory
     * will be used).
     *
     * @param width the image width
     * @param height the image height
     */
    public int getMaxBackBufferMemory(int width, int height) {
        int maxBuffers = 0;
        for (Layer layer : mapContent.layers()) {
            if (!layer.isVisible()) {
                // Only render layer when layer is visible
                continue;
            }

            // Skip layers that do not have multiple FeatureTypeStyles
            if (!(layer instanceof StyleLayer)) {
                continue;
            }

            StyleLayer styleLayer = (StyleLayer) layer;

            if (styleLayer.getStyle().featureTypeStyles().size() < 2) continue;

            // count how many lite feature type styles are active
            int currCount = 0;
            FeatureType ftype = layer.getFeatureSource().getSchema();
            for (FeatureTypeStyle fts : styleLayer.getStyle().featureTypeStyles()) {
                if (isFeatureTypeStyleActive(ftype, fts)) {
                    // get applicable rules at the current scale
                    List<List<Rule>> splittedRules = splitRules(fts);
                    List<Rule> ruleList = splittedRules.get(0);
                    List<Rule> elseRuleList = splittedRules.get(1);

                    // if none, skip this fts
                    if ((ruleList.isEmpty()) && (elseRuleList.isEmpty())) continue;

                    currCount++;
                }
            }
            // consider the first fts does not allocate a buffer
            currCount--;

            if (currCount > maxBuffers) maxBuffers = currCount;
        }

        return maxBuffers * width * height * 4;
    }

