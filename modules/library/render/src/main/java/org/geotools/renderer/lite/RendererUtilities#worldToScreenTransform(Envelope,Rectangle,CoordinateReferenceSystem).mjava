    /**
     * This worldToScreenTransform method makes the assumption that the crs is in Lon,Lat or
     * Lat,Lon. If the provided envelope does not carry along a crs the assumption that the map
     * extent is in the classic Lon,Lat form. In case the provided envelope is of type.
     *
     * <p>Note that this method takes into account also the OGC standard with respect to the
     * relation between pixels and sample.
     *
     * @param mapExtent The envelope of the map in lon,lat
     * @param paintArea The area to paint as a rectangle
     * @todo add georeferenced envelope check when merge with trunk will be performed
     */
    public static AffineTransform worldToScreenTransform(
            Envelope mapExtent, Rectangle paintArea, CoordinateReferenceSystem destinationCrs)
            throws TransformException {

        // is the crs also lon,lat?
        final CoordinateReferenceSystem crs2D = CRS.getHorizontalCRS(destinationCrs);
        if (crs2D == null)
            throw new TransformException(
                    Errors.format(ErrorKeys.CANT_REDUCE_TO_TWO_DIMENSIONS_$1, destinationCrs));
        final boolean lonFirst =
                crs2D.getCoordinateSystem()
                        .getAxis(0)
                        .getDirection()
                        .absolute()
                        .equals(AxisDirection.EAST);
        final GeneralEnvelope newEnvelope =
                lonFirst
                        ? new GeneralEnvelope(
                                new double[] {mapExtent.getMinX(), mapExtent.getMinY()},
                                new double[] {mapExtent.getMaxX(), mapExtent.getMaxY()})
                        : new GeneralEnvelope(
                                new double[] {mapExtent.getMinY(), mapExtent.getMinX()},
                                new double[] {mapExtent.getMaxY(), mapExtent.getMaxX()});
        newEnvelope.setCoordinateReferenceSystem(destinationCrs);

        //
        // with this method I can build a world to grid transform
        // without adding half of a pixel translations. The cost
        // is a hashtable lookup. The benefit is reusing the last
        // transform (instead of creating a new one) if the grid
        // and envelope are the same one than during last invocation.
        final GridToEnvelopeMapper m = (GridToEnvelopeMapper) gridToEnvelopeMappers.get();
        m.setGridRange(new GridEnvelope2D(paintArea));
        m.setEnvelope(newEnvelope);
        return (AffineTransform) (m.createTransform().inverse());
    }

