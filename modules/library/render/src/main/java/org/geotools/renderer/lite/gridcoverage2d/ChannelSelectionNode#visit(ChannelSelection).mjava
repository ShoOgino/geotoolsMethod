    /*
     * (non-Javadoc)
     *
     * @see org.geotools.renderer.lite.gridcoverage2d.StyleVisitorAdapter#visit(org.geotools.styling.ChannelSelection)
     */
    public void visit(final ChannelSelection cs) {
        // /////////////////////////////////////////////////////////////////////
        //
        // Ensure that the ChannelSelection is not null and that the source is
        // not null
        //
        // /////////////////////////////////////////////////////////////////////
        final List<CoverageProcessingNode> localSources = getSources();
        final int length = localSources.size();
        if (length == 0)
            throw new IllegalArgumentException(
                    Errors.format(ErrorKeys.SOURCE_CANT_BE_NULL_$1, "ChannelSelectionNode"));
        final GridCoverage2D source = (GridCoverage2D) getSource(0).getOutput();
        GridCoverageRendererUtilities.ensureSourceNotNull(source, this.getName().toString());

        // /////////////////////////////////////////////////////////////////////
        //
        // Get the channel selection and parse it in order to create the
        // subchain
        //
        // /////////////////////////////////////////////////////////////////////
        // creating a new separate chain
        final RootNode chainSource = new RootNode(source, getHints());
        final BandMergeNode subChainSink = new BandMergeNode(getHints());
        RenderedImage sourceImage = source.getRenderedImage();

        // save the alpha channel (if any) for future restore
        boolean hasAlpha =
                sourceImage != null
                        && sourceImage.getColorModel() != null
                        && sourceImage.getColorModel().hasAlpha();
        RenderedImage alpha = null;
        if (hasAlpha) {
            alpha =
                    new ImageWorker(sourceImage)
                            .setRenderingHints(getHints())
                            .retainLastBand()
                            .getRenderedImage();
            subChainSink.setAlpha(alpha);
        }
        // anchoring the chain for later disposal
        setSink(subChainSink);

        if (cs != null) {
            final SelectedChannelType[] rgb = cs.getRGBChannels();
            final SelectedChannelType gray = cs.getGrayChannel();
            // both of them are set?
            if ((rgb != null && rgb[0] != null && rgb[1] != null && rgb[2] != null)
                    && (gray != null))
                throw new IllegalArgumentException(
                        Errors.format(
                                ErrorKeys.ILLEGAL_ARGUMENT_$1,
                                "Both gray and rgb channel selection are valid!"));
            final SelectedChannelType[] sc = gray == null ? rgb : new SelectedChannelType[] {gray};

            // If we do not really select any bands from the original coverage, we try to entirely
            // skip this operation
            // this means that either we have to select 1 real band, or we have to select 3 real
            // bands
            // Notice that we also try to be as resilient as possible since
            if (sc != null
                    && ((sc.length == 1 && sc[0] != null)
                            || (sc.length == 3
                                    && (sc[0] != null || sc[1] != null || sc[2] != null)))) {
                for (int i = 0; i < sc.length; i++) {

                    // get the channel element
                    final SelectedChannelType channel = sc[i];
                    if (LOGGER.isLoggable(Level.FINE))
                        LOGGER.fine("Channel " + i + " was " + channel.getChannelName());

                    if (channel == null) {
                        ZeroImageNode zero = new ZeroImageNode(getHints());
                        zero.addSource(chainSource);
                        subChainSink.addSource(zero);
                        zero.addSink(subChainSink);
                    } else {

                        // //
                        //
                        // BAND SELECTION

                        //
                        // //
                        final BandSelectionNode bandSelectionNode = new BandSelectionNode();
                        bandSelectionNode.addSource(chainSource);
                        bandSelectionNode.visit(channel);

                        // //
                        //
                        // CONTRAST ENHANCEMENT
                        //
                        // //
                        final ContrastEnhancementNode contrastenhancementNode =
                                new ContrastEnhancementNode();
                        contrastenhancementNode.addSource(bandSelectionNode);
                        bandSelectionNode.addSink(contrastenhancementNode);
                        contrastenhancementNode.visit(
                                channel != null ? channel.getContrastEnhancement() : null);

                        // //
                        //
                        // BAND MERGE
                        //
                        // //
                        contrastenhancementNode.addSink(subChainSink);
                        subChainSink.addSource(contrastenhancementNode);
                    }
                }
                return;
            }
        }
        // no band selection, just forward this node
        subChainSink.addSource(chainSource);
    }

