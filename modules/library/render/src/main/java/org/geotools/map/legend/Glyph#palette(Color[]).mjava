    /**
     * Icon for grid data, small grid made up of provided colors.
     * Layout:<pre><code>
     *    0 1 2 3 4 5 6 7 8 9 101112131415
     *  0
     *  1 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     *  2 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     *  3 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     *  4 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     *  5 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     *  6 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     *  7 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     *  8 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     *  9 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     * 10 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     * 11 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     * 12 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     * 14 AABBCDEEFfGgHhIiJjKkllmmnnoopp
     * 15
     * </code><pre>
     * </p>
     * @param c palette of colors
     * @return Icon representing a palette
     *
     */
    public static BufferedImage palette(Color[] c) {
        BufferedImage bi =
                new BufferedImage(DEFAULT_WIDTH, DEFAULT_HEIGHT, BufferedImage.TYPE_INT_ARGB);

        Graphics2D gc = (Graphics2D) bi.getGraphics();
        gc.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        final Color[] colors = new Color[16];
        Color color = Color.GRAY;
        if (c == null) {
            for (int i = 0; i < 16; i++) color = Color.GRAY;
        } else {
            for (int i = 0; i < 16; i++) {
                int lookup = (i * c.length) / 16;
                if (c[lookup] != null) color = c[lookup];
                colors[i] = color;
            }
        }

        for (int i = 0; i < 16; i++) {
            gc.setColor(colors[i]);
            gc.drawLine(i, 0, i, 15);
        }

        gc.setColor(Color.GRAY);
        gc.drawRoundRect(0, 0, 14, 14, 2, 2);

        return bi;
    }

