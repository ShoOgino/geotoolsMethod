    /**
     * Applies each feature type styler in turn to all of the features. This
     * perhaps needs some explanation to make it absolutely clear.
     * featureStylers[0] is applied to all features before featureStylers[1] is
     * applied. This can have important consequences as regards the painting
     * order.
     * <p>
     * In most cases, this is the desired effect. For example, all line features
     * may be rendered with a fat line and then a thin line. This produces a
     * 'cased' effect without any strange overlaps.
     * </p>
     * <p>
     * This method is internal and should only be called by render.
     * </p>
     * <p>
     * </p>
     * 
     * @param graphics
     *            DOCUMENT ME!
     * @param features
     *            An array of features to be rendered
     * @param featureStylers
     *            An array of feature stylers to be applied
     * @param at
     *            DOCUMENT ME!
     * @param destinationCrs -
     *            The destination CRS, or null if no reprojection is required
     * @param screenSize
     * @param layerId 
     * @throws IOException
     * @throws IllegalFilterException
     */
    private void processStylers(final Graphics2D graphics, final Layer layer, String layerId)
            throws Exception {
        /*
         * DJB: changed this a wee bit so that it now does the layer query AFTER
         * it has evaluated the rules for scale inclusion. This makes it so that
         * geometry columns (and other columns) will not be queried unless they
         * are actually going to be required. see geos-469
         */
        // /////////////////////////////////////////////////////////////////////
        //
        // Preparing feature information and styles
        //
        // /////////////////////////////////////////////////////////////////////
        final FeatureSource featureSource = layer.getFeatureSource();

        final CoordinateReferenceSystem sourceCrs;
        final ArrayList<LiteFeatureTypeStyle> lfts ;

        if (featureSource == null) {
            throw new IllegalArgumentException("The layer does not contain a feature source");
        }

        final FeatureType schema = featureSource.getSchema();
        final GeometryDescriptor geometryAttribute = schema.getGeometryDescriptor();
        if(geometryAttribute != null && geometryAttribute.getType() != null) {
            sourceCrs = geometryAttribute.getType().getCoordinateReferenceSystem();
        } else {
            sourceCrs = null;
        }

        lfts = createLiteFeatureTypeStyles(layer, graphics);
        if (lfts.isEmpty()) {
            return;
        } else {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Processing " + lfts.size() + " stylers for "
                        + featureSource.getSchema().getName());
            }
        }
        
        // make sure all spatial filters in the feature source native SRS 
        reprojectSpatialFilters(lfts, featureSource);
        
        // apply the uom and dpi rescale
        applyUnitRescale(lfts);
        
        // classify by sortby and transformation (aka how we produce the features to
        // be rendered)
        List<List<LiteFeatureTypeStyle>> txClassified = classifyByFeatureProduction(lfts);
        
        // render groups by uniform transformation
        for (List<LiteFeatureTypeStyle> uniform : txClassified) {
            FeatureCollection features = getFeatures(layer, featureSource, sourceCrs,
                    schema, geometryAttribute,
                    uniform);

            // finally, perform rendering
            if (isOptimizedFTSRenderingEnabled() && lfts.size() > 1) {
                drawOptimized(graphics, layerId, features, uniform);
            } else {
                drawPlain(graphics, layerId, features, uniform);
            }
        }
    }

