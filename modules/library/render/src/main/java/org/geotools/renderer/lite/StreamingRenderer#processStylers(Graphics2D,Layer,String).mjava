    /**
     * Applies all the styles to the features/coverages contained in the given layer.
     *
     * @param graphics Target graphics for rendering
     * @param layer The layer being styled
     * @param layerId Handle used to identify the layer in the {@link LabelCache}
     * @throws Exception
     */
    private void processStylers(final Graphics2D graphics, final Layer layer, String layerId)
            throws Exception {
        // /////////////////////////////////////////////////////////////////////
        //
        // Preparing feature information and styles
        //
        // /////////////////////////////////////////////////////////////////////
        final FeatureSource featureSource = layer.getFeatureSource();
        if (featureSource == null) {
            throw new IllegalArgumentException(
                    "The layer does not contain a feature source: " + layer.getTitle());
        }
        final FeatureType schema = featureSource.getSchema();

        final ArrayList<LiteFeatureTypeStyle> lfts =
                createLiteFeatureTypeStyles(layer, graphics, isOptimizedFTSRenderingEnabled());
        if (lfts.isEmpty()) {
            return;
        } else {
            if (LOGGER.isLoggable(Level.FINE)) {
                LOGGER.fine("Processing " + lfts.size() + " stylers for " + schema.getName());
            }
        }

        // classify by sortby and transformation (aka how we produce the features to
        // be rendered)
        List<List<LiteFeatureTypeStyle>> txClassified = classifyByFeatureProduction(lfts);

        // render groups by uniform transformation
        for (List<LiteFeatureTypeStyle> uniformLfts : txClassified) {
            FeatureCollection features = getFeatures(layer, schema, uniformLfts);
            if (features == null) {
                continue;
            }

            // optimize filters for in memory sequential execution
            // step one, collect duplicated filters and expressions
            RepeatedFilterVisitor repeatedVisitor = new RepeatedFilterVisitor();
            uniformLfts
                    .stream()
                    .flatMap(fts -> Arrays.stream(fts.ruleList))
                    .filter(r -> !r.isElseFilter() && r.getFilter() != null)
                    .forEach(r -> r.getFilter().accept(repeatedVisitor, null));
            Set<Object> repeatedObjects = repeatedVisitor.getRepeatedObjects();
            // step two, memoize the repeated ones and convert simple features access to indexed
            if (schema instanceof SimpleFeatureType || !repeatedObjects.isEmpty()) {
                MemoryFilterOptimizer filterOptimizer =
                        new MemoryFilterOptimizer(features.getSchema(), repeatedObjects);
                for (LiteFeatureTypeStyle fts : uniformLfts) {
                    for (int i = 0; i < fts.ruleList.length; i++) {
                        Rule rule = fts.ruleList[i];
                        DuplicatingStyleVisitor optimizingStyleVisitor =
                                new DuplicatingStyleVisitor(
                                        STYLE_FACTORY, filterFactory, filterOptimizer);
                        rule.accept(optimizingStyleVisitor);
                        fts.ruleList[i] = (Rule) optimizingStyleVisitor.getCopy();
                    }
                }
            }

            // finally, perform rendering
            if (isOptimizedFTSRenderingEnabled() && lfts.size() > 1) {
                drawOptimized(graphics, layerId, features, uniformLfts);
            } else {
                drawPlain(graphics, layerId, features, uniformLfts);
            }
        }
    }

