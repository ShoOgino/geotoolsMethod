    /**
     * Returns the first font associated to the feature that can be found on the
     * current machine
     *
     * @param feature
     *            The feature whose font is to be found
     * @param fonts
     *            An array of fonts dependent of the feature, the first that is
     *            found on the current machine is returned
     *
     * @return The first of the specified fonts found on this machine or null if
     *         none found
     */
    private java.awt.Font[] getFonts(Object feature, Font[] fonts) {
        List<java.awt.Font> result = new ArrayList<>();
        // try to build a font using the full spec
        if (fonts != null && fonts.length > 0) {
            for (int k = 0; k < fonts.length; k++) {
                Font curr = fonts[k];
                for (Expression family : curr.getFamily()) {
                    String requestedFont = evalToString(family, feature, null);
                    java.awt.Font javaFont = FontCache.getDefaultInstance().getFont(requestedFont);

                    if (javaFont != null) {
                        java.awt.Font font = styleFont(feature, curr, javaFont);
                        result.add(font);
                    }
                }
            }
        }

        if (result.isEmpty()) {
            java.awt.Font font = new java.awt.Font("Serif", java.awt.Font.PLAIN, 12);
            if (fonts != null && fonts.length > 0) {
                font = styleFont(feature, fonts[0], font);
            }
            result.add(font);
        }

        return result.toArray(new java.awt.Font[result.size()]);
    }

