    /**
     * Creates the bounding box filters (one for each geometric attribute) needed to query a <code>
     * MapLayer</code>'s feature source to return just the features for the target rendering extent
     *
     * @param schema the layer's feature source schema
     * @param attributes set of needed attributes
     * @param bbox the expression holding the target rendering bounding box
     * @return an or'ed list of bbox filters, one for each geometric attribute in <code>attributes
     *     </code>. If there are just one geometric attribute, just returns its corresponding <code>
     *     GeometryFilter</code>.
     * @throws IllegalFilterException if something goes wrong creating the filter
     */
    private Filter createBBoxFilters(
            FeatureType schema, List<PropertyName> attributes, List<ReferencedEnvelope> bboxes)
            throws IllegalFilterException {
        // if there are no bboxes to render then use Filter.EXCLUDE as there is no clear way
        // to return
        if (bboxes.isEmpty()) {
            return Filter.EXCLUDE;
        }

        Filter filter = Filter.INCLUDE;
        final int length = attributes.size();
        Object attType;

        for (int j = 0; j < length; j++) {
            // NC - support nested attributes -> use evaluation for getting descriptor
            // result is not necessary a descriptor, is Name in case of @attribute
            attType = attributes.get(j).evaluate(schema);

            // the attribute type might be missing because of rendering transformations, skip it
            if (attType == null) {
                continue;
            }

            if (attType instanceof GeometryDescriptor) {
                Filter gfilter = new FastBBOX(attributes.get(j), bboxes.get(0), filterFactory);

                if (filter == Filter.INCLUDE) {
                    filter = gfilter;
                } else {
                    filter = filterFactory.or(filter, gfilter);
                }

                if (bboxes.size() > 0) {
                    for (int k = 1; k < bboxes.size(); k++) {
                        // filter = filterFactory.or( filter, new FastBBOX(localName, bboxes.get(k),
                        // filterFactory) );
                        filter =
                                filterFactory.or(
                                        filter,
                                        new FastBBOX(
                                                attributes.get(j), bboxes.get(k), filterFactory));
                    }
                }
            }
        }

        return filter;
    }

