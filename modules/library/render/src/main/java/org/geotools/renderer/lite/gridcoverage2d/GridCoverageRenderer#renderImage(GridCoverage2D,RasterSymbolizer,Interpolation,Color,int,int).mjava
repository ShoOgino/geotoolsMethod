    /**
     * Turns the coverage into a rendered image applying the necessary transformations and the
     * symbolizer
     * 
     * @param gridCoverage
     * @param symbolizer
     * @return The transformed image, or null if the coverage does not lie within the rendering
     *         bounds
     * @throws FactoryException
     * @throws TransformException
     * @throws NoninvertibleTransformException
     */
    public RenderedImage renderImage(
            final GridCoverage2D gridCoverage,
            final RasterSymbolizer symbolizer, 
            final Interpolation interpolation, 
            final Color background,
            final int tileSizeX, 
            final int tileSizeY
            ) throws FactoryException, TransformException, NoninvertibleTransformException {

        // Build the final image and the associated world to grid transformation
        final GCpair couple = prepareFinalImage(gridCoverage, symbolizer);
        if (couple == null)
            return null;
        // NOTICE that at this stage the image we get should be 8 bits, either RGB, RGBA, Gray, GrayA
        // either multiband or indexed. It could also be 16 bits indexed!!!!
        
        final RenderedImage finalImage = couple.getGridCoverage().getRenderedImage();
        final AffineTransform clonedFinalWorldToGrid = couple.getTransform();

        // TODO: optimize translate/scale transformations
        // TODO: use mosaic to merge with a background respecting alpha and transparency
        // TODO: check tolerance value
        // TODO: do we need to pass in any hints?
        
        boolean hasScaleX=!(Math.abs(clonedFinalWorldToGrid.getScaleX()-1) < 1E-2/(finalImage.getWidth()+1-finalImage.getMinX()));
        boolean hasScaleY=!(Math.abs(clonedFinalWorldToGrid.getScaleY()-1) < 1E-2/(finalImage.getHeight()+1-finalImage.getMinY()));
        boolean hasShearX=!(clonedFinalWorldToGrid.getShearX() == 0.0);
        boolean hasShearY=!(clonedFinalWorldToGrid.getShearY() == 0.0);
        boolean hasTranslateX=!(Math.abs(clonedFinalWorldToGrid.getTranslateX()) <  1E-2);
        boolean hasTranslateY=!(Math.abs(clonedFinalWorldToGrid.getTranslateY()) <  1E-2);
        boolean isTranslateXInt=!(Math.abs(clonedFinalWorldToGrid.getTranslateX() - (int) clonedFinalWorldToGrid.getTranslateX()) <  1E-2);
        boolean isTranslateYInt=!(Math.abs(clonedFinalWorldToGrid.getTranslateY() - (int) clonedFinalWorldToGrid.getTranslateY()) <  1E-2);
        
        boolean isIdentity = clonedFinalWorldToGrid.isIdentity() && !hasScaleX&&!hasScaleY &&!hasTranslateX&&!hasTranslateY;
        boolean isScale = hasScaleX&&hasScaleY &&!hasShearX&&!hasShearY;
        
        // TODO how can we check that the a skew is harmless????
        if(isIdentity){
            // TODO check if we are missing anything like tiling or such that comes from hints 
            return finalImage;
        }
        
        // TOLERANCE ON PIXELS SIZE
        
        // Check and see if the affine transform is in fact doing
        // a Translate operation. That is a scale by 1 and no rotation.
        // In which case call translate. Note that only integer translate
        // is applicable. For non-integer translate we'll have to do the
        // affine.
        // If the hints contain an ImageLayout hint, we can't use 
        // TranslateIntOpImage since it isn't capable of dealing with that.
        // Get ImageLayout from renderHints if any.
        ImageLayout layout_ = RIFUtil.getImageLayoutHint(hints);                                
        if ( !hasScaleX &&
             !hasScaleY  &&
              !hasShearX&&
              !hasShearY&&
              isTranslateXInt&&
              isTranslateYInt&&
            layout_ == null) {
            // It's a integer translate
            return new TranslateIntOpImage(finalImage,
            								hints,
                                           (int) clonedFinalWorldToGrid.getShearX(),
                                           (int) clonedFinalWorldToGrid.getShearY());
        }                                
                          
        // final transformation
        final ImageLayout layout = new ImageLayout(finalImage);
        layout.setTileGridXOffset(0).setTileGridYOffset(0).setTileHeight(tileSizeY).setTileWidth(tileSizeX);
        final RenderingHints hints = new RenderingHints(JAI.KEY_IMAGE_LAYOUT, layout);
        //add hints to preserve IndexColorModel
        if(interpolation instanceof InterpolationNearest)
            hints.add(new RenderingHints(JAI.KEY_REPLACE_INDEX_COLOR_MODEL, Boolean.FALSE));
        //SG add hints for the border extender
        hints.add(new RenderingHints(JAI.KEY_BORDER_EXTENDER,BorderExtender.createInstance(BorderExtender.BORDER_COPY)));
    	RenderedImage im=null;
    	try{
    		// scale ?
    		if (isScale){
    			im=ScaleDescriptor.create(	finalImage, 
    									(float) clonedFinalWorldToGrid.getScaleX(),
    									(float) clonedFinalWorldToGrid.getScaleY(),
    									(float) clonedFinalWorldToGrid.getTranslateX(), 
    									(float) clonedFinalWorldToGrid.getTranslateY(), 
    									interpolation, 
    									hints);
    		}else{
                    // use more general affine (slower)
                    im = AffineDescriptor.create(
                            finalImage, 
                            clonedFinalWorldToGrid, 
                            interpolation,
                            null, 
                            hints);
    		}
    	}finally{
    		if(DEBUG)
    			writeRenderedImage(im, "postAffine");
    	}
    	return im;

    }

