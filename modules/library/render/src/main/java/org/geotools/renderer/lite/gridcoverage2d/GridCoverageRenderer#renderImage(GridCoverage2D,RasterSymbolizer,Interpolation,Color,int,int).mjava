    /**
     * Turns the coverage into a rendered image applying the necessary transformations and the
     * symbolizer
     * 
     * @param gridCoverage
     * @param symbolizer
     * @return The transformed image, or null if the coverage does not lie within the rendering
     *         bounds
     * @throws FactoryException
     * @throws TransformException
     * @throws NoninvertibleTransformException
     */
    public RenderedImage renderImage(
            final GridCoverage2D gridCoverage,
            final RasterSymbolizer symbolizer, 
            final Interpolation interpolation, 
            final Color background,
            final int tileSizeX, 
            final int tileSizeY
            ) throws FactoryException, TransformException, NoninvertibleTransformException {

        // Build the final image and the associated world to grid transformation
        final GCpair couple = prepareFinalImage(gridCoverage, symbolizer);
        if (couple == null)
            return null;
        // NOTICE that at this stage the image we get should be 8 bits, either RGB, RGBA, Gray, GrayA
        // either multiband or indexed. It could also be 16 bits indexed!!!!
        
        final RenderedImage finalImage = couple.getGridCoverage().getRenderedImage();
        final AffineTransform finalRaster2Model = couple.getTransform();
        
        //paranoiac check to avoid that JAI freaks out when computing its internal layouT on images that are too small
        Rectangle2D finalLayout= layoutHelper(
                        finalImage, 
                        (float)finalRaster2Model.getScaleX(), 
                        (float)finalRaster2Model.getScaleY(), 
                        (float)finalRaster2Model.getTranslateX(), 
                        (float)finalRaster2Model.getTranslateY(), 
                        interpolation);
        if(finalLayout.isEmpty()){
                if(LOGGER.isLoggable(java.util.logging.Level.FINE))
                        LOGGER.fine("Unable to create a granuleDescriptor "+this.toString()+ " due to jai scale bug");
                return null;
        }

        // final transformation
        final ImageLayout layout = new ImageLayout(finalImage);
        layout.setTileGridXOffset(0).setTileGridYOffset(0).setTileHeight(tileSizeY).setTileWidth(tileSizeX);
        final RenderingHints localHints = this.hints.clone(); 
            localHints.add(new RenderingHints(JAI.KEY_IMAGE_LAYOUT, layout));
        //add hints to preserve IndexColorModel
        if(interpolation instanceof InterpolationNearest)
            localHints.add(new RenderingHints(JAI.KEY_REPLACE_INDEX_COLOR_MODEL, Boolean.FALSE));
        //SG add hints for the border extender
        localHints.add(new RenderingHints(JAI.KEY_BORDER_EXTENDER,BorderExtender.createInstance(BorderExtender.BORDER_COPY)));
    	RenderedImage im=null;
    	try {
    	    ImageWorker iw = new ImageWorker(finalImage);
    	    iw.setRenderingHints(localHints);
    	    iw.affine(finalRaster2Model, interpolation, null);
    	    im = iw.getRenderedImage();
    	} finally {
    		if(DEBUG)
    			writeRenderedImage(im, "postAffine");
    	}
    	return im;

    }

