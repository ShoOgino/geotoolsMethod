    /** initialization of the basic element for this {@link SLDColorMapBuilder}. */
    private void init() {
        if (numberOfColorMapElements != -1) return;
        // //
        //
        // A ColorMapTransform with a single entry makes sense only if we have
        // ColorMapTransform type VALUES
        //
        // //
        if (numberColorMapEntries == 1 && linearColorMapType != ColorMap.TYPE_VALUES)
            throw new IllegalArgumentException(
                    Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, "colormap entries", "1"));

        // /////////////////////////////////////////////////////////////////////
        //
        // PREPARATION
        //
        // /////////////////////////////////////////////////////////////////////
        numberOfColorMapElements = numberColorMapEntries;
        if (linearColorMapType == ColorMap.TYPE_RAMP) {

            // //
            //
            // Let's distribute the number of colors that we'll use between the
            // various color map elements we'll build. We start by checking if we can use
            // 256 colors, otherwise we switch to 65536.
            //
            // Keep into account that some categories are inherently single
            // valued, hence we take them out of the count because we don't.
            //
            // //
            double colorsToDistribute =
                    !extendedColors && numberColorMapEntries < 256 ? 256 : 65536;
            // default color
            if (gapsColor != null) colorsToDistribute--;
            // preserved values
            if (preservedValuesColor != null) colorsToDistribute--;

            // compute the number of colors we can use for each color map element
            colorsPerColorMapElement =
                    (int)
                            ((colorsToDistribute)
                                    /
                                    // we remove one since the first and last element use 1 color
                                    // only, hence we want to account only the internal ranges
                                    (numberOfColorMapElements - 1));

            // now keep into account the last element
            numberOfColorMapElements++;
        } else colorsPerColorMapElement = 1;
    }

