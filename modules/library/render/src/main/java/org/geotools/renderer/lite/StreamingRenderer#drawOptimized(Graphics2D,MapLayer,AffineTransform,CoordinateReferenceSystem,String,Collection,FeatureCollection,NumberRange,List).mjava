    /**
     * Performs rendering so that the collection is scanned only once even in presence
     * of multiple feature type styles, using the in memory buffer for each feature type
     * style other than the first one (that uses the graphics provided by the user)s 
     */
    private void drawOptimized(final Graphics2D graphics, MapLayer currLayer, AffineTransform at,
            CoordinateReferenceSystem destinationCrs, String layerId, Collection collection,
            FeatureCollection features, final NumberRange scaleRange, final List lfts) {
        
 
        final LiteFeatureTypeStyle[] fts_array = (LiteFeatureTypeStyle[]) lfts
                .toArray(new LiteFeatureTypeStyle[lfts.size()]);

        
        if( collection != null ) {
            Iterator iterator = collection.iterator();        
            if( iterator == null ) return; // nothing to do

            try {
                boolean clone = isCloningRequired(currLayer, fts_array);
                RenderableFeature rf = new RenderableFeature(currLayer, clone);
                // loop exit condition tested inside try catch
                // make sure we test hasNext() outside of the try/cath that follows, as that
                // one is there to make sure a single feature error does not ruin the rendering
                // (best effort) whilst an exception in hasNext() + ignoring catch results in
                // an infinite loop
                while (iterator.hasNext() && !renderingStopRequested) { 
                    try {
                        rf.setFeature(iterator.next());
                        // draw the feature on the main graphics and on the eventual extra image buffers
                        for (LiteFeatureTypeStyle liteFeatureTypeStyle : fts_array) {
                            rf.setScreenMap(liteFeatureTypeStyle.screenMap);
                            process(rf, liteFeatureTypeStyle, scaleRange, at, destinationCrs, layerId);
                        }
                    } catch (Throwable tr) {
                        fireErrorEvent(tr);
                    }
                }
                // submit the merge request
                requests.put(new MergeLayersRequest(graphics, fts_array));
            } catch(InterruptedException e) {
                fireErrorEvent(e);
            } finally {
                if( iterator instanceof Closeable ){
                    try {
                        ((Closeable)iterator).close();
                    } catch (IOException e) {
                        LOGGER.log(Level.FINER, e.getMessage(), e);
                    }
                }
            }             
        }

        if( features != null ) {
            FeatureIterator<?> iterator = features.features();
            if( iterator == null ) return; // nothing to do
            try {
                boolean clone = isCloningRequired(currLayer, fts_array);
                RenderableFeature rf = new RenderableFeature(currLayer, clone);
                // loop exit condition tested inside try catch
                // make sure we test hasNext() outside of the try/cath that follows, as that
                // one is there to make sure a single feature error does not ruin the rendering
                // (best effort) whilst an exception in hasNext() + ignoring catch results in
                // an infinite loop
                while (iterator.hasNext() && !renderingStopRequested) { 
                    try {
                        rf.setFeature(iterator.next());
                        // draw the feature on the main graphics and on the eventual extra image buffers
                        for (LiteFeatureTypeStyle liteFeatureTypeStyle : fts_array) {
                            rf.setScreenMap(liteFeatureTypeStyle.screenMap);
                            process(rf, liteFeatureTypeStyle, scaleRange, at, destinationCrs, layerId);
    
                        }
                    } catch (Throwable tr) {
                        fireErrorEvent(tr);
                    }
                }
                // submit the merge request
                requests.put(new MergeLayersRequest(graphics, fts_array));
            }catch(InterruptedException e) {
                fireErrorEvent(e);
            } finally {
                iterator.close();
            } 
        }
    }

