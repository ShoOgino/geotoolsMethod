    /**
     * In this test we create multiple tasks: half of which add a layer to the layer list and the
     * rest which remove the layer. Then the tasks are shuffled, submitted to the executor, and all
     * started at the same time (or at least given permission to run at the same time).
     */
    @Test
    public void addAndRemoveOnSeparateThreads() throws Exception {
        final CountDownLatch startLatch = new CountDownLatch(1);
        final int numThreads = 100;

        Layer layer1 = new MockLayer(WORLD);

        List<Runnable> tasks = new ArrayList<Runnable>(numThreads);
        int k = 0;
        while (k < numThreads / 2) {
            tasks.add(
                    new AddLayerTask(layer1, startLatch) {
                        @Override
                        public void postRun() {
                            assertTrue(mapContent.layers().size() == 1);
                        }
                    });
            k++;
        }
        while (k < numThreads) {
            tasks.add(
                    new RemoveLayerTask(layer1, startLatch) {
                        @Override
                        public void postRun() {
                            assertTrue(mapContent.layers().isEmpty());
                        }
                    });
            k++;
        }

        Collections.shuffle(tasks);
        for (Runnable task : tasks) {
            executor.submit(task);
        }

        // Counting down the latch allows the tasks to run
        startLatch.countDown();
    }

