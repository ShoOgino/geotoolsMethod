    /**
     * SWAN test-case.
     *
     * @throws IOException
     */
    @Test
    public void SWAN() throws IOException {
        // /////////////////////////////////////////////////////////////////////
        //
        // This test is interesting since it can be used to simulate the
        // case where someone specifies a ColorMap that overlaps with the native
        // NoData value. For this SWAN data the NoData value is -9999.0 and no
        // NaN which falls right into the first category.
        //
        // We overcome this problem by simply giving higher priority to the
        // NoData category over the other categories when doing a search for
        // the right category given a certain value. This force us to
        // first evaluate the no data category and then evaluate a possible
        // provided overlapping value.
        //
        // This test is also interesting since we create a color map by
        // providing output indexes that are not ordered and also that are not
        // all contained in a closed natural interval. As you can notice by
        // inspecting the different classes below there is an index, 51, which
        // is way outside the range of the others.
        //
        // /////////////////////////////////////////////////////////////////////
        final RenderedImage image = getSWAN();

        for (int i = 0; i < TEST_NUM; i++) {
            final LinearColorMapElement c0 =
                    LinearColorMapElement.create(
                            "c0",
                            Color.green,
                            RangeFactory.create(Double.NEGATIVE_INFINITY, 0.3),
                            51);

            final LinearColorMapElement c1 =
                    LinearColorMapElement.create(
                            "c2", Color.yellow, RangeFactory.create(0.3, false, 0.6, true), 1);

            final LinearColorMapElement c1b =
                    LinearColorMapElement.create(
                            "c2", Color.BLACK, RangeFactory.create(0.3, false, 0.6, true), 1);
            final LinearColorMapElement c1c =
                    LinearColorMapElement.create(
                            "c2", Color.yellow, RangeFactory.create(0.3, false, 0.6, true), 1);
            assertFalse(c1.equals(c1b));
            assertTrue(c1.equals(c1c));

            final LinearColorMapElement c3 =
                    LinearColorMapElement.create(
                            "c3", Color.red, RangeFactory.create(0.60, false, 0.90, true), 2);

            final LinearColorMapElement c4 =
                    LinearColorMapElement.create(
                            "c4",
                            Color.BLUE,
                            RangeFactory.create(0.9, false, Double.POSITIVE_INFINITY, true),
                            3);

            final LinearColorMapElement nodata =
                    LinearColorMapElement.create(
                            "nodata", new Color(0, 0, 0, 0), RangeFactory.create(-9.0, -9.0), 4);

            final LinearColorMap list =
                    new LinearColorMap(
                            "testSWAN",
                            new LinearColorMapElement[] {c0, c1, c3, c4},
                            new LinearColorMapElement[] {nodata},
                            new Color(0, 0, 0));

            assertEquals(list.getSourceDimensions(), 1);
            assertEquals(list.getTargetDimensions(), 1);
            assertEquals(list.getName().toString(), "testSWAN");
            assertNotNull(c0.toString());

            ImageWorker w = new ImageWorker(image);
            boolean exceptionThrown = false;
            try {
                // //
                // forcing a bad band selection ...
                // //
                final RenderedOp d = w.classify(list, Integer.valueOf(2)).getRenderedOperation();
                d.getTiles();
                // we should not be here!

            } catch (Exception e) {
                // //
                // ... ok, Exception wanted!
                // //
                exceptionThrown = true;
            }
            assertTrue(exceptionThrown);

            // pbj.setParameter("bandIndex", Integer.valueOf(0));
            final RenderedOp finalImage =
                    w.classify(list, Integer.valueOf(0)).getRenderedOperation();
            // JAI.create(
            // RasterClassifierOpImage.OPERATION_NAME, pbj);
            if (TestData.isInteractiveTest()) ImageIOUtilities.visualize(finalImage, "testSWAN1");
            else finalImage.getTiles();
            finalImage.dispose();
        }
    }

