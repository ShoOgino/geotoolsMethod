    @Test
    public void testStopRenderingDeadlock() throws Exception {
        SimpleFeature feature = createLine(0, 0, 10, 10);
        
        // setup the mock that will return an infinite feature collection
        SimpleFeatureIterator it = createNiceMock(SimpleFeatureIterator.class);
        expect(it.hasNext()).andReturn(true).anyTimes();
        expect(it.next()).andReturn(feature).anyTimes();
        replay(it);
        
        SimpleFeatureCollection fc = createNiceMock(SimpleFeatureCollection.class);
        expect(fc.features()).andReturn(it);
        expect(fc.size()).andReturn(Integer.MAX_VALUE);
        expect(fc.getSchema()).andReturn(testFeatureType).anyTimes();
        replay(fc);
        
        SimpleFeatureSource fs = createNiceMock(SimpleFeatureSource.class);
        expect(fs.getFeatures((Query) anyObject())).andReturn(fc);
        expect(fs.getSchema()).andReturn(testFeatureType).anyTimes();
        expect(fs.getSupportedHints()).andReturn(new HashSet()).anyTimes();
        replay(fs);
        
        // the executor that will be used to run the paint thread
        ExecutorService painterExecutor = Executors.newSingleThreadExecutor();
        
        // build map context
        MapContent mc = new MapContext(DefaultGeographicCRS.WGS84);
        mc.addLayer(new FeatureLayer(fs, createLineStyle()));
        
        // prepare the renderer with just one slot in the rendering blocking queue
        final StreamingRenderer sr = new StreamingRenderer() {
            @Override
            protected BlockingQueue<RenderingRequest> getRequestsQueue() {
                return new StreamingRenderer.RenderingBlockingQueue(1);
            }
        };
        sr.setMapContent(mc);
        sr.setThreadPool(painterExecutor);        
        
        // prepare a very slow graphics
        Graphics2D g2d = createNiceMock(Graphics2D.class);
        g2d.draw((Shape) anyObject());
        expectLastCall().andStubAnswer(new IAnswer<Object>() {
            
            @Override
            public Object answer() throws Throwable {
                Thread.sleep(100);
                return null;
            }
        });
        replay(g2d);
        
        // prepare a thread that will stop the renderer in one seconds
        ExecutorService ex = Executors.newSingleThreadExecutor();
        ex.submit(new Callable<Boolean>() {

            @Override
            public Boolean call() throws Exception {
                Thread.sleep(1000);
                sr.stopRendering();
                return true;
            }
        
        });
        
        // now draw, wait a bit, and then stop the rendering
        ReferencedEnvelope reWgs = new ReferencedEnvelope(new Envelope(-180,
                180, -90, 90), DefaultGeographicCRS.WGS84);
        sr.paint(g2d, new Rectangle(200, 200), reWgs);
        
        // also make sure we close up the painter thread
        painterExecutor.shutdown();
        painterExecutor.awaitTermination(1000, TimeUnit.MILLISECONDS);
        
        // if the bug if fixed, we get here, if it's not, infinite wait that we 
        // cannot do anything to stop...
        
    }

