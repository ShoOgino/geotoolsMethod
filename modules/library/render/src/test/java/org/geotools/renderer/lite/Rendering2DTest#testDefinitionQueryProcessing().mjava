    /**
     * Tests the layer definition query behavior as implemented by StreamingRenderer.
     *
     * <p>This method relies on the features created on createTestFeatureCollection()
     *
     * @throws Exception
     */
    public void testDefinitionQueryProcessing() throws Exception {

        // LOGGER.info("starting definition query test");
        // final SimpleFeatureCollection ft = createTestDefQueryFeatureCollection();
        // final Style style = createDefQueryTestStyle();
        // FeatureResults results;
        // Envelope envelope = ft.getBounds();
        //
        // // we'll use this as the definition query for the layer
        // Query layerQuery;
        //
        // MapLayer layer = new DefaultMapLayer(ft, style);
        // MapContext map = new DefaultMapContext(new MapLayer[] { layer });
        // map.setAreaOfInterest(envelope, ft.getFeatureType()
        // .getDefaultGeometry().getCoordinateSystem());
        // StreamingRenderer renderer = new StreamingRenderer();
        // renderer.setContext(map);
        // renderer.setRendererHints(rendererHints);
        //
        // // this is the reader that StreamingRenderer obtains after applying
        // // the mixed filter to a given layer.
        // Filter filter = Filter.INCLUDE;
        // FilterFactory ffac = FilterFactoryFinder.createFilterFactory();
        //
        // // test maxFeatures, render just the first 2 features
        // layerQuery = new DefaultQuery("querytest", filter, 2, null,
        // "handle");
        // layer.setQuery(layerQuery);
        //
        // results = renderer.queryLayer(layer,layer.getFeatureSource() ,
        // layer.getFeatureSource() .getSchema(), null, envelope,
        // DefaultGeographicCRS.WGS84, map.getCoordinateReferenceSystem(), null,
        // null);
        // assertEquals(2, results.getCount());
        // // just the 3 geometric atts should get be loaded
        // assertEquals(4, results.getSchema().getAttributeCount());
        //
        // RendererBaseTest.showRender("testDefinitionQuery1", renderer, 1000,
        // null);
        //
        // // test attribute based filter
        // FeatureType schema = ft.features().next().getFeatureType();
        // filter = ffac.createCompareFilter(AbstractFilter.COMPARE_EQUALS);
        // ((CompareFilter) filter).addLeftValue(ffac.createAttributeExpression(
        // schema, "id"));
        // ((CompareFilter) filter).addRightValue(ffac
        // .createLiteralExpression("ft1"));
        //
        // // note we include the "id" field in the layer query. Bad practice,
        // // since it goes
        // // against
        // // the performance gain of
        // // renderer.setOptimizedDataLoadingEnabled(true),
        // // but we should test it anyway
        // layerQuery = new DefaultQuery("querytest", filter, Integer.MAX_VALUE,
        // new String[] { "id" }, "handle");
        // layer.setQuery(layerQuery);
        //
        // results = renderer.queryLayer(layer, null, envelope,
        // DefaultGeographicCRS.WGS84);
        // assertEquals(1, results.getCount());
        // // the 4 atts should be loaded since the definition query includes
        // "id"
        // assertEquals(4, results.getSchema().getAttributeCount());
        // // we can check this since we explicitly requested the "id"
        // attribute.
        // // If we not,
        // // it would be not loaded
        // String val = (String) results.reader().next().getAttribute("id");
        // assertEquals("ft1", val);
        //
        // RendererBaseTest.showRender("testDefinitionQuery2", renderer, 1000,
        // null);
        //
        // // try a bbox filter as definition query for the layer
        // filter = null;
        // GeometryFilter gfilter;
        // // contains the first 2 features
        // Envelope env = new Envelope(20, 130, 20, 130);
        // gfilter = ffac.createGeometryFilter(AbstractFilter.GEOMETRY_BBOX);
        // gfilter
        // .addLeftGeometry(ffac
        // .createAttributeExpression(schema, "point"));
        // gfilter.addRightGeometry(ffac.createBBoxExpression(env));
        // filter = gfilter;
        //
        // gfilter = ffac.createGeometryFilter(AbstractFilter.GEOMETRY_BBOX);
        // gfilter.addLeftGeometry(ffac.createAttributeExpression(schema,
        // "line"));
        // gfilter.addRightGeometry(ffac.createBBoxExpression(env));
        // filter = filter.or(gfilter);
        //
        // gfilter = ffac.createGeometryFilter(AbstractFilter.GEOMETRY_BBOX);
        // gfilter.addLeftGeometry(ffac.createAttributeExpression(schema,
        // "polygon"));
        // gfilter.addRightGeometry(ffac.createBBoxExpression(env));
        // filter = filter.or(gfilter);
        //
        // System.err.println("trying with filter: " + filter);
        //
        // layerQuery = new DefaultQuery("querytest", filter, Integer.MAX_VALUE,
        // null, "handle");
        // layer.setQuery(layerQuery);
        //
        // results = renderer.queryLayer(layer, null, envelope,
        // DefaultGeographicCRS.WGS84);
        // assertEquals(2, results.getCount());
        // // the 4 atts should be loaded since the definition query includes
        // "id"
        // assertEquals(4, results.getSchema().getAttributeCount());
        //
        // RendererBaseTest.showRender("testDefinitionQuery3", renderer, 1000,
        // null);

    }

