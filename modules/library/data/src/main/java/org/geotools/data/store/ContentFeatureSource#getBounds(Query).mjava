    /**
     * Returns the bounds of the results of the specified query against the 
     * feature source.
     * <p>
     * This method calls through to {@link #getBoundsInternal(Query)} which 
     * subclasses must implement. It also contains optimizations which check 
     * state for cached values.
     * </p>
     */
    public final ReferencedEnvelope getBounds(Query query) throws IOException {
        query = joinQuery( query );
        query = resolvePropertyNames(query);

        //
        //calculate the bounds
        //
        ReferencedEnvelope bounds;
        if(!canTransact() && transaction != null && transaction != Transaction.AUTO_COMMIT) {
            // grab the in memory transaction diff
            DiffTransactionState state = (DiffTransactionState) getTransaction().getState(getEntry());
            Diff diff = state.getDiff();
            
            // don't compute the bounds of the features that are modified or removed in the diff
            Iterator<String> i = diff.getModified().keySet().iterator();
            FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2();
            Set<FeatureId> modifiedFids = new HashSet<FeatureId>();
            while(i.hasNext()){
                String featureId = i.next();
                modifiedFids.add(ff.featureId(featureId));
            }
            Filter skipFilter = ff.not( ff.id(modifiedFids) );
            
            Query q = new Query(query);
            q.setFilter(ff.and(skipFilter, query.getFilter()));
            bounds = getBoundsInternal(q);
            
            // update with the diff contents, all added feature and all modified, not deleted ones
            if(bounds != null) {
                // new ones
                Iterator<SimpleFeature> it = diff.getAdded().values().iterator();
                while(it.hasNext()){
                    SimpleFeature feature = (SimpleFeature) it.next();
                    BoundingBox fb = feature.getBounds();
                    if(fb != null) {
                        bounds.expandToInclude(ReferencedEnvelope.reference(fb));
                    }
                }
                
                // modified ones
                it = diff.getModified().values().iterator();
                while(it.hasNext()){
                    SimpleFeature feature = (SimpleFeature) it.next();
                    if(feature != Diff.NULL) {
                        BoundingBox fb = feature.getBounds();
                        if(fb != null) {
                            bounds.expandToInclude(ReferencedEnvelope.reference(fb));
                        }
                    }
                }
            }
        } else {
            bounds = getBoundsInternal(query);
        }
        // reprojection
        if ( !canReproject() ) {
            CoordinateReferenceSystem targetCRS = query.getCoordinateSystemReproject();
            if (targetCRS != null) {
                CoordinateReferenceSystem nativeCRS = getSchema().getCoordinateReferenceSystem();
                if(nativeCRS == null) {
                    throw new IOException("Cannot reproject data, the source CRS is not available");
                } else if(!nativeCRS.equals(targetCRS)) {
                    try {
                        bounds = bounds.transform(targetCRS, true);
                    } catch (Exception e) {
                        if(e instanceof IOException)
                            throw (IOException) e;
                        else
                            throw (IOException) new IOException("Error occurred trying to reproject data").initCause(e);
                    }
                }
            }    
        }
        
        return bounds;
    }

