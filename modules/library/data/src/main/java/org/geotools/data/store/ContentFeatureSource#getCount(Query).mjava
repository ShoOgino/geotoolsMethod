    /**
     * Returns the count of the number of features of the feature source.
     * <p>
     * This method calls through to {@link #getCount(Query)} which 
     * subclasses must implement. It also contains optimizations which check 
     * state for cached values.
     * </p>
     */
    public final int getCount(Query query) throws IOException {
        query = joinQuery( query );
        query = resolvePropertyNames( query );
        
        // calculate the count
        int count = getCountInternal( query );
        
        // if internal is not counted, return
        if (count < 0) {
            return count;
        }
        // if the internal actually counted, consider transactions
        if(!canTransact() && transaction != null && transaction != Transaction.AUTO_COMMIT) {
            DiffTransactionState state = (DiffTransactionState) getTransaction().getState(getEntry());
            Diff diff = state.getDiff();
            synchronized (diff) {
                // consider newly added features that satisfy the filter
                Iterator<SimpleFeature> it = diff.getAdded().values().iterator();
                Filter filter = query.getFilter();
                while(it.hasNext()){
                    SimpleFeature feature = it.next();
                    if(filter.evaluate(feature)) {
                        count++;
                    }
                        
                }
                
                // consider removed features that satisfy the filter
                it = diff.getModified().values().iterator();
                FilterFactory2 ff = CommonFactoryFinder.getFilterFactory2();
                Set<FeatureId> modifiedFids = new HashSet<FeatureId>();
                int modifiedPostCount = 0;
                while(it.hasNext()){
                    SimpleFeature feature = (SimpleFeature) it.next();
                    
                    if(feature == Diff.NULL) {
                        count--;
                    } else {
                        modifiedFids.add(ff.featureId(feature.getID()));
                        if(filter.evaluate(feature)) {
                            modifiedPostCount++;
                        }
                    }
                }
                
                // consider the updated feature if any, we need to know how
                // many of those matched the filter before
                if(modifiedFids.size() > 0) {
                    Id idFilter = ff.id(modifiedFids);
                    Query q = new Query(query);
                    q.setFilter(ff.and(idFilter, query.getFilter()));
                    int modifiedPreCount = getCountInternal(q);
                    if(modifiedPreCount == -1) {
                        return -1;
                    } else {
                        count = count + modifiedPostCount - modifiedPreCount;
                    }
                }
            }
        }
        
        // offset
        int offset = query.getStartIndex() != null ? query.getStartIndex() : 0;
        if( !canOffset() && offset > 0 ) {
            // skip the first n records
            count = Math.max(0, count - offset);
            
        }
        
        // max feature limit
        if ( !canLimit() ) {
            if (query.getMaxFeatures() != -1 && query.getMaxFeatures() < Integer.MAX_VALUE ) {
                count = Math.min(query.getMaxFeatures(), count);
            }    
        }
        
        return count;
    }

