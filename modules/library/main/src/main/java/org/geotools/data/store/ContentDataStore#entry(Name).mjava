    /**
     * Helper method to look up an entry in the datastore.
     *
     * <p>This method will create a new instance of {@link ContentEntry} if one does not exist.
     *
     * <p>In the event that the name does not map to an entry and one cannot be created <code>null
     * </code> will be returned. Note that {@link #ensureEntry(TypeName)} will throw an exception in
     * this case.
     *
     * @param The name of the entry.
     * @return The entry, or <code>null</code> if it does not exist.
     */
    protected final ContentEntry entry(Name name) throws IOException {
        ContentEntry entry = null;

        boolean found = entries.containsKey(name);
        boolean unqualifiedSearch = name.getNamespaceURI() == null;
        if (!found && unqualifiedSearch && this.namespaceURI != null) {
            Name defaultNsName = new NameImpl(namespaceURI, name.getLocalPart());
            if (entries.containsKey(defaultNsName)) {
                name = defaultNsName;
                found = true;
            }
        }

        if (!found) {
            // refresh the entries (calling createTypeNames() can be quite expensive,
            // make it count) and do namespace-less matches as required
            List<Name> typeNames = createTypeNames();

            for (Name tn : typeNames) {
                synchronized (this) {
                    if (!entries.containsKey(tn)) {
                        entry = new ContentEntry(this, tn);
                        entries.put(tn, entry);
                    }
                }

                // do namespace-less matching if necessary
                if (!found
                        && (tn.equals(name)
                                || (unqualifiedSearch
                                        && tn.getLocalPart().equals(name.getLocalPart())))) {
                    name = tn;
                    found = true;
                }
            }
        }

        return entries.get(name);
    }

