    private Class<?> largestType(Class<?> type1, Class<?> type2) {
        // start with the easy cases
        if (type1.isAssignableFrom(type2)) {
            return type1;
        } else if (type2.isAssignableFrom(type1)) {
            return type2;
        }

        // consider numbers and promotions
        if (Number.class.isAssignableFrom(type1) && Number.class.isAssignableFrom(type2)) {
            List<Class<?>> c1 = PROMOTIONS.get(type1);
            List<Class<?>> c2 = PROMOTIONS.get(type2);
            if (c1 == null || c2 == null) {
                return Object.class;
            }
            List<Class<?>> intersection = new ArrayList<>(c1);
            intersection.retainAll(c2);
            if (intersection.isEmpty()) {
                return Object.class;
            } else {
                // lowest shared type
                return intersection.get(0);
            }
        }

        // ok, let's get the most specific superclass then...
        return getCommonSuperclass(type1, type2);
    }

