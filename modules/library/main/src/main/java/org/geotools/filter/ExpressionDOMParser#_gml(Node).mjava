    /**
     * Parses the gml of this node to jts.
     *
     * @param root the parent node of the gml to parse.
     * @return the java representation of the geometry contained in root.
     */
    private Geometry _gml(Node root) {
        LOGGER.finer("processing gml " + root);

        List<Coordinate> coordList;
        Node child = root;

        // Jesus I hate DOM.  I have no idea why this was checking for localname
        // and then nodename - lead to non-deterministic behavior, that for
        // some reason only failed if the filter parser was used within the
        // SLDparser.  I really would like that class redone, so we don't have
        // to use this crappy DOM GML parser.
        String childName = child.getNodeName();
        if (childName == null) {
            childName = child.getLocalName();
        }
        if (!childName.startsWith("gml:")) {
            childName = "gml:" + childName;
        }

        if (childName.equalsIgnoreCase("gml:box")) {
            coordList =
                    new ExpressionDOMParser(CommonFactoryFinder.getFilterFactory2()).coords(child);

            org.locationtech.jts.geom.Envelope env = new org.locationtech.jts.geom.Envelope();

            for (Coordinate coordinate : coordList) {
                env.expandToInclude(coordinate);
            }
            Coordinate[] coords = new Coordinate[NUM_BOX_COORDS];
            coords[0] = new Coordinate(env.getMinX(), env.getMinY());
            coords[1] = new Coordinate(env.getMinX(), env.getMaxY());
            coords[2] = new Coordinate(env.getMaxX(), env.getMaxY());
            coords[3] = new Coordinate(env.getMaxX(), env.getMinY());
            coords[4] = new Coordinate(env.getMinX(), env.getMinY());

            // return new ReferencedEnvelope( env, null );
            org.locationtech.jts.geom.LinearRing ring = null;

            try {
                ring = gfac.createLinearRing(coords);
            } catch (org.locationtech.jts.geom.TopologyException tope) {
                LOGGER.fine("Topology Exception in GMLBox" + tope);

                return null;
            }
            return gfac.createPolygon(ring, null);
        }

        // check for geometry properties
        if (childName.equalsIgnoreCase("gml:polygonmember")
                || childName.equalsIgnoreCase("gml:pointmember")
                || childName.equalsIgnoreCase("gml:linestringmember")
                || childName.equalsIgnoreCase("gml:linearringmember")) {

            for (int i = 0; i < child.getChildNodes().getLength(); i++) {
                Node newChild = child.getChildNodes().item(i);
                if (newChild.getNodeType() == Node.ELEMENT_NODE) {
                    childName = newChild.getNodeName();
                    if (!childName.startsWith("gml:")) {
                        childName = "gml:" + childName;
                    }
                    root = newChild;
                    child = newChild;
                    break;
                }
            }
        }

        if (childName.equalsIgnoreCase("gml:polygon")) {
            LOGGER.finer("polygon");

            LinearRing outer = null;
            List<LinearRing> inner = new ArrayList<>();
            NodeList kids = root.getChildNodes();

            for (int i = 0; i < kids.getLength(); i++) {
                Node kid = kids.item(i);
                LOGGER.finer("doing " + kid);

                String kidName = kid.getNodeName();
                if (kidName == null) {
                    kidName = child.getLocalName();
                }
                if (!kidName.startsWith("gml:")) {
                    kidName = "gml:" + kidName;
                }

                if (kidName.equalsIgnoreCase("gml:outerBoundaryIs")) {
                    outer = (LinearRing) gml(kid);
                }

                if (kidName.equalsIgnoreCase("gml:innerBoundaryIs")) {
                    inner.add((LinearRing) gml(kid));
                }
            }

            if (inner.isEmpty()) {
                return gfac.createPolygon(outer, null);
            } else {
                return gfac.createPolygon(outer, inner.toArray(new LinearRing[0]));
            }
        }

        if (childName.equalsIgnoreCase("gml:outerBoundaryIs")
                || childName.equalsIgnoreCase("gml:innerBoundaryIs")) {
            LOGGER.finer("Boundary layer");

            NodeList kids = ((Element) child).getElementsByTagName("gml:LinearRing");
            if (kids.getLength() == 0) kids = ((Element) child).getElementsByTagName("LinearRing");
            return gml(kids.item(0));
        }

        if (childName.equalsIgnoreCase("gml:linearRing")) {
            LOGGER.finer("LinearRing");
            coordList =
                    new ExpressionDOMParser(CommonFactoryFinder.getFilterFactory2()).coords(child);

            org.locationtech.jts.geom.LinearRing ring = null;

            try {
                ring = gfac.createLinearRing(coordList.toArray(new Coordinate[] {}));
            } catch (TopologyException te) {
                LOGGER.finer("Topology Exception build linear ring: " + te);

                return null;
            }

            return ring;
        }

        if (childName.equalsIgnoreCase("gml:linestring")) {
            LOGGER.finer("linestring");
            coordList =
                    new ExpressionDOMParser(CommonFactoryFinder.getFilterFactory2()).coords(child);

            LineString line = gfac.createLineString(coordList.toArray(new Coordinate[] {}));

            return line;
        }

        if (childName.equalsIgnoreCase("gml:point")) {
            LOGGER.finer("point");
            coordList =
                    new ExpressionDOMParser(CommonFactoryFinder.getFilterFactory2()).coords(child);

            Point point = gfac.createPoint(coordList.get(0));

            return point;
        }

        if (childName.toLowerCase().startsWith("gml:multipolygon")
                || childName.toLowerCase().startsWith("gml:multilinestring")
                || childName.toLowerCase().startsWith("gml:multipoint")) {

            List<Geometry> multi = new ArrayList<>();

            // parse all children thru parseGML
            NodeList kids = child.getChildNodes();

            for (int i = 0; i < kids.getLength(); i++) {
                if (kids.item(i).getNodeType() == Node.ELEMENT_NODE) {
                    multi.add(gml(kids.item(i)));
                }
            }

            if (childName.toLowerCase().startsWith("gml:multipolygon")) {
                LOGGER.finer("MultiPolygon");
                return gfac.createMultiPolygon(multi.toArray(new Polygon[0]));
            } else if (childName.toLowerCase().startsWith("gml:multilinestring")) {
                LOGGER.finer("MultiLineString");
                return gfac.createMultiLineString(multi.toArray(new LineString[0]));
            } else {
                LOGGER.finer("MultiPoint");
                return gfac.createMultiPoint(multi.toArray(new Point[0]));
            }
        }

        return null;
    }

