    @Override
    public Geometry postProcess(MathTransform mt, Geometry geometry) {
        // Let's check if the geometry is undoubtedly not going to need processing
        Envelope env = geometry.getEnvelopeInternal();
        final double width = getWidth(env, targetCRS);
        final double reWidth = getWidth(renderingEnvelope, targetCRS);

        // if it was large and still larger, or small and still small, it likely did not wrap
        if (width < targetHalfCircle
                && renderingEnvelope.contains(env)
                && reWidth <= targetHalfCircle * 2) {
            return geometry;
        }

        // Check if the geometry has wrapped the dateline. Heuristic: we assume
        // anything larger than half of the world might have wrapped it, however,
        // if it's touching both datelines then don't wrap it, as it might be something
        // like antarctica
        final boolean northEast = CRS.getAxisOrder(targetCRS) == CRS.AxisOrder.NORTH_EAST;
        if (datelineWrappingCheckEnabled
                && ((geometry.getUserData() == LARGE_EARTH_OBJECT && width < targetHalfCircle)
                        || (geometry.getUserData() != LARGE_EARTH_OBJECT
                                && width > targetHalfCircle
                                && width < targetHalfCircle * 2))) {
            final Geometry wrapped = geometry.copy();
            wrapped.apply(
                    new WrappingCoordinateFilter(
                            targetHalfCircle, targetHalfCircle * 2, mt, northEast));
            wrapped.geometryChanged();
            geometry = wrapped;
            env = geometry.getEnvelopeInternal();
        }

        // The viewing area might contain the geometry multiple times due to
        // wrapping.
        // This is obvious for the geometries that wrapped the dateline, but the
        // viewing
        // area might be large enough to contain the same continent multiple
        // times (a-la Google Maps)
        List<Geometry> geoms = new ArrayList<Geometry>();
        Class geomType = null;

        // search the west-most location inside the current rendering envelope
        // (there may be many)
        double base, curr, lowLimit, highLimit;
        if (northEast) {
            base = env.getMinY();
            curr = env.getMinY();
            lowLimit =
                    Math.max(
                            renderingEnvelope.getMinY(),
                            renderingEnvelope.getMedian(1) - maxWraps * targetHalfCircle * 2);
            highLimit =
                    Math.min(
                            renderingEnvelope.getMaxY(),
                            renderingEnvelope.getMedian(1) + maxWraps * targetHalfCircle * 2);
        } else {
            base = env.getMinX();
            curr = env.getMinX();
            double geometryWidth = geometry.getEnvelopeInternal().getWidth();
            lowLimit =
                    Math.max(
                            renderingEnvelope.getMinX() - geometryWidth,
                            renderingEnvelope.getMedian(0) - maxWraps * targetHalfCircle * 2);
            highLimit =
                    Math.min(
                            renderingEnvelope.getMaxX() + geometryWidth,
                            renderingEnvelope.getMedian(0) + maxWraps * targetHalfCircle * 2);
        }
        while (curr > lowLimit) {
            curr -= targetHalfCircle * 2;
        }

        // clone and offset as necessary
        geomType = accumulate(geoms, geometry, geomType, renderingEnvelope);
        while (curr <= highLimit) {
            double offset = curr - base;
            if (Math.abs(offset) >= targetHalfCircle) {
                // we make a copy and offset it
                Geometry offseted = geometry.copy();
                offseted.apply(new OffsetOrdinateFilter(northEast ? 1 : 0, offset));
                offseted.geometryChanged();
                geomType = accumulate(geoms, offseted, geomType, renderingEnvelope);
            }

            curr += targetHalfCircle * 2;
        }

        // if we could not find any geom type we stumbled int an empty geom collection
        if (geomType == null) {
            return null;
        }

        // if we did not have to actually clone the geometries
        if (geoms.size() == 1) {
            return geoms.get(0);
        }

        // rewrap all the clones into a single geometry
        if (Point.class.equals(geomType)) {
            Point[] points = geoms.toArray(new Point[geoms.size()]);
            return geometry.getFactory().createMultiPoint(points);
        } else if (LineString.class.isAssignableFrom(geomType)) {
            LineString[] lines = geoms.toArray(new LineString[geoms.size()]);
            return geometry.getFactory().createMultiLineString(lines);
        } else if (Polygon.class.equals(geomType)) {
            Polygon[] polys = geoms.toArray(new Polygon[geoms.size()]);
            return geometry.getFactory().createMultiPolygon(polys);
        } else {
            return geometry.getFactory()
                    .createGeometryCollection(geoms.toArray(new Geometry[geoms.size()]));
        }
    }

