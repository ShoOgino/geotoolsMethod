    /**
     * Restriction only works on exact structure match.
     *
     * <p>This is the way XMLSchema handles it ...
     */
    // @SuppressWarnings("unchecked")
    // public ComplexType restriction(ComplexType parent,ComplexType restrict) {
    //
    // ComplexType type = null;
    //
    // if (
    // parent instanceof ChoiceType && restrict instanceof ChoiceType
    // ) {
    //
    // Set choices = (Set) restriction(
    // ((ChoiceType)parent).getAttributes(),
    // ((ChoiceType)restrict).getAttributes(),
    // new HashSet()
    // );
    //
    // type = xmlFactory.createChoiceType(choices);
    // }
    // else if (parent instanceof SequenceType && restrict instanceof
    // SequenceType) {
    // List sequence = (List) restriction(
    // ((SequenceType)parent).getAttributes(),
    // ((SequenceType)restrict).getAttributes(),
    // new ArrayList()
    // );
    //
    // type = xmlFactory.createSequenceType(sequence);
    // }
    // else if (
    // parent instanceof ComplexType && restrict instanceof ComplexType
    // ){
    // List elements = (List) restriction(
    // ((ComplexType)parent).getAttributes(),
    // ((ComplexType)restrict).getAttributes(),
    // new ArrayList()
    // );
    //
    // ComplexType ct = (ComplexType) restrict;
    // type = xmlFactory.createType(
    // ct.getName(),elements,ct.isIdentified(),ct.isNillable().booleanValue(),
    // ct.getRestrictions(),ct,ct.isAbstract());
    //
    // }
    // else {
    // throw new IllegalArgumentException("Cannot restrict provided schema");
    // }
    //
    // return type;
    //
    // }
    // public ComplexType restriction(ComplexType parent,
    // Collection/*<AttributeDescriptor>*/ schema) {
    // ComplexType type = null;
    //
    // if (parent instanceof ChoiceType) {
    // Set choices = (Set) restriction(
    // ((ChoiceType)parent).getAttributes(),schema,new HashSet()
    // );
    // type = xmlFactory.createChoiceType(choices);
    // }
    // else if (parent instanceof SequenceType) {
    // List sequence = (List) restriction(
    // ((SequenceType)parent).getAttributes(), schema, new ArrayList()
    // );
    //
    // type = xmlFactory.createSequenceType(sequence);
    // }
    // else if (parent instanceof ComplexType){
    // List elements = (List) restriction(
    // ((ComplexType)parent).getAttributes(),schema, new ArrayList()
    // );
    //
    // //duplicate parent type with new schema
    // //JD: this is a bit of a hack, creating type manually (ie wihtout
    // // factory, because we have constructed the schema manually
    //
    // ComplexType ct = (ComplexType) parent;
    // type = new ComplexTypeImpl(
    // ct.getName(),elements,ct.isIdentified(),
    // ct.isNillable().booleanValue(),ct.getRestrictions(),ct,
    // ct.isAbstract()
    // );
    // type = xmlFactory.createType(
    // ct.getName(),elements,ct.isIdentified(),ct.isNillable().booleanValue(),
    // ct.getRestrictions(),null,ct.isAbstract());
    // }
    // else {
    // throw new IllegalArgumentException("Cannot restrict provided schema");
    // }
    //
    // return type;
    // }
    //
    // public ComplexType extension(
    // ComplexType parent, Collection/*<AttributeDescriptor>*/ schema
    // ) {
    //
    // //create a dummy type for the schema
    // ComplexType type = null;
    //
    // if (parent instanceof ChoiceType) {
    //
    // Set choices = new HashSet();
    // choices.addAll(((ChoiceType)parent).getAttributes());
    // choices.addAll(schema);
    //
    // type = xmlFactory.createChoiceType(choices);
    // }
    // else if (parent instanceof SequenceType) {
    //
    // List sequence = new ArrayList();
    //
    // sequence.addAll(((SequenceType)parent).getAttributes());
    // sequence.addAll(schema);
    //
    // type = xmlFactory.createSequenceType(sequence);
    // }
    // else if (parent instanceof ComplexType){
    // List elements = new ArrayList();
    // elements.addAll(((ComplexType)parent).getAttributes());
    // elements.addAll(schema);
    //
    // //JD: fix this, passing in null here to avoid recalling this method
    // // this method needs to be factored out somewhere else
    // ComplexType ct = (ComplexType) parent;
    // type = xmlFactory.createType(
    // ct.getName(),elements,ct.isIdentified(),ct.isNillable().booleanValue(),
    // ct.getRestrictions(),null,ct.isAbstract());
    // }
    //
    // return type;
    // }
    //
    //
    // /**
    // * Extending a schema.
    // * <p>
    // * Since we will be creating a new Descriptor we need the factory.
    // */
    // public ComplexType extension(ComplexType parent, ComplexType extend) {
    //
    // ComplexType type = null;
    //
    // if (parent instanceof ChoiceType && extend instanceof ChoiceType) {
    //
    // Set choices = new HashSet();
    // choices.addAll(((ChoiceType)parent).getAttributes());
    // choices.addAll(((ChoiceType)extend).getAttributes());
    //
    // type = xmlFactory.createChoiceType(choices);
    // }
    // else if (
    // parent instanceof SequenceType && extend instanceof SequenceType
    // ) {
    //
    // List sequence = new ArrayList();
    //
    // sequence.addAll(((SequenceType)parent).getAttributes());
    // sequence.addAll(((SequenceType)extend).getAttributes());
    //
    // type = xmlFactory.createSequenceType(sequence);
    // }
    // else if (
    // parent instanceof ComplexType && extend instanceof ComplexType
    // ){
    // List elements = new ArrayList();
    // elements.addAll(((ComplexType)parent).getAttributes());
    // elements.addAll(((ComplexType)extend).getAttributes());
    //
    // ComplexType ct = (ComplexType) extend;
    //
    // //JD: this is a bit of a hack, creating type manually (ie wihtout
    // // factory, because we have constructed the schema manually
    // type = new ComplexTypeImpl(
    // ct.getName(),elements,ct.isIdentified(),
    // ct.isNillable().booleanValue(),ct.getRestrictions(),ct,
    // ct.isAbstract()
    // );
    //
    // }
    //
    // return type;
    //
    // }
    /**
     * We can only restrict node if the restricftion is a subtype that used by node.
     *
     * @return restrict, iff restrict.getType() ISA node.getType()
     */
    AttributeDescriptor restrict(AttributeDescriptor node, AttributeDescriptor restrict) {

        if (node.getType() == restrict.getType()) {
            return restrict;
        }
        for (AttributeType /* <?> */ type = restrict.getType();
                type != null;
                type = type.getSuper()) {
            if (node.getType().equals(type)) {
                return restrict;
            }
        }
        throw new IllegalArgumentException("Cannot restrict provided schema");
    }

