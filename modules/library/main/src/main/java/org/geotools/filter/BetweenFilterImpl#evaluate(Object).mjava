    /**
     * Determines whether or not a given feature is 'inside' this filter.
     *
     * @param feature Specified feature to examine.
     * @return Flag confirming whether or not this feature is inside the filter.
     */
    public boolean evaluate(Object feature) {
        if (middleValue == null) {
            return false;
        } else {
            /*Object leftObj = leftValue.getValue(feature);
               Object rightObj = rightValue.getValue(feature);
               Object middleObj = middleValue.getValue(feature);
               //if (leftObj instanceof Number &&
               //middleObj instanceof Number &&
               //rightObj instanceof Number) {
            double left = ((Number) leftObj).doubleValue();
            double right = ((Number) rightObj).doubleValue();
            double mid = ((Number) middleObj).doubleValue();

            return (left <= mid) && (right >= mid);
               */
            Object middleObj = eval(middleValue, feature);
            // evaluate the between wrt the class of the middle object
            Object leftObj = eval(expression1, feature, middleObj.getClass());
            Object rightObj = eval(expression2, feature, middleObj.getClass());

            if (leftObj instanceof Number
                    && middleObj instanceof Number
                    && rightObj instanceof Number) {
                double left = ((Number) leftObj).doubleValue();
                double right = ((Number) rightObj).doubleValue();
                double mid = ((Number) middleObj).doubleValue();

                return (left <= mid) && (right >= mid);
                // instanceof Comparator?  And same object type?

                // this may miss variations on similar classes that actually
                // could be compared, but I think AttributeType parsing may
                // have helped us out before we get here.
            } else if (leftObj.getClass() == middleObj.getClass()
                    && rightObj.getClass() == middleObj.getClass()
                    &&
                    // I don't think we need to check all for comparator
                    // if they are all the same class?
                    leftObj instanceof Comparable) {
                return (((Comparable) leftObj).compareTo(middleObj) <= 0
                        && ((Comparable) middleObj).compareTo(rightObj) <= 0);
            } else {
                String mesg =
                        "Supplied between values are either not "
                                + "compatible or not supported for comparison: "
                                + leftObj
                                + " <= "
                                + middleObj
                                + " <= "
                                + rightObj;
                throw new IllegalArgumentException(mesg);
            }
        }
    }

