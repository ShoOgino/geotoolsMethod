    /**
     * Compares this filter to the specified object. Returns true if the passed in object is the
     * same as this expression. Checks to make sure the expression types are the same as well as the
     * literals.
     *
     * @param obj - the object to compare this ExpressionLiteral against.
     * @return true if specified object is equal to this expression; false otherwise.
     * @task REVISIT: missmatched types now considered not equal. This may be a problem when
     *     comparing Doubles and Integers
     */
    public boolean equals(Object obj) {
        if (obj instanceof LiteralExpressionImpl) {
            LiteralExpressionImpl expLit = (LiteralExpressionImpl) obj;
            // This is a problem.  The Expression with type String of "2.0"
            // should be equals to the Expression with type Integer of "2.0"
            // Same thing with doubles and integers (as noted in the javadocs)

            // null handling
            if (this.literal == null) {
                return expLit.literal == null;
            } else if (expLit.literal == null) {
                return false;
            }

            // direct comparison if same type
            if (getExpressionType(this) == getExpressionType(expLit)) {
                if (this.literal.equals(expLit.literal)) {
                    return true;
                }
            }

            // do the conversion dance
            int expressionType = getExpressionType(this);
            if (expressionType == ExpressionType.LITERAL_GEOMETRY
                    && this.literal instanceof Geometry) {
                return ((Geometry) this.literal).equalsExact(expLit.evaluate(null, Geometry.class));
            } else if (expressionType == ExpressionType.LITERAL_GEOMETRY
                    && this.literal instanceof Envelope) {
                return this.literal.equals(expLit.evaluate(null, Envelope.class));
            } else if (expressionType == ExpressionType.LITERAL_INTEGER) {
                return this.literal.equals(expLit.evaluate(null, Integer.class));
            } else if (expressionType == ExpressionType.LITERAL_STRING) {
                return this.literal.equals(expLit.evaluate(null, String.class));
            } else if (expressionType == ExpressionType.LITERAL_DOUBLE) {
                return this.literal.equals(expLit.evaluate(null, Double.class));
            } else if (expressionType == ExpressionType.LITERAL_LONG) {
                return this.literal.equals(expLit.evaluate(null, Long.class));
            } else {
                // try to convert the other to the current type
                Object other = expLit.evaluate(null, this.literal.getClass());
                if (other != null) {
                    return other.equals(this.literal);
                }
                // converters might be one way, try the opposite
                other = expLit.getValue();
                Object converted = this.evaluate(null, other.getClass());
                if (converted != null) {
                    return converted.equals(other);
                }
                // final attemp with a string to string comparison
                String str1 = this.evaluate(null, String.class);
                String str2 = expLit.evaluate(null, String.class);
                return str1 != null && str2 != null && str1.equals(str2);
            }
        } else if (obj instanceof Literal) {
            // some other Literal implementation like ConstantExpression
            Literal other = (Literal) obj;
            return equals(new LiteralExpressionImpl(other.getValue()));
        } else {
            return false;
        }
    }

