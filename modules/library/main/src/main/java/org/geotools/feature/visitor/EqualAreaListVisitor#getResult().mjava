    public CalcResult getResult() {
        if (binCount == 0 || count == 0) {
            return CalcResult.NULL_RESULT;
        }

        // sort the list
        Collections.sort(items);

        if (binCount > count) { // resize
            binCount = count;
            this.bins = createBinsArray(binCount);
        }

        // algorithm based off "Greedy 2" version in
        // "Equal-area Breaks: A Classification Scheme for Data to Obtain an Evenly-colored
        // Choropleth Map"
        // https://pdfs.semanticscholar.org/151e/8036f6aa4412e7c7923c35bb8dd8113793d3.pdf
        double totalArea = items.stream().mapToDouble(item -> item.area).sum();
        double avgArea = totalArea / binCount;
        List<Comparable> currentBin = new ArrayList<>();
        int binIndex = 0;
        double area = 0;
        for (ValueArea valueArea : items) {
            currentBin.add(valueArea.value);
            area += valueArea.area;
            if (area >= avgArea * (binIndex + 1) && binIndex < binCount - 1) {
                bins[binIndex++] = currentBin;
                currentBin = new ArrayList<>();
            }
        }
        if (currentBin.size() > 0) {
            bins[binIndex] = currentBin;
        } else {
            binIndex--;
        }

        // it is possible that we have created less bin than requested
        // (happens when the number of classes is close to the number of features being classified)
        if (binIndex < binCount - 1) {
            List<Comparable>[] reduced = createBinsArray(binIndex + 1);
            System.arraycopy(bins, 0, reduced, 0, binIndex + 1);
            this.bins = reduced;
        }

        return new AbstractCalcResult() {
            public Object getValue() {
                return bins;
            }
        };
    }

