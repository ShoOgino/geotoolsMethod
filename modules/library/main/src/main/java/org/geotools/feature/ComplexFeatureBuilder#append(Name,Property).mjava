    /**
     * Append a property value to the complex feature under construction and associate it with the
     * name specified.
     *
     * @param name The name of the property you wish to set.
     * @param value The value of the property to append.
     */
    public void append(Name name, Property value) {
        PropertyDescriptor propertyDescriptor = featureType.getDescriptor(name);

        // The 'name' must exist in the type, if not, throw an exception:
        if (propertyDescriptor == null) {
            throw new IllegalArgumentException(
                    String.format(
                            "The name '%s' is not a valid descriptor name for the type '%s'.",
                            name, this.featureType.getName()));
        }

        Class<?> expectedClass = propertyDescriptor.getType().getBinding();
        if (value != null) {
            Class<?> providedClass = value.getType().getBinding();

            // Make sure that the provided class and the expected class match or
            // that the expectedClass is a base class of the providedClass:
            if (!providedClass.equals(expectedClass)
                    && !expectedClass.isAssignableFrom(providedClass)) {
                throw new IllegalArgumentException(
                        String.format(
                                "The value provided contains an object of '%s' but the method expects an object of '%s'.",
                                providedClass, expectedClass));
            }
        } else { // value == null
            if (propertyDescriptor.isNillable()) {
                value = (Property) expectedClass.cast(null);
            } else {
                // NOTE: This could possibly to changed to allow for processing
                // remote xlinks.
                value = (Property) expectedClass.cast(null);
            }
        }

        // At this point the converted value has been set so we must persist it
        // to the object's state:
        ArrayList<Property> valueList;

        if (values.containsKey(name)) {
            valueList = values.get(name);

            // Make sure that the list isn't already at capacity:
            int maxOccurs = propertyDescriptor.getMaxOccurs();
            if (valueList.size() == maxOccurs) {
                throw new IndexOutOfBoundsException(
                        String.format(
                                "You can't add another object with the name of '%s' because you already have the maximum number (%s) allowed by the property descriptor.",
                                name, maxOccurs));
            }
        } else {
            valueList = new ArrayList<>();
            values.put(name, valueList);
        }

        valueList.add(value);
    }

