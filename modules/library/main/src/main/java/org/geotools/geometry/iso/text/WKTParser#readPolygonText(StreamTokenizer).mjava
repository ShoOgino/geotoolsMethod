    /**
     * Creates a <code>SurfaceBoundary</code> using the next token in the stream.
     *
     * @param tokenizer tokenizer over a stream of text in Well-known Text format. The next tokens
     *     must form a &lt;Polygon Text&gt;.
     * @return a <code>Surface</code> specified by the vertices in the stream
     * @throws ParseException if the coordinates used to create the <code>Polygon</code> shell and
     *     holes do not form closed linestrings, or if an unexpected token was encountered.
     * @throws IOException if an I/O error occurs
     */
    private Surface readPolygonText(StreamTokenizer tokenizer) throws IOException, ParseException {
        String nextToken = getNextEmptyOrOpener(tokenizer);
        if (nextToken.equals(EMPTY)) {
            return null;
        }
        Curve curve = readLinearRingText(tokenizer);
        List<OrientableCurve> curveList = Collections.singletonList(curve);
        Ring shell = primitiveFactory.createRing(curveList);
        // Ring shell = readLinearRingText(tokenizer);
        List<Ring> holes = new ArrayList<>();
        nextToken = getNextCloserOrComma(tokenizer);
        while (nextToken.equals(COMMA)) {
            Curve holecurve = readLinearRingText(tokenizer);
            List<OrientableCurve> holeList = Collections.singletonList(holecurve);
            Ring hole = primitiveFactory.createRing(holeList);
            // Ring hole = readLinearRingText(tokenizer);
            holes.add(hole);
            nextToken = getNextCloserOrComma(tokenizer);
        }
        SurfaceBoundary sb = primitiveFactory.createSurfaceBoundary(shell, holes);
        return primitiveFactory.createSurface(sb);
    }

