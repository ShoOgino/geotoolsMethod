    /**
     * Given a full transformation from screen to world and the paint area computes a best guess of
     * the maxium generalization distance that won't make the transformations induced by the
     * generalization visible on screen.
     *
     * <p>In other words, it computes how long a pixel is in the native spatial reference system of
     * the data
     *
     * @param screenToWorld
     * @param paintArea
     * @return
     * @throws TransformException
     */
    public static double[] computeGeneralizationDistances(
            MathTransform screenToWorld, Rectangle paintArea, double pixelDistance)
            throws TransformException {
        try {
            // init the spans with the upper left corner
            double[] spans = getGeneralizationSpans(paintArea.x, paintArea.y, screenToWorld);
            // search over a simple 3x3 grid for higher spans so that we perform a basic sampling of
            // the whole area
            // and we pick the shortest generalization distances
            for (int i = 0; i < 2; i++) {
                for (int j = 0; j < 2; j++) {
                    double[] ns =
                            getGeneralizationSpans(
                                    paintArea.x + paintArea.width * i / 2.0,
                                    paintArea.y + paintArea.height / 2.0,
                                    screenToWorld);
                    if (isFinite(ns[0]) && (ns[0] < spans[0] || !isFinite(spans[0]))) {
                        spans[0] = ns[0];
                    }
                    if (isFinite(ns[1]) && (ns[1] < spans[1] || !isFinite(spans[1]))) {
                        spans[1] = ns[1];
                    }
                }
            }
            if (!isFinite(spans[0])) {
                spans[0] = 0;
            }
            if (!isFinite(spans[1])) {
                spans[1] = 0;
            }
            spans[0] *= pixelDistance;
            spans[1] *= pixelDistance;
            return spans;
        } catch (TransformException e) {
            // if we can't transform we went way out of the area of definition for the transform ->
            // don't generalize
            return new double[] {0, 0};
        }
    }

