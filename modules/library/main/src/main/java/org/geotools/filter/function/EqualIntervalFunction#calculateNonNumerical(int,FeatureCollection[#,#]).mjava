    @SuppressWarnings("unchecked")
    private RangedClassifier calculateNonNumerical(
            int classNum, FeatureCollection<?, ?> featureCollection) throws IOException {
        // obtain of list of unique values, so we can enumerate
        UniqueVisitor uniqueVisit = new UniqueVisitor(getParameters().get(0));
        featureCollection.accepts(uniqueVisit, new NullProgressListener());
        List result = uniqueVisit.getResult().toList();
        // sort the results and put them in an array
        Collections.sort(result);

        Comparable[] values = (Comparable[]) result.toArray(new Comparable[result.size()]);

        // size arrays
        classNum = Math.min(classNum, values.length);
        Comparable[] localMin = new Comparable[classNum];
        Comparable[] localMax = new Comparable[classNum];

        // we have 2 options here:
        // 1. break apart by numeric value: (aaa, aab, aac, bbb) --> [aaa, aab, aac], [bbb]
        // 2. break apart by item count:                         --> [aaa, aab], [aac, bbb]

        // this code currently implements option #2 (this is a quantile, why don't we use their code
        // instead)

        // calculate number of items to put in each of the larger bins
        int binPop = (int) Math.ceil((double) values.length / classNum);
        // determine index of bin where the next bin has one less item
        int lastBigBin = values.length % classNum;
        if (lastBigBin == 0) lastBigBin = classNum;
        else lastBigBin--;

        int itemIndex = 0;
        // for each bin
        for (int binIndex = 0; binIndex < classNum; binIndex++) {
            // store min
            if (binIndex < localMin.length)
                localMin[binIndex] =
                        (itemIndex < values.length ? values[itemIndex] : values[values.length - 1]);
            else
                localMin[localMin.length - 1] =
                        (itemIndex < values.length ? values[itemIndex] : values[values.length - 1]);
            itemIndex += binPop;
            // store max
            if (binIndex == classNum - 1) {
                if (binIndex < localMax.length)
                    localMax[binIndex] =
                            (itemIndex < values.length
                                    ? values[itemIndex]
                                    : values[values.length - 1]);
                else
                    localMax[localMax.length - 1] =
                            (itemIndex < values.length
                                    ? values[itemIndex]
                                    : values[values.length - 1]);
            } else {
                if (binIndex < localMax.length)
                    localMax[binIndex] =
                            (itemIndex + 1 < values.length
                                    ? values[itemIndex + 1]
                                    : values[values.length - 1]);
                else
                    localMax[localMax.length - 1] =
                            (itemIndex + 1 < values.length
                                    ? values[itemIndex + 1]
                                    : values[values.length - 1]);
            }
            if (lastBigBin == binIndex) binPop--; // decrease the number of items in a bin for the
            // next iteration
        }
        return new RangedClassifier(localMin, localMax);
    }

