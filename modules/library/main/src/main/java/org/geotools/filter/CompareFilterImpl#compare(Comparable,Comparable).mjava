    /**
     * Subclass convenience method which compares to instances of comparables in a pretty lax way,
     * converting types among String, Number, Double when appropriate.
     *
     * @return same contract as {@link Comparable#compareTo(java.lang.Object)}.
     */
    protected int compare(Comparable leftObj, Comparable rightObj) {
        // implements a lax compare, doing some back flips for numbers
        if (!(leftObj instanceof Number && rightObj instanceof Number)) {
            // check for case of one number one string
            if (!(leftObj.getClass() == rightObj.getClass())) {
                // special handling for dates, as we can do meaningful comparisons among
                // the class hierarchy
                if (leftObj instanceof Date || rightObj instanceof Date) {
                    // they do compare fine if they are both dates, otherwise we need to convert
                    if (!(leftObj instanceof Date)) {
                        leftObj = Converters.convert(leftObj, Date.class);
                    }
                    if (!(rightObj instanceof Date)) {
                        rightObj = Converters.convert(rightObj, Date.class);
                    }
                    // if conversion failed fall back on string comparison
                    if (leftObj == null || rightObj == null) {
                        leftObj = leftObj.toString();
                        rightObj = rightObj.toString();
                    }
                } else if (leftObj instanceof Number && (rightObj.getClass() == String.class)) {
                    try {
                        rightObj = new Double(Double.parseDouble((String) rightObj));
                        leftObj = new Double(((Number) leftObj).doubleValue());
                    } catch (Exception e) {
                        leftObj = leftObj.toString();
                        rightObj = rightObj.toString();
                    }
                } else if ((leftObj.getClass() == String.class) && rightObj instanceof Number) {
                    try {
                        leftObj = new Double(Double.parseDouble((String) leftObj));
                        rightObj = new Double(((Number) rightObj).doubleValue());
                    } catch (Exception e) {
                        leftObj = leftObj.toString();
                        rightObj = rightObj.toString();
                    }
                } else {
                    leftObj = leftObj.toString();
                    rightObj = rightObj.toString();
                }
            } else if (leftObj instanceof String && rightObj instanceof String) {
                // Check for case of strings that can both be converted to Numbers
                try {
                    leftObj = new Double(Double.parseDouble((String) leftObj));
                    rightObj = new Double(Double.parseDouble((String) rightObj));
                } catch (Exception e) {
                    leftObj = leftObj.toString();
                    rightObj = rightObj.toString();
                }
            }
            return leftObj.compareTo(rightObj);
        } else {
            // both numbers, make double
            double left = ((Number) leftObj).doubleValue();
            double right = ((Number) rightObj).doubleValue();
            return left > right ? 1 : (left == right ? 0 : -1);
        }
    }

