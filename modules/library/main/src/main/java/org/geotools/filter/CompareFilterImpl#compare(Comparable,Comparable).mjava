    /**
     * Subclass convenience method which compares to instances of comparables
     * in a pretty lax way, converting types among String, Number, Double when 
     * appropriate.
     * 
     * @return same contract as {@link Comparable#compareTo(java.lang.Object)}.
     */
    protected int compare (Comparable leftObj, Comparable rightObj) {
    	//implements a lax compare, doing some back flips for numbers
    	if (!(leftObj instanceof Number && rightObj instanceof Number)) 
    	{	
    		//check for case of one number one string
    		if (!(leftObj.getClass() == rightObj.getClass()))  
    	    {
    		    // special handling for dates, as we can do meaningful comparisons among
    		    // the class hierarchy 
    		    if(leftObj instanceof Date || rightObj instanceof Date) {
    		        // they do compare fine if they are both dates, otherwise we need to convert
    		        if(!(leftObj instanceof Date)) {
    		            leftObj = Converters.convert(leftObj, Date.class);
    		        }
                    if(!(rightObj instanceof Date)) {
                        rightObj = Converters.convert(rightObj, Date.class);
                    }
                    // if conversion failed fall back on string comparison
                    if(leftObj == null || rightObj == null) {
                        leftObj = leftObj.toString();
                        rightObj = rightObj.toString();
                    }
   		        } else if ( leftObj instanceof Number && (rightObj.getClass() == String.class) )
    	    	{
    	    		try{
    	    			rightObj = new Double( Double.parseDouble( (String) rightObj ));
    	    			leftObj  = new Double(  ((Number) leftObj).doubleValue() );
    	    		}
    	    		catch(Exception e)
    				{
    			    	leftObj = leftObj.toString();
    			    	rightObj = rightObj.toString();
    				}
    	    	}
    	    	else if ( (leftObj.getClass() == String.class) && rightObj instanceof Number )
    	    	{
    	    		try{
    	    			leftObj = new Double( Double.parseDouble( (String) leftObj ) );
    	    			rightObj  = new Double(  ((Number) rightObj).doubleValue() );
    	    		}
    	    		catch(Exception e)
    				{
    			    	leftObj = leftObj.toString();
    			    	rightObj = rightObj.toString();
    				}
    	    	}
    	    	else
    	    	{
    	    		leftObj = leftObj.toString();
    	    		rightObj = rightObj.toString();
    	    	}
    	    }
    		return leftObj.compareTo(rightObj);
    	} else {
    		//both numbers, make double
    	    double left = ((Number) leftObj).doubleValue();
    	    double right = ((Number) rightObj).doubleValue();
    	    return left > right ? 1 : (left == right ? 0 : -1);  
    	}
    }

