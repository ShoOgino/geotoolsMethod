    /**
     * Subclass convenience method which compares to instances of comparables
     * in a pretty lax way, converting types among String, Number, Double when 
     * appropriate.
     * 
     * @return same contract as {@link Comparable#compareTo(java.lang.Object)}.
     */
    protected int compare (Comparable leftObj, Comparable rightObj) {
    	//implements a lax compare, doing some back flips for numbers
    	if (!(leftObj instanceof Number && rightObj instanceof Number)) 
    	{	
    		//check for case of one number one string
    		if (!(leftObj.getClass() == rightObj.getClass()))  
    	    {
        		//differnt classes, if numbers lets try and match them up
    	    	if ( leftObj instanceof Number && (rightObj.getClass() == String.class) )
    	    	{
    	    		try{
    	    			rightObj = new Double( Double.parseDouble( (String) rightObj ));
    	    			leftObj  = new Double(  ((Number) leftObj).doubleValue() );
    	    		}
    	    		catch(Exception e)
    				{
    			    	leftObj = leftObj.toString();
    			    	rightObj = rightObj.toString();
    				}
    	    	}
    	    	else if ( (leftObj.getClass() == String.class) && rightObj instanceof Number )
    	    	{
    	    		try{
    	    			leftObj = new Double( Double.parseDouble( (String) leftObj ) );
    	    			rightObj  = new Double(  ((Number) rightObj).doubleValue() );
    	    		}
    	    		catch(Exception e)
    				{
    			    	leftObj = leftObj.toString();
    			    	rightObj = rightObj.toString();
    				}
    	    	}
    	    	else
    	    	{
    	    		leftObj = leftObj.toString();
    	    		rightObj = rightObj.toString();
    	    	}
    	    }
    		return leftObj.compareTo(rightObj);
    	} else {
    		//both numbers, make double
    	    double left = ((Number) leftObj).doubleValue();
    	    double right = ((Number) rightObj).doubleValue();
    	    return left > right ? 1 : (left == right ? 0 : -1);  
    	}
    }

