    public <T> T evaluate(Object object, Class<T> context) {
        // initialize the lookup data structures only once and in a thread safe way please
        if (interpPoints == null) {
            synchronized (this) {
                if (interpPoints == null) {
                    initialize();
                }
            }
        }

        if (method == Method.NUMERIC && Color.class.isAssignableFrom(context)) {
            throw new IllegalArgumentException(
                    "Trying to evaluate the function as Color but the method parameter is set as NUMERIC");
        }

        if (method == Method.COLOR && !Color.class.isAssignableFrom(context)) {
            throw new IllegalArgumentException(
                    "Trying to evaluate the function as "
                            + context.getSimpleName()
                            + " but the method parameter is set as COLOR");
        }

        /**
         * Lookup value should be either the name of a feature property which can be evaluated to a
         * Double or the string "RasterData" (case-insensitive) indicating use of this function in a
         * raster colormap.
         */
        final Expression lookup = parameters.get(0);
        Double lookupValue = null;

        /*
         * TODO: is this the correct way to handle the rasterdata option ?
         */
        String lookupString = lookup.evaluate(object, String.class);
        if (lookupString == null) {
            return null;
        }
        if (lookupString.equalsIgnoreCase(RASTER_DATA)) {
            lookupValue = ((Number) object).doubleValue();
        } else {
            lookupValue = Double.valueOf(lookupString);
        }

        /** Degenerate case: a single interpolation point. Evaluate it directly. */
        if (interpPoints.size() == 1) {
            return parameters.get(2).evaluate(object, context);
        }

        final int segment = findSegment(lookupValue, object);
        if (segment <= 0) {
            // Data below the range of the interpolation points
            return interpPoints.get(0).getValue(object, context);
        } else if (segment >= interpPoints.size()) {
            // Data above the range of the interpolation points
            return interpPoints.get(interpPoints.size() - 1).getValue(object, context);
        }

        /**
         * The lookup value is within or above the range of the interpolation points - perform the
         * requested type of interpolation
         */
        switch (mode) {
            case COSINE:
                return cosineInterpolate(lookupValue, object, segment, context);

            case CUBIC:
                return cubicInterpolate(lookupValue, object, segment, context);

            case LINEAR:
            default:
                return linearInterpolate(lookupValue, object, segment, context);
        }
    }

