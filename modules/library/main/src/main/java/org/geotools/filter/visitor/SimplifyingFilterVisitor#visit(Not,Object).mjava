    public Object visit(Not filter, Object extraData) {
        FilterFactory2 ff = getFactory(extraData);
        Filter inner = filter.getFilter();
		if (inner instanceof Not) {
            // simplify out double negation
            Not innerNot = (Not) inner;
            return innerNot.getFilter().accept(this, extraData);
        } else if (inner instanceof And) {
            // De Morgan
            And and = (And) inner;
            List<Filter> children = and.getChildren();
            List<Filter> negatedChildren = new ArrayList<>();
            for (Filter child : children) {
                negatedChildren.add((Filter) ff.not(child).accept(this, extraData));
            }
            return ff.or(negatedChildren);
        } else if (inner instanceof Or) {
            // De Morgan
            Or or = (Or) inner;
            List<Filter> children = or.getChildren();
            List<Filter> negatedChildren = new ArrayList<>();
            for (Filter child : children) {
                negatedChildren.add((Filter) ff.not(child).accept(this, extraData));
            }
            return ff.and(negatedChildren);
        } else if(isSimpleFeature()) {
            Filter simplified = (Filter) inner.accept(this, extraData);
            if(simplified == Filter.INCLUDE) {
                return Filter.EXCLUDE;
            } else if(simplified == Filter.EXCLUDE) {
                return Filter.INCLUDE;
            } else if (simplified instanceof PropertyIsBetween) {
                PropertyIsBetween pb = (PropertyIsBetween) simplified;
                Filter lt = ff.less(pb.getExpression(), pb.getLowerBoundary());
                Filter gt = ff.greater(pb.getExpression(), pb.getUpperBoundary());
                return ff.or(lt, gt);
            } else if (simplified instanceof PropertyIsEqualTo) {
                PropertyIsEqualTo pe = (PropertyIsEqualTo) simplified;
                return ff.notEqual(pe.getExpression1(), pe.getExpression2(), pe.isMatchingCase());
            } else if (simplified instanceof PropertyIsNotEqualTo) {
                PropertyIsNotEqualTo pe = (PropertyIsNotEqualTo) simplified;
                return ff.equal(pe.getExpression1(), pe.getExpression2(), pe.isMatchingCase());
            } else if (simplified instanceof PropertyIsGreaterThan) {
                PropertyIsGreaterThan pg = (PropertyIsGreaterThan) simplified;
                return ff.lessOrEqual(pg.getExpression1(), pg.getExpression2(), pg.isMatchingCase());
            } else if (simplified instanceof PropertyIsGreaterThanOrEqualTo) {
                PropertyIsGreaterThanOrEqualTo pg = (PropertyIsGreaterThanOrEqualTo) simplified;
                return ff.less(pg.getExpression1(), pg.getExpression2(), pg.isMatchingCase());
            } else if (simplified instanceof PropertyIsLessThan) {
                PropertyIsLessThan pl = (PropertyIsLessThan) simplified;
                return ff.greaterOrEqual(pl.getExpression1(), pl.getExpression2(), pl.isMatchingCase());
            } else if (simplified instanceof PropertyIsLessThanOrEqualTo) {
                PropertyIsLessThanOrEqualTo pl = (PropertyIsLessThanOrEqualTo) simplified;
                return ff.greater(pl.getExpression1(), pl.getExpression2(), pl.isMatchingCase());
            }
        }
        // fallback, cannot do anything "intelligent"
        return super.visit(filter, extraData);
    }

