    /**
     * Creates a new filter by appending a newFilter to a baseFilter.
     * <p>
     * This works in a smooth fashion if the baseFilter is a BinaryLogicalOperator
     * (And or Or). The created filter will be a combination of the baseFilter children with the
     * newFilter appended on the end.
     * <p>
     * Otherwise this method will:
     * <il>
     * <li>if createOr is true: combine the two filters using Or</li>
     * <li>if createOr is false: combine the two filters using And</li>
     * </ul>
     * filter to append newFilter to the end of baseFilter.
     * @param baseFilter
     * @param newFilter
     * @param createOr True to append with an Or filter if needed, false to append with And
     * @return the combined filters
     */
     public Filter append(Filter baseFilter, Filter newFilter, boolean createOr) {
        //no need to create a grouping filter if none currently exists
        if (baseFilter == null){
            return newFilter;
        }
        //similarly, just return the existing one if the new one is null
        if (newFilter == null){
            return baseFilter;
        }
        if (baseFilter instanceof And){
            And and = (And) baseFilter;
            List<Filter> children = new ArrayList<Filter>( and.getChildren() );
            children.add(newFilter);
            return ff.and( children );            
        }
        if (baseFilter instanceof Or){
            Or or = (Or) baseFilter;
            List<Filter> children = new ArrayList<Filter>( or.getChildren() );
            children.add(newFilter);
            return ff.or( children );            
        }
        if (createOr){
            return ff.or( baseFilter, newFilter );
        }
        else {
            return ff.and( baseFilter, newFilter );            
        }
    }

