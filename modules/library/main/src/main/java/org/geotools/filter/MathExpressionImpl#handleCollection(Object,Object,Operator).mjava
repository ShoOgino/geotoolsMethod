    protected Object handleCollection(Object value1, Object value2, Operator operator) {
        // case 1, both are collections
        if (value1 instanceof Collection && value2 instanceof Collection) {
            Collection<Number> result = new ArrayList<Number>();
            // by default first list is set to bigger
            // second is set to smaller
            List<Number> biggerList =
                    (List)
                            ((Collection) value1)
                                    .stream()
                                    .map(v -> Converters.convert(v, Number.class))
                                    .collect(Collectors.toList());
            List<Number> smallerList =
                    (List)
                            ((Collection) value2)
                                    .stream()
                                    .map(v -> Converters.convert(v, Number.class))
                                    .collect(Collectors.toList());
            // swap if second is bigger
            if (((Collection) value2).size() > ((Collection) value1).size()) {
                biggerList =
                        (List)
                                ((Collection) value2)
                                        .stream()
                                        .map(v -> Converters.convert(v, Number.class))
                                        .collect(Collectors.toList());
                smallerList =
                        (List)
                                ((Collection) value1)
                                        .stream()
                                        .map(v -> Converters.convert(v, Number.class))
                                        .collect(Collectors.toList());
            }

            // loop over bigger list
            // multiply with correspdoning position in other list
            // store in result
            // store unchanged items that dont have corresponding number in other list
            for (int i = 0; i < biggerList.size(); i++) {
                if (i < smallerList.size())
                    result.add(
                            doArithmeticOperation(
                                    biggerList.get(i).doubleValue(),
                                    smallerList.get(i).doubleValue(),
                                    operator));
                else result.add(biggerList.get(i).doubleValue());
            }

            return result;

        } else if (value1 instanceof Collection) {
            // only first is collection
            List<Number> biggerList =
                    (List)
                            ((Collection) value1)
                                    .stream()
                                    .map(v -> Converters.convert(v, Number.class))
                                    .collect(Collectors.toList());
            final Number scalar = Filters.number(value2);
            return biggerList
                    .stream()
                    .map(
                            n ->
                                    doArithmeticOperation(
                                            n.doubleValue(), scalar.doubleValue(), operator))
                    .collect(Collectors.toList());
        } else {
            // only first is collection
            List<Number> biggerList =
                    (List)
                            ((Collection) value2)
                                    .stream()
                                    .map(v -> Converters.convert(v, Number.class))
                                    .collect(Collectors.toList());
            final Number scalar = Filters.number(value1);
            return biggerList
                    .stream()
                    .map(
                            n ->
                                    doArithmeticOperation(
                                            n.doubleValue(), scalar.doubleValue(), operator))
                    .collect(Collectors.toList());
        }
    }

