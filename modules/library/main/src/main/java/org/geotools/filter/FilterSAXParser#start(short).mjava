    /**
     * Handles all incoming generic string 'messages,' including a message to
     * create the filter, based on the XML tag that represents the start of
     * the filter.
     *
     * @param filterType The string from the SAX filter.
     *
     * @throws IllegalFilterException Filter is illegal.
     */
    public void start(short filterType) throws IllegalFilterException {
        LOGGER.finest("starting filter type " + filterType);

        if ((filterType == AbstractFilter.FID) && !curState.equals("fid")) {
            LOGGER.finer("creating the FID filter");
            curFilter = ff.createFidFilter();
        } else if (AbstractFilter.isGeometryDistanceFilter(filterType)) {
            curFilter = ff.createGeometryDistanceFilter(filterType);
        } else if (AbstractFilter.isGeometryFilter(filterType)) {
            curFilter = ff.createGeometryFilter(filterType);
        } else if (filterType == AbstractFilter.BETWEEN) {
            curFilter = ff.createBetweenFilter();
        } else if (filterType == AbstractFilter.NULL) {
            curFilter = ff.createNullFilter();
        } else if (filterType == AbstractFilter.LIKE) {
            curFilter = ff.createLikeFilter();
        } else if (AbstractFilter.isCompareFilter(filterType)) {
            curFilter = ff.createCompareFilter(filterType);
        } else {
            throw new IllegalFilterException(
                "Attempted to start a new filter with invalid type: "
                + filterType);
        }

        curState = setInitialState(filterType);
        this.filterType = filterType;

        attributes = new HashMap();
    }

