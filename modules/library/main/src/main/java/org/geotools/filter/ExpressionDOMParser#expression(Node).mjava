    /**
     * parses an expression for a filter.
     *
     * @param root the root node to parse, should be an filter expression.
     * @return the geotools representation of the expression held in the node.
     */
    public Expression expression(Node root) {
        LOGGER.finer("parsingExpression " + root.getLocalName());

        // NodeList children = root.getChildNodes();
        // LOGGER.finest("children "+children);
        if ((root == null) || (root.getNodeType() != Node.ELEMENT_NODE)) {
            LOGGER.finer("bad node input ");

            return null;
        }

        LOGGER.finer("processing root " + root.getLocalName());

        Node child = root;

        String childName =
                (child.getLocalName() != null) ? child.getLocalName() : child.getNodeName();

        if (childName.indexOf(':') != -1) {
            // the DOM parser wasnt properly set to handle namespaces...
            childName = childName.substring(childName.indexOf(':') + 1);
        }

        if (childName.equalsIgnoreCase("Literal")) {
            LOGGER.finer("processing literal " + child);

            NodeList kidList = child.getChildNodes();
            LOGGER.finest("literal elements (" + kidList.getLength() + ") " + kidList.toString());

            for (int i = 0; i < kidList.getLength(); i++) {
                Node kid = kidList.item(i);
                LOGGER.finest("kid " + i + " " + kid);

                if (kid == null) {
                    LOGGER.finest("Skipping ");

                    continue;
                }

                if (kid.getNodeValue() == null) {
                    /* it might be a gml string so we need to convert it into
                     * a geometry this is a bit tricky since our standard
                     * gml parser is SAX based and we're a DOM here.
                     */
                    LOGGER.finer(
                            "node " + kid.getNodeValue() + " namespace " + kid.getNamespaceURI());
                    LOGGER.fine("a literal gml string?");

                    try {
                        Geometry geom = parseGML(kid);

                        if (geom != null) {
                            LOGGER.finer("built a " + geom.getGeometryType() + " from gml");
                            LOGGER.finer("\tpoints: " + geom.getNumPoints());
                        } else {
                            LOGGER.finer("got a null geometry back from gml parser");
                        }

                        return ff.literal(geom);
                    } catch (IllegalFilterException ife) {
                        LOGGER.warning("Problem building GML/JTS object: " + ife);
                    }

                    return null;
                }

                // CDATA shouldn't be interpretted
                if (kid.getNodeType() != Node.CDATA_SECTION_NODE
                        && kid.getNodeValue().trim().length() == 0) {
                    LOGGER.finest("empty text element");

                    continue;
                }

                // debuging only

                /*switch(kid.getNodeType()){
                case Node.ELEMENT_NODE:
                    LOGGER.finer("element :"+kid);
                    break;
                case Node.TEXT_NODE:
                    LOGGER.finer("text :"+kid);
                    break;
                case Node.ATTRIBUTE_NODE:
                    LOGGER.finer("Attribute :"+kid);
                    break;
                case Node.CDATA_SECTION_NODE:
                    LOGGER.finer("Cdata :"+kid);
                    break;
                case Node.COMMENT_NODE:
                    LOGGER.finer("comment :"+kid);
                    break;
                } */
                String nodeValue = kid.getNodeValue();
                LOGGER.finer("processing " + nodeValue);

                try {
                    // always store internal values as strings.  We might lose info otherwise.
                    return ff.literal(nodeValue);
                } catch (IllegalFilterException ife) {
                    LOGGER.finer("Unable to build expression " + ife);
                    return null;
                }
            }
            // creates an empty literal expression if there is nothing inside the literal
            return ff.literal("");
        }

        if (childName.equalsIgnoreCase("add")) {
            try {
                LOGGER.fine("processing an Add");

                // Node left = null;
                // Node right = null;
                Node value = child.getFirstChild();

                while (value.getNodeType() != Node.ELEMENT_NODE) {
                    value = value.getNextSibling();
                }

                LOGGER.finer("add left value -> " + value + "<-");
                Expression left = parseExpression(value);
                value = value.getNextSibling();

                while (value.getNodeType() != Node.ELEMENT_NODE) {
                    value = value.getNextSibling();
                }

                LOGGER.finer("add right value -> " + value + "<-");
                Expression right = parseExpression(value);

                return ff.add(left, right);
            } catch (IllegalFilterException ife) {
                LOGGER.warning("Unable to build expression " + ife);
                return null;
            }
        }

        if (childName.equalsIgnoreCase("sub")) {
            try {
                // NodeList kids = child.getChildNodes();
                Node value = child.getFirstChild();

                while (value.getNodeType() != Node.ELEMENT_NODE) {
                    value = value.getNextSibling();
                }
                LOGGER.finer("add left value -> " + value + "<-");
                Expression left = parseExpression(value);
                value = value.getNextSibling();

                while (value.getNodeType() != Node.ELEMENT_NODE) {
                    value = value.getNextSibling();
                }

                LOGGER.finer("add right value -> " + value + "<-");
                Expression right = parseExpression(value);

                return ff.subtract(left, right);
            } catch (IllegalFilterException ife) {
                LOGGER.warning("Unable to build expression " + ife);

                return null;
            }
        }

        if (childName.equalsIgnoreCase("mul")) {
            try {
                // NodeList kids = child.getChildNodes();
                Node value = child.getFirstChild();

                while (value.getNodeType() != Node.ELEMENT_NODE) {
                    value = value.getNextSibling();
                }

                LOGGER.finer("add left value -> " + value + "<-");
                Expression left = parseExpression(value);
                value = value.getNextSibling();

                while (value.getNodeType() != Node.ELEMENT_NODE) {
                    value = value.getNextSibling();
                }

                LOGGER.finer("add right value -> " + value + "<-");
                Expression right = parseExpression(value);

                return ff.multiply(left, right);
            } catch (IllegalFilterException ife) {
                LOGGER.warning("Unable to build expression " + ife);

                return null;
            }
        }

        if (childName.equalsIgnoreCase("div")) {
            try {
                Node value = child.getFirstChild();

                while (value.getNodeType() != Node.ELEMENT_NODE) {
                    value = value.getNextSibling();
                }

                LOGGER.finer("add left value -> " + value + "<-");
                Expression left = parseExpression(value);
                value = value.getNextSibling();

                while (value.getNodeType() != Node.ELEMENT_NODE) {
                    value = value.getNextSibling();
                }

                LOGGER.finer("add right value -> " + value + "<-");
                Expression right = parseExpression(value);

                return ff.divide(left, right);
            } catch (IllegalFilterException ife) {
                LOGGER.warning("Unable to build expression " + ife);

                return null;
            }
        }

        if (childName.equalsIgnoreCase("PropertyName")) {
            try {
                // JD: trim whitespace here
                String value = child.getFirstChild().getNodeValue();
                value = value != null ? value.trim() : value;
                PropertyName attribute = ff.property(value, getNameSpaces(root));

                //                attribute.setAttributePath(child.getFirstChild().getNodeValue());
                return attribute;
            } catch (IllegalFilterException ife) {
                LOGGER.warning("Unable to build expression: " + ife);

                return null;
            }
        }

        if (childName.equalsIgnoreCase("Function")) {
            Element param = (Element) child;

            NamedNodeMap map = param.getAttributes();
            String funcName = null;

            for (int k = 0; k < map.getLength(); k++) {
                String res = map.item(k).getNodeValue();
                String name = map.item(k).getLocalName();

                if (name == null) {
                    name = map.item(k).getNodeName();
                }
                if (name.indexOf(':') != -1) {
                    // the DOM parser was not properly set to handle namespaces...
                    name = name.substring(name.indexOf(':') + 1);
                }

                LOGGER.fine("attribute " + name + " with value of " + res);

                if (name.equalsIgnoreCase("name")) {
                    funcName = res;
                }
            }

            if (funcName == null) {
                LOGGER.severe("failed to find a function name in " + child);
                return null;
            }

            ArrayList<Expression> args = new ArrayList<Expression>();
            Node value = child.getFirstChild();

            ARGS:
            while (value != null) {
                while (value.getNodeType() != Node.ELEMENT_NODE) {
                    value = value.getNextSibling();
                    if (value == null) break ARGS;
                }
                args.add(parseExpression(value));
                value = value.getNextSibling();
            }
            Expression[] array = args.toArray(new Expression[0]);
            return ff.function(funcName, array);
        }

        if (child.getNodeType() == Node.TEXT_NODE) {
            LOGGER.finer("processing a text node " + root.getNodeValue());

            String nodeValue = root.getNodeValue();
            LOGGER.finer("Text name " + nodeValue);

            // see if it's an int
            try {
                try {
                    Integer intLiteral = Integer.valueOf(nodeValue);

                    return ff.literal(intLiteral);
                } catch (NumberFormatException e) {
                    /* really empty */
                }

                try {
                    Double doubleLit = new Double(nodeValue);

                    return ff.literal(doubleLit);
                } catch (NumberFormatException e) {
                    /* really empty */
                }

                return ff.literal(nodeValue);
            } catch (IllegalFilterException ife) {
                LOGGER.finer("Unable to build expression " + ife);
            }
        }

        return null;
    }

