    private RangedClassifier calculateNumericalPercentages(
            int classNum, Comparable globalMin, Comparable globalMax) {
        // handle constant value case
        if (globalMax.equals(globalMin)) {
            return new RangedClassifier(new Comparable[] {globalMin}, new Comparable[] {globalMax});
        }

        double slotWidth =
                (((Number) globalMax).doubleValue() - ((Number) globalMin).doubleValue())
                        / classNum;
        // size arrays
        Comparable[] localMin = new Comparable[classNum];
        Comparable[] localMax = new Comparable[classNum];
        for (int i = 0; i < classNum; i++) {
            // calculate the min + max values
            localMin[i] = Double.valueOf(((Number) globalMin).doubleValue() + (i * slotWidth));
            localMax[i] =
                    Double.valueOf(
                            ((Number) globalMax).doubleValue() - ((classNum - i - 1) * slotWidth));
            // determine number of decimal places to allow
            int decPlaces = decimalPlaces(slotWidth);
            // clean up truncation error
            if (decPlaces > -1) {
                localMin[i] =
                        Double.valueOf(round(((Number) localMin[i]).doubleValue(), decPlaces));
                localMax[i] =
                        Double.valueOf(round(((Number) localMax[i]).doubleValue(), decPlaces));
            }

            if (i == 0) {
                // ensure first min is less than or equal to globalMin
                if (localMin[i].compareTo(Double.valueOf(((Number) globalMin).doubleValue())) < 0)
                    localMin[i] =
                            Double.valueOf(
                                    fixRound(
                                            ((Number) localMin[i]).doubleValue(),
                                            decPlaces,
                                            false));
            } else if (i == classNum - 1) {
                // ensure last max is greater than or equal to globalMax
                if (localMax[i].compareTo(Double.valueOf(((Number) globalMax).doubleValue())) > 0)
                    localMax[i] =
                            Double.valueOf(
                                    fixRound(
                                            ((Number) localMax[i]).doubleValue(), decPlaces, true));
            }
            // synchronize min with previous max
            if ((i != 0) && (!localMin[i].equals(localMax[i - 1]))) {
                localMin[i] = localMax[i - 1];
            }
        }
        return new RangedClassifier(localMin, localMax);
    }

