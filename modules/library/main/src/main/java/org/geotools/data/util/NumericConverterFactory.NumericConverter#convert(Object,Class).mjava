        public Object convert(Object source, Class target) throws Exception {
            target = primitiveToWrapperClass(target);
            if (source instanceof Number) {
                Number s = (Number) source;

                // integral
                if (Long.class.equals(target)) {
                    return Long.valueOf(s.longValue());
                }
                if (Integer.class.equals(target)) {
                    return Integer.valueOf(s.intValue());
                }
                if (Short.class.equals(target)) {
                    return Short.valueOf(s.shortValue());
                }
                if (Byte.class.equals(target)) {
                    return Byte.valueOf(s.byteValue());
                }
                if (BigInteger.class.equals(target)) {
                    return BigInteger.valueOf(s.longValue());
                }

                // floating point
                // JD: we use the string reprensentation to avoid coordinate
                // drift due to precision issues, there could be some
                // performance issues with this.
                if (Double.class.equals(target)) {
                    return new Double(s.toString());
                }
                if (Float.class.equals(target)) {
                    return new Float(s.toString());
                }
                if (BigDecimal.class.equals(target)) {
                    return new BigDecimal(s.toString());
                }

                if (Number.class.equals(target)) {
                    try {
                        return Integer.valueOf(s.toString());
                    } catch (Exception e) {
                    }

                    try {
                        return new BigInteger(s.toString());
                    } catch (Exception e) {
                    }

                    try {
                        return new Double(s.toString());
                    } catch (Exception e) {
                    }

                    try {
                        return new BigDecimal(s.toString());
                    } catch (Exception e) {
                    }
                }
            } else if (source instanceof String) {
                String s = (String) source;
                // ensure we trim any space off the string
                s = s.trim();

                String integral = toIntegral(s);

                // floating point
                if (Double.class.equals(target)) {
                    return new Double(s);
                }
                if (Float.class.equals(target)) {
                    return new Float(s);
                }
                if (BigDecimal.class.equals(target)) {
                    return new BigDecimal(s);
                }

                // textual
                if (Long.class.equals(target)) {
                    return Long.valueOf(integral);
                }
                if (Integer.class.equals(target)) {
                    return Integer.valueOf(integral);
                }
                if (Short.class.equals(target)) {
                    return Short.valueOf(integral);
                }
                if (Byte.class.equals(target)) {
                    return Byte.valueOf(integral);
                }
                if (BigInteger.class.equals(target)) {
                    return new BigInteger(integral);
                }

                // fallback. If you ask for Number, you get our 'best guess'
                if (Number.class.equals(target)) {
                    if (integral.equals(s)) {
                        // we think this is an integer of some sort
                        try {
                            return Integer.valueOf(integral);
                        } catch (Exception e) {
                        }

                        try {
                            return new BigInteger(integral);
                        } catch (Exception e) {
                        }
                    }
                    try {
                        return new Double(s);
                    } catch (Exception e) {
                    }

                    try {
                        return new BigDecimal(s);
                    } catch (Exception e) {
                    }
                }
            }
            // nothing matched. Return null.
            return null;
        }

