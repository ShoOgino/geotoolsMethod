    /**
     * The {@link #polygonClip(LinearRing)} routine can generate invalid rings fully on top of the
     * clipping area borders (with no inside). Do a quick check that does not involve an expensive
     * isValid() call
     *
     * @return The ring, or null if the ring was not valid
     */
    private LinearRing cleanupRings(LinearRing ring) {
        if (ring == null || ring.isEmpty()) {
            return null;
        }

        final CoordinateSequence cs = ring.getCoordinateSequence();
        double px = cs.getX(0);
        double py = cs.getY(0);
        boolean fullyOnBorders = true;
        for (int i = 1; i < cs.size() && fullyOnBorders; i++) {
            double x = cs.getX(i);
            double y = cs.getY(i);
            // check if the current segment lies on the bbox side fully
            if ((x == px && (x == xmin || x == xmax)) || (y == py && (y == ymin || y == ymax))) {
                px = x;
                py = y;
            } else {
                fullyOnBorders = false;
            }
        }
        // all sides are sitting on the bbox borders, this is the degenerate case
        // we are trying to filter out
        if (fullyOnBorders) {
            // could still be a case of a polygon equal to the clipping border itself
            // This area test could actually replace the whole method,
            // but it's more expensive to run, so we use it as a last resort for a specific case
            if (ring.getFactory().createPolygon(ring).getArea() > 0) {
                return ring;
            } else {
                return null;
            }
        } else {
            return ring;
        }
    }

