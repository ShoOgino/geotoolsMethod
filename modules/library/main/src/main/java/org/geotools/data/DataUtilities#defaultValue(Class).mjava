    /**
     * Returns a non-null default value for the class that is passed in. This is a helper class an
     * can't create a default class for all types but it does support:
     *
     * <ul>
     *   <li>String
     *   <li>Object - will return empty string
     *   <li>Integer
     *   <li>Double
     *   <li>Long
     *   <li>Short
     *   <li>Float
     *   <li>BigDecimal
     *   <li>BigInteger
     *   <li>Character
     *   <li>Boolean
     *   <li>UUID
     *   <li>Timestamp
     *   <li>java.sql.Date
     *   <li>java.sql.Time
     *   <li>java.util.Date
     *   <li>JTS Geometries
     *   <li>Arrays - will return an empty array of the appropriate type
     * </ul>
     *
     * @param type
     * @return
     */
    public static Object defaultValue(Class type) {
        if (type == String.class || type == Object.class) {
            return "";
        }
        if (type == Integer.class) {
            return Integer.valueOf(0);
        }
        if (type == Double.class) {
            return new Double(0);
        }
        if (type == Long.class) {
            return Long.valueOf(0);
        }
        if (type == Short.class) {
            return Short.valueOf((short) 0);
        }
        if (type == Float.class) {
            return new Float(0.0f);
        }
        if (type == BigDecimal.class) {
            return BigDecimal.valueOf(0);
        }
        if (type == BigInteger.class) {
            return BigInteger.valueOf(0);
        }
        if (type == Character.class) {
            return new Character(' ');
        }
        if (type == Boolean.class) {
            return Boolean.FALSE;
        }
        if (type == UUID.class) {
            return UUID.fromString("00000000-0000-0000-0000-000000000000");
        }
        if (type == Timestamp.class) return new Timestamp(0);
        if (type == java.sql.Date.class) return new java.sql.Date(0);
        if (type == java.sql.Time.class) return new java.sql.Time(0);
        if (type == java.util.Date.class) return new java.util.Date(0);

        GeometryFactory fac = new GeometryFactory();
        Coordinate coordinate = new Coordinate(0, 0);
        Point point = fac.createPoint(coordinate);

        if (type == Point.class) {
            return point;
        }
        if (type == MultiPoint.class) {
            return fac.createMultiPoint(new Point[] {point});
        }
        LineString lineString =
                fac.createLineString(new Coordinate[] {new Coordinate(0, 0), new Coordinate(0, 1)});
        if (type == LineString.class) {
            return lineString;
        }
        LinearRing linearRing =
                fac.createLinearRing(
                        new Coordinate[] {
                            new Coordinate(0, 0),
                            new Coordinate(0, 1),
                            new Coordinate(1, 1),
                            new Coordinate(1, 0),
                            new Coordinate(0, 0)
                        });
        if (type == LinearRing.class) {
            return linearRing;
        }
        if (type == MultiLineString.class) {
            return fac.createMultiLineString(new LineString[] {lineString});
        }
        Polygon polygon = fac.createPolygon(linearRing, new LinearRing[0]);
        if (type == Polygon.class) {
            return polygon;
        }
        if (type == MultiPolygon.class) {
            return fac.createMultiPolygon(new Polygon[] {polygon});
        }

        if (type.isArray()) {
            return Array.newInstance(type.getComponentType(), 0);
        }

        throw new IllegalArgumentException(type + " is not supported by this method");
    }

