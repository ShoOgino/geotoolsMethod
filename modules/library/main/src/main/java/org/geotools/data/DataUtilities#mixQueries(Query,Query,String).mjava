    /**
     * Takes two {@link Query}objects and produce a new one by mixing the restrictions of both of
     * them.
     *
     * <p>The policy to mix the queries components is the following:
     *
     * <ul>
     *   <li>typeName: type names MUST match (not checked if some or both queries equals to <code>
     *       Query.ALL</code>)
     *   <li>handle: you must provide one since no sensible choice can be done between the handles
     *       of both queries
     *   <li>maxFeatures: the lower of the two maxFeatures values will be used (most restrictive)
     *   <li>attributeNames: the attributes of both queries will be joined in a single set of
     *       attributes. IMPORTANT: only <b><i>explicitly</i></b> requested attributes will be
     *       joint, so, if the method <code>retrieveAllProperties()</code> of some of the queries
     *       returns <code>true</code> it does not means that all the properties will be joined. You
     *       must create the query with the names of the properties you want to load.
     *   <li>filter: the filters of both queries are or'ed, then simplified using
     *       SimplifiyingFilterVisitor
     *   <li><b>any other query property is ignored</b> and no guarantees are made of their return
     *       values, so client code shall explicitly care of hints, startIndex, etc., if needed.
     * </ul>
     *
     * @param firstQuery Query against this DataStore
     * @return Query restricted to the limits of definitionQuery
     * @throws NullPointerException if some of the queries is null
     * @throws IllegalArgumentException if the type names of both queries do not match
     */
    public static Query mixQueries(Query firstQuery, Query secondQuery, String handle) {
        if ((firstQuery == null) && (secondQuery == null)) {
            // throw new NullPointerException("Cannot combine two null queries");
            return Query.ALL;
        }
        if (firstQuery == null || firstQuery.equals(Query.ALL)) {
            return secondQuery;
        } else if (secondQuery == null || secondQuery.equals(Query.ALL)) {
            return firstQuery;
        }
        if ((firstQuery.getTypeName() != null) && (secondQuery.getTypeName() != null)) {
            if (!firstQuery.getTypeName().equals(secondQuery.getTypeName())) {
                String msg =
                        "Type names do not match: "
                                + firstQuery.getTypeName()
                                + " != "
                                + secondQuery.getTypeName();
                throw new IllegalArgumentException(msg);
            }
        }

        // mix versions, if possible
        String version;
        if (firstQuery.getVersion() != null) {
            if (secondQuery.getVersion() != null
                    && !secondQuery.getVersion().equals(firstQuery.getVersion()))
                throw new IllegalArgumentException(
                        "First and second query refer different versions");
            version = firstQuery.getVersion();
        } else {
            version = secondQuery.getVersion();
        }

        // none of the queries equals Query.ALL, mix them
        // use the more restrictive max features field
        int maxFeatures = Math.min(firstQuery.getMaxFeatures(), secondQuery.getMaxFeatures());

        // join attributes names
        List<PropertyName> propNames =
                joinAttributes(firstQuery.getProperties(), secondQuery.getProperties());

        // join filters
        Filter filter = firstQuery.getFilter();
        Filter filter2 = secondQuery.getFilter();

        if ((filter == null) || filter.equals(Filter.INCLUDE)) {
            filter = filter2;
        } else if ((filter2 != null) && !filter2.equals(Filter.INCLUDE)) {
            filter = ff.and(filter, filter2);
        }
        filter = SimplifyingFilterVisitor.simplify(filter);
        Integer start = 0;
        if (firstQuery.getStartIndex() != null) {
            start = firstQuery.getStartIndex();
        }
        if (secondQuery.getStartIndex() != null) {
            start += secondQuery.getStartIndex();
        }
        // collect all hints
        Hints hints = new Hints();
        if (firstQuery.getHints() != null) {
            hints.putAll(firstQuery.getHints());
        }
        if (secondQuery.getHints() != null) {
            hints.putAll(secondQuery.getHints());
        }
        // build the mixed query
        String typeName =
                firstQuery.getTypeName() != null
                        ? firstQuery.getTypeName()
                        : secondQuery.getTypeName();

        Query mixed = new Query(typeName, filter, maxFeatures, propNames, handle);
        mixed.setVersion(version);
        mixed.setHints(hints);
        if (start != 0) {
            mixed.setStartIndex(start);
        }
        return mixed;
    }

