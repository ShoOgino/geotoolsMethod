    /**
     * List of child filters.
     *
     * <p>Where a child filter is considered:
     *
     * <ul>
     *   <li>Not: has a single child filter being negated
     *   <li>And: has a list of child filters
     *   <li>Or: has a list of child filters
     * </ul>
     *
     * Any other filters will return false.
     *
     * <p>This represents the space covered by a number of the search functions, if *all* is true
     * this function will recursively search for additional child filters beyond those directly
     * avaialble from your filter.
     *
     * <p>The returned list is a mutable copy that can be used with filter factory to construct a
     * new filter when you are ready. To make that explicit I am returning an ArrayList so it is
     * clear that the result can be modified.
     *
     * @param filter
     * @param all true to recurse into the filter and retrieve all children; false to only return
     *     the top level children
     * @return are belong to us
     */
    public static ArrayList<Filter> children(Filter filter, boolean all) {
        final ArrayList<Filter> children = new ArrayList<Filter>();
        if (filter == null) {
            return children;
        }
        if (all) {
            filter.accept(
                    new DefaultFilterVisitor() {
                        public Object visit(And filter, Object data) {
                            List<Filter> childList = filter.getChildren();
                            if (childList != null) {
                                for (Filter child : childList) {
                                    if (child == null) continue;

                                    children.add(child);
                                    data = child.accept(this, data);
                                }
                            }
                            return data;
                        }

                        public Object visit(Or filter, Object data) {
                            List<Filter> childList = filter.getChildren();
                            if (childList != null) {
                                for (Filter child : childList) {
                                    if (child == null) continue;

                                    children.add(child);
                                    data = child.accept(this, data);
                                }
                            }
                            return data;
                        }

                        public Object visit(Not filter, Object data) {
                            Filter child = filter.getFilter();
                            if (child != null) {
                                children.add(child);
                                data = child.accept(this, data);
                            }
                            return data;
                        }
                    },
                    null);
        } else {
            if (filter instanceof Not) {
                Not not = (Not) filter;
                if (not.getFilter() != null) {
                    children.add(not.getFilter());
                }
            }
            if (filter instanceof BinaryLogicOperator) {
                BinaryLogicOperator parent = (BinaryLogicOperator) filter;
                List<Filter> reviewChildren = parent.getChildren();
                if (reviewChildren != null) {
                    for (Filter child : reviewChildren) {
                        if (child != null) {
                            children.add(child);
                        }
                    }
                }
            }
        }
        return children;
    }

