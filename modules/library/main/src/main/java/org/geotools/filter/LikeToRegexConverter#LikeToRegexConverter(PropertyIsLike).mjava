    public LikeToRegexConverter(PropertyIsLike like) {
        String pattern = like.getLiteral();
        String wildcardMulti = like.getWildCard();
        String wildcardSingle = like.getSingleChar();
        String escape = like.getEscape();

        // The following things happen for both wildcards:
        // (1) If a user-defined wildcard exists, replace with Java wildcard
        // (2) If a user-defined escape exists, Java wildcard + user-escape
        // Then, test for matching pattern and return result.
        char esc = escape.charAt(0);
        if (LOGGER.isLoggable(Level.FINER)) {
            LOGGER.finer("wildcard " + wildcardMulti + " single " + wildcardSingle);
            LOGGER.finer("escape " + escape + " esc " + esc + " esc == \\ " + (esc == '\\'));
        }

        String escapedWildcardMulti = fixSpecials(wildcardMulti, escape);
        String escapedWildcardSingle = fixSpecials(wildcardSingle, escape);

        // escape any special chars which are not our wildcards
        StringBuffer tmp = new StringBuffer("");

        boolean escapedMode = false;

        for (int i = 0; i < pattern.length(); i++) {
            char chr = pattern.charAt(i);
            if (LOGGER.isLoggable(Level.FINER)) {
                LOGGER.finer("tmp = " + tmp + " looking at " + chr);
            }

            if (pattern.regionMatches(false, i, escape, 0, escape.length())) {
                // skip the escape string
                LOGGER.finer("escape ");
                escapedMode = true;

                i += escape.length();
                chr = pattern.charAt(i);
            }

            if (pattern.regionMatches(false, i, wildcardMulti, 0, wildcardMulti.length())) { // replace
                                                                                             // with
                                                                                             // java
                                                                                             // wildcard
                LOGGER.finer("multi wildcard");

                if (escapedMode) {
                    LOGGER.finer("escaped ");
                    tmp.append(escapedWildcardMulti);
                } else {
                    tmp.append(".*");
                }

                i += (wildcardMulti.length() - 1);
                escapedMode = false;

                continue;
            }

            if (pattern.regionMatches(false, i, wildcardSingle, 0, wildcardSingle.length())) {
                // replace with java single wild card
                LOGGER.finer("single wildcard");

                if (escapedMode) {
                    LOGGER.finer("escaped ");
                    tmp.append(escapedWildcardSingle);
                } else {
                    // From the OpenGIS filter encoding spec,
                    // "the single singleChar character matches exactly one character"
                    tmp.append(".{1}");
                }

                i += (wildcardSingle.length() - 1);
                escapedMode = false;

                continue;
            }

            if (isSpecial(chr)) {
                LOGGER.finer("special");
                tmp.append(escape + chr);
                escapedMode = false;

                continue;
            }

            tmp.append(chr);
            escapedMode = false;
        }

        pattern = tmp.toString();
        if (LOGGER.isLoggable(Level.FINER)) {
            LOGGER.finer("final pattern " + pattern);
        }

        this.pattern = pattern;
    }

