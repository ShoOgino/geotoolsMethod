    /**
     * FeatureResults query against featureSource.
     *
     * <p>Please note that is object will not be valid after the transaction has closed.
     *
     * <p>Really? I think it would be, it would just reflect the same query against the
     * SimpleFeatureSource using AUTO_COMMIT.
     */
    public DefaultFeatureResults(SimpleFeatureSource source, Query query) throws IOException {
        super(null, getSchemaInternal(source, query));
        this.featureSource = source;

        SimpleFeatureType originalType = source.getSchema();

        String typeName = originalType.getTypeName();
        if (typeName.equals(query.getTypeName())) {
            this.query = query;
        } else {
            // jg: this should be an error, we are deliberatly gobbling a mistake
            // option 1: remove Query.getTypeName
            // option 2: throw a warning
            // option 3: restore exception code
            this.query = new Query(query);
            this.query.setTypeName(typeName);
        }

        if (originalType.getGeometryDescriptor() == null) {
            return; // no transform needed
        }

        CoordinateReferenceSystem cs = null;
        if (query.getCoordinateSystemReproject() != null) {
            cs = query.getCoordinateSystemReproject();
        } else if (query.getCoordinateSystem() != null) {
            cs = query.getCoordinateSystem();
        }
        CoordinateReferenceSystem originalCRS =
                originalType.getGeometryDescriptor().getCoordinateReferenceSystem();
        if (query.getCoordinateSystem() != null) {
            originalCRS = query.getCoordinateSystem();
        }
        if (cs != null && cs != originalCRS) {
            try {
                transform = CRS.findMathTransform(originalCRS, cs, true);
            } catch (FactoryException noTransform) {
                throw (IOException)
                        new IOException("Could not reproject data to " + cs).initCause(noTransform);
            }
        }
    }

