    /**
     * Given OGC PropertyIsLike Filter information, construct an SQL-compatible 'like' pattern.
     *
     * <p>SQL % --> match any number of characters _ --> match a single character
     *
     * <p>NOTE; the SQL command is 'string LIKE pattern [ESCAPE escape-character]' We could
     * re-define the escape character, but I'm not doing to do that in this code since some
     * databases will not handle this case.
     *
     * <p>Method: 1.
     *
     * <p>Examples: ( escape ='!', multi='*', single='.' ) broadway* -> 'broadway%' broad_ay ->
     * 'broad_ay' broadway -> 'broadway'
     *
     * <p>broadway!* -> 'broadway*' (* has no significance and is escaped) can't -> 'can''t' ( '
     * escaped for SQL compliance)
     *
     * <p>NOTE: we also handle "'" characters as special because they are end-of-string characters.
     * SQL will convert ' to '' (double single quote).
     *
     * <p>NOTE: we dont handle "'" as a 'special' character because it would be too confusing to
     * have a special char as another special char. Using this will throw an error
     * (IllegalArgumentException).
     */
    public static String convertToSQL92(
            char escape, char multi, char single, boolean matchCase, String pattern)
            throws IllegalArgumentException {
        if ((escape == '\'') || (multi == '\'') || (single == '\''))
            throw new IllegalArgumentException("do not use single quote (') as special char!");

        StringBuffer result = new StringBuffer(pattern.length() + 5);
        for (int i = 0; i < pattern.length(); i++) {
            char chr = pattern.charAt(i);
            if (chr == escape) {
                // emit the next char and skip it
                if (i != (pattern.length() - 1)) result.append(pattern.charAt(i + 1)); //
                i++; // skip next char
            } else if (chr == single) {
                result.append('_');
            } else if (chr == multi) {
                result.append('%');
            } else if (chr == '\'') {
                result.append('\'');
                result.append('\'');
            } else {
                result.append(matchCase ? chr : Character.toUpperCase(chr));
            }
        }

        return result.toString();
    }

