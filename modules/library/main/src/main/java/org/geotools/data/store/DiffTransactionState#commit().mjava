    @Override

    /**
     * Will apply differences to store.
     *
     * <p>The provided diff will be modified as the differences are applied, If the operations are
     * all successful diff will be empty at the end of this process.
     *
     * <p>diff can be used to represent the following operations:
     *
     * <ul>
     *   <li>fid|null: represents a fid being removed
     *   <li>fid|feature: where fid exists, represents feature modification
     *   <li>fid|feature: where fid does not exist, represents feature being modified
     * </ul>
     *
     * @param typeName typeName being updated
     * @param diff differences to apply to FeatureWriter
     * @throws IOException If the entire diff cannot be writen out
     * @t
     * @see org.geotools.data.Transaction.State#commit()
     */
    public synchronized void commit() throws IOException {
        if (diff.isEmpty()) {
            return; // nothing to do
        }
        FeatureWriter<SimpleFeatureType, SimpleFeature> writer;
        ContentFeatureStore store;
        ContentEntry entry = state.getEntry();
        Name name = entry.getName();
        ContentDataStore dataStore = entry.getDataStore();
        ContentFeatureSource source = (ContentFeatureSource) dataStore.getFeatureSource(name);
        if (source instanceof ContentFeatureStore) {
            // request a plain writer with no events, filtering or locking checks
            store = (ContentFeatureStore) dataStore.getFeatureSource(name, transaction);
            writer = store.getWriter(Filter.INCLUDE, ContentDataStore.WRITER_COMMIT);
        } else {
            throw new UnsupportedOperationException("not writable");
        }
        SimpleFeature feature;
        SimpleFeature update;

        Throwable cause = null;
        try {
            while (writer.hasNext()) {
                feature = writer.next();
                String fid = feature.getID();

                if (diff.getModified().containsKey(fid)) {
                    update = diff.getModified().get(fid);

                    if (update == Diff.NULL) {
                        writer.remove();

                    } else {
                        try {
                            feature.setAttributes(update.getAttributes());
                            writer.write();

                        } catch (IllegalAttributeException e) {
                            throw new DataSourceException("Could update " + fid, e);
                        }
                    }
                }
            }

            SimpleFeature addedFeature;
            SimpleFeature nextFeature;

            synchronized (diff) {
                for (String fid : diff.getAddedOrder()) {
                    addedFeature = diff.getAdded().get(fid);

                    nextFeature = writer.next();

                    if (nextFeature == null) {
                        throw new DataSourceException("Could not add " + fid);
                    } else {
                        try {
                            nextFeature.setAttributes(addedFeature.getAttributes());
                            // if( Boolean.TRUE.equals(
                            // addedFeature.getUserData().get(Hints.USE_PROVIDED_FID)) ){
                            nextFeature.getUserData().put(Hints.USE_PROVIDED_FID, true);
                            if (addedFeature.getUserData().containsKey(Hints.PROVIDED_FID)) {
                                String providedFid =
                                        (String) addedFeature.getUserData().get(Hints.PROVIDED_FID);
                                nextFeature.getUserData().put(Hints.PROVIDED_FID, providedFid);
                            } else {
                                nextFeature
                                        .getUserData()
                                        .put(Hints.PROVIDED_FID, addedFeature.getID());
                            }
                            // }
                            writer.write();

                        } catch (IllegalAttributeException e) {
                            throw new DataSourceException("Could update " + fid, e);
                        }
                    }
                }
            }
        } catch (IOException | RuntimeException e) {
            cause = e;
            throw e;
        } finally {
            try {
                writer.close();
                state.fireBatchFeatureEvent(true);
                diff.clear();
            } catch (IOException | RuntimeException e) {
                if (cause != null) {
                    e.initCause(cause);
                }
                throw e;
            }
        }
    }

