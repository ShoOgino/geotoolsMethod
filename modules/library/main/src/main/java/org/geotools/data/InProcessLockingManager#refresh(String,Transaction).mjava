    /**
     * Refresh locks held by the authorization <code>authID</code>.
     *
     * <p>(remember that the lock may have expired)
     *
     * @param authID Authorization identifing Lock to refresh
     * @param transaction Transaction with authorization for lockID
     * @return <code>true</code> if lock was found and refreshed
     * @throws IOException If transaction not authorized to refresh authID
     * @throws IllegalArgumentException If authID or transaction not provided
     */
    @Override
    public synchronized boolean refresh(String authID, Transaction transaction) throws IOException {
        if (authID == null) {
            throw new IllegalArgumentException("lockID required");
        }

        if ((transaction == null) || (transaction == Transaction.AUTO_COMMIT)) {
            throw new IllegalArgumentException(
                    "Tansaction required (with authorization for " + authID + ")");
        }

        Lock lock;
        boolean refresh = false;

        for (Iterator<Lock> i = allLocks().iterator(); i.hasNext(); ) {
            lock = i.next();

            if (lock.isExpired()) {
                i.remove();
            } else if (lock.isMatch(authID)) {
                if (lock.isAuthorized(transaction)) {
                    lock.refresh();
                    refresh = true;
                } else {
                    throw new IOException("Not authorized to refresh " + lock);
                }
            }
        }

        return refresh;
    }

