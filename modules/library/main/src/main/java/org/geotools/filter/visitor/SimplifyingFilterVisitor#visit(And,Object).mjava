    @Override
    public Object visit(And filter, Object extraData)
    {
        // scan, clone and simplify the children
        List<Filter> newChildren = new ArrayList<Filter>(filter.getChildren().size());
        for (Filter child : filter.getChildren())
        {
            Filter cloned = (Filter) child.accept(this, extraData);

            // if any of the child filters is exclude,
            // the whole chain of AND is equivalent to
            // EXCLUDE
            if (cloned == Filter.EXCLUDE)
            {
                return Filter.EXCLUDE;
            }

            // these can be skipped
            if (cloned == Filter.INCLUDE)
            {
                continue;
            }

            if (cloned instanceof And)
            {
                And and = (And) cloned;
                newChildren.addAll(and.getChildren());
            }
            else
            {
                newChildren.add(cloned);
            }
        }
        
        // see if we have dual filters that can lead to Filter.Exclude, or duplicated filters
        for (int i = 0; i < newChildren.size(); i++) {
            for(int j = i + 1; j < newChildren.size(); ) {
                Filter f1 = newChildren.get(i);
                Filter f2 = newChildren.get(j);
                if(f1.equals(f2)) {
                    newChildren.remove(j);
                } else if(dualFilters(f1, f2)) {
                    return Filter.EXCLUDE;
                } else {
                    j++;
                }
            }
        }
        
        // we might end up with an empty list
        if (newChildren.size() == 0)
        {
            return Filter.INCLUDE;
        }

        // remove the logic we have only one filter
        if (newChildren.size() == 1)
        {
            return newChildren.get(0);
        }

        // else return the cloned and simplified up list
        return getFactory(extraData).and(newChildren);
    }

