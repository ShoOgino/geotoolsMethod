    /**
     * Returns an iterator object that iterates along the <code>Shape</code> boundary and provides
     * access to the geometry of the <code>Shape</code> outline. If an optional {@link
     * AffineTransform} is specified, the coordinates returned in the iteration are transformed
     * accordingly.
     *
     * <p>Each call to this method returns a fresh <code>PathIterator</code> object that traverses
     * the geometry of the <code>Shape</code> object independently from any other <code>PathIterator
     * </code> objects in use at the same time.
     *
     * <p>It is recommended, but not guaranteed, that objects implementing the <code>Shape</code>
     * interface isolate iterations that are in process from any changes that might occur to the
     * original object's geometry during such iterations.
     *
     * <p>Before using a particular implementation of the <code>Shape</code> interface in more than
     * one thread simultaneously, refer to its documentation to verify that it guarantees that
     * iterations are isolated from modifications.
     *
     * @param at an optional <code>AffineTransform</code> to be applied to the coordinates as they
     *     are returned in the iteration, or <code>null</code> if untransformed coordinates are
     *     desired
     * @return a new <code>PathIterator</code> object, which independently traverses the geometry of
     *     the <code>Shape</code>.
     */
    public PathIterator getPathIterator(AffineTransform at) {
        AbstractLiteIterator pi = null;

        AffineTransform combined = null;

        if (affineTransform == null) {
            combined = at;
        } else if ((at == null) || at.isIdentity()) {
            combined = affineTransform;
        } else {
            combined = new AffineTransform(affineTransform);
            combined.concatenate(at);
        }

        // return iterator according to the kind of geometry we include
        if (this.geometry instanceof Point) {
            pi = new PointIterator((Point) geometry, combined);
        }

        if (this.geometry instanceof Polygon) {

            pi = new PolygonIterator((Polygon) geometry, combined, generalize, maxDistance);
        } else if (this.geometry instanceof LinearRing) {
            lineIterator.init((LinearRing) geometry, combined, generalize, (float) maxDistance);
            pi = lineIterator;
        } else if (this.geometry instanceof LineString) {
            //        	if(((LineString) geometry).getCoordinateSequence() instanceof
            // PackedCoordinateSequence.Double)
            //	            pi = new PackedLineIterator((LineString) geometry, combined, generalize,
            //	                    (float) maxDistance);
            //        	else
            if (combined == affineTransform)
                lineIterator.init(
                        (LineString) geometry,
                        combined,
                        generalize,
                        (float) maxDistance,
                        xScale,
                        yScale);
            else
                lineIterator.init((LineString) geometry, combined, generalize, (float) maxDistance);
            pi = lineIterator;
        } else if (this.geometry instanceof GeometryCollection) {
            collIterator.init((GeometryCollection) geometry, combined, generalize, maxDistance);
            pi = collIterator;
        }

        return pi;
    }

