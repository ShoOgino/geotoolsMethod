    /**
     * Catches inner and outer LinearRings messages and handles them appropriately.
     *
     * @param message Name of sub geometry located.
     * @param type Type of sub geometry located.
     */
    public void subGeometry(String message, int type) {
        // if we have found a linear ring, either
        // add it to the list of inner boundaries if we are reading them
        // and at the end of the LinearRing
        // add it to the outer boundary if we are reading it and at the end of
        // the LinearRing
        // create a new linear ring, if we are at the start of a new linear ring
        if (message.equals("LinearRing")) {
            if (type == GEOMETRY_END) {
                if (location == INNER_BOUNDARY) {
                    LinearRing ring = (LinearRing) currentHandler.create(geometryFactory);
                    Coordinate[] points = ring.getCoordinates();

                    /* it is important later that internal rings (holes) are
                     * anticlockwise (counter clockwise) - so we reverse the
                     * points if necessary
                     */
                    if (Orientation.isCCW(points)) {
                        LOGGER.finer("good hole found");

                        // System.out.println("inner boundary: " + message);
                        innerBoundaries.add(ring);

                    } else {
                        LOGGER.finer("bad hole found - fixing");
                        Coordinate[] newPoints = new Coordinate[points.length];

                        for (int i = 0, j = points.length - 1; i < points.length; i++, j--) {
                            newPoints[i] = points[j];
                        }

                        try {
                            ring = geometryFactory.createLinearRing(newPoints);
                            innerBoundaries.add(ring);
                        } catch (TopologyException e) {
                            LOGGER.warning("Caught Topology exception in GMLPolygonHandler");
                            ring = null;
                        }
                    }
                } else if (location == OUTER_BOUNDARY) {
                    /* it is important later that the outerboundary is
                     * clockwise  - so we reverse the
                     * points if necessary
                     */
                    outerBoundary = (LinearRing) currentHandler.create(geometryFactory);

                    Coordinate[] points = outerBoundary.getCoordinates();

                    if (Orientation.isCCW(points)) {
                        LOGGER.finer("bad outer ring - rebuilding");
                        //  System.out.println("rebuilding outer ring");
                        Coordinate[] newPoints = new Coordinate[points.length];

                        for (int i = 0, j = points.length - 1; i < points.length; i++, j--) {
                            newPoints[i] = points[j];
                        }

                        try {
                            outerBoundary = geometryFactory.createLinearRing(newPoints);
                            // System.out.println("outer boundary: " + message);

                        } catch (TopologyException e) {
                            LOGGER.warning("Caught Topology exception in " + "GMLPolygonHandler");
                            outerBoundary = null;
                        }
                    }
                }
            } else if (type == GEOMETRY_START) {
                currentHandler = new SubHandlerLinearRing();
            }
        } else if (message.equals("outerBoundaryIs")) {
            //  or, if we are getting notice of an inner/outer boundary marker,
            // set current location appropriately
            LOGGER.finer("new outer Boundary");
            location = OUTER_BOUNDARY;
        } else if (message.equals("innerBoundaryIs")) {
            LOGGER.finer("new InnerBoundary");
            location = INNER_BOUNDARY;
        }
    }

