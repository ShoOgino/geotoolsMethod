    private Object calculate(SimpleFeatureCollection featureCollection) {
        FeatureCalc quantityVisitor = getListVisitor();
        if (progress == null) progress = new NullProgressListener();
        try {
            featureCollection.accepts(quantityVisitor, progress);
        } catch (IOException e) {
            LOGGER.log(
                    Level.SEVERE, "QuantileFunction calculate(SimpleFeatureCollection) failed", e);
            return null;
        }
        if (progress.isCanceled()) return null;
        CalcResult calcResult = quantityVisitor.getResult();
        if (calcResult == null || calcResult == CalcResult.NULL_RESULT) {
            return null;
        }
        List[] bin = (List[]) calcResult.getValue();

        // generate the min and max values, and round off if applicable/necessary
        Comparable globalMin = (Comparable) bin[0].toArray()[0];
        Object lastBin[] = bin[bin.length - 1].toArray();
        if (lastBin.length == 0) {
            return null;
        }
        Comparable globalMax = (Comparable) lastBin[lastBin.length - 1];

        if ((globalMin instanceof Number) && (globalMax instanceof Number)) {
            return calculateNumerical(bin, globalMin, globalMax);
        } else {
            return calculateNonNumerical(bin, globalMin, globalMax);
        }
    }

