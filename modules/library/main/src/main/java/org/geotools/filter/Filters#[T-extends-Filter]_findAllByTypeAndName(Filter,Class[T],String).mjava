    /**
     * Find all filters (including the base filter itself) that are of the given type and use
     * the specified property.
     * @param filter
     * @param filterType
     * @param property
     * @return
     */
    static <T extends Filter> List<T> findAllByTypeAndName(Filter filter, Class<T> filterType, String property) {
        List<T> retVal = new ArrayList<T>();
        
        ArrayList<Filter> allBase = allYourBase(filter); 
        // The first visitor finds all filters of the specified type, and the second visitor finds all
        // filters that use the given property.  Intersecting the two gives us all that use both.
        
        //FindType findType = new FindType(filterType);
        //FindProperty findProperty = new FindProperty(property);        
        for( Filter base : allBase ){
            if( filterType.isInstance(base) && uses(base, property) ){                
                retVal.add( filterType.cast(base) );
            }
        }
//        Collection<Filter> intersectFilters = (Collection<Filter>) filter.accept(findType, new LinkedHashSet());
//        if (intersectFilters != null && !intersectFilters.isEmpty()) {
//
//            Collection<Filter> geoFilters = (Collection<Filter>) filter.accept(findProperty, new LinkedHashSet());
//            intersectFilters.retainAll(geoFilters);
//            retVal = new ArrayList<Filter>(intersectFilters);
//        }
        return retVal;
    }

