    /**
     * Handles incoming characters.
     *
     * @param message the incoming chars from the SAX handler.
     * @throws IllegalFilterException If there are problems with filter constrcution.
     * @task TODO: this function is a mess, but it's mostly due to filters being loosely coupled
     *     with schemas, so we have to make a lot of guesses.
     * @task TODO: Revisit stripping leading characters. Needed now to get things working, and may
     *     be the best choice in the end, but it should be thought through more.
     */
    public void message(String message, boolean convertToNumber) throws IllegalFilterException {
        // TODO 2:
        // AT SOME POINT MUST MAKE THIS HANDLE A TYPED FEATURE
        // BY PASSING IT A FEATURE AND CHECKING ITS TYPE HERE
        LOGGER.finer("incoming message: " + message);
        LOGGER.finer("should read chars: " + readChars);

        if (readChars) {
            // If an attribute path, set it.  Assumes undeclared type.
            if (curExprssn instanceof PropertyName) {
                LOGGER.finer("...");

                // HACK: this code is to get rid of the leading junk that can
                // occur in a filter encoding.  The '.' is from the .14 wfs spec
                // when the style was typeName.propName, such as road.nlanes,
                // The ':' is from wfs 1.0 xml request, such as myns:nlanes,
                // and the '/' is from wfs 1.0 kvp style: road/nlanes.
                // We're not currently checking to see if the typename matches,
                // or if the namespace is right, which isn't the best,
                // so that should be fixed.
                String[] splitName = message.split("[.:/]");
                String newAttName = message;

                if (splitName.length == 1) {
                    newAttName = splitName[0];
                } else {
                    // REVISIT: not sure what to do if there are multiple
                    // delimiters.
                    // REVISIT: should we examine the first value?  See
                    // if the namespace or typename matches up right?
                    // this is currently very permissive, just grabs
                    // the value of the end.
                    newAttName = splitName[splitName.length - 1];
                }

                LOGGER.finer("setting attribute expression: " + newAttName);
                ((AttributeExpressionImpl) curExprssn).setPropertyName(newAttName);
                LOGGER.finer("...");
                currentState = "complete";
                LOGGER.finer("...");
            } else if (curExprssn instanceof Literal) {
                // This is a relatively loose assignment routine, which uses
                //  the fact that the three allowed literal types have a strict
                //  instatiation hierarchy (ie. double can be an int can be a
                //  string, but not the other way around).
                // A better routine would consider the use of this expression
                //  (ie. will it be compared to a double or searched with a
                //  like filter?)
                // HACK: This should also not use exception catching, it's
                // expensive and bad code practice.
                if (convertToNumber) {
                    try {
                        Object temp = Integer.valueOf(message);
                        ((LiteralExpressionImpl) curExprssn).setValue(temp);
                        currentState = "complete";
                    } catch (NumberFormatException nfe1) {
                        try {
                            Object temp = Double.valueOf(message);
                            ((LiteralExpressionImpl) curExprssn).setValue(temp);
                            currentState = "complete";
                        } catch (NumberFormatException nfe2) {
                            Object temp = message;
                            ((LiteralExpressionImpl) curExprssn).setValue(temp);
                            currentState = "complete";
                        }
                    }
                } else {
                    Object temp = message;
                    ((LiteralExpressionImpl) curExprssn).setValue(temp);
                    currentState = "complete";
                }
            } else if (expFactory != null) {
                expFactory.message(message, convertToNumber);
            }
        } else if (expFactory != null) {
            expFactory.message(message, convertToNumber);
        }
    }

