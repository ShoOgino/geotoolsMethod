    /**
     * Handles incoming characters.
     *
     * @param message the incoming chars from the SAX handler.
     *
     * @throws IllegalFilterException If there are problems with filter
     *         constrcution.
     *
     * @task TODO: this function is a mess, but it's mostly due to filters
     *       being loosely coupled with schemas, so we have to make a lot of
     *       guesses.
     * @task TODO: Revisit stripping leading characters.  Needed now to get
     *       things working, and may be the best choice in the end, but it
     *       should be thought through more.
     */
    public void message(String message, boolean convertToNumber) throws IllegalFilterException {
        // TODO 2:
        // AT SOME POINT MUST MAKE THIS HANDLE A TYPED FEATURE
        // BY PASSING IT A FEATURE AND CHECKING ITS TYPE HERE
        LOGGER.finer("incoming message: " + message);
        LOGGER.finer("should read chars: " + readChars);

        if (readChars) {
            // If an attribute path, set it.  Assumes undeclared type.
            if (curExprssn instanceof PropertyName) {
                LOGGER.finer("...");

                //HACK: this code is to get rid of the leading junk that can
                //occur in a filter encoding.  The '.' is from the .14 wfs spec
                //when the style was typeName.propName, such as road.nlanes, 
                //The ':' is from wfs 1.0 xml request, such as myns:nlanes, 
                //and the '/' is from wfs 1.0 kvp style: road/nlanes.  
                //We're not currently checking to see if the typename matches,
                // or if the namespace is right, which isn't the best, 
                //so that should be fixed.
                String[] splitName = message.split("[.:/]");
                String newAttName = message;

                if (splitName.length == 1) {
                    newAttName = splitName[0];
                } else {
                    //REVISIT: not sure what to do if there are multiple
                    //delimiters.  
                    //REVISIT: should we examine the first value?  See
                    //if the namespace or typename matches up right?
                    //this is currently very permissive, just grabs
                    //the value of the end.
                    newAttName = splitName[splitName.length - 1];
                }

                LOGGER.finer("setting attribute expression: " + newAttName);
                ((AttributeExpressionImpl) curExprssn).setPropertyName(newAttName);
                LOGGER.finer("...");
                currentState = "complete";
                LOGGER.finer("...");
            } else if (curExprssn instanceof Literal) {
                // This is a relatively loose assignment routine, which uses
                //  the fact that the three allowed literal types have a strict
                //  instatiation hierarchy (ie. double can be an int can be a 
                //  string, but not the other way around).
                // A better routine would consider the use of this expression
                //  (ie. will it be compared to a double or searched with a
                //  like filter?)
                //HACK: This should also not use exception catching, it's 
                //expensive and bad code practice.
                if (convertToNumber){
	            	try {
	                    Object temp = new Integer(message);
	                    ((LiteralExpressionImpl) curExprssn).setValue(temp);
	                    currentState = "complete";
	                } catch (NumberFormatException nfe1) {
	                    try {
	                        Object temp = new Double(message);
	                        ((LiteralExpressionImpl) curExprssn).setValue(temp);
	                        currentState = "complete";
	                    } catch (NumberFormatException nfe2) {
	                        Object temp = message;
	                        ((LiteralExpressionImpl) curExprssn).setValue(temp);
	                        currentState = "complete";
	                    }
	                }
                }else{
                    Object temp = message;
                    ((LiteralExpressionImpl) curExprssn).setValue(temp);
                    currentState = "complete";
                }
            } else if (expFactory != null) {
                expFactory.message(message,convertToNumber);
            }
        } else if (expFactory != null) {
            expFactory.message(message,convertToNumber);
        }
    }

