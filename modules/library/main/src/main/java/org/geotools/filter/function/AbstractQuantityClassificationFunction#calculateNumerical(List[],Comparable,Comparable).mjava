    private Object calculateNumerical(List[] bin, Comparable globalMin, Comparable globalMax) {
        if (globalMax.equals(globalMin)) {
            return new RangedClassifier(new Comparable[] {globalMin}, new Comparable[] {globalMax});
        }

        int classNum = bin.length;
        // size arrays
        Comparable[] localMin = new Comparable[classNum];
        Comparable[] localMax = new Comparable[classNum];
        // globally consistent
        // double slotWidth = (((Number) globalMax).doubleValue() - ((Number)
        // globalMin).doubleValue()) / classNum;
        for (int i = 0; i < classNum; i++) {
            // copy the min + max values
            List thisBin = bin[i];
            localMin[i] = (Comparable) thisBin.get(0);
            localMax[i] = (Comparable) thisBin.get(thisBin.size() - 1);
            // locally accurate
            double slotWidth =
                    ((Number) localMax[i]).doubleValue() - ((Number) localMin[i]).doubleValue();
            if (slotWidth == 0.0) { // use global value, as there is only 1 value in this set
                slotWidth =
                        (((Number) globalMax).doubleValue() - ((Number) globalMin).doubleValue())
                                / classNum;
            }
            // determine number of decimal places to allow
            int decPlaces = decimalPlaces(slotWidth);
            decPlaces = Math.max(decPlaces, decimalPlaces(((Number) localMin[i]).doubleValue()));
            decPlaces = Math.max(decPlaces, decimalPlaces(((Number) localMax[i]).doubleValue()));
            // clean up truncation error
            if (decPlaces > -1) {
                localMin[i] = new Double(round(((Number) localMin[i]).doubleValue(), decPlaces));
                localMax[i] = new Double(round(((Number) localMax[i]).doubleValue(), decPlaces));
            }

            if (i == 0) {
                // ensure first min is less than or equal to globalMin
                if (localMin[i].compareTo(new Double(((Number) globalMin).doubleValue())) > 0)
                    localMin[i] =
                            new Double(
                                    fixRound(
                                            ((Number) localMin[i]).doubleValue(),
                                            decPlaces,
                                            false));
            } else if (i == classNum - 1) {
                // ensure last max is greater than or equal to globalMax
                if (localMax[i].compareTo(new Double(((Number) globalMax).doubleValue())) < 0)
                    localMax[i] =
                            new Double(
                                    fixRound(
                                            ((Number) localMax[i]).doubleValue(), decPlaces, true));
            }

            // synchronize previous max with current min; the ranged classifier is min <= x < y;
            if (i != 0) {
                localMax[i - 1] = localMin[i];
            }
        }
        // TODO: disallow having 2 identical bins (ie 0..0, 0..0, 0..0, 0..100)
        return new RangedClassifier(localMin, localMax);
    }

