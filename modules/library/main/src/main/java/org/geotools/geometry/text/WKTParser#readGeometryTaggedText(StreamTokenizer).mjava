    /**
     * Creates a <code>Geometry</code> using the next token in the stream.
     *
     * @param tokenizer tokenizer over a stream of text in Well-known Text
     *                  format. The next tokens must form a &lt;Geometry Tagged Text&gt;.
     * @return a <code>Object</code> of the correct type for the next item
     *         in the stream
     * @throws ParseException if the coordinates used to create a <code>Polygon</code>
     *                        shell and holes do not form closed linestrings, or if an unexpected
     *                        token was encountered
     * @throws IOException    if an I/O error occurs
     */
    private Geometry readGeometryTaggedText(StreamTokenizer tokenizer) throws IOException, ParseException {
        String type = getNextWord(tokenizer);
        if (type.equals("POINT")) {
            return readPointText(tokenizer);
        }  else if (type.equalsIgnoreCase("LINESTRING")) {
            return readLineStringText(tokenizer);
        } else if (type.equalsIgnoreCase("LINEARRING")) {
        	return readLinearRingText(tokenizer);
        }  else if (type.equalsIgnoreCase("POLYGON")) {
            return readPolygonText(tokenizer);
        } else if (type.equalsIgnoreCase("MULTIPOINT")) {
            return readMultiPointText(tokenizer);
        } else if (type.equalsIgnoreCase("MULTIPOLYGON")) {
            return readMultiPolygonText(tokenizer);
        } else if (type.equalsIgnoreCase("GEOMETRYCOLLECTION")) {
        	return readGeometryCollectionText(tokenizer);
        } else if (type.equalsIgnoreCase("MULTILINESTRING")) {
        	return readMultiLineStringText(tokenizer);
        }
        throw new ParseException("Unknown geometry type: " + type, tokenizer.lineno());
    }

