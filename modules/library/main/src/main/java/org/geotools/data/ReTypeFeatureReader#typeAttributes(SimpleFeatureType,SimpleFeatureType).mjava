    /**
     * Supplies mapping from original to target FeatureType.
     * 
     * <p>
     * Will also ensure that mapping results in a valid selection of values
     * from the original. Only the xpath expression and binding are checked.
     * </p>
     *
     * @param target Desired FeatureType
     * @param origional Original FeatureType
     *
     * @return Mapping from originoal to target FeatureType
     *
     * @throws IllegalArgumentException if unable to provide a mapping
     */
    protected AttributeDescriptor[] typeAttributes(SimpleFeatureType target,
        SimpleFeatureType origional) {
        if (FeatureTypes.equalsExact(origional, target)) {
            throw new IllegalArgumentException(
                "FeatureReader allready produces contents with the correct schema");
        }

        if (target.getAttributeCount() > origional.getAttributeCount()) {
            throw new IllegalArgumentException(
                "Unable to retype  FeatureReader<SimpleFeatureType, SimpleFeature> (origional does not cover requested type)");
        }

        String xpath;
        AttributeDescriptor[] types = new AttributeDescriptor[target.getAttributeCount()];

        for (int i = 0; i < target.getAttributeCount(); i++) {
            AttributeDescriptor attrib = target.getDescriptor(i);
            xpath = attrib.getLocalName();
            
            types[i] = attrib;
            
            AttributeDescriptor check = origional.getDescriptor( xpath );
            Class<?> targetBinding = attrib.getType().getBinding();
            Class<?> checkBinding = check.getType().getBinding();
            if( !targetBinding.isAssignableFrom( checkBinding )){
                throw new IllegalArgumentException(
                    "Unable to retype FeatureReader for " + xpath +
                    " as "+Classes.getShortName(checkBinding) + 
                    " cannot be assigned to "+Classes.getShortName(targetBinding) );                
            }
        }

        return types;
    }

