    /**
     * Initializes the factory to create a new expression. Called when the filter handler reaches a
     * new expression.
     *
     * @param declaredType The string representation of the expression type.
     * @throws IllegalFilterException If there are problems creating expressions.
     */
    public void start(String declaredType, Attributes atts) throws IllegalFilterException {
        LOGGER.finer("incoming type: " + declaredType);
        LOGGER.finer("declared type: " + this.declaredType);
        LOGGER.finer("current state: " + currentState);

        if (expFactory == null) {
            this.declaredType = declaredType;

            short convertType = convertType(declaredType);
            if (DefaultExpression.isFunctionExpression(convertType)) {
                expFactory = new ExpressionSAXParser(schema);
                String name = getFunctionName(atts);
                Function function = functionFinder.findFunction(name);
                if (function != null && function instanceof FunctionExpression) {
                    curExprssn = function;
                } else {
                    throw new IllegalFilterException(
                            name + " not availabel as FunctionExpressio:" + function);
                }
                LOGGER.finer("is <function> expression");
            }

            // if the expression is math, then create a factory for its
            // sub expressions, otherwise just instantiate the main expression
            if (DefaultExpression.isMathExpression(convertType)) {
                expFactory = new ExpressionSAXParser(schema);
                switch (convertType) {
                    case ExpressionType.MATH_ADD:
                        curExprssn = new AddImpl(null, null);
                        break;
                    case ExpressionType.MATH_SUBTRACT:
                        curExprssn = new SubtractImpl(null, null);
                        break;
                    case ExpressionType.MATH_MULTIPLY:
                        curExprssn = new MultiplyImpl(null, null);
                        break;
                    case ExpressionType.MATH_DIVIDE:
                        curExprssn = new DivideImpl(null, null);
                        break;
                    default:
                        throw new IllegalFilterException("Unsupported math expression");
                }
                LOGGER.finer("is math expression");
            } else if (DefaultExpression.isLiteralExpression(convertType)) {
                curExprssn = new LiteralExpressionImpl();
                readChars = true;
                LOGGER.finer("is literal expression");
            } else if (DefaultExpression.isAttributeExpression(convertType)) {
                curExprssn = new AttributeExpressionImpl(schema);
                readChars = true;
                LOGGER.finer("is attribute expression");
            }
            currentState = setInitialState(curExprssn);
            readyFlag = false;
        } else {
            expFactory.start(declaredType, atts);
        }
    }

