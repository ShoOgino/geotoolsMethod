    private SimpleFeatureCollection getFeatureCollection(Query query, Envelope bounds)
            throws IOException {
        query = DataUtilities.resolvePropertyNames(query, getSchema());
        final int offset = query.getStartIndex() != null ? query.getStartIndex() : 0;
        if (offset > 0 && query.getSortBy() == null) {
            if (!getQueryCapabilities().supportsSorting(query.getSortBy())) {
                throw new IllegalStateException(
                        "Feature source does not support this sorting "
                                + "so there is no way a stable paging (offset/limit) can be performed");
            }
            Query copy = new Query(query);
            copy.setSortBy(new SortBy[] {SortBy.NATURAL_ORDER});
            query = copy;
        }
        SimpleFeatureCollection collection;
        // step one filter
        if (query.getFilter() != null && query.getFilter().equals(Filter.EXCLUDE)) {
            return new EmptyFeatureCollection(getSchema());
        }
        if (query.getFilter() != null && query.getFilter().equals(Filter.INCLUDE)) {
            collection = contents;
        }
        if (query.getFilter() != null && query.getFilter().equals(Filter.INCLUDE)) {
            collection = contents;
        } else {
            collection = contents.subCollection(query.getFilter());
        }
        // step two: reproject
        if (query.getCoordinateSystemReproject() != null) {
            collection =
                    new ReprojectingFeatureCollection(
                            collection, query.getCoordinateSystemReproject());
        }
        // step two sort! (note this makes a sorted copy)
        if (query.getSortBy() != null && query.getSortBy().length != 0) {
            SimpleFeature array[] = collection.toArray(new SimpleFeature[collection.size()]);
            // Arrays sort is stable (not resorting equal elements)
            for (SortBy sortBy : query.getSortBy()) {
                Comparator<SimpleFeature> comparator = DataUtilities.sortComparator(sortBy);
                Arrays.sort(array, comparator);
            }
            ArrayList<SimpleFeature> list = new ArrayList<>(Arrays.asList(array));
            collection = new ListFeatureCollection(getSchema(), list);
        }

        // step three skip to start and return max number of fetaures
        if (offset > 0 || !query.isMaxFeaturesUnlimited()) {
            long max = Long.MAX_VALUE;
            if (!query.isMaxFeaturesUnlimited()) {
                max = query.getMaxFeatures();
            }
            collection = new MaxSimpleFeatureCollection(collection, offset, max);
        }
        // step four - retyping
        // (It would be nice to do this earlier so as to not have all the baggage
        // of unneeded attributes)
        if (query.getPropertyNames() != Query.ALL_NAMES) {
            // rebuild the type and wrap the reader
            SimpleFeatureType schema = collection.getSchema();
            SimpleFeatureType target =
                    SimpleFeatureTypeBuilder.retype(schema, query.getPropertyNames());
            if (!target.equals(schema)) {
                collection = new ReTypingFeatureCollection(collection, target);
            }
        }
        return collection;
    }

