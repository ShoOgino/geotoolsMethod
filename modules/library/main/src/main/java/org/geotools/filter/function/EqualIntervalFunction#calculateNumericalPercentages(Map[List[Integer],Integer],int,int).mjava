    private double[] calculateNumericalPercentages(
            Map<List<Integer>, Integer> queryResult, int totalSize, int classNum) {
        double[] percentages = new double[classNum];
        // getting a tree set from the keys to get them asc ordered and
        // collect percentages in the right order
        Set<Integer> keys =
                queryResult
                        .keySet()
                        .stream()
                        .map(l -> l.get(0))
                        .collect(Collectors.toCollection(() -> new TreeSet<>()));
        int i = 0;
        for (Integer key : keys) {
            List<Integer> keyL = Arrays.asList(key);
            // handle case when the query return one class plus,
            // when i.e. classWidth is an integer so that in an
            // interval of values 1-25, for three classes,
            // we would have value 25 falling in group with key 3
            if (i >= percentages.length) {
                int last = percentages.length - 1;
                percentages[last] += (Double.valueOf(queryResult.get(keyL)) / totalSize) * 100;
            } else {
                percentages[i] = (Double.valueOf(queryResult.get(keyL)) / totalSize) * 100;
            }
            i++;
        }
        return percentages;
    }

