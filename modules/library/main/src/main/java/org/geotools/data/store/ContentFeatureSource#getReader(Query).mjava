    /** Returns a reader for the features specified by a query. */
    public final FeatureReader<SimpleFeatureType, SimpleFeature> getReader(Query query)
            throws IOException {
        query = joinQuery(query);
        query = resolvePropertyNames(query);

        // see if we need to enable native sorting in order to support stable paging
        if (query.getStartIndex() != null
                && (query.getSortBy() == null || query.getSortBy().length == 0)) {
            Query dq = new Query(query);
            dq.setSortBy(new SortBy[] {SortBy.NATURAL_ORDER});
            query = dq;
        }

        // check for a join
        if (!query.getJoins().isEmpty() && getQueryCapabilities().isJoiningSupported()) {
            throw new IOException("Feature source does not support joins");
        }

        // if the implementation can retype but not sort, we might have
        // to remove the retyping, or we won't be able to sort in memory
        FeatureReader<SimpleFeatureType, SimpleFeature> reader;
        boolean postRetypeRequired =
                !canSort()
                        && canRetype()
                        && query.getSortBy() != null
                        && query.getPropertyNames() != Query.ALL_NAMES;
        if (postRetypeRequired) {
            List<String> requestedProperties =
                    new ArrayList<>(Arrays.asList(query.getPropertyNames()));
            Set<String> sortProperties = getSortPropertyNames(query.getSortBy());
            if (requestedProperties.containsAll(sortProperties)) {
                reader = getReaderInternal(query);
            } else {
                // add the sort properties that we miss
                Query loadingQuery = new Query(query);
                sortProperties.removeAll(requestedProperties);
                requestedProperties.addAll(sortProperties);
                loadingQuery.setPropertyNames(requestedProperties);
                reader = getReaderInternal(loadingQuery);
            }
        } else {
            reader = getReaderInternal(query);
        }

        //
        // apply wrappers based on subclass capabilities
        //
        // transactions
        if (!canTransact() && transaction != null && transaction != Transaction.AUTO_COMMIT) {
            DiffTransactionState state =
                    (DiffTransactionState) getTransaction().getState(getEntry());
            reader =
                    new DiffFeatureReader<SimpleFeatureType, SimpleFeature>(
                            reader, state.getDiff());
        }

        // filtering
        if (!canFilter()) {
            if (query.getFilter() != null && query.getFilter() != Filter.INCLUDE) {
                reader =
                        new FilteringFeatureReader<SimpleFeatureType, SimpleFeature>(
                                reader, query.getFilter());
            }
        }

        // sorting
        if (query.getSortBy() != null && query.getSortBy().length != 0) {
            if (!canSort()) {
                reader = new SortedFeatureReader(DataUtilities.simple(reader), query);
            }
        }

        // retyping
        if (!canRetype() || postRetypeRequired) {
            if (query.getPropertyNames() != Query.ALL_NAMES) {
                // rebuild the type and wrap the reader
                SimpleFeatureType target =
                        SimpleFeatureTypeBuilder.retype(
                                reader.getFeatureType(), query.getPropertyNames());

                // do an equals check because we may have needlessly retyped (that is,
                // the subclass might be able to only partially retype)
                if (!target.equals(reader.getFeatureType())) {
                    reader = new ReTypeFeatureReader(reader, target, false);
                }
            }
        }

        // offset
        int offset = query.getStartIndex() != null ? query.getStartIndex() : 0;
        if (!canOffset() && offset > 0) {
            // skip the first n records
            for (int i = 0; i < offset && reader.hasNext(); i++) {
                reader.next();
            }
        }

        // max feature limit
        if (!canLimit()) {
            if (query.getMaxFeatures() != -1 && query.getMaxFeatures() < Integer.MAX_VALUE) {
                reader =
                        new MaxFeatureReader<SimpleFeatureType, SimpleFeature>(
                                reader, query.getMaxFeatures());
            }
        }

        // reprojection
        if (!canReproject()) {
            CoordinateReferenceSystem sourceCRS = query.getCoordinateSystem();
            CoordinateReferenceSystem targetCRS = query.getCoordinateSystemReproject();
            CoordinateReferenceSystem nativeCRS =
                    reader.getFeatureType().getCoordinateReferenceSystem();

            if (sourceCRS != null && !sourceCRS.equals(nativeCRS)) {
                // override the nativeCRS
                try {
                    reader = new ForceCoordinateSystemFeatureReader(reader, sourceCRS);
                } catch (SchemaException e) {
                    throw (IOException)
                            new IOException("Error occurred trying to force CRS").initCause(e);
                }
            } else {
                // no override
                sourceCRS = nativeCRS;
            }
            if (targetCRS != null) {
                if (sourceCRS == null) {
                    throw new IOException("Cannot reproject data, the source CRS is not available");
                } else if (!sourceCRS.equals(targetCRS)) {
                    try {
                        reader = new ReprojectFeatureReader(reader, targetCRS);
                    } catch (Exception e) {
                        if (e instanceof IOException) throw (IOException) e;
                        else
                            throw (IOException)
                                    new IOException("Error occurred trying to reproject data")
                                            .initCause(e);
                    }
                }
            }
        }

        // TODO: Use InProcessLockingManager to assert read locks?
        // if (!canLock()) {
        //            LockingManager lockingManager = getDataStore().getLockingManager();
        //            return ((InProcessLockingManager)lockingManager).checkedReader(reader,
        // transaction);
        // }

        return reader;
    }

