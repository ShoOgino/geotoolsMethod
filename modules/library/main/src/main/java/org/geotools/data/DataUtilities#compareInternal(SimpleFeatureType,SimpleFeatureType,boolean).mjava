    /**
     * Compare attribute coverage between two feature types (allowing the identification of
     * subTypes).
     *
     * <p>The comparison results in a number with the following meaning:
     *
     * <ul>
     *   <li>1: if typeA is a sub type/reorder/renamespace of typeB
     *   <li>0: if typeA and typeB are the same type
     *   <li>-1: if typeA is not subtype of typeB
     * </ul>
     *
     * <p>Comparison is based on {@link AttributeDescriptor} - the {@link
     * #isMatch(AttributeDescriptor, AttributeDescriptor, boolean)} method is used to quickly
     * confirm that the local name and java binding (or attribute class) are compatible.
     *
     * <p>Namespace is not considered in this operations. You may still need to reType to get the
     * correct namespace, or reorder.
     *
     * <p>Please note this method will not result in a stable sort if used in a {@link Comparator}
     * as -1 is used to indicate incompatiblity (rather than simply "before").
     *
     * @param typeA FeatureType being compared
     * @param typeB FeatureType being compared against
     * @param strict flag controlling the comparison check
     */
    protected static int compareInternal(
            SimpleFeatureType typeA, SimpleFeatureType typeB, boolean strict) {
        if (typeA == typeB) {
            return 0;
        }

        if (typeA == null) {
            return -1;
        }

        if (typeB == null) {
            return -1;
        }

        int countA = typeA.getAttributeCount();
        int countB = typeB.getAttributeCount();

        if (countA > countB) {
            return -1;
        }

        // may still be the same featureType (Perhaps they differ on namespace?)
        AttributeDescriptor a;
        int match = 0;

        for (int i = 0; i < countA; i++) {
            a = typeA.getDescriptor(i);

            if (isMatch(a, typeB.getDescriptor(i), strict)) {
                match++;
            } else if (!isMatch(a, typeB.getDescriptor(a.getLocalName()), strict)) {
                // cannot find any match for Attribute in typeA
                return -1;
            }
        }

        if ((countA == countB) && (match == countA)) {
            // all attributes in typeA agreed with typeB
            // (same order and type)
            return 0;
        }

        return 1;
    }

