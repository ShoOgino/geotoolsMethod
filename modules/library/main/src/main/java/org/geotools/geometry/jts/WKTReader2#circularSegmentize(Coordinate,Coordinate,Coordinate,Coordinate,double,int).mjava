    private List<Coordinate> circularSegmentize(Coordinate p1, Coordinate p2, Coordinate p3, Coordinate center,
            double radius, int perQuad) {
        List<Coordinate> result;

        Coordinate pbuf = new Coordinate();
        int ptcount;
        
        Coordinate pt;
        
        double sweep = 0.0,
               angle = 0.0,
               increment = 0.0;
        double a1, a2, a3, i;
        
        if(radius < 0)
        {
            // does not form a circle
            result = new ArrayList<Coordinate>();
            result.add(p1);
            result.add(p2);
            return result;
        }
 
        a1 = atan2(p1.y - center.y, p1.x - center.x);
        a2 = atan2(p2.y - center.y, p2.x - center.x);
        a3 = atan2(p3.y - center.y, p3.x - center.x);
  
        if(abs(p1.x - p3.x) < EPSILON_SQLMM
                        && abs(p1.y - p3.y) < EPSILON_SQLMM)
        {
                sweep = 2*M_PI;
        }
        /* Clockwise */
        else if(a1 > a2 && a2 > a3)
        {
                sweep = a3 - a1;
        }
        /* Counter-clockwise */
        else if(a1 < a2 && a2 < a3)
        {
                sweep = a3 - a1;
        }
        /* Clockwise, wrap */
        else if((a1 < a2 && a1 > a3) || (a2 < a3 && a1 > a3))
        {
                sweep = a3 - a1 + 2*M_PI;
        }
        /* Counter-clockwise, wrap */
        else if((a1 > a2 && a1 < a3) || (a2 > a3 && a1 < a3))
        {
                sweep = a3 - a1 - 2*M_PI;
        }
        else
        {
                sweep = 0.0;
        }
         
        ptcount = (int) ceil(abs(perQuad * sweep / M_PI_2));
       
        result = new ArrayList<Coordinate>( ptcount );
 
        increment = M_PI_2 / perQuad;
        if(sweep < 0) increment *= -1.0;
        angle = a1;

        result.add( p1 ); // start with first point
        
        for(i = 0; i < ptcount - 1; i++)
        {
            pt = new Coordinate();
            result.add( pt );
            
            angle += increment;
            if(increment > 0.0 && angle > M_PI) angle -= 2*M_PI;
            if(increment < 0.0 && angle < -1*M_PI) angle -= 2*M_PI;
            
            pt.x = center.x + radius*cos(angle);
            pt.y = center.y + radius*sin(angle);
            /*
             //
             // update this code to handle interopolation of z and m values
             //
            if((sweep > 0 && angle < a2) || (sweep < 0 && angle > a2))
            {
                if((sweep > 0 && a1 < a2) || (sweep < 0 && a1 > a2))
                {
                        pbuf.z = interpolate_arc(angle, p1->z, a1, p2->z, a2);
                        pbuf.m = interpolate_arc(angle, p1->m, a1, p2->m, a2);
                }
                else
                {
                    if(sweep > 0)
                    {
                        pbuf.z = interpolate_arc(angle, p1->z, a1-(2*M_PI), p2->z, a2);
                        pbuf.m = interpolate_arc(angle, p1->m, a1-(2*M_PI), p2->m, a2);
                    }
                    else
                    {
                        pbuf.z = interpolate_arc(angle, p1->z, a1+(2*M_PI), p2->z, a2);
                        pbuf.m = interpolate_arc(angle, p1->m, a1+(2*M_PI), p2->m, a2);
                    }
                }
            }
            else
            {
                if((sweep > 0 && a2 < a3) || (sweep < 0 && a2 > a3))
                {
                    pbuf.z = interpolate_arc(angle, p2->z, a2, p3->z, a3);
                    pbuf.m = interpolate_arc(angle, p2->m, a2, p3->m, a3);
                }
                else
                {
                    if(sweep > 0)
                    {
                        pbuf.z = interpolate_arc(angle, p2->z, a2-(2*M_PI), p3->z, a3);
                        pbuf.m = interpolate_arc(angle, p2->m, a2-(2*M_PI), p3->m, a3);
                    }
                    else
                    {
                        pbuf.z = interpolate_arc(angle, p2->z, a2+(2*M_PI), p3->z, a3);
                        pbuf.m = interpolate_arc(angle, p2->m, a2+(2*M_PI), p3->m, a3);
                    }
                }
            }
            */
        }
        result.add( p3 );
 
        return result;
    }

