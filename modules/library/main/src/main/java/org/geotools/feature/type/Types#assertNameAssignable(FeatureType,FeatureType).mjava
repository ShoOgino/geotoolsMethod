    /**
     * FeatureType comparison indicating if the description provided by two FeatureTypes is similar
     * to the point data can be exchanged. This comparison is really very focused on the name /
     * value contract and is willing to overlook details like length restrictions.
     *
     * <p>When creating compatible FeatureTypes you will find some systems have different abilities
     * which is reflected in how well they support a given FeatureType.
     *
     * <p>As an example databases traditionally support variable length strings with a limit of 32
     * k; while a shapefile is limited to 256 characters. When working with data from both these
     * data sources you will need to make adjustments based on these abilities. If true is returned
     * data conforming to the expected FeatureType can be used with the actual FeatureType.
     *
     * <p>After assertOrderCovered returns without error the following code will work:
     *
     * <pre><code>
     * for( Property property : feature.getProperties() ){
     *     Object value = property.getValue();
     *
     *     Property target = newFeature.getProperty( property.getName().getLocalPart() );
     *     target.setValue( value );
     * }
     * </code></pre>
     *
     * Specifically this says that between the two feature types data is assignable on a name by
     * name basis.
     *
     * @param expected Expected FeatureType being used to compare against
     * @param actual Actual FeatureType
     * @return true if actual is equal to or a subset of the expected feature type.
     */
    public static void assertNameAssignable(FeatureType expected, FeatureType actual) {
        // check feature type name
        String expectedName = expected.getName().getLocalPart();
        String actualName = actual.getName().getLocalPart();
        if (!expectedName.equals(actualName)) {
            throw new IllegalAttributeException(
                    "Expected '" + expectedName + "' but was supplied '" + actualName + "'.");
        }
        // check attributes names
        Set<String> names = new TreeSet<String>();
        for (PropertyDescriptor descriptor : actual.getDescriptors()) {
            names.add(descriptor.getName().getLocalPart());
        }
        for (PropertyDescriptor descriptor : expected.getDescriptors()) {
            expectedName = descriptor.getName().getLocalPart();
            if (names.contains(expectedName)) {
                names.remove(expectedName); // only use once!
            } else {
                throw new IllegalAttributeException(
                        "Expected to find a match for '"
                                + expectedName
                                + "' but was not available remaining names: "
                                + names);
            }
        }
        if (!names.isEmpty()) {
            throw new IllegalAttributeException(
                    "Expected to find attributes '"
                            + expectedName
                            + "' but was not available remaining names: "
                            + names);
        }

        // check attribute bindings
        for (PropertyDescriptor expectedDescriptor : expected.getDescriptors()) {
            expectedName = expectedDescriptor.getName().getLocalPart();
            PropertyDescriptor actualDescriptor = actual.getDescriptor(expectedName);

            Class<?> expectedBinding = expectedDescriptor.getType().getBinding();
            Class<?> actualBinding = actualDescriptor.getType().getBinding();
            if (!actualBinding.isAssignableFrom(expectedBinding)) {
                throw new IllegalArgumentException(
                        "Expected "
                                + expectedBinding.getSimpleName()
                                + " for "
                                + expectedName
                                + " but was "
                                + actualBinding.getSimpleName());
            }
        }
    }

