    /**
     * Convenience method which evaluates the expressions and trys to align the values to be of the
     * same type.
     *
     * <p>If the values can not be aligned, the original values are returned.
     *
     * @return
     */
    protected Object[] eval(Object v1, Object v2) {
        if (v1 != null && v2 != null) {
            // try to convert so that values are of same type
            if (v1.getClass().equals(v2.getClass())) {
                // nothing to do
                return new Object[] {v1, v2};
            }

            // try safe conversions
            Hints hints = new Hints(ConverterFactory.SAFE_CONVERSION, Boolean.TRUE);
            Object o = Converters.convert(v2, v1.getClass(), hints);
            if (o != null) {
                return new Object[] {v1, o};
            }
            // try the other way
            o = Converters.convert(v1, v2.getClass(), hints);
            if (o != null) {
                return new Object[] {o, v2};
            }

            // unsafe conversions
            hints.put(ConverterFactory.SAFE_CONVERSION, Boolean.FALSE);
            o = Converters.convert(v2, v1.getClass(), hints);
            if (o != null) {
                return new Object[] {v1, o};
            }
            o = Converters.convert(v1, v2.getClass(), hints);
            if (o != null) {
                return new Object[] {o, v2};
            }
        }

        return new Object[] {v1, v2};
    }

