    protected List<Filter> basicOrSimplification(List<Filter> filters) {
        // perform range simplifications (by intersection), if possible
        if (rangeSimplicationEnabled && featureType != null && isSimpleFeature()) {
            RangeCombiner combiner = new RangeCombiner.Or(ff, featureType, filters);
            filters = combiner.getReducedFilters();
        }

        // eliminate include and exclude
        List<Filter> simplified = new ArrayList<>(filters.size());
        for (Filter child : filters) {
            // if any of the child filters is INCLUDE,
            // the whole chain of OR is equivalent to
            // INCLUDE
            if (child == Filter.INCLUDE) {
                return Arrays.asList(Filter.INCLUDE);
            }

            // these can be skipped
            if (child == Filter.EXCLUDE) {
                continue;
            }

            simplified.add(child);
        }

        // see if we have dual filters that can lead to Filter.Exclude, or duplicated filters
        for (int i = 0; i < simplified.size(); i++) {
            for (int j = i + 1; j < simplified.size(); ) {
                Filter f1 = simplified.get(i);
                Filter f2 = simplified.get(j);
                if (f1.equals(f2)) {
                    simplified.remove(j);
                } else if (dualFilters(f1, f2)) {
                    return Arrays.asList(Filter.INCLUDE);
                } else {
                    j++;
                }
            }
        }
        return simplified;
    }

