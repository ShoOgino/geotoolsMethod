    /**
     * Returns a set of envelopes that will be used to query the data given the specified rendering
     * envelope and the current query envelope
     */
    public List<ReferencedEnvelope> getQueryEnvelopes()
            throws TransformException, FactoryException {
        CoordinateReferenceSystem renderingCRS = renderingEnvelope.getCoordinateReferenceSystem();
        if (!queryAcrossDateline) {
            return Collections.singletonList(transformEnvelope(renderingEnvelope, sourceCRS));
        }
        if (renderingCRS instanceof GeographicCRS
                && !CRS.equalsIgnoreMetadata(renderingCRS, WGS84)) {
            // special case, if we just transform the coordinates are going to be wrapped by the
            // referencing
            // subsystem directly
            ReferencedEnvelope re = renderingEnvelope;
            List<ReferencedEnvelope> envelopes = new ArrayList<ReferencedEnvelope>();
            addTransformedEnvelope(re, envelopes);
            if (CRS.getAxisOrder(renderingCRS) == CRS.AxisOrder.NORTH_EAST) {
                if (re.getMinY() >= -180.0 && re.getMaxY() <= 180) {
                    return envelopes;
                }
                // We need to split reprojected envelope and normalize it. To be lenient with
                // situations in which the data is just broken (people saying 4326 just because they
                // have no idea at all) we don't actually split, but add elements
                if (re.getMinY() < -180) {
                    ReferencedEnvelope envelope =
                            new ReferencedEnvelope(
                                    re.getMinX(),
                                    re.getMaxX(),
                                    re.getMinY() + 360,
                                    Math.min(re.getMaxY() + 360, 180),
                                    re.getCoordinateReferenceSystem());
                    addTransformedEnvelope(envelope, envelopes);
                }
                if (re.getMaxY() > 180) {
                    ReferencedEnvelope envelope =
                            new ReferencedEnvelope(
                                    re.getMinX(),
                                    re.getMaxX(),
                                    Math.max(re.getMinY() - 360, -180),
                                    re.getMaxY() - 360,
                                    re.getCoordinateReferenceSystem());
                    addTransformedEnvelope(envelope, envelopes);
                }
            } else {
                if (re.getMinX() >= -180.0 && re.getMaxX() <= 180) {
                    return Collections.singletonList(
                            transformEnvelope(renderingEnvelope, sourceCRS));
                }
                // We need to split reprojected envelope and normalize it. To be lenient with
                // situations in which the data is just broken (people saying 4326 just because they
                // have no idea at all) we don't actually split, but add elements
                if (re.getMinX() < -180) {
                    ReferencedEnvelope envelope =
                            new ReferencedEnvelope(
                                    re.getMinX() + 360,
                                    Math.min(re.getMaxX() + 360, 180),
                                    re.getMinY(),
                                    re.getMaxY(),
                                    re.getCoordinateReferenceSystem());
                    addTransformedEnvelope(envelope, envelopes);
                }
                if (re.getMaxX() > 180) {
                    ReferencedEnvelope envelope =
                            new ReferencedEnvelope(
                                    Math.max(re.getMinX() - 360, -180),
                                    re.getMaxX() - 360,
                                    re.getMinY(),
                                    re.getMaxY(),
                                    re.getCoordinateReferenceSystem());
                    addTransformedEnvelope(envelope, envelopes);
                }
            }
            mergeEnvelopes(envelopes);
            return envelopes;
        } else {
            if (!Double.isNaN(datelineX)
                    && renderingEnvelope.getMinX() < datelineX
                    && renderingEnvelope.getMaxX() > datelineX
                    && renderingEnvelope.getWidth() < radius) {
                double minX = renderingEnvelope.getMinX();
                double minY = renderingEnvelope.getMinY();
                double maxX = renderingEnvelope.getMaxX();
                double maxY = renderingEnvelope.getMaxY();
                ReferencedEnvelope re1 =
                        new ReferencedEnvelope(minX, datelineX - EPS, minY, maxY, renderingCRS);
                List<ReferencedEnvelope> result = new ArrayList<ReferencedEnvelope>();
                ReferencedEnvelope tx1 = transformEnvelope(re1, WGS84);
                if (tx1 != null) {
                    tx1.expandToInclude(180, tx1.getMinY());
                    addTransformedEnvelope(tx1, result);
                }
                ReferencedEnvelope re2 =
                        new ReferencedEnvelope(datelineX + EPS, maxX, minY, maxY, renderingCRS);
                ReferencedEnvelope tx2 = transformEnvelope(re2, WGS84);
                if (tx2 != null) {
                    if (tx2.getMinX() > 180) {
                        tx2.translate(-360, 0);
                    }
                    tx2.expandToInclude(-180, tx1.getMinY());
                    addTransformedEnvelope(tx2, result);
                }

                mergeEnvelopes(result);
                return result;
            } else {
                return getSourceEnvelopes(renderingEnvelope);
            }
        }
    }

