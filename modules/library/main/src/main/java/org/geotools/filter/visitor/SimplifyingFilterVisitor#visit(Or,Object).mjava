    @Override
    public Object visit(Or filter, Object extraData)
    {
        // scan, clone and simplify the children
        List<Filter> newChildren = new ArrayList<Filter>(filter.getChildren().size());
        for (Filter child : filter.getChildren())
        {
            Filter cloned = (Filter) child.accept(this, extraData);

            // if any of the child filters is INCLUDE,
            // the whole chain of OR is equivalent to
            // INCLUDE
            if (cloned == Filter.INCLUDE)
            {
                return Filter.INCLUDE;
            }

            // these can be skipped
            if (cloned == Filter.EXCLUDE)
            {
                continue;
            }

            if (cloned instanceof Or)
            {
                Or or = (Or) cloned;
                newChildren.addAll(or.getChildren());
            }
            else
            {
                newChildren.add(cloned);
            }
        }
        
        // we might end up with an empty list
        if (newChildren.size() == 0)
        {
            return Filter.EXCLUDE;
        }

        // remove the logic we have only one filter
        if (newChildren.size() == 1)
        {
            return newChildren.get(0);
        }
        
        // see if we have dual filters that can lead to Filter.INCLUDE
        for (int i = 0; i < newChildren.size(); i++) {
            for(int j = i + 1; j < newChildren.size(); j++) {
                Filter f1 = newChildren.get(i);
                Filter f2 = newChildren.get(j);
                if(unionIsInclude(f1, f2)) {
                    return Filter.INCLUDE;
                }
            }
        }

        // else return the cloned and simplified up list
        return getFactory(extraData).or(newChildren);
    }

