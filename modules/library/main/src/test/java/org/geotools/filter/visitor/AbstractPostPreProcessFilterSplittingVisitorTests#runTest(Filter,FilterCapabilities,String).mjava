	/**
	 * Runs 3 tests.  1 with out filtercapabilities containing filter type.  1 with filter caps containing filter type
	 * 1 with an edit to the attribute being queried by filter.
	 * @param filter filter to process
	 * @param filterTypeMask the constant in {@link FilterCapabilities} that is equivalent to the FilterType used in filter
	 * @param attToEdit the attribute in filter that is queried.  If null then edit test is not ran.
	 */
	protected void runTest(Filter filter, FilterCapabilities supportedCaps, String attToEdit) throws SchemaException {
		// initialize fields that might be previously modified in current test
        PostPreProcessFilterSplittingVisitor visitor=newVisitor(new FilterCapabilities()); 
		if (accessor!=null )
		accessor.setUpdate("",null);

		// Testing when FilterCapabilites indicate that filter type is not supported
		filter.accept(visitor, null);

		assertEquals(filter, visitor.getFilterPost());
		assertEquals(Filter.INCLUDE, visitor.getFilterPre());
		
		// now filter type is supported
		visitor=newVisitor(supportedCaps);
		
        filter.accept(visitor, null);
		
		assertEquals(Filter.INCLUDE, visitor.getFilterPost());
		assertEquals(filter, visitor.getFilterPre());
		
		if (attToEdit != null && accessor!=null ) {
			// Test when the an update exists that affects the attribute of a
			// feature
            HashSet idSet = new HashSet();
            idSet.add(ff.featureId("fid"));
			Id updateFilter = ff.id(idSet);

			accessor.setUpdate(attToEdit, updateFilter);

			visitor = newVisitor(supportedCaps);

            filter.accept(visitor, null);

			assertEquals(filter, visitor.getFilterPost());
			assertEquals(ff.or(filter, updateFilter), visitor.getFilterPre());
		}
	}

