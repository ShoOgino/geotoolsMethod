    /**
     * This method is called when the parser close a node. Here is built the filters an expressions
     * recognized in the parsing process.
     *
     * @param n a Node instance
     * @return Filter or Expression
     * @throws CQLException
     */
    private Object build(Node n) throws CQLException {

        switch (n.getType()) {

                // ----------------------------------------
                // (+|-) Integer and Float
                // ----------------------------------------
            case JJTINTEGERNODE:
                return this.builder.buildLiteralInteger(getTokenInPosition(0).toString());
            case JJTFLOATINGNODE:
                return this.builder.buildLiteralDouble(getTokenInPosition(0).toString());
            case JJTNEGATIVENUMBER_NODE:
                return this.builder.bulidNegativeNumber();

                // ----------------------------------------
                // String
                // ----------------------------------------
            case JJTSTRINGNODE:
                return this.builder.buildLiteralString(getTokenInPosition(0).toString());

                // ----------------------------------------
                // Identifier
                // ----------------------------------------
            case JJTIDENTIFIER_NODE:
                return this.builder.buildIdentifier(JJTIDENTIFIER_PART_NODE);

            case JJTIDENTIFIER_PART_NODE:
                return this.builder.buildIdentifierPart(getTokenInPosition(0));

                // ----------------------------------------
                // attribute
                // ----------------------------------------
            case JJTSIMPLE_ATTRIBUTE_NODE:
                return this.builder.buildSimpleAttribute();

            case JJTCOMPOUND_ATTRIBUTE_NODE:
                return this.builder.buildCompoundAttribute(
                        JJTSIMPLE_ATTRIBUTE_NODE, ATTRIBUTE_PATH_SEPARATOR);

                // ----------------------------------------
                // function
                // ----------------------------------------
            case JJTFUNCTION_NODE:
                return this.builder.buildFunction(JJTFUNCTIONNAME_NODE);

            case JJTFUNCTIONNAME_NODE:
                return n; // used as mark of function name in stack

            case JJTFUNCTIONARG_NODE:
                return n; // used as mark of args in stack

                // Math Nodes
            case JJTADDNODE:
            case JJTSUBTRACTNODE:
            case JJTMULNODE:
            case JJTDIVNODE:
                return buildBinaryExpression(n.getType());

                // Boolean expression
            case JJTBOOLEAN_AND_NODE:
                return buildLogicFilter(JJTBOOLEAN_AND_NODE);

            case JJTBOOLEAN_OR_NODE:
                return buildLogicFilter(JJTBOOLEAN_OR_NODE);

            case JJTBOOLEAN_NOT_NODE:
                return buildLogicFilter(JJTBOOLEAN_NOT_NODE);

                // ----------------------------------------
                // between predicate actions
                // ----------------------------------------
            case JJTBETWEEN_NODE:
                return this.builder.buildBetween();

            case JJTNOT_BETWEEN_NODE:
                return this.builder.buildNotBetween();

                // ----------------------------------------
                // Compare predicate actions
                // ----------------------------------------
            case JJTCOMPARISONPREDICATE_EQ_NODE:
            case JJTCOMPARISONPREDICATE_GT_NODE:
            case JJTCOMPARISONPREDICATE_LT_NODE:
            case JJTCOMPARISONPREDICATE_GTE_NODE:
            case JJTCOMPARISONPREDICATE_LTE_NODE:
                return buildBinaryComparasionOperator(n.getType());

            case JJTCOMPARISONPREDICATE_NOT_EQUAL_NODE:
                Filter eq = buildBinaryComparasionOperator(JJTCOMPARISONPREDICATE_EQ_NODE);
                Not notFilter = this.builder.buildNotFilter(eq);

                return notFilter;

                // ----------------------------------------
                // Text predicate (Like)
                // ----------------------------------------
            case JJTLIKE_NODE:
                return this.builder.buildLikeFilter(true);

            case JJTNOT_LIKE_NODE:
                return this.builder.buildNotLikeFilter(true);

                // ----------------------------------------
                // Text predicate (ILike)
                // ----------------------------------------
            case JJTILIKE_NODE:
                return this.builder.buildLikeFilter(false);

            case JJTNOT_ILIKE_NODE:
                return this.builder.buildNotLikeFilter(false);

                // ----------------------------------------
                // Null predicate
                // ----------------------------------------
            case JJTNULLPREDICATENODE:
                return this.builder.buildPropertyIsNull();

            case JJTNOTNULLPREDICATENODE:
                return this.builder.buildPorpertyNotIsNull();

                // ----------------------------------------
                // temporal predicate actions
                // ----------------------------------------
            case JJTDATE_NODE:
                return this.builder.buildDateExpression(getTokenInPosition(0));

            case JJTDATETIME_NODE:
                return this.builder.buildDateTimeExpression(getTokenInPosition(0));

            case JJTDURATION_DATE_NODE:
                return this.builder.buildDurationExpression(getTokenInPosition(0));

            case JJTPERIOD_BETWEEN_DATES_NODE:
                return this.builder.buildPeriodBetweenDates();

            case JJTPERIOD_WITH_DATE_DURATION_NODE:
                return this.builder.buildPeriodDateAndDuration();

            case JJTPERIOD_WITH_DURATION_DATE_NODE:
                return this.builder.buildPeriodDurationAndDate();

            case JJTTPTEQUALS_DATETIME_NODE:
                return this.builder.buildTEquals();

            case JJTTPBEFORE_DATETIME_NODE:
                return buildBefore();

            case JJTTPAFTER_DATETIME_NODE:
                return buildAfterPredicate();

            case JJTTPDURING_PERIOD_NODE:
                return buildDuring();

            case JJTTPBEFORE_OR_DURING_PERIOD_NODE:
                return buildBeforeOrDuring();

            case JJTTPDURING_OR_AFTER_PERIOD_NODE:
                return buildDuringOrAfter();

                // ----------------------------------------
                // existence predicate actions
                // ----------------------------------------
            case JJTEXISTENCE_PREDICATE_EXISTS_NODE:
                return this.builder.buildPropertyExists();

            case JJTEXISTENCE_PREDICATE_DOESNOTEXIST_NODE:
                Filter filter = this.builder.buildPropertyExists();
                Filter filterPropNotExist = this.builder.buildNotFilter(filter);

                return filterPropNotExist;

                // ----------------------------------------
                // routine invocation Geo Operation
                // ----------------------------------------
            case JJTROUTINEINVOCATION_GEOOP_EQUAL_NODE:
            case JJTROUTINEINVOCATION_GEOOP_DISJOINT_NODE:
            case JJTROUTINEINVOCATION_GEOOP_INTERSECT_NODE:
            case JJTROUTINEINVOCATION_GEOOP_TOUCH_NODE:
            case JJTROUTINEINVOCATION_GEOOP_CROSS_NODE:
            case JJTROUTINEINVOCATION_GEOOP_WITHIN_NODE:
            case JJTROUTINEINVOCATION_GEOOP_CONTAIN_NODE:
            case JJTROUTINEINVOCATION_GEOOP_OVERLAP_NODE:
                return buildBinarySpatialOperator(n.getType());

            case JJTROUTINEINVOCATION_GEOOP_BBOX_NODE:
            case JJTROUTINEINVOCATION_GEOOP_BBOX_SRS_NODE:
                return buildBBox(n.getType());

            case JJTROUTINEINVOCATION_GEOOP_RELATE_NODE:
                return this.builder.buildSpatialRelateFilter();

            case JJTDE9IM_NODE:
                return this.builder.buildDE9IM(getToken(0).image);

                // ----------------------------------------
                // routine invocation RelGeo Operation
                // ----------------------------------------
            case JJTTOLERANCE_NODE:
                return this.builder.buildTolerance();

            case JJTDISTANCEUNITS_NODE:
                return this.builder.buildDistanceUnit(getTokenInPosition(0));

            case JJTROUTINEINVOCATION_RELOP_BEYOND_NODE:
            case JJTROUTINEINVOCATION_RELOP_DWITHIN_NODE:
                return buildDistanceBufferOperator(n.getType());

                // ----------------------------------------
                // Geometries:
                // ----------------------------------------
            case JJTPOINT_NODE:
                return this.builder.buildCoordinate();

            case JJTPOINTTEXT_NODE:
                return this.builder.buildPointText();

            case JJTLINESTRINGTEXT_NODE:
                return this.builder.buildLineString(JJTPOINT_NODE);

            case JJTPOLYGONTEXT_NODE:
                return this.builder.buildPolygon(JJTLINESTRINGTEXT_NODE);

            case JJTMULTIPOINTTEXT_NODE:
                return this.builder.buildMultiPoint(JJTPOINTTEXT_NODE);

            case JJTMULTILINESTRINGTEXT_NODE:
                return this.builder.buildMultiLineString(JJTLINESTRINGTEXT_NODE);

            case JJTMULTIPOLYGONTEXT_NODE:
                return this.builder.buildMultiPolygon(JJTPOLYGONTEXT_NODE);

            case JJTREFERENCEDGEOMETRYLITERAL:
                return this.builder.buildReferencedGeometryLiteral();

            case JJTGEOMETRYLITERAL:
                return this.builder.buildGeometryLiteral();

            case JJTSIMPLEGEOMETRYLITERAL:
                return this.builder.buildSimpleGeometryLiteral();

            case JJTGEOMETRYCOLLECTIONTEXT_NODE:
                return this.builder.buildGeometryCollection(JJTSIMPLEGEOMETRYLITERAL);

            case JJTWKTNODE:
                return this.builder.buildGeometry();

            case JJTENVELOPETAGGEDTEXT_NODE:
                return this.builder.buildEnvelop(TokenAdapter.newAdapterFor(n.getToken()));

            case JJTINCLUDE_NODE:
                return Filter.INCLUDE;

            case JJTEXCLUDE_NODE:
                return Filter.EXCLUDE;

            case JJTTRUENODE:
                return this.builder.buildTrueLiteral();

            case JJTFALSENODE:
                return this.builder.buildFalseLiteral();

                // ----------------------------------------
                //  ID Predicate
                // ----------------------------------------
            case JJTFEATURE_ID_NODE:
                return this.builder.buildFeatureID(getTokenInPosition(0));

            case JJTID_PREDICATE_NODE:
                return this.builder.buildFilterId(JJTFEATURE_ID_NODE);
                // ----------------------------------------
                //  IN Predicate
                // ----------------------------------------
            case JJTIN_PREDICATE_NODE:
                return this.builder.buildInPredicate(JJTEXPRESSION_IN_LIST_NODE);

            case JJTNOT_IN_PREDICATE_NODE:
                Or orFilter = this.builder.buildInPredicate(JJTEXPRESSION_IN_LIST_NODE);
                Not notOrFilter = this.builder.buildNotFilter(orFilter);

                return notOrFilter;
        }

        return null;
    }

