    /**
	 * Computes the intersection of two {@link Envelope}s.
	 * 
	 * @param env
	 *            the envelope to intersect with
	 * @return a new Envelope representing the intersection of the envelopes
	 *         (this will be the null envelope if either argument is null, or
	 *         they do not intersect
	 */
	public ReferencedEnvelope3D intersection(ReferencedEnvelope3D env) {
		ensureCompatibleReferenceSystem( env );
		
		if (isNull() || env.isNull() || !intersects( env))
			return new ReferencedEnvelope3D();

		double intMinX = getMinX() > env.getMinX() ? getMinX() : env.getMinX();
		double intMinY = getMinY() > env.getMinY() ? getMinY() : env.getMinY();
		double intMinZ = minz > env.minz ? minz : env.minz;
		double intMaxX = getMaxX() < env.getMaxX() ? getMaxX() : env.getMaxX();
		double intMaxY = getMaxY() < env.getMaxY() ? getMaxY() : env.getMaxY();
		double intMaxZ = maxz < env.maxz ? maxz : env.maxz;

		return new ReferencedEnvelope3D(intMinX, intMaxX, intMinY, intMaxY, intMinZ, intMaxZ, env.getCoordinateReferenceSystem());
	}

