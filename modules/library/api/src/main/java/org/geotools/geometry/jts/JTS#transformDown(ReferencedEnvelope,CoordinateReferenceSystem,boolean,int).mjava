    /**
     * Transform from 3D down to 2D.
     * <p>
     * This method transforms each ordinate into WGS84, manually converts this to WGS84_3D with
     * the addition of a Double.NaN, and then transforms to the final 3D position.
     * 
     * @param sourceEnvelope
     * @param targetEnvelope
     * @param transform
     * @param npoints
     * @return ReferencedEnvelope matching provided 2D TargetCRS
     * @throws TransformException
     */
    public static ReferencedEnvelope transformDown(final ReferencedEnvelope sourceEnvelope,
            CoordinateReferenceSystem targetCRS, boolean lenient, int npoints)
            throws TransformException, OperationNotFoundException, FactoryException {
        final double xmin = sourceEnvelope.getMinX();
        final double xmax = sourceEnvelope.getMaxX();
        final double ymin = sourceEnvelope.getMinY();
        final double ymax = sourceEnvelope.getMaxY();
        final double scaleX = (xmax - xmin) / npoints;
        final double scaleY = (ymax - ymin) / npoints;
        
        final double zmin = sourceEnvelope.getMinimum(2);
        final double zmax = sourceEnvelope.getMaximum(2);
        final double z = (zmax-zmin) / 2; // just average is fine as we are trying to remove height
        
        ReferencedEnvelope targetEnvelope = new ReferencedEnvelope( targetCRS );
        
        /*
         * Gets a first estimation using an algorithm capable to take singularity in account
         * (North pole, South pole, 180ï¿½ longitude). We will expand this initial box later.
         */
        CoordinateOperationFactory coordinateOperationFactory = CRS
                .getCoordinateOperationFactory(lenient);
        CoordinateOperation operation1 = coordinateOperationFactory.createOperation(
                sourceEnvelope.getCoordinateReferenceSystem(), DefaultGeographicCRS.WGS84);
        MathTransform transform1 = operation1.getMathTransform();
        final CoordinateOperation operation2 = coordinateOperationFactory.createOperation(
                DefaultGeographicCRS.WGS84, targetCRS);
        MathTransform transform2 = operation2.getMathTransform();
    
        for( int t = 0; t < npoints; t++ ){
            double dx = scaleX * t;
            double dy = scaleY * t;
            
            GeneralDirectPosition position = new GeneralDirectPosition( sourceEnvelope.getCoordinateReferenceSystem());
            position.setOrdinate(0, xmin );
            position.setOrdinate(1, ymin+dy);
            position.setOrdinate(2, z );
            
            DirectPosition pt = transformDown( position, transform1, transform2 );
            targetEnvelope.expandToInclude(pt);
            
            GeneralDirectPosition top = new GeneralDirectPosition( xmin+dx, ymax, z);
            pt = transformDown( top, transform1, transform2 );
            targetEnvelope.expandToInclude(pt);
            
            GeneralDirectPosition right = new GeneralDirectPosition( xmax, ymin-dy, z);
            pt = transformDown( right, transform1, transform2 );
            targetEnvelope.expandToInclude(pt);
            
            GeneralDirectPosition bottom = new GeneralDirectPosition( xmax-dx, ymax, z);
            pt = transformDown( bottom, transform1, transform2 );
            targetEnvelope.expandToInclude(pt);
        }
        return targetEnvelope;
    }

