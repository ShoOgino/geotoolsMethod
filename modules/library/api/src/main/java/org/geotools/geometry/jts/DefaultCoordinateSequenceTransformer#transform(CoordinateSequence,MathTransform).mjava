    /** {@inheritDoc} */
    public CoordinateSequence transform(
            final CoordinateSequence sequence, final MathTransform transform)
            throws TransformException {
        final int sourceDim = transform.getSourceDimensions();
        final int targetDim = transform.getTargetDimensions();
        final int size = sequence.size();
        final Coordinate[] tcs = new Coordinate[size];
        final int bufferCapacity = buffer.length / Math.max(sourceDim, targetDim);
        int remainingBeforeFlush = Math.min(bufferCapacity, size);
        int ib = 0; // Index in the buffer array.
        int it = 0; // Index in the target sequence.

        // create a target CS so that the dimensions not contemplated in the source CS
        // are copied over (think Z or M with a 2d CRS)
        int targetCSDim = targetDim + (sequence.getDimension() - sourceDim);
        CoordinateSequence result = JTS.createCS(csFactory, sequence.size(), targetCSDim);

        for (int i = 0; i < size; i++) {
            switch (sourceDim) {
                default:
                    throw new MismatchedDimensionException();

                case 3:
                    buffer[ib + 2] = sequence.getOrdinate(i, 2); // Fall through

                case 2:
                    buffer[ib + 1] = sequence.getY(i); // Fall through

                case 1:
                    buffer[ib] = sequence.getX(i); // Fall through

                case 0:
                    break;
            }

            ib += sourceDim;

            if (--remainingBeforeFlush == 0) {
                /*
                 * The buffer is full, or we just copied the last coordinates.
                 * Transform the coordinates and flush to the destination array.
                 */
                assert (ib % sourceDim) == 0;

                final int n = ib / sourceDim;
                transform.transform(buffer, 0, buffer, 0, n);
                ib = 0;

                for (int j = 0; j < n; j++) {
                    // final Coordinate t;

                    // copy the transformed portion
                    int oi = 0;
                    for (; oi < targetDim; oi++) {
                        result.setOrdinate(it, oi, buffer[ib++]);
                    }
                    // copy over the non transformed portion
                    for (; oi < targetCSDim; oi++) {
                        result.setOrdinate(
                                it, oi, sequence.getOrdinate(it, oi + (targetDim - sourceDim)));
                    }
                    // force to NaN eventual extra ordinates the sequence has (some are fixed size,
                    // wont'
                    // care about us trying to tell them a size). This works around a bug in the
                    // default
                    // JTS coordinate sequence implementation
                    for (; oi < result.getDimension(); oi++) {
                        result.setOrdinate(it, oi, Double.NaN);
                    }
                    it++;
                }
                assert ib == (n * targetDim);
                ib = 0;
                remainingBeforeFlush = Math.min(bufferCapacity, size - (i + 1));
            }
        }
        assert it == tcs.length : tcs.length - it;

        return result;
    }

