    @Override
    protected void connect() throws Exception {
        super.connect();

        // a plain view without specs, used to check we guess the geometry field properly
        StringBuffer sb = new StringBuffer();
        sb.append("select * from ");
        if (dbSchemaName != null) {
            dialect.encodeSchemaName(dbSchemaName, sb);
            sb.append(".");
        }
        dialect.encodeTableName(tname("river"), sb);
        VirtualTable vt = new VirtualTable("riverFull", sb.toString());
        dataStore.createVirtualTable(vt);

        sb.append(" where 1 = 1 :where_clause:");
        vt = new VirtualTable("riverFullPlaceHolder", sb.toString());
        dataStore.createVirtualTable(vt);

        // a first vt with a condition, computing a new field
        sb = new StringBuffer();
        sb.append("select ");
        dialect.encodeColumnName(null, aname("id"), sb);
        sb.append(", ");
        dialect.encodeColumnName(null, aname("geom"), sb);
        sb.append(", ");
        dialect.encodeColumnName(null, aname("river"), sb);
        sb.append(", ");
        dialect.encodeColumnName(null, aname("flow"), sb);
        sb.append(" * 2 as ");
        dialect.encodeColumnName(null, aname("doubleFlow"), sb);
        sb.append(" from ");
        if (dbSchemaName != null) {
            dialect.encodeSchemaName(dbSchemaName, sb);
            sb.append(".");
        }
        dialect.encodeTableName(tname("river"), sb);
        sb.append(" where ");
        dialect.encodeColumnName(null, aname("flow"), sb);
        sb.append(" > 4");
        vt = new VirtualTable("riverReduced", sb.toString());
        vt.addGeometryMetadatata(aname("geom"), LineString.class, 4326);
        dataStore.createVirtualTable(vt);

        // same vt, this time with a sql comment
        sb.append("\n--This is a comment");
        vt = new VirtualTable("riverReducedComment", sb.toString());
        vt.addGeometryMetadatata(aname("geom"), LineString.class, 4326);
        dataStore.createVirtualTable(vt);

        // the same vt, but with a id specification
        vt = new VirtualTable("riverReducedPk", sb.toString());
        vt.addGeometryMetadatata(aname("geom"), LineString.class, 4326);
        vt.setPrimaryKeyColumns(Arrays.asList(aname("id")));
        dataStore.createVirtualTable(vt);

        // a final vt with some parameters
        sb = new StringBuffer();
        sb.append("select ");
        dialect.encodeColumnName(null, aname("id"), sb);
        sb.append(", ");
        dialect.encodeColumnName(null, aname("geom"), sb);
        sb.append(", ");
        dialect.encodeColumnName(null, "flow", sb);
        sb.append(" * %mul% as ");
        dialect.encodeColumnName(null, "mulflow", sb);
        sb.append(" from ");
        if (dbSchemaName != null) {
            dialect.encodeSchemaName(dbSchemaName, sb);
            sb.append(".");
        }
        dialect.encodeTableName(tname("river"), sb);
        sb.append(" %where%");
        vt = new VirtualTable("riverParam", sb.toString());
        vt.addGeometryMetadatata(aname("geom"), LineString.class, 4326);
        vt.addParameter(
                new VirtualTableParameter("mul", "1", new RegexpValidator("[\\d\\.e\\+-]+")));
        vt.addParameter(new VirtualTableParameter("where", ""));
        dataStore.createVirtualTable(vt);
    }

