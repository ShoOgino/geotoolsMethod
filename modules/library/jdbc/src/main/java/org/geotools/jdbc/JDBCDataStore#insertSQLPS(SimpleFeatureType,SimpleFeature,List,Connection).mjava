    /**
     * Generates a 'INSERT INFO' prepared statement.
     */
    protected PreparedStatement insertSQLPS(SimpleFeatureType featureType, SimpleFeature feature, List keyValues, Connection cx) 
        throws IOException, SQLException {
        PreparedStatementSQLDialect dialect = (PreparedStatementSQLDialect) getSQLDialect();
        
        // grab the primary key and collect the pk column names 
        PrimaryKey key = null; 
        try {
            key = getPrimaryKey(featureType);
        } catch (IOException e) {
            throw new RuntimeException( e );
        }
        Set<String> pkColumnNames = getColumnNames(key);
        
        StringBuffer sql = new StringBuffer();
        sql.append("INSERT INTO ");
        encodeTableName(featureType.getTypeName(), sql, null);

        // column names
        sql.append(" ( ");

        for (int i = 0; i < featureType.getAttributeCount(); i++) {
            String colName = featureType.getDescriptor(i).getLocalName();
            // skip the pk columns in case we have exposed them
            if(pkColumnNames.contains(colName)) {
                continue;
            }

            dialect.encodeColumnName(colName, sql);
            sql.append(",");
        }

        // primary key values
        boolean useExisting = Boolean.TRUE.equals(feature.getUserData().get(Hints.USE_PROVIDED_FID));
        for (PrimaryKeyColumn col : key.getColumns() ) {
            //only include if its non auto generating
            if ( !(col instanceof AutoGeneratedPrimaryKeyColumn ) || useExisting ) {
                dialect.encodeColumnName(col.getName(), sql);
                sql.append( ",");
            }
        }
        sql.setLength(sql.length() - 1);

        // values
        sql.append(" ) VALUES ( ");
        for (AttributeDescriptor att : featureType.getAttributeDescriptors()) {
            String colName = att.getLocalName();
            // skip the pk columns in case we have exposed them, we grab the
            // value from the pk itself
            if(pkColumnNames.contains(colName)) {
                continue;
            }
            
            // geometries might need special treatment, delegate to the dialect
            if(att instanceof GeometryDescriptor) {
                Geometry geometry = (Geometry) feature.getAttribute(att.getName());
                dialect.prepareGeometryValue(geometry, getDescriptorDimension(att), getDescriptorSRID(att), att.getType().getBinding(),  sql );
            } else {
                sql.append("?");
            }
            sql.append(",");
        }
        for (PrimaryKeyColumn col : key.getColumns() ) {
            //only include if its non auto generating
            if ( !(col instanceof AutoGeneratedPrimaryKeyColumn ) || useExisting) {
                sql.append("?").append( ",");
            }
        }
        
        sql.setLength(sql.length()-1);
        sql.append(")");
        LOGGER.log(Level.FINE, "Inserting new feature with ps: {0}", sql);
        
        //create the prepared statement
        PreparedStatement ps = cx.prepareStatement(sql.toString());
        
        //set the attribute values
        int i = 1;
        for(AttributeDescriptor att : featureType.getAttributeDescriptors()) {
            String colName = att.getLocalName();
            // skip the pk columns in case we have exposed them, we grab the
            // value from the pk itself
            if(pkColumnNames.contains(colName)) {
                continue;
            }
            
            Class binding = att.getType().getBinding();

            Object value = feature.getAttribute(colName);
            if (value == null) {
                if (!att.isNillable()) {
                    //TODO: throw an exception    
                }
            }
            
            if (Geometry.class.isAssignableFrom(binding)) {
                Geometry g = (Geometry) value;
                int srid = getGeometrySRID(g, att);
                int dimension = getGeometryDimension(g, att);
                dialect.setGeometryValue( g, dimension, srid, binding, ps, i );
            } else {
                dialect.setValue( value, binding, ps, i, cx );
            }
            if ( LOGGER.isLoggable( Level.FINE ) ) {
                LOGGER.fine( (i) + " = " + value );    
            }
            i++;
        }
        
        //set the key values 
        //mind, we are reusing the i index from the previous loop
        for ( int j = 0; j < key.getColumns().size(); j++ ) {
            PrimaryKeyColumn col = key.getColumns().get( j );
            //only include if its non auto generating
            if (!(col instanceof AutoGeneratedPrimaryKeyColumn ) || useExisting) {
                //get the next value for the column
                //Object value = getNextValue( col, key, cx );
                Object value = keyValues.get( j );
                dialect.setValue( value, col.getType(), ps, i, cx);
                i++;
                if ( LOGGER.isLoggable( Level.FINE ) ) {
                    LOGGER.fine( (i) + " = " + value );    
                }
            }
        }
        
        return ps;
    }

