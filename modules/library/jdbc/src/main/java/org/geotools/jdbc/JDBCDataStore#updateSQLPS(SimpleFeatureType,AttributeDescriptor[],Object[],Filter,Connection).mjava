    /**
     * Generates an 'UPDATE' prepared statement.
     */
    protected PreparedStatement updateSQLPS(SimpleFeatureType featureType, AttributeDescriptor[] attributes,
            Object[] values, Filter filter, Connection cx ) throws IOException, SQLException {
        PreparedStatementSQLDialect dialect = (PreparedStatementSQLDialect) getSQLDialect();
        
        // grab the primary key and collect the pk column names 
        PrimaryKey key = null; 
        try {
            key = getPrimaryKey(featureType);
        } catch (IOException e) {
            throw new RuntimeException( e );
        }
        Set<String> pkColumnNames = getColumnNames(key);
        
        StringBuffer sql = new StringBuffer();
        sql.append("UPDATE ");
        encodeTableName(featureType.getTypeName(), sql, null);

        sql.append(" SET ");

        for (int i = 0; i < attributes.length; i++) {
            // skip exposed primary key values, they are read only
            AttributeDescriptor att = attributes[i];
            String attName = att.getLocalName();
            if(pkColumnNames.contains(attName)) {
                continue;
            }
            
            dialect.encodeColumnName(attName, sql);
            sql.append(" = ");
            
            // geometries might need special treatment, delegate to the dialect
            if(attributes[i] instanceof GeometryDescriptor) {
                Geometry geometry = (Geometry) values[i];
                final Class<?> binding = att.getType().getBinding();
                dialect.prepareGeometryValue(geometry, getDescriptorSRID(att), binding,  sql );
            } else {
                sql.append("?");
            }
            sql.append(",");
        }
        sql.setLength(sql.length() - 1);
        sql.append(" ");

        PreparedFilterToSQL toSQL = null;
        if (filter != null  && !Filter.INCLUDE.equals(filter)) {
            //encode filter
            try {
                toSQL = createPreparedFilterToSQL(featureType);
                sql.append(" ").append(toSQL.encodeToString(filter));
            } catch (FilterToSQLException e) {
                throw new RuntimeException(e);
            }
        }
        
        PreparedStatement ps = cx.prepareStatement(sql.toString());
        LOGGER.log(Level.FINE, "Updating features with prepared statement: {0}", sql);
        
        int i = 0;
        int j = 0;
        for (; i < attributes.length; i++) {
            // skip exposed primary key columns
            AttributeDescriptor att = attributes[i];
            String attName = att.getLocalName();
            if(pkColumnNames.contains(attName)) {
                continue;
            }
            
            Class binding = att.getType().getBinding();
            if (Geometry.class.isAssignableFrom( binding ) ) {
                Geometry g = (Geometry) values[i];
                dialect.setGeometryValue(g, getDescriptorSRID(att), binding, ps, j+1);
            } else {
                dialect.setValue( values[i], binding, ps, j+1, cx);    
            }
            if ( LOGGER.isLoggable( Level.FINE ) ) {
                LOGGER.fine( (j+1) + " = " + values[i] );
            }
            // we do this only if we did not skip the exposed pk
            j++;
        }
        
        if ( toSQL != null ) {
            setPreparedFilterValues(ps, toSQL, i, cx);
            //for ( int j = 0; j < toSQL.getLiteralValues().size(); j++, i++)  {
            //    Object value = toSQL.getLiteralValues().get( j );
            //    Class binding = toSQL.getLiteralTypes().get( j );
            //    
            //    dialect.setValue( value, binding, ps, i+1, cx );
            //    if ( LOGGER.isLoggable( Level.FINE ) ) {
            //        LOGGER.fine( (i+1) + " = " + value );
            //}
        }
        
        return ps;
    }

