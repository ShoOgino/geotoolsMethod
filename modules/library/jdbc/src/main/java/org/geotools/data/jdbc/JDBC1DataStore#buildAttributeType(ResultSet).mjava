	/**
	 * Constructs an AttributeDescriptor from a row in a ResultSet. The ResultSet
	 * contains the information retrieved by a call to getColumns() on the
	 * DatabaseMetaData object. This information can be used to construct an
	 * Attribute Type.
	 *
	 * <p>
	 * The default implementation constructs an AttributeDescriptor using the default
	 * JDBC type mappings defined in JDBCDataStore. These type mappings only
	 * handle native Java classes and SQL standard column types, so to handle
	 * Geometry columns, sub classes should override this to check if a column
	 * is a geometry column, if it is a geometry column the appropriate
	 * determination of the geometry type can be performed. Otherwise,
	 * overriding methods should call super.buildAttributeType.
	 * </p>
	 *
	 * <p>
	 * Note: Overriding methods must never move the current row pointer in the
	 * result set.
	 * </p>
	 *
	 * @param rs
	 *            The ResultSet containing the result of a
	 *            DatabaseMetaData.getColumns call.
	 *
	 * @return The AttributeDescriptor built from the ResultSet or null if the column
	 *         should be excluded from the schema.
	 *
	 * @throws IOException
	 *             If an error occurs processing the ResultSet.
	 */
	protected AttributeDescriptor buildAttributeType(ResultSet rs) throws IOException {
		try {
			final int COLUMN_NAME = 4;
			final int DATA_TYPE = 5;
			final int NULLABLE = 11;
			final int LENGTH = 7;
			
			String columnName = rs.getString(COLUMN_NAME);
			int dataType = rs.getInt(DATA_TYPE);
			Class type = (Class) TYPE_MAPPINGS.get(new Integer(dataType));
			
			//check for nullability
			int nullCode = rs.getInt( NULLABLE );
			boolean nillable = true;
			switch( nullCode ) {
				case DatabaseMetaData.columnNoNulls:
					nillable = false;
					break;
					
				case DatabaseMetaData.columnNullable:
					nillable = true;
					break;
					
				case DatabaseMetaData.columnNullableUnknown:
					nillable = true;
					break;
			}
			
			if (type == null) {
				return null;
			} else {
				int min = nillable ? 0 : 1;
				//JD: We would like to set the nillable flag properly here, but there is a lot of 
				// code that sets the value of an attribute to be null while building a feature, 
				// think of feature readers that have to copy content, so we always set it to true,
				// perhaps with the new feature model things like this will be fished out
				//return AttributeTypeFactory.newAttributeType(columnName, type, nillable, null, null, null, min, 1 );
				AttributeTypeBuilder atb = new AttributeTypeBuilder();
				atb.setName(columnName);
				atb.setBinding(type);
				atb.setMinOccurs(min);
				atb.setMaxOccurs(1);
//				atb.setLength( rs.getInt( LENGTH ) );
//				atb.setNillable(nillable);
				return atb.buildDescriptor(columnName);
			}
		} catch (SQLException e) {
			throw new IOException("SQL exception occurred: " + e.getMessage());
		}
	}

