    /**
     * Common implementation for BinaryComparisonOperator filters.  This way
     * they're all handled centrally.
     *  
     *  DJB: note, postgis overwrites this implementation because of the way
     *       null is handled.  This is for <PropertyIsNull> filters and <PropertyIsEqual> filters
     *       are handled.  They will come here with "property = null".  
     *       NOTE: 
     *        SELECT * FROM <table> WHERE <column> isnull;  -- postgresql
     *        SELECT * FROM <table> WHERE isnull(<column>); -- oracle???
     *
     * @param filter the comparison to be turned into SQL.
     *
     * @throws RuntimeException for io exception with writer
     */
    protected void visitBinaryComparisonOperator(BinaryComparisonOperator filter, Object extraData) throws RuntimeException {
        LOGGER.finer("exporting SQL ComparisonFilter");

        Expression left = filter.getExpression1();
        Expression right = filter.getExpression2();
        Class leftContext = null, rightContext = null;
        if (left instanceof PropertyName) {
            // aha!  It's a propertyname, we should get the class and pass it in
            // as context to the tree walker.
            AttributeDescriptor attType = (AttributeDescriptor)left.evaluate(featureType);
            if (attType != null) {
                rightContext = attType.getType().getBinding();
            }
        }
        else if (left instanceof Function) {
            //check for a function return type
            Class ret = getFunctionReturnType((Function)left);
            if (ret != null) {
                rightContext = ret;
            }
        }
        
        if (right instanceof PropertyName) {
            AttributeDescriptor attType = (AttributeDescriptor)right.evaluate(featureType);
            if (attType != null) {
                leftContext = attType.getType().getBinding();
            }
        }
        else if (right instanceof Function){
            Class ret = getFunctionReturnType((Function)right);
            if (ret != null) {
                leftContext = ret;
            }
        }

        //case sensitivity
        boolean matchCase = true;
        if ( !filter.isMatchingCase() ) {
            //we only do for = and !=
            if ( filter instanceof PropertyIsEqualTo || 
                    filter instanceof PropertyIsNotEqualTo ) {
                //and only for strings
                if ( String.class.equals( leftContext ) 
                        || String.class.equals( rightContext ) ) {
                    matchCase = false;
                }
            }
        }
        
        String type = (String) extraData;

        try {
            if ( matchCase ) {
                if (leftContext != null && isBinaryExpression(left)) {
                    writeBinaryExpression(left, leftContext);
                }
                else {
                    left.accept(this, leftContext);
                }
                
                out.write(" " + type + " ");

                if (rightContext != null && isBinaryExpression(right)) {
                    writeBinaryExpression(right, rightContext);
                }
                else {
                    right.accept(this, rightContext);
                }
            }
            else {
                // wrap both sides in "lower"
                FunctionImpl f = new FunctionImpl() {
                    {
                        functionName = new FunctionNameImpl("lower",
                                parameter("lowercase", String.class),
                                parameter("string", String.class));
                    }
                };
                f.setName("lower");
                
                f.setParameters(Arrays.asList(left));
                f.accept(this, Arrays.asList(leftContext));
                
                out.write(" " + type + " ");
                
                f.setParameters(Arrays.asList(right));
                f.accept(this, Arrays.asList(rightContext));
            }
            
        } catch (java.io.IOException ioe) {
            throw new RuntimeException(IO_ERROR, ioe);
        }
    }

