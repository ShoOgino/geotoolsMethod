    /**
     * Handles the common case of a PropertyName,Literal geometry binary temporal operator.
     *
     * <p>Subclasses should override if they support more temporal operators than what is handled in
     * this base class.
     */
    protected Object visitBinaryTemporalOperator(
            BinaryTemporalOperator filter,
            PropertyName property,
            Literal temporal,
            boolean swapped,
            Object extraData) {

        Class typeContext = null;
        AttributeDescriptor attType = (AttributeDescriptor) property.evaluate(featureType);
        if (attType != null) {
            typeContext = attType.getType().getBinding();
        }

        // check for time period
        Period period = null;
        if (temporal.evaluate(null) instanceof Period) {
            period = (Period) temporal.evaluate(null);
        }

        // verify that those filters that require a time period have one
        if ((filter instanceof Begins
                        || filter instanceof BegunBy
                        || filter instanceof Ends
                        || filter instanceof EndedBy
                        || filter instanceof During
                        || filter instanceof TContains)
                && period == null) {
            throw new IllegalArgumentException("Filter requires a time period");
        }
        if (filter instanceof TEquals && period != null) {
            throw new IllegalArgumentException("TEquals filter does not accept time period");
        }

        // ensure the time period is the correct argument
        if ((filter instanceof Begins || filter instanceof Ends || filter instanceof During)
                && swapped) {
            throw new IllegalArgumentException("Time period must be second argument of Filter");
        }
        if ((filter instanceof BegunBy || filter instanceof EndedBy || filter instanceof TContains)
                && !swapped) {
            throw new IllegalArgumentException("Time period must be first argument of Filter");
        }

        try {
            if (filter instanceof After || filter instanceof Before) {
                String op = filter instanceof After ? " > " : " < ";
                String inv = filter instanceof After ? " < " : " > ";

                if (period != null) {
                    out.write("(");

                    property.accept(this, extraData);
                    out.write(swapped ? inv : op);
                    visitBegin(period, extraData);

                    out.write(" AND ");

                    property.accept(this, extraData);
                    out.write(swapped ? inv : op);
                    visitEnd(period, extraData);

                    out.write(")");
                } else {
                    if (swapped) {
                        temporal.accept(this, typeContext);
                    } else {
                        property.accept(this, extraData);
                    }

                    out.write(op);

                    if (swapped) {
                        property.accept(this, extraData);
                    } else {
                        temporal.accept(this, typeContext);
                    }
                }
            } else if (filter instanceof Begins
                    || filter instanceof Ends
                    || filter instanceof BegunBy
                    || filter instanceof EndedBy) {
                property.accept(this, extraData);
                out.write(" = ");

                if (filter instanceof Begins || filter instanceof BegunBy) {
                    visitBegin(period, extraData);
                } else {
                    visitEnd(period, extraData);
                }
            } else if (filter instanceof During || filter instanceof TContains) {
                property.accept(this, extraData);
                out.write(" BETWEEN ");

                visitBegin(period, extraData);
                out.write(" AND ");
                visitEnd(period, extraData);
            } else if (filter instanceof TEquals) {
                property.accept(this, extraData);
                out.write(" = ");
                temporal.accept(this, typeContext);
            }
        } catch (IOException e) {
            throw new RuntimeException("Error encoding temporal filter", e);
        }

        return extraData;
    }

