    public static JoinInfo create(Query query, SimpleFeatureType featureType, JDBCDataStore dataStore)
        throws IOException {
        
        JoinInfo info = new JoinInfo();
        info.setPrimaryAlias("a");
        
        for (int i = 0; i < query.getJoins().size(); i++) {
            Join j = query.getJoins().get(i);

            JoinPart part = new JoinPart(j);
            info.getParts().add(part);

            //load the feature type being joined to
            JDBCFeatureSource joinFeatureSource = dataStore.getAbsoluteFeatureSource(j.getTypeName());
            part.setFeatureSource(joinFeatureSource);

            //ensure every join as a unique alias
            String alias = String.valueOf((char)('b' + i));
            part.setAlias(alias);

            //hack on the join filter as necessary
            Filter joinFilter = j.getJoinFilter();

            Map<String, String> mappings = new HashMap<String, String>();
            if (query.getAlias() != null) {
                //rewrite any user specified alias with the one we specified
                mappings.put(query.getAlias(), "a");
            }
            if (j.getAlias() != null) {
                //rewrite any user specified alias with the one we specified
                mappings.put(j.getAlias(), alias);
            }
            if (!mappings.isEmpty()) {
                joinFilter = (Filter) joinFilter.accept(new JoinPrefixRewriter(mappings), null);
            }

            //qualify all property names in the join filter so that they known about their 
            // feature type and alias
            joinFilter = (Filter) joinFilter.accept(new JoinQualifier(featureType, "a", 
                    joinFeatureSource.getSchema(), alias), null);
            part.setJoinFilter(joinFilter);

            //split the other filter
            Filter[] prePostFilters = joinFeatureSource.splitFilter(j.getFilter());

            //build the query and return feature types based on the post filter
            SimpleFeatureType[] types = joinFeatureSource.buildQueryAndReturnFeatureTypes(
                joinFeatureSource.getSchema(), j.getPropertyNames(), prePostFilters[1]);

            //alias any attributes in this feature type that clash with attributes in the primary
            // feature type
            types[0] = SimpleFeatureTypeBuilder.copy(types[0]);
            for (AttributeDescriptor att : types[0].getAttributeDescriptors()) {
                if (featureType.getDescriptor(att.getName()) != null) {
                    att.getUserData().put(
                            JDBCDataStore.JDBC_COLUMN_ALIAS, alias + "_" + att.getLocalName());
                }
            }

            part.setQueryFeatureType(types[0]);
            part.setReturnFeatureType(types[1]);

            //qualify the pre filter
            if (prePostFilters[0] != null && prePostFilters[0] != Filter.INCLUDE) {
                prePostFilters[0] = (Filter) prePostFilters[0].accept(
                    new JoinQualifier(joinFeatureSource.getSchema(), alias), null); 
            }
            part.setPreFilter(prePostFilters[0]);
            part.setPostFilter(prePostFilters[1]);
            
            //assign an attribute name in the resulting feature type
            //TODO: we should check to ensure that the joined feature type attribute name are 
            // actually unique
            part.setAttributeName(part.getJoin().getAlias() != null ? 
                part.getJoin().getAlias() : part.getQueryFeatureType().getTypeName());
        }

        //qualify the main query filter
        Filter filter = query.getFilter();
        if (filter != null && !Filter.INCLUDE.equals(filter)) {
            filter = (Filter) filter.accept(new JoinQualifier(featureType, "a"), null);
        }
        info.setFilter(filter);
        return info;
    }

