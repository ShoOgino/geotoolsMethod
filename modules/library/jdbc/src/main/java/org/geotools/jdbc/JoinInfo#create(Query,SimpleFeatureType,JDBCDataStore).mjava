    public static JoinInfo create(
            Query query, SimpleFeatureType featureType, JDBCDataStore dataStore)
            throws IOException {

        JoinInfo info = new JoinInfo();
        info.setPrimaryAlias("a");

        for (int i = 0; i < query.getJoins().size(); i++) {
            Join j = query.getJoins().get(i);

            JoinPart part = new JoinPart(j);
            info.getParts().add(part);

            // load the feature type being joined to
            JDBCFeatureSource joinFeatureSource =
                    dataStore.getAbsoluteFeatureSource(j.getTypeName());
            part.setFeatureSource(joinFeatureSource);

            // ensure every join as a unique alias
            String alias = String.valueOf((char) ('b' + i));
            part.setAlias(alias);

            // hack on the join filter as necessary
            Filter joinFilter = j.getJoinFilter();

            Map<String, String> mappings = new HashMap<>();
            if (query.getAlias() != null) {
                // rewrite any user specified alias with the one we specified
                mappings.put(query.getAlias(), "a");
            }
            if (j.getAlias() != null) {
                // rewrite any user specified alias with the one we specified
                mappings.put(j.getAlias(), alias);
            }
            if (!mappings.isEmpty()) {
                joinFilter = (Filter) joinFilter.accept(new JoinPrefixRewriter(mappings), null);
            }

            // qualify all property names in the join filter so that they known about their
            // feature type and alias
            joinFilter =
                    (Filter)
                            joinFilter.accept(
                                    new JoinQualifier(
                                            featureType, "a", joinFeatureSource.getSchema(), alias),
                                    null);
            part.setJoinFilter(joinFilter);

            // split the other filter
            Filter[] prePostFilters = joinFeatureSource.splitFilter(j.getFilter());

            // build the query and return feature types based on the post filter
            SimpleFeatureType[] types =
                    joinFeatureSource.buildQueryAndReturnFeatureTypes(
                            joinFeatureSource.getSchema(), j.getPropertyNames(), prePostFilters[1]);

            // alias any attributes in this feature type that clash with attributes in the primary
            // feature type
            types[0] = SimpleFeatureTypeBuilder.copy(types[0]);
            for (AttributeDescriptor att : types[0].getAttributeDescriptors()) {
                if (featureType.getDescriptor(att.getName()) != null) {
                    att.getUserData()
                            .put(JDBCDataStore.JDBC_COLUMN_ALIAS, alias + "_" + att.getLocalName());
                }
            }

            part.setQueryFeatureType(types[0]);
            part.setReturnFeatureType(types[1]);

            // qualify the pre filter
            if (prePostFilters[0] != null && prePostFilters[0] != Filter.INCLUDE) {
                prePostFilters[0] =
                        (Filter)
                                prePostFilters[0].accept(
                                        new JoinQualifier(joinFeatureSource.getSchema(), alias),
                                        null);
            }
            part.setPreFilter(prePostFilters[0]);
            part.setPostFilter(prePostFilters[1]);

            // assign an attribute name in the resulting feature type
            // TODO: we should check to ensure that the joined feature type attribute name are
            // actually unique
            part.setAttributeName(
                    part.getJoin().getAlias() != null
                            ? part.getJoin().getAlias()
                            : part.getQueryFeatureType().getTypeName());
        }

        // qualify the main query filter
        Filter filter = query.getFilter();
        if (filter != null && !Filter.INCLUDE.equals(filter)) {
            filter = (Filter) filter.accept(new JoinQualifier(featureType, "a"), null);
        }
        info.setFilter(filter);
        return info;
    }

