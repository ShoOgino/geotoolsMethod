    @Override
    public Object visit(Or filter, Object extraData) {
        if (filter.getChildren().size() < 2) {
            return super.visit(filter, extraData);
        }
        // this list contains a name -> List<filter> entry for any simple property name comparison,
        // and a filter -> visit(Filter) for any other case
        LinkedHashMap<Object, Object> grouped = new LinkedHashMap<>();
        int maxListSize = 0;
        for (Filter child : filter.getChildren()) {
            // not equal comparisons are simplified another way
            if (child instanceof PropertyIsNotEqualTo
                    || !(child instanceof BinaryComparisonOperator)) {
                grouped.put(child, child.accept(this, null));
            } else {
                String name = getComparisonPropertyName((BinaryComparisonOperator) child);
                if (name == null) {
                    // not a case we can simplify, visit and accumulate
                    @SuppressWarnings("unchecked")
                    List<Filter> cast = (List<Filter>) child.accept(this, null);
                    grouped.put(child, cast);
                } else {
                    @SuppressWarnings("unchecked")
                    List<Filter> filters = (List<Filter>) grouped.get(name);
                    if (filters == null) {
                        filters = new ArrayList<>();
                        grouped.put(name, filters);
                    }
                    // just add the child, no need to clone it
                    filters.add(child);
                    maxListSize = Math.max(filters.size(), maxListSize);
                }
            }
        }

        // nothing to group, the classic translation can be used instead
        if (maxListSize < 2) {
            return super.visit(filter, extraData);
        }

        // some comparisons can be grouped, great
        List<Filter> children = new ArrayList<>();
        for (Map.Entry<Object, Object> entry : grouped.entrySet()) {
            if (entry.getKey() instanceof String) {
                Not notNull = ff.not(ff.isNull(ff.property((String) entry.getKey())));
                @SuppressWarnings("unchecked")
                List<Filter> filters = (List<Filter>) entry.getValue();
                if (filters.size() == 1) {
                    children.add(ff.and(filters.get(0), notNull));
                } else {
                    children.add(ff.and(ff.or(filters), notNull));
                }
            } else {
                children.add((Filter) entry.getValue());
            }
        }
        if (children.size() == 1) {
            return children.get(0);
        }
        return ff.or(children);
    }

