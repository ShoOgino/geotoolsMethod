    /**
     * DataSource access allowing SQL use: intended to allow client code to query available schemas.
     *
     * <p>This DataSource is the clients responsibility to close() when they are finished using it.
     *
     * @param params Map of connection parameter.
     * @return DataSource for SQL use
     */
    public BasicDataSource createDataSource(Map<String, ?> params) throws IOException {
        // create a datasource
        BasicDataSource dataSource = new BasicDataSource();

        // driver
        dataSource.setDriverClassName(getDriverClassName());

        // url
        dataSource.setUrl(getJDBCUrl(params));

        // username (on embedded dbs it can be optional)
        String user = (String) USER.lookUp(params);
        if (user != null) {
            dataSource.setUsername(user);
        }

        // password
        String passwd = (String) PASSWD.lookUp(params);
        if (passwd != null) {
            dataSource.setPassword(passwd);
        }

        // max wait
        Integer maxWait = (Integer) MAXWAIT.lookUp(params);
        if (maxWait != null && maxWait != -1) {
            dataSource.setMaxWait(maxWait * 1000);
        }

        // connection pooling options
        Integer minConn = (Integer) MINCONN.lookUp(params);
        if (minConn != null) {
            dataSource.setMinIdle(minConn);
        }

        Integer maxConn = (Integer) MAXCONN.lookUp(params);
        if (maxConn != null) {
            dataSource.setMaxActive(maxConn);
        }

        Boolean validate = (Boolean) VALIDATECONN.lookUp(params);
        if (validate != null && validate && getValidationQuery() != null) {
            dataSource.setTestOnBorrow(true);
            dataSource.setValidationQuery(getValidationQuery());
        }

        Boolean testWhileIdle = (Boolean) TEST_WHILE_IDLE.lookUp(params);
        if (testWhileIdle != null) {
            dataSource.setTestWhileIdle(testWhileIdle);
        }

        Integer timeBetweenEvictorRuns = (Integer) TIME_BETWEEN_EVICTOR_RUNS.lookUp(params);
        if (timeBetweenEvictorRuns != null && timeBetweenEvictorRuns > 0) {
            dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictorRuns * 1000l);
        }

        Integer minEvictableTime = (Integer) MIN_EVICTABLE_TIME.lookUp(params);
        if (minEvictableTime != null) {
            dataSource.setMinEvictableIdleTimeMillis(minEvictableTime * 1000l);
        }

        Integer evictorTestsPerRun = (Integer) EVICTOR_TESTS_PER_RUN.lookUp(params);
        if (evictorTestsPerRun != null) {
            dataSource.setNumTestsPerEvictionRun(evictorTestsPerRun);
        }

        // some datastores might need this
        dataSource.setAccessToUnderlyingConnectionAllowed(true);
        return dataSource;
    }

