    /** Computes the column metadata by running the virtual table query */
    static List<ColumnMetadata> getColumnMetadata(
            Connection cx, VirtualTable vtable, SQLDialect dialect, JDBCDataStore store)
            throws SQLException {
        List<ColumnMetadata> result = new ArrayList<ColumnMetadata>();

        Statement st = null;
        ResultSet rs = null;
        try {
            String sql;
            // avoid actually running the query as it might be very expensive
            // and just grab the metadata instead
            StringBuffer sb = new StringBuffer();
            sb.append("select * from (");
            sb.append(vtable.expandParameters(null));
            sb.append(")");
            dialect.encodeTableAlias("vtable", sb);
            // state we don't want rows, we just want to gather the results metadata
            sb.append(" where 1 = 0");
            sql = sb.toString();

            st = cx.createStatement();

            LOGGER.log(Level.FINE, "Gathering sql view result structure: {0}", sql);

            rs = st.executeQuery(sql);

            ResultSetMetaData metadata = rs.getMetaData();
            for (int i = 1; i < metadata.getColumnCount() + 1; i++) {
                ColumnMetadata column = new ColumnMetadata();
                column.name = metadata.getColumnLabel(i);
                column.typeName = metadata.getColumnTypeName(i);
                column.sqlType = metadata.getColumnType(i);
                column.nullable = metadata.isNullable(i) != ResultSetMetaData.columnNoNulls;
                column.srid = vtable.getNativeSrid(column.name);
                column.binding = vtable.getGeometryType(column.name);
                if (column.binding == null) {
                    // determine from type mappings
                    column.binding = store.getMapping(column.typeName);

                    if (column.binding == null) {
                        // determine from type name mappings
                        column.binding = store.getMapping(column.sqlType);
                    }
                }
                result.add(column);
            }
        } finally {
            store.closeSafe(st);
            store.closeSafe(rs);
        }

        return result;
    }

