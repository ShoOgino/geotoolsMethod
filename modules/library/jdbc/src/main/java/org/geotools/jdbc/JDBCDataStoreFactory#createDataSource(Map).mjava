    /**
     * DataSource access allowing SQL use: intended to allow client code to query available schemas.
     * <p>
     * This DataSource is the clients responsibility to close() when they are finished using it.
     * </p> 
     * @param params Map of connection parameter.
     * @return DataSource for SQL use
     * @throws IOException
     */
    public BasicDataSource createDataSource(Map params) throws IOException {
        //create a datasource
        BasicDataSource dataSource = new BasicDataSource();

        // driver
        dataSource.setDriverClassName(getDriverClassName());

        // url
        dataSource.setUrl(getJDBCUrl(params));

        // username
        String user = (String) USER.lookUp(params);
        dataSource.setUsername(user);

        // password
        String passwd = (String) PASSWD.lookUp(params);
        if (passwd != null) {
            dataSource.setPassword(passwd);
        }
        
        // max wait
        Integer maxWait = (Integer) MAXWAIT.lookUp(params);
        if (maxWait != null && maxWait != -1) {
            dataSource.setMaxWait(maxWait * 1000);
        }
        
        // connection pooling options
        Integer minConn = (Integer) MINCONN.lookUp(params);
        if ( minConn != null ) {
            dataSource.setMinIdle(minConn);    
        }
        
        Integer maxConn = (Integer) MAXCONN.lookUp(params);
        if ( maxConn != null ) {
            dataSource.setMaxActive(maxConn);
        }
        
        Boolean validate = (Boolean) VALIDATECONN.lookUp(params);
        if(validate != null && validate && getValidationQuery() != null) {
            dataSource.setTestOnBorrow(true);
            dataSource.setValidationQuery(getValidationQuery());
        }
        
        Boolean testWhileIdle = (Boolean) TEST_WHILE_IDLE.lookUp(params);
        if(testWhileIdle != null) {
            dataSource.setTestWhileIdle(testWhileIdle);
        }
        
        Integer timeBetweenEvictorRuns = (Integer) TIME_BETWEEN_EVICTOR_RUNS.lookUp(params);
        if(timeBetweenEvictorRuns != null && timeBetweenEvictorRuns > 0) {
            dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictorRuns * 1000l);
        }

        Integer minEvictableTime = (Integer) MIN_EVICTABLE_TIME.lookUp(params);
        if(minEvictableTime != null) {
            dataSource.setMinEvictableIdleTimeMillis(minEvictableTime * 1000l);
        }

        Integer evictorTestsPerRun = (Integer) EVICTOR_TESTS_PER_RUN.lookUp(params);
        if(evictorTestsPerRun != null) {
            dataSource.setNumTestsPerEvictionRun(evictorTestsPerRun);
        }
        
        // some datastores might need this
        dataSource.setAccessToUnderlyingConnectionAllowed(true);
        return dataSource;
    }

