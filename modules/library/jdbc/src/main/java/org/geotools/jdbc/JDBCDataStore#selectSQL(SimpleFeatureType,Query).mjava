    /**
     * Generates a 'SELECT p1, p2, ... FROM ... WHERE ...' statement.
     * 
     * @param featureType
     *            the feature type that the query must return (may contain less
     *            attributes than the native one)
     * @param attributes
     *            the properties queried, or {@link Query#ALL_NAMES} to gather
     *            all of them
     * @param query
     *            the query to be run. The type name and property will be ignored, as they are
     *            supposed to have been already embedded into the provided feature type
     * @param sort
     *            sort conditions
     */
    protected String selectSQL(SimpleFeatureType featureType, Query query) throws IOException, SQLException {
        StringBuffer sql = new StringBuffer();
        sql.append("SELECT ");

        //column names

        //primary key
        PrimaryKey key = null;
        try {
            key = getPrimaryKey(featureType);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        Set<String> pkColumnNames = getColumnNames(key);
        
        // we need to add the primary key columns only if they are not already exposed
        for ( PrimaryKeyColumn col : key.getColumns() ) {
            dialect.encodeColumnName(col.getName(), sql);
            sql.append(",");
        }
        
        //other columns
        for (AttributeDescriptor att : featureType.getAttributeDescriptors()) {
            String columnName = att.getLocalName();
            // skip the eventually exposed pk column values
            if(pkColumnNames.contains(columnName))
                continue;
            if (att instanceof GeometryDescriptor) {
                //encode as geometry
            	encodeGeometryColumn((GeometryDescriptor) att, sql, query.getHints());

                //alias it to be the name of the original geometry
                dialect.encodeColumnAlias(columnName, sql);
            } else {
                dialect.encodeColumnName(columnName, sql);
            }

            sql.append(",");
        }

        sql.setLength(sql.length() - 1);

        sql.append(" FROM ");
        encodeTableName(featureType.getTypeName(), sql, query.getHints());

        //filtering
        Filter filter = query.getFilter();
        if (filter != null && !Filter.INCLUDE.equals(filter)) {
            //encode filter
            try {
                // grab the full feature type, as we might be encoding a filter
                // that uses attributes that aren't returned in the results
                SimpleFeatureType fullSchema = getSchema(featureType.getTypeName());
                FilterToSQL toSQL = createFilterToSQL(fullSchema);
                sql.append(" ").append(toSQL.encodeToString(filter));
            } catch (FilterToSQLException e) {
                throw new RuntimeException(e);
            }
        }

        //sorting
        sort(featureType, query.getSortBy(), key, sql);
        
        // finally encode limit/offset, if necessary
        applyLimitOffset(sql, query);

        return sql.toString();
    }

