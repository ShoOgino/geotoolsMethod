    /**
     * Results the value of an aggregate function over a query.
     * @return generated result, or null if unsupported
     */
    protected Object getAggregateValue(FeatureVisitor visitor, SimpleFeatureType featureType, Query query, Connection cx)
            throws IOException {
        // check if group by is supported by the udnerlign store
        if(isGroupByVisitor(visitor) && !dialect.isGroupBySupported()) {
            return null;
        }
        // try to match the visitor with an aggregate function
        String function = matchAggregateFunction(visitor);
        if (function == null) {
            // this visitor is not supported
            return null;
        }
        // try to extract an aggregate attribute from the visitor
        Expression aggregateExpression = getAggregateExpression(visitor);
        // check if aggregation expression is supported
        if (aggregateExpression instanceof FunctionExpression) {
            FunctionExpression func = (FunctionExpression)aggregateExpression;
            if(!getSupportedFunctions().containsKey(func.getFunctionName().getName())) {
                return null;
            }
        }
        
        // if the visitor is limiting the result to a given start - max, we will
        // try to apply limits to the aggregate query
        LimitingVisitor limitingVisitor = null;
        if (visitor instanceof LimitingVisitor) {
            limitingVisitor = (LimitingVisitor) visitor;
        }
        // if the visitor is a group by visitor we extract the group by attributes
        List<AttributeDescriptor> groupByAttributes = extractGroupByAttributes(visitor, featureType);
        //result of the function
        try {
            Object result = null;
            List results = new ArrayList();
            Statement st = null;
            ResultSet rs = null;
            
            try {
                if ( dialect instanceof PreparedStatementSQLDialect ) {
                    st = selectAggregateSQLPS(function, aggregateExpression, groupByAttributes, featureType, query, limitingVisitor,  cx);
                    rs = ((PreparedStatement)st).executeQuery();
                } 
                else {
                    String sql = selectAggregateSQL(function, aggregateExpression, groupByAttributes, featureType, query, limitingVisitor);
                    LOGGER.fine( sql );
                    
                    st = cx.createStatement();
                    st.setFetchSize(fetchSize);
                    rs = st.executeQuery( sql );
                }
             
                while(rs.next()) {
                    if (groupByAttributes == null || groupByAttributes.isEmpty()) {
                        Object value = rs.getObject(1);
                        result = value;
                        results.add(value);
                    }
                    else {
                        results.add(extractValuesFromResultSet(rs, groupByAttributes.size()));
                    }
                }
            } finally {
                closeSafe( rs );
                closeSafe( st );
            }
            
            if ( setResult(visitor, results.size() > 1 ? results : result) ){
                return result == null ? results : result;
            }
            
            return null;
        }
        catch( SQLException e ) {
            throw (IOException) new IOException().initCause(e);
        }
    }

