    /**
     * @param filterType LOGIC_NOT, LOGIC_AND or LOGIC_OR
     * @param startOfFilterStack
     * @return Data Stack data representing the genrated filter
     * @throws IllegalFilterException
     */
    private Data buildFilter(short filterType, int startOfFilterStack)
            throws IllegalFilterException {
        if (current.isEmpty()) {
            return Data.ALL;
        }

        if (filterType == FilterType.LOGIC_NOT) {
            return buildNotFilter(startOfFilterStack);
        }

        if (current.size() == (startOfFilterStack + 1)) {
            return (Data) current.pop();
        }

        List<Filter> filterList = new ArrayList<Filter>();

        while (current.size() > startOfFilterStack) {
            Data data = (Data) current.pop();
            if (data.filter != Filter.EXCLUDE) {
                filterList.add(data.filter);
            }
        }

        Filter f;
        if (filterType == FilterType.LOGIC_AND) {
            f = ff.and(filterList);
        } else if (filterType == FilterType.LOGIC_OR) {
            f = ff.or(filterList);
        } else {
            // not expected
            f = null;
        }
        return new Data(compressFilter(filterType, f));
    }

