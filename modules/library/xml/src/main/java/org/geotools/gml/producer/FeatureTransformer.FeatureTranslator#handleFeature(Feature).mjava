        /**
         * Handles sax for a feature.
         *
         * <p>Please take care when considering the prefix/namespace for the feature. It is defined
         * by either:
         *
         * <ul>
         *   <li>the FeatureType using type.getName().getNamespaceURI() and the user data entry for
         *       "prefix".
         *   <li>FeatureTypeNamespaces as provided to the constructor
         * </ul>
         *
         * @param f Feature being encoded
         * @throws RuntimeException Used to report any troubles during encoding
         */
        @Override
        public void handleFeature(Feature f) {
            try {
                contentHandler.startElement("", "", memberString, NULL_ATTS);

                FeatureType type = f.getType();
                String name = type.getName().getLocalPart();
                String namespaceURI = type.getName().getNamespaceURI();
                if (namespaceURI != null) {
                    currentPrefix = getNamespaceSupport().getPrefix(namespaceURI);
                    if (currentPrefix == null) {
                        currentPrefix = (String) type.getUserData().get("prefix");
                        if (currentPrefix != null) {
                            getNamespaceSupport().declarePrefix(currentPrefix, namespaceURI);
                        }
                    }
                }

                if (currentPrefix == null) {
                    currentPrefix = types.findPrefix(type);
                }

                if (currentPrefix == null) {
                    throw new IllegalStateException(
                            "FeatureType namespace/prefix unknown for "
                                    + name
                                    + "look up in: "
                                    + types);
                } else if (currentPrefix.length() > 0) {
                    name = currentPrefix + ":" + name;
                }

                Attributes fidAtts = encodeFeatureId(f);

                contentHandler.startElement("", "", name, fidAtts);

                // encode the bounds if requested and the bounds are not missing or empty
                if (featureBounding && f.getBounds() != null && !f.getBounds().isEmpty()) {
                    // HACK pt.2 see line 511, if the cite stuff wanted to hack
                    // in a boundedBy geometry, we don't want to do it twice.
                    // So if
                    if (!prefixGml || (f.getProperty("boundedBy") == null)) {
                        writeBounds(f.getBounds());
                    }
                }
            } catch (Exception e) {
                throw new IllegalStateException(
                        "Could not transform " + f.getIdentifier() + " :" + e, e);
            }
        }

