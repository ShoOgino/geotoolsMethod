        /**
         * @see org.geotools.xml.xsi.Type#getValue(org.geotools.xml.xsi.Element,
         *     org.geotools.xml.xsi.ElementValue[], org.xml.sax.Attributes)
         */
        @Override
        public Object getValue(
                Element element,
                ElementValue[] value,
                final Attributes attrs,
                Map<String, Object> hints)
                throws OperationNotSupportedException, SAXException {
            Object[] values = null;

            logger.finest("Getting value for " + name);

            if (isDerived || simple) {
                try {
                    Object v = parent.getValue(element, value, attrs, hints);

                    return v; // this means it's meant to be extended ... and so should already
                    // include the extensions.
                } catch (SAXNotSupportedException snse) {
                    logger.finest(snse.toString());

                    // do nothing ... except pretend it is not derived
                }
            }

            if (simple) {
                return null;
            }

            if (element.getType() instanceof ComplexType
                    && ((ComplexType) element.getType()).getChild() instanceof Choice) {
                if (value.length > 0) return value[0].getValue();
            } else {
                values = new Object[value.length + 1];
                logger.finest("Getting value for " + element.getName() + ":" + name);

                // This seems to some how be for mixed content?  Don't really understand what
                // is going on here.
                values[0] =
                        new ElementValue() {
                            @Override
                            public Element getElement() {
                                return null;
                            }

                            @Override
                            public Object getValue() {
                                return attrs;
                            }
                        };

                for (int i = 1; i < value.length + 1; i++) {
                    values[i] = value[i - (isMixed() ? 0 : 1)].getValue();
                    logger.finest(
                            "*" + ((values[i] != null) ? values[i].getClass().getName() : "null"));
                }

                if (isMixed()) values[values.length - 1] = value[0];
            }
            return values;
        }

