    /**
     * Reads latitude and longitude text grid shift file data into {@link grid}. The first two lines
     * of the shift data file contain the header, with the first being a description of the grid.
     * The second line contains 8 values separated by spaces: num. columns, num. rows, num. z, min
     * x, delta x, min y, delta y and angle. Shift data values follow this and are also separated by
     * spaces. Row records are organized from low y (latitude) to high and columns are orderd from
     * low longitude to high.
     *
     * @param latGridUrl URL to the text latitude shift file (.laa extention).
     * @param longGridUrl URL to the text longitude shift file (.loa extention).
     * @throws IOException if the data files cannot be read.
     * @throws FactoryException if there is an inconsistency in the data
     */
    private NADConGridShift loadTextGrid(URL latGridUrl, URL longGridUrl)
            throws IOException, FactoryException {
        String latLine;
        String longLine;
        StringTokenizer latSt;
        StringTokenizer longSt;

        // //////////////////////
        // setup
        // //////////////////////
        InputStreamReader latIsr = new InputStreamReader(latGridUrl.openStream());
        BufferedReader latBr = new BufferedReader(latIsr);

        InputStreamReader longIsr = new InputStreamReader(longGridUrl.openStream());
        BufferedReader longBr = new BufferedReader(longIsr);

        // //////////////////////
        // read header info
        // //////////////////////
        latBr.readLine(); // skip header description
        latLine = latBr.readLine();
        if (latLine == null) {
            throw new IOException("Invalid lat grid file, does not contain a grid");
        }
        latSt = new StringTokenizer(latLine, " ");

        if (latSt.countTokens() != 8) {
            throw new FactoryException(
                    Errors.format(
                            ErrorKeys.HEADER_UNEXPECTED_LENGTH_$1,
                            String.valueOf(latSt.countTokens())));
        }

        int nc = Integer.parseInt(latSt.nextToken());
        int nr = Integer.parseInt(latSt.nextToken());
        int nz = Integer.parseInt(latSt.nextToken());

        float xmin = Float.parseFloat(latSt.nextToken());
        float dx = Float.parseFloat(latSt.nextToken());
        float ymin = Float.parseFloat(latSt.nextToken());
        float dy = Float.parseFloat(latSt.nextToken());

        float angle = Float.parseFloat(latSt.nextToken());
        float xmax = xmin + ((nc - 1) * dx);
        float ymax = ymin + ((nr - 1) * dy);

        // now read long shift grid
        longBr.readLine(); // skip header description
        longLine = longBr.readLine();
        if (longLine == null) {
            throw new IOException("Invalid lon grid file, does not contain a grid");
        }
        longSt = new StringTokenizer(longLine, " ");

        if (longSt.countTokens() != 8) {
            throw new FactoryException(
                    Errors.format(
                            ErrorKeys.HEADER_UNEXPECTED_LENGTH_$1,
                            String.valueOf(longSt.countTokens())));
        }

        // check that latitude grid header is the same as for latitude grid
        if ((nc != Integer.parseInt(longSt.nextToken()))
                || (nr != Integer.parseInt(longSt.nextToken()))
                || (nz != Integer.parseInt(longSt.nextToken()))
                || (xmin != Float.parseFloat(longSt.nextToken()))
                || (dx != Float.parseFloat(longSt.nextToken()))
                || (ymin != Float.parseFloat(longSt.nextToken()))
                || (dy != Float.parseFloat(longSt.nextToken()))
                || (angle != Float.parseFloat(longSt.nextToken()))) {
            throw new FactoryException(Errors.format(ErrorKeys.GRID_LOCATIONS_UNEQUAL));
        }

        // //////////////////////
        // read grid shift data into LocalizationGrid
        // //////////////////////
        NADConGridShift gridShift = new NADConGridShift(xmin, ymin, xmax, ymax, dx, dy, nc, nr);

        int i = 0;
        int j = 0;
        for (i = 0; i < nr; i++) {
            for (j = 0; j < nc; ) {
                latLine = latBr.readLine();
                if (latLine == null) {
                    throw new IOException("Was expecting one more line in the lat file");
                }
                latSt = new StringTokenizer(latLine, " ");
                longLine = longBr.readLine();
                if (longLine == null) {
                    throw new IOException("Was expecting one more line in the lat file");
                }
                longSt = new StringTokenizer(longLine, " ");

                while (latSt.hasMoreTokens() && longSt.hasMoreTokens()) {
                    gridShift.setLocalizationPoint(
                            j,
                            i,
                            (double) Float.parseFloat(longSt.nextToken()),
                            (double) Float.parseFloat(latSt.nextToken()));
                    ++j;
                }
            }
        }

        assert i == nr : i;
        assert j == nc : j;

        return gridShift;
    }

