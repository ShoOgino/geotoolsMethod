        /**
         * Apply the inverse transform to a set of points. More specifically, this method transform
         * "real world" coordinates to grid coordinates. This method use an iterative algorithm for
         * that purpose. A {@link TransformException} is thrown in the computation do not converge.
         *
         * @param srcPts the array containing the source point coordinates.
         * @param srcOff the offset to the first point to be transformed in the source array.
         * @param dstPts the array into which the transformed point coordinates are returned. May be
         *     the same than {@code srcPts}.
         * @param dstOff the offset to the location of the first transformed point that is stored in
         *     the destination array.
         * @param numPts the number of point objects to be transformed.
         * @throws TransformException if a point can't be transformed.
         */
        @Override
        public void transform(
                final double[] srcPts, int srcOff, final double[] dstPts, int dstOff, int numPts)
                throws TransformException {
            int postIncrement = 0;
            if (srcPts == dstPts && srcOff < dstOff) {
                srcOff += (numPts - 1) * 2;
                dstOff += (numPts - 1) * 2;
                postIncrement = -4;
            }
            final Point2D.Double source = new Point2D.Double();
            final Point2D.Double target = new Point2D.Double();
            final AffineTransform tr = new AffineTransform(global);
            while (--numPts >= 0) {
                source.x = srcPts[srcOff++];
                source.y = srcPts[srcOff++];
                inverseTransform(source, target, tr);
                dstPts[dstOff++] = target.x;
                dstPts[dstOff++] = target.y;
                srcOff += postIncrement;
                dstOff += postIncrement;
            }
        }

