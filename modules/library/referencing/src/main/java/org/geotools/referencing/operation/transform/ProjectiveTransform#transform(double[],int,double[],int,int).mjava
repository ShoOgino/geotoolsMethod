    /**
     * Transforms an array of floating point coordinates by this matrix. Point coordinates must have
     * a dimension equals to <code>{@link Matrix#getNumCol}-1</code>. For example, for square matrix
     * of size 4&times;4, coordinate points are three-dimensional and stored in the arrays starting
     * at the specified offset ({@code srcOff}) in the order <code>
     * [x<sub>0</sub>, y<sub>0</sub>, z<sub>0</sub>,
     *        x<sub>1</sub>, y<sub>1</sub>, z<sub>1</sub>...,
     *        x<sub>n</sub>, y<sub>n</sub>, z<sub>n</sub>]</code>.
     *
     * @param srcPts The array containing the source point coordinates.
     * @param srcOff The offset to the first point to be transformed in the source array.
     * @param dstPts The array into which the transformed point coordinates are returned.
     * @param dstOff The offset to the location of the first transformed point that is stored in the
     *     destination array. The source and destination array sections can be overlaps.
     * @param numPts The number of points to be transformed
     */
    @Override
    public void transform(
            double[] srcPts, int srcOff, final double[] dstPts, int dstOff, int numPts) {
        final int inputDimension = numCol - 1; // The last ordinate will be assumed equals to 1.
        final int outputDimension = numRow - 1;
        final double[] buffer = new double[numRow];
        if (srcPts == dstPts) {
            // We are going to write in the source array. Checks if
            // source and destination sections are going to clash.
            final int upperSrc = srcOff + numPts * inputDimension;
            if (upperSrc > dstOff) {
                if (inputDimension >= outputDimension
                        ? dstOff > srcOff
                        : dstOff + numPts * outputDimension > upperSrc) {
                    // If source overlaps destination, then the easiest workaround is
                    // to copy source data. This is not the most efficient however...
                    srcPts = new double[numPts * inputDimension];
                    System.arraycopy(dstPts, srcOff, srcPts, 0, srcPts.length);
                    srcOff = 0;
                }
            }
        }
        while (--numPts >= 0) {
            int mix = 0;
            for (int j = 0; j < numRow; j++) {
                double sum = elt[mix + inputDimension];
                for (int i = 0; i < inputDimension; i++) {
                    sum += srcPts[srcOff + i] * elt[mix++];
                }
                buffer[j] = sum;
                mix++;
            }
            final double w = buffer[outputDimension];
            for (int j = 0; j < outputDimension; j++) {
                // 'w' is equals to 1 if the transform is affine.
                dstPts[dstOff++] = buffer[j] / w;
            }
            srcOff += inputDimension;
        }
    }

