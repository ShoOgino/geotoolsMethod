    /**
     * Constructs a polar stereographic projection.
     *
     * @param  parameters The group of parameter values.
     * @param  descriptor The expected parameter descriptor.
     * @param  forceSouthPole Forces projection to North pole if {@link Boolean#FALSE},
     *         to South pole if {@link Boolean#TRUE}, or do not force (i.e. detect
     *         from other parameter values) if {@code null}.
     * @throws ParameterNotFoundException if a required parameter was not found.
     */
    PolarStereographic(final ParameterValueGroup      parameters,
                       final ParameterDescriptorGroup descriptor,
                       final Boolean                  forceSouthPole)
            throws ParameterNotFoundException
    {
        super(parameters, descriptor);
        /*
         * Get "standard_parallel_1" parameter value. This parameter should be mutually exclusive
         * with "latitude_of_origin", but this is not a strict requirement for this constructor.
         *
         *   +-----------------------------------+--------------------+-------------+
         *   | Projection                        | Parameter          | Force pole  |
         *   | --------------------------------- | ------------------ | ----------- |
         *   | Polar Stereographic (variant A)   | Latitude of origin | auto detect |
         *   | Polar Stereographic (variant B)   | Standard Parallel  | auto detect |
         *   | Stereographic North Pole          | Standard Parallel  | North pole  |
         *   | Stereographic South Pole          | Standard Parallel  | South pole  |
         *   +-----------------------------------+--------------------+-------------+
         *
         * "Standard Parallel" (a.k.a. "Latitude true scale") default to 90°N for every cases
         * (including Polar A, but it is meanless in this case), except for "Stereographic South
         * Pole" where it default to 90°S.
         */
        final ParameterDescriptor trueScaleDescriptor = Boolean.TRUE.equals(forceSouthPole) ?
                ProviderSouth.STANDARD_PARALLEL : ProviderNorth.STANDARD_PARALLEL;
        final Collection<GeneralParameterDescriptor> expected = descriptor.descriptors();
        double latitudeTrueScale;
        if (isExpectedParameter(expected, trueScaleDescriptor)) {
            // Any cases except Polar A
            latitudeTrueScale = doubleValue(expected, trueScaleDescriptor, parameters);
        } else {
            // Polar A case
            latitudeTrueScale = (latitudeOfOrigin < 0) ? -PI/2 : PI/2;
        }
        ensureLatitudeInRange(trueScaleDescriptor, latitudeTrueScale, true);
        /*
         * Forces the "standard_parallel_1" to the appropriate hemisphere,
         * and forces the "latitude_of_origin" to ±90°.
         */
        poleForced = (forceSouthPole != null);
        if (poleForced) {
            southPole = forceSouthPole.booleanValue();
            latitudeTrueScale = abs(latitudeTrueScale);
            if (southPole) {
                latitudeTrueScale = -latitudeTrueScale;
            }
        } else {
            southPole = (latitudeTrueScale < 0);
        }
        this.latitudeOfOrigin = (southPole) ? -(PI/2) : +(PI/2);
        this.standardParallel = latitudeTrueScale; // May be anything in [-90 .. +90] range.
        /*
         * Computes coefficients.
         */
        latitudeTrueScale = abs(latitudeTrueScale);
        if (abs(latitudeTrueScale - PI/2) >= EPSILON) {
            final double t = sin(latitudeTrueScale);
            k0 = msfn(t, cos(latitudeTrueScale)) /
                 tsfn(latitudeTrueScale, t); // Derives from (21-32 and 21-33)
        } else {
            // True scale at pole (part of (21-33))
            k0 = 2.0 / sqrt(pow(1+excentricity, 1+excentricity)*
                            pow(1-excentricity, 1-excentricity));
        }
    }

