    /**
     * Creates the Builder from a List of control points and a List of four DirectPositions defining
     * the vertexes of the area for interpolation.
     *
     * @param vectors A List of {@linkplain
     *     org.geotools.referencing.operation.builder.MappedPosition MappedPosition}
     * @param vertices A List with four points defining the quadrilateral in the region of interest.
     */
    public RubberSheetBuilder(List<MappedPosition> vectors, List<DirectPosition> vertices)
            throws IllegalArgumentException, MismatchedDimensionException,
                    MismatchedReferenceSystemException, TriangulationException {

        // Validates the vectors parameter while setting it
        super.setMappedPositions(vectors);

        // Validate the vertices parameter
        if (vertices.size() != 4) {
            throw new IllegalArgumentException("The region of interest must have four vertices.");
        }

        // Get the DirectPositions (In Java 1.4 we fail hard on this cast.)
        DirectPosition[] ddpp = new DirectPosition[4];
        for (int i = 0; i < vertices.size(); i++) {
            ddpp[i] = (DirectPosition) vertices.get(i);
        }

        // Check they have a common crs;
        CoordinateReferenceSystem crs;
        try {
            crs = getSourceCRS();
        } catch (FactoryException e) {
            // Can't fetch the CRS. Use the one from the first region of interest point instead.
            crs = ddpp[0].getCoordinateReferenceSystem();
        }
        if (!(CRS.equalsIgnoreMetadata(crs, ddpp[0].getCoordinateReferenceSystem())
                || CRS.equalsIgnoreMetadata(crs, ddpp[1].getCoordinateReferenceSystem())
                || CRS.equalsIgnoreMetadata(crs, ddpp[2].getCoordinateReferenceSystem())
                || CRS.equalsIgnoreMetadata(crs, ddpp[3].getCoordinateReferenceSystem()))) {
            throw new MismatchedReferenceSystemException(
                    "Region of interest defined by mismatched DirectPositions.");
        }

        // Check the vectors are inside the vertices.
        //  This is a quick check by envelope, can be more rigorous when we move
        //  to n dimensional operations.
        DirectPosition[] dpa = this.getSourcePoints();
        GeneralEnvelope srcextnt = new GeneralEnvelope(2);
        for (DirectPosition directPosition : dpa) {
            srcextnt.add(directPosition);
        }
        GeneralEnvelope vtxextnt = new GeneralEnvelope(2);
        vtxextnt.add(ddpp[0]);
        vtxextnt.add(ddpp[1]);
        vtxextnt.add(ddpp[2]);
        vtxextnt.add(ddpp[3]);
        if (!vtxextnt.contains(srcextnt, true))
            throw new IllegalArgumentException(
                    "The region of interest must contain the control points");

        Quadrilateral quad = new Quadrilateral(ddpp[0], ddpp[1], ddpp[2], ddpp[3]);

        MapTriangulationFactory trianglemap = new MapTriangulationFactory(quad, vectors);

        this.trianglesMap = trianglemap.getTriangleMap();
        this.trianglesToKeysMap = mapTrianglesToKey();
    }

