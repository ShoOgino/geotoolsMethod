    /**
     * Implementation of transformation step on compound CRS.
     * <p>
     * <strong>NOTE:</strong> If there is a horizontal (geographic or projected) CRS together with a vertical CRS, then we can't performs the
     * transformation since the vertical value has an impact on the horizontal value, and this impact is not taken in account if the horizontal and
     * vertical components are not together in a 3D geographic CRS. This case occurs when the vertical CRS is not a height above the ellipsoid. It
     * must be checked by the caller before this method is invoked.
     *
     * @param sourceCRS Input coordinate reference system.
     * @param sources The source CRS components.
     * @param targetCRS Output coordinate reference system.
     * @param targets The target CRS components.
     * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}.
     * @throws FactoryException If the operation can't be constructed.
     */
    private CoordinateOperation createOperationStep(final CoordinateReferenceSystem sourceCRS,
            final List<SingleCRS> sources, final CoordinateReferenceSystem targetCRS,
            final List<SingleCRS> targets) throws FactoryException {
        /*
         * Try to find operations from source CRSs to target CRSs. All pairwise combinaisons are tried, but the preference is given to CRS in the same
         * order (source[0] with target[0], source[1] with target[1], etc.). Operations found are stored in 'steps', but are not yet given to pass
         * through transforms. We need to know first if some ordinate values need reordering (for matching the order of target CRS) if any ordinates
         * reordering and source ordinates drops are required.
         */
        final CoordinateReferenceSystem[] ordered = new CoordinateReferenceSystem[targets.size()];
        final CoordinateOperation[] steps = new CoordinateOperation[targets.size()];
        final boolean[]                   done    = new boolean                  [sources.size()];
        final int[]                       indices = new int[getDimension(sourceCRS)];
        int count=0, dimensions=0;
search: for (int j=0; j<targets.size(); j++) {
            int lower, upper=0;
            final CoordinateReferenceSystem target = targets.get(j);
            OperationNotFoundException cause = null;
            for (int i=0; i<sources.size(); i++) {
                final CoordinateReferenceSystem source = sources.get(i);
                lower  = upper;
                upper += getDimension(source);
                if (done[i]) continue;
                try {
                    steps[count] = createOperation(source, target);
                } catch (OperationNotFoundException exception) {
                    // No operation path for this pair.
                    // Search for an other pair.
                    if (cause==null || i==j) {
                        cause = exception;
                    }
                    continue;
                }
                ordered[count++] = source;
                while (lower < upper) {
                    indices[dimensions++] = lower++;
                }
                done[i] = true;
                continue search;
            }
            /*
             * No source CRS was found for current target CRS.
             * Consequently, we can't get a transformation path.
             */
            throw new OperationNotFoundException(getErrorMessage(sourceCRS, targetCRS), cause);
        }
        /*
         * A transformation has been found for every source and target CRS pairs.
         * Some reordering of ordinate values may be needed. Prepare it now as an
         * affine transform. This transform also drop source dimensions not used
         * for any target coordinates.
         */
        assert count == targets.size() : count;
        while (count != 0 && steps[--count].getMathTransform().isIdentity())
            ;
        final ReferencingFactoryContainer factories = getFactoryContainer();
        CoordinateOperation operation = null;
        CoordinateReferenceSystem sourceStepCRS = sourceCRS;
        final XMatrix select = MatrixFactory.create(dimensions+1, indices.length+1);
        select.setZero();
        select.setElement(dimensions, indices.length, 1);
        for (int j=0; j<dimensions; j++) {
            select.setElement(j, indices[j], 1);
        }
        if (!select.isIdentity()) {
            if (ordered.length == 1) {
                sourceStepCRS = ordered[0];
            } else {
                sourceStepCRS = factories.getCRSFactory().createCompoundCRS(
                        getTemporaryName(sourceCRS), ordered);
            }
            operation = createFromAffineTransform(AXIS_CHANGES, sourceCRS, sourceStepCRS, select);
        }
        /*
         * Now creates the pass through transforms for each transformation steps found above.
         * We get (or construct temporary) source and target CRS for this step. They will be
         * given to the constructor of the pass through operation, after the construction of
         * pass through transform.
         */
        int lower, upper = 0;
        for (int i = 0; i < targets.size(); i++) {
            CoordinateOperation step = steps[i];
            final Map<String, ?> properties = AbstractIdentifiedObject.getProperties(step);
            final CoordinateReferenceSystem source = ordered[i];
            final CoordinateReferenceSystem target = targets.get(i);
            final CoordinateReferenceSystem targetStepCRS;
            ordered[i] = target; // Used for the construction of targetStepCRS.
            MathTransform mt = step.getMathTransform();
            if (i >= count) {
                targetStepCRS = targetCRS;
            } else if (mt.isIdentity()) {
                targetStepCRS = sourceStepCRS;
            } else if (ordered.length == 1) {
                targetStepCRS = ordered[0];
            } else {
                targetStepCRS = factories.getCRSFactory()
                        .createCompoundCRS(getTemporaryName(target), ordered);
            }
            lower = upper;
            upper += getDimension(source);
            if (lower != 0 || upper != dimensions) {
                /*
                 * Constructs the pass through transform only if there is at least one ordinate to pass. Actually, the code below would give an
                 * acceptable result even if this check was not performed, except for creation of intermediate objects.
                 */
                if (!(step instanceof Operation)) {
                    final MathTransform stepMT = step.getMathTransform();
                    step = DefaultOperation.create(AbstractIdentifiedObject.getProperties(step),
                            step.getSourceCRS(), step.getTargetCRS(), stepMT,
                            new DefaultOperationMethod(stepMT), step.getClass());
                }
                mt = getMathTransformFactory().createPassThroughTransform(lower, mt,
                        dimensions - upper);
                step = new DefaultPassThroughOperation(properties, sourceStepCRS, targetStepCRS,
                        (Operation) step, mt);
            }
            operation = (operation == null) ? step : concatenate(operation, step);
            sourceStepCRS = targetStepCRS;
        }
        assert upper == dimensions : upper;
        return operation;
    }

