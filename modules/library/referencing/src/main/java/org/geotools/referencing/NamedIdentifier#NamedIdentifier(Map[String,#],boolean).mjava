    /**
     * Implementation of the constructor. The remarks in the {@code properties} will be parsed only
     * if the {@code standalone} argument is set to {@code true}, i.e. this identifier is being
     * constructed as a standalone object. If {@code false}, then this identifier is assumed to be
     * constructed from inside the {@link AbstractIdentifiedObject} constructor.
     *
     * @param properties The properties to parse, as described in the public constructor.
     * @param standalone {@code true} for parsing "remarks" as well.
     * @throws InvalidParameterValueException if a property has an invalid value.
     * @throws IllegalArgumentException if a property is invalid for some other reason.
     */
    NamedIdentifier(final Map<String, ?> properties, final boolean standalone)
            throws IllegalArgumentException {
        ensureNonNull("properties", properties);
        Object code = null;
        Object codespace = null;
        Object version = null;
        Object authority = null;
        Object remarks = null;
        GrowableInternationalString growable = null;
        /*
         * Iterate through each map entry. This have two purposes:
         *
         *   1) Ignore case (a call to properties.get("foo") can't do that)
         *   2) Find localized remarks.
         *
         * This algorithm is sub-optimal if the map contains a lot of entries of no interest to
         * this identifier. Hopefully, most users will fill a map only with usefull entries.
         */
        String key = null;
        Object value = null;
        for (final Map.Entry<String, ?> entry : properties.entrySet()) {
            key = entry.getKey().trim().toLowerCase();
            value = entry.getValue();
            /*
             * Note: String.hashCode() is part of J2SE specification,
             *       so it should not change across implementations.
             */
            switch (key.hashCode()) {
                case 3373707:
                    {
                        if (!standalone && key.equals("name")) {
                            code = value;
                            continue;
                        }
                        break;
                    }
                case 3059181:
                    {
                        if (key.equals(CODE_KEY)) {
                            code = value;
                            continue;
                        }
                        break;
                    }
                case -1108676807:
                    {
                        if (key.equals(CODESPACE_KEY)) {
                            codespace = value;
                            continue;
                        }
                        break;
                    }
                case 351608024:
                    {
                        if (key.equals(VERSION_KEY)) {
                            version = value;
                            continue;
                        }
                        break;
                    }
                case 1475610435:
                    {
                        if (key.equals(AUTHORITY_KEY)) {
                            if (value instanceof String) {
                                value = Citations.fromName(value.toString());
                            }
                            authority = value;
                            continue;
                        }
                        break;
                    }
                case 1091415283:
                    {
                        if (standalone && key.equals(REMARKS_KEY)) {
                            if (value instanceof InternationalString) {
                                remarks = value;
                                continue;
                            }
                        }
                        break;
                    }
            }
            /*
             * Search for additional locales (e.g. "remarks_fr").
             */
            if (standalone && value instanceof String) {
                if (growable == null) {
                    if (remarks instanceof GrowableInternationalString) {
                        growable = (GrowableInternationalString) remarks;
                    } else {
                        growable = new GrowableInternationalString();
                    }
                }
                growable.add(REMARKS_KEY, key, value.toString());
            }
        }
        /*
         * Get the localized remarks, if it was not yet set. If a user specified remarks
         * both as InternationalString and as String for some locales (which is a weird
         * usage...), then current implementation discart the later with a warning.
         */
        if (growable != null && !growable.getLocales().isEmpty()) {
            if (remarks == null) {
                remarks = growable;
            } else {
                final Logger logger = Logging.getLogger(NamedIdentifier.class);
                final LogRecord record =
                        Loggings.format(Level.WARNING, LoggingKeys.LOCALES_DISCARTED);
                record.setLoggerName(logger.getName());
                logger.log(record);
            }
        }
        /*
         * Completes the code space if it was not explicitly set. We take the first
         * identifier if there is any, otherwise we take the shortest title.
         */
        if (codespace == null && authority instanceof Citation) {
            codespace = getCodeSpace((Citation) authority);
        }
        /*
         * Stores the definitive reference to the attributes. Note that casts are performed only
         * there (not before). This is a wanted feature, since we want to catch ClassCastExceptions
         * are rethrown them as more informative exceptions.
         */
        try {
            key = CODE_KEY;
            this.code = (String) (value = code);
            key = VERSION_KEY;
            this.version = (String) (value = version);
            key = CODESPACE_KEY;
            this.codespace = (String) (value = codespace);
            key = AUTHORITY_KEY;
            this.authority = (Citation) (value = authority);
            key = REMARKS_KEY;
            this.remarks = (InternationalString) (value = remarks);
        } catch (ClassCastException exception) {
            InvalidParameterValueException e =
                    new InvalidParameterValueException(
                            Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2, key, value), key, value);
            e.initCause(exception);
            throw e;
        }
        ensureNonNull(CODE_KEY, code);
    }

