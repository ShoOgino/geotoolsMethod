    /**
     * Returns {@code true} if it is safe to dispose this factory. This method is invoked indirectly
     * by {@link ThreadedEpsgFactory} after some timeout in order to release resources. This method
     * will block the disposal if some {@linkplain #getAuthorityCodes set of authority codes} are
     * still in use.
     */
    final synchronized boolean canDispose() {
        boolean can = true;
        Map<SoftReference, WeakReference<AuthorityCodes>> pool = null;
        for (final Iterator<Map.Entry<Class<?>, Reference<AuthorityCodes>>> it =
                        authorityCodes.entrySet().iterator();
                it.hasNext(); ) {
            final Map.Entry<Class<?>, Reference<AuthorityCodes>> entry = it.next();
            final Reference<AuthorityCodes> reference = entry.getValue();
            final AuthorityCodes codes = reference.get();
            if (codes == null) {
                it.remove();
                continue;
            }
            /*
             * A set of authority codes is still in use. We can't dispose this factory.
             * But maybe the set was retained only by soft references... So we continue
             * the iteration anyway and replace all soft references by weak ones, in order
             * to get more chances to be garbage-collected before the next disposal cycle.
             */
            can = false;
            if (reference instanceof SoftReference) {
                // Each reference appears twice (once with the type key, and once under the SQL
                // statement as key). So we need to manage a pool of references for avoiding
                // duplication.
                if (pool == null) {
                    pool = new IdentityHashMap<SoftReference, WeakReference<AuthorityCodes>>();
                }
                WeakReference<AuthorityCodes> weak = pool.get(reference);
                if (weak == null) {
                    weak = new WeakReference<AuthorityCodes>(codes);
                    pool.put((SoftReference) reference, weak);
                }
                entry.setValue(weak);
            }
        }
        return can;
    }

