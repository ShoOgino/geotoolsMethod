    /**
     * Retourne le point sur le segment de droite {@code (x1,y1)-(x2,y2)}
     * qui se trouve à la distance {@code distance} spécifiée du point
     * {@code point}. Appellons {@code result} le point retourné par
     * cette méthode. Si {@code result} est non-nul, alors il est garantit
     * qu'il répond aux conditions suivantes (aux erreurs d'arrondissements près):
     *
     * <ul>
     *   <li>{@code result} est un point du segment de droite {@code (x1,y1)-(x2,y2)}.
     *       Il ne trouve pas au delà des points extrêmes {@code (x1,y1)} et
     *       {@code (x2,y2)} de ce segment.</li>
     *   <li>La distance entre les points {@code result} et {@code point}
     *       est exactement {@code distance} (aux erreurs d'arrondissements près).
     *       Cette distance peut être calculée par {@code point.distance(result)}.</li>
     * </ul>
     *
     * Si aucun point ne peut répondre à ces conditions, alors cette méthode retourne
     * {@code null}. Si deux points peuvent répondre à ces conditions, alors par
     * convention cette méthode retourne le point le plus près du point {@code (x1,y1)}.
     *
     * @param  x1 <var>x</var> value of the first point on the line.
     * @param  y1 <var>y</var> value of the first point on the line.
     * @param  x2 <var>x</var> value of the last  point on the line.
     * @param  y2 <var>y</var> value of the last  point on the line.
     * @param  x  <var>x</var> value of a point close to the given line.
     * @param  y  <var>y</var> value of a point close to the given line.
     * @param  distance The distance between the given point and the point to be returned.
     * @return A point on the given line located at the given distance from the given point.
     *
     * @see #nearestColinearPoint(double,double , double,double , double,double)
     */
    public static Point2D colinearPoint(double x1, double y1, double x2, double y2,
                                        double x, double y, double distance)
    {
        final double ox1 = x1;
        final double oy1 = y1;
        final double ox2 = x2;
        final double oy2 = y2;
        distance *= distance;
        if (x1 == x2) {
            double dy = x1-x;
            dy = sqrt(distance - dy*dy);
            y1 = y - dy;
            y2 = y + dy;
        } else if (y1 == y2) {
            double dx = y1 - y;
            dx = sqrt(distance - dx*dx);
            x1 = x - dx;
            x2 = x + dx;
        } else {
            final double m  = (y1-y2) / (x2-x1);
            final double y0 = (y2-y) + m*(x2-x);
            final double B  = m * y0;
            final double A  = m*m + 1;
            final double C  = sqrt(B*B + A*(distance - y0*y0));
            x1 = (B+C)/A;
            x2 = (B-C)/A;
            y1 = y + y0-m*x1;
            y2 = y + y0-m*x2;
            x1 += x;
            x2 += x;
        }
        boolean in1, in2;
        if (oy1 > oy2) {
            in1 = y1<=oy1 && y1>=oy2;
            in2 = y2<=oy1 && y2>=oy2;
        } else {
            in1 = y1>=oy1 && y1<=oy2;
            in2 = y2>=oy1 && y2<=oy2;
        }
        if (ox1 > ox2) {
            in1 &= x1<=ox1 && x1>=ox2;
            in2 &= x2<=ox1 && x2>=ox2;
        } else {
            in1 &= x1>=ox1 && x1<=ox2;
            in2 &= x2>=ox1 && x2<=ox2;
        }
        if (!in1 && !in2) return null;
        if (!in1) return new Point2D.Double(x2,y2);
        if (!in2) return new Point2D.Double(x1,y1);
        x = x1 - ox1;
        y = y1 - oy1;
        final double d1 = x*x + y*y;
        x = x2 - ox1;
        y = y2 - oy1;
        final double d2 = x*x + y*y;
        if (d1>d2) return new Point2D.Double(x2,y2);
        else       return new Point2D.Double(x1,y1);
    }

