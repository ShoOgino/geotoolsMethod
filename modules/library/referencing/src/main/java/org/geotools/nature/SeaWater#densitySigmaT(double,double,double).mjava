    /**
     * Computes density sigma-T as a function of salinity, temperature and pressure.
     * Density Sigma-T is equivalent to the true density minus 1000&nbsp;kg/m³, and
     * has typical values around 35. This computation avoid some rouding errors
     * occuring in the true density computation.
     *
     * @param S Salinity PSS-78 (0 to 42)
     * @param T Temperature ITS-68 (-2 to 40°C)
     * @param P Pressure in decibars (0 to 10<sup>5</sup> dbar), not including atmospheric pressure.
     * @return  Density Sigma-T (kg/m³).
     */
    public static double densitySigmaT(final double S, final double T, double P) {
        P /= 10.0;
        // Sea water density at atmospheric pressure
        final double SR = Math.sqrt(S);
        final double RHO = (EOS80_D*S + polynome(T,EOS80_C)*SR + polynome(T,EOS80_B))*S + polynome(T,EOS80_A);

        // Specific volume at atmospheric pressure
        final double V_35_0_0    = 1.0/RHO_35_0_0;
        final double SVAN_S_T_0  = -RHO*V_35_0_0/(RHO+RHO_35_0_0);
        if (P <= 0) {
            return RHO + DR_35_0_0;
        }
        // Compression terms, DK = K(S,T,P) - K(35,0,P)
        final double K0 = (polynome(T,EOS80_F) + polynome(T,EOS80_G)*SR)*S + polynome(T,EOS80_E);
        final double DK = K0 + (((EOS80_J * SR + polynome(T,EOS80_I)) * S + polynome(T,EOS80_H)) +
                          (polynome(T,EOS80_K) + polynome(T,EOS80_M) * S) * P) * P;

        final double K_35_0_P = polynome(P,EOS80_N);
        final double V_S_T_0  = SVAN_S_T_0 + V_35_0_0;
        final double SVANS    = SVAN_S_T_0 * (1.0 - P/K_35_0_P) + V_S_T_0 * P * DK /
                                (K_35_0_P * (K_35_0_P + DK));

        // Compute density anomaly
        final double V_35_0_P  = V_35_0_0*( 1.0 - P/K_35_0_P );
        final double DR_35_0_P = P/(K_35_0_P*V_35_0_P);
        final double DVAN      = SVANS/( V_35_0_P*( V_35_0_P + SVANS ) );
        return DR_35_0_0 + DR_35_0_P - DVAN;
    }

