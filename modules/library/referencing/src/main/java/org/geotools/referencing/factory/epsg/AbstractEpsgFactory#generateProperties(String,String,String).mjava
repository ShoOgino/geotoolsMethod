    /**
     * Returns the name for the {@link IdentifiedObject} to construct. This method also search for
     * alias.
     *
     * @param name The name for the {@link IndentifiedObject} to construct.
     * @param code The EPSG code of the object to construct.
     * @param remarks Remarks, or {@code null} if none.
     * @return The name together with a set of properties.
     */
    private Map<String, Object> generateProperties(
            final String name, final String code, String remarks)
            throws SQLException, FactoryException {
        properties.clear();
        final Citation authority = getAuthority();
        if (name != null) {
            properties.put(IdentifiedObject.NAME_KEY, new NamedIdentifier(authority, name.trim()));
        }
        if (code != null) {
            final InternationalString edition = authority.getEdition();
            final String version = (edition != null) ? edition.toString() : null;
            properties.put(
                    IdentifiedObject.IDENTIFIERS_KEY,
                    new NamedIdentifier(authority, code.trim(), version));
        }
        if (remarks != null && (remarks = remarks.trim()).length() != 0) {
            properties.put(IdentifiedObject.REMARKS_KEY, remarks);
        }
        /*
         * Search for alias.
         */
        List<GenericName> alias = null;
        final PreparedStatement stmt =
                prepareStatement(
                        "Alias",
                        "SELECT NAMING_SYSTEM_NAME, ALIAS"
                                + " FROM [Alias] INNER JOIN [Naming System]"
                                + " ON [Alias].NAMING_SYSTEM_CODE ="
                                + " [Naming System].NAMING_SYSTEM_CODE"
                                + " WHERE OBJECT_CODE = ?");
        stmt.setString(1, code);
        try (ResultSet result = stmt.executeQuery()) {
            while (result.next()) {
                final String scope = result.getString(1);
                final String local = getString(result, 2, code);
                final GenericName generic;
                if (scope == null) {
                    generic = new LocalName(local);
                } else {
                    LocalName cached = scopes.get(scope);
                    if (cached == null) {
                        cached = new LocalName(scope);
                        scopes.put(scope, cached);
                    }
                    generic = new ScopedName(cached, local);
                }
                if (alias == null) {
                    alias = new ArrayList<>();
                }
                alias.add(generic);
            }
        }
        if (alias != null) {
            properties.put(
                    IdentifiedObject.ALIAS_KEY, alias.toArray(new GenericName[alias.size()]));
        }
        return properties;
    }

