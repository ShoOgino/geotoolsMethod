    /**
     * Creates an envelope for a grid range transformed to an envelope using the specified math
     * transform. The <cite>grid to CRS</cite> transform should map either the {@linkplain
     * PixelInCell#CELL_CENTER cell center} (as in OGC convention) or {@linkplain
     * PixelInCell#CELL_CORNER cell corner} (as in Java2D/JAI convention) depending on the {@code
     * anchor} value. This constructor creates an envelope containing entirely all pixels on a
     * <cite>best effort</cite> basis - usually accurate for affine transforms.
     *
     * <p><b>Note:</b> The convention is specified as a {@link PixelInCell} code instead than the
     * more detailled {@link org.opengis.metadata.spatial.PixelOrientation}, because the later is
     * restricted to the two-dimensional case while the former can be used for any number of
     * dimensions.
     *
     * @param gridRange The grid range.
     * @param anchor Whatever grid range coordinates map to pixel center or pixel corner.
     * @param gridToCRS The transform (usually affine) from grid range to the envelope CRS.
     * @param crs The envelope CRS, or {@code null} if unknow.
     * @throws MismatchedDimensionException If one of the supplied object doesn't have a dimension
     *     compatible with the other objects.
     * @throws IllegalArgumentException if an argument is illegal for some other reason, including
     *     failure to use the provided math transform.
     * @since 2.3
     * @see
     *     org.geotools.coverage.grid.GeneralGridEnvelope#GeneralGridEnvelope(Envelope,PixelInCell,boolean)
     */
    public GeneralEnvelope(
            final GridEnvelope gridRange,
            final PixelInCell anchor,
            final MathTransform gridToCRS,
            final CoordinateReferenceSystem crs)
            throws IllegalArgumentException {
        ensureNonNull("gridRange", gridRange);
        ensureNonNull("gridToCRS", gridToCRS);
        final int dimRange = gridRange.getDimension();
        final int dimSource = gridToCRS.getSourceDimensions();
        final int dimTarget = gridToCRS.getTargetDimensions();
        ensureSameDimension(dimRange, dimSource);
        ensureSameDimension(dimRange, dimTarget);
        ordinates = new double[dimSource * 2];
        final double offset = PixelTranslation.getPixelTranslation(anchor) + 0.5;
        for (int i = 0; i < dimSource; i++) {
            /*
             * According OpenGIS specification, GridGeometry maps pixel's center. We want a bounding
             * box for all pixels, not pixel's centers. Offset by 0.5 (use -0.5 for maximum too, not
             * +0.5, since maximum is exclusive).
             *
             * Note: the offset of 1 after getHigh(i) is because high values are inclusive according
             * ISO specification, while our algorithm and Java usage expect exclusive values.
             */
            setRange(i, gridRange.getLow(i) - offset, gridRange.getHigh(i) - (offset - 1));
        }
        final GeneralEnvelope transformed;
        try {
            transformed = CRS.transform(gridToCRS, this);
        } catch (TransformException exception) {
            throw new IllegalArgumentException(
                    Errors.format(ErrorKeys.BAD_TRANSFORM_$1, Classes.getClass(gridToCRS)),
                    exception);
        }
        assert transformed.ordinates.length == this.ordinates.length;
        System.arraycopy(transformed.ordinates, 0, this.ordinates, 0, ordinates.length);
        setCoordinateReferenceSystem(crs);
    }

