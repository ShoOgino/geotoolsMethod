        /**
         * Returns a set of authority codes that <strong>may</strong> identify the same object than
         * the specified one. This implementation tries to get a smaller set than what {@link
         * DirectEpsgFactory#getAuthorityCodes} would produce.
         */
        @Override
        protected Set getSpecificCodeCandidates(final IdentifiedObject object)
                throws FactoryException {
            String select = "COORD_REF_SYS_CODE";
            String from = "[Coordinate Reference System]";
            String where, code;
            String sql;
            if (object instanceof Ellipsoid) {
                final double semiMajorAxis = ((Ellipsoid) object).getSemiMajorAxis();
                double tol = getTolerance();
                // consider tolerance
                final double min = semiMajorAxis - semiMajorAxis * tol;
                final double max = semiMajorAxis + semiMajorAxis * tol;
                code = Double.toString(semiMajorAxis);
                sql =
                        "SELECT ELLIPSOID_CODE FROM [Ellipsoid] JOIN [Unit of Measure] on [Ellipsoid].UOM_CODE = [Unit of Measure].UOM_CODE WHERE (SEMI_MAJOR_AXIS * FACTOR_B / FACTOR_C) between "
                                + min
                                + " AND "
                                + max
                                + " ORDER BY ABS(DEPRECATED)";
            } else {
                IdentifiedObject dependency;
                if (object instanceof GeneralDerivedCRS) {
                    dependency = ((GeneralDerivedCRS) object).getBaseCRS();
                    where = "SOURCE_GEOGCRS_CODE";
                } else if (object instanceof SingleCRS) {
                    dependency = ((SingleCRS) object).getDatum();
                    where = "DATUM_CODE";
                } else if (object instanceof GeodeticDatum) {
                    dependency = ((GeodeticDatum) object).getEllipsoid();
                    select = "DATUM_CODE";
                    from = "[Datum]";
                    where = "ELLIPSOID_CODE";
                } else {
                    return super.getCodeCandidates(object);
                }
                if (dependency instanceof Ellipsoid) {
                    // since we match only by major axis length, which is shared among several,
                    // we need to pick all codes, not just some
                    Set candidates = getSpecificCodeCandidates(dependency);
                    if (candidates.isEmpty()) {
                        // could not find the object using a fast scan, bail out
                        return Collections.emptySet();
                    }
                    sql = "SELECT " + select + " FROM " + from + " WHERE " + where + " in (";
                    code = candidates.toString(); // just for the exception
                    for (Object candidate : candidates) {
                        sql += candidate + ", ";
                    }
                    sql = sql.substring(0, sql.length() - 2) + ")";
                } else {
                    Identifier id = identifySubObject(buffered, dependency);
                    if (id == null || (code = id.getCode()) == null) {
                        id = identifySubObject(lonLatFactory, dependency);
                        if (id == null || (code = id.getCode()) == null) {
                            // could not find the object using a fast scan, bail out
                            return Collections.emptySet();
                        }
                    }
                    sql =
                            "SELECT "
                                    + select
                                    + " FROM "
                                    + from
                                    + " WHERE "
                                    + where
                                    + "='"
                                    + code
                                    + "' ORDER BY ABS(DEPRECATED)";
                }
            }
            sql = adaptSQL(sql);
            final Set<String> result = new LinkedHashSet<String>();
            try {
                final Statement s = getConnection().createStatement();
                final ResultSet r = s.executeQuery(sql);
                while (r.next()) {
                    result.add(r.getString(1));
                }
                r.close();
                s.close();
            } catch (SQLException exception) {
                throw databaseFailure(Identifier.class, code, exception);
            }
            return result;
        }

