    /**
     * Sorts an array of codes in preference order. This method orders pairwise the codes according
     * the information provided in the supersession table. If the same object is superseded by more
     * than one object, then the most recent one is inserted first. Except for the codes moved as a
     * result of pairwise ordering, this method try to preserve the old ordering of the supplied
     * codes (since deprecated operations should already be last). The ordering is performed in
     * place.
     *
     * @param codes The codes, usually as an array of {@link String}. If the array do not contains
     *     string objects, then the {@link Object#toString} method must returns the code for each
     *     element.
     */
    private void sort(final Object[] codes) throws SQLException, FactoryException {
        if (codes.length <= 1) {
            return; // Nothing to sort.
        }
        final PreparedStatement stmt;
        stmt =
                prepareStatement(
                        "Supersession",
                        "SELECT SUPERSEDED_BY"
                                + " FROM [Supersession]"
                                + " WHERE OBJECT_CODE = ?"
                                + " ORDER BY SUPERSESSION_YEAR DESC");
        int maxIterations = 15; // For avoiding never-ending loop.
        do {
            boolean changed = false;
            for (int i = 0; i < codes.length; i++) {
                final String code = codes[i].toString();
                stmt.setInt(1, Integer.parseInt(code));
                final ResultSet result = stmt.executeQuery();
                while (result.next()) {
                    final String replacement = getString(result, 1, code);
                    for (int j = i + 1; j < codes.length; j++) {
                        final Object candidate = codes[j];
                        if (replacement.equals(candidate.toString())) {
                            /*
                             * Found a code to move in front of the superceded one.
                             */
                            System.arraycopy(codes, i, codes, i + 1, j - i);
                            codes[i++] = candidate;
                            changed = true;
                        }
                    }
                }
                result.close();
            }
            if (!changed) {
                return;
            }
        } while (--maxIterations != 0);
        LOGGER.finer("Possible recursivity in supersessions.");
    }

