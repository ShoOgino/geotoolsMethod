    /**
     * Loads the coefficients from the specified ASCII file and initialize the internal
     * <cite>clenshaw arrays</cite>.
     *
     * <p><strong>Note:</strong> ASCII may looks like an unefficient format for binary distribution.
     * A binary file with coefficient values read by {@link java.io.DataInput#readDouble} would be
     * more compact than an <u>uncompressed</u> ASCII file. However, binary files are hard to
     * compress by the ZIP algorithm. Our experience show that a 675 kb uncompressed ASCII file is
     * only 222 kb after ZIP or JAR compression. The same data as a binary file is 257 kb
     * uncompressed and 248 kb compressed. So surprisingly, the ASCII file is more compact than the
     * binary file after compression. Since it is the primary format provided by the Earth-Info web
     * site, we use it directly in order to avoid a multiplication of formats.
     *
     * @param filename The filename (e.g. {@code "WGS84.cof"}, relative to this class directory.
     * @throws IOException if the file can't be read or has an invalid content.
     */
    protected void load(final String filename) throws IOException {
        try (InputStream stream = EarthGravitationalModel.class.getResourceAsStream(filename)) {
            if (stream == null) {
                throw new FileNotFoundException(filename);
            }
            try (LineNumberReader in =
                    new LineNumberReader(new InputStreamReader(stream, "ISO-8859-1"))) {
                String line;
                while ((line = in.readLine()) != null) {
                    final StringTokenizer tokens = new StringTokenizer(line);
                    try {
                        /*
                         * Note: we use 'parseShort' instead of 'parseInt' as an easy way to ensure that
                         *       the values are in some reasonable range. The range is typically [0..180].
                         *       We don't check that, but at least 'parseShort' disallows values greater
                         *       than 32767. Additional note: we real all lines in all cases even if we
                         *       discard some of them, in order to check the file format.
                         */
                        final int n = Short.parseShort(tokens.nextToken());
                        final int m = Short.parseShort(tokens.nextToken());
                        final double cbar = Double.parseDouble(tokens.nextToken());
                        final double sbar = Double.parseDouble(tokens.nextToken());
                        if (n <= nmax) {
                            final int ll = locatingArray(n) + m;
                            cnmGeopCoef[ll] = cbar;
                            snmGeopCoef[ll] = sbar;
                        }
                    } catch (RuntimeException cause) {
                        /*
                         * Catch the following exceptions:
                         *   - NoSuchElementException      if a line has too few numbers.
                         *   - NumberFormatException       if a number can't be parsed.
                         *   - IndexOutOfBoundsException   if 'n' or 'm' values are illegal.
                         */
                        final IOException exception =
                                new IOException(
                                        Errors.format(
                                                ErrorKeys.BAD_LINE_IN_FILE_$2,
                                                filename,
                                                in.getLineNumber()));
                        exception.initCause(
                                cause); // TODO: Inline when we will be allowed to target Java 6.
                        throw exception;
                    }
                }
            }
        }
        initialize();
    }

