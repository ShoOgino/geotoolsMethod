    /**
     * Replaces (if needed) the specified coordinate reference system. The default implementation
     * checks if there is a {@linkplain #replace(Datum) datum replacement} or a {@linkplain
     * #replace(CoordinateSystem) coordinate system replacement}. If there is at least one of those,
     * then this method returns a new coordinate reference system using the new datum and coordinate
     * system.
     *
     * @param crs The coordinate reference system to replace.
     * @return A new CRS, or {@code crs} if no change were needed.
     * @throws FactoryException if an error occured while creating the new CRS object.
     */
    // @Override
    protected CoordinateReferenceSystem replace(final CoordinateReferenceSystem crs)
            throws FactoryException {
        /*
         * Gets the replaced coordinate system and datum, and checks if there is any change.
         */
        final CoordinateSystem oldCS = crs.getCoordinateSystem();
        final CoordinateSystem cs = replace(oldCS);
        final Datum oldDatum, datum;
        if (crs instanceof SingleCRS) {
            oldDatum = ((SingleCRS) crs).getDatum();
            datum = replace(oldDatum);
        } else {
            datum = oldDatum = null;
        }
        final boolean sameCS = Utilities.equals(cs, oldCS) && Utilities.equals(datum, oldDatum);
        /*
         * Creates a new coordinate reference system using the same properties
         * than the original CRS, except for the coordinate system, datum and
         * authority code.
         */
        CoordinateReferenceSystem modified;
        if (crs instanceof GeneralDerivedCRS) {
            final GeneralDerivedCRS derivedCRS = (GeneralDerivedCRS) crs;
            final CoordinateReferenceSystem oldBaseCRS = derivedCRS.getBaseCRS();
            final CoordinateReferenceSystem baseCRS = replace(oldBaseCRS);
            if (sameCS && Utilities.equals(baseCRS, oldBaseCRS)) {
                return crs;
            }
            final Map<String, ?> properties = getProperties(crs);
            final ReferencingFactoryContainer factories = getFactoryContainer(true);
            final CRSFactory crsFactory = factories.getCRSFactory();
            Conversion fromBase = derivedCRS.getConversionFromBase();
            fromBase =
                    new DefiningConversion(
                            getProperties(fromBase),
                            fromBase.getMethod(),
                            fromBase.getParameterValues());
            if (crs instanceof ProjectedCRS) {
                modified =
                        crsFactory.createProjectedCRS(
                                properties, (GeographicCRS) baseCRS, fromBase, (CartesianCS) cs);
            } else {
                // TODO: Need a createDerivedCRS method.
                throw new FactoryException(
                        Errors.format(ErrorKeys.UNSUPPORTED_CRS_$1, crs.getName().getCode()));
            }
        } else if (sameCS) {
            return crs;
        } else {
            final Map<String, ?> properties = getProperties(crs);
            final ReferencingFactoryContainer factories = getFactoryContainer(true);
            final CRSFactory crsFactory = factories.getCRSFactory();
            if (crs instanceof GeographicCRS) {
                modified =
                        crsFactory.createGeographicCRS(
                                properties, (GeodeticDatum) datum, (EllipsoidalCS) cs);
            } else if (crs instanceof GeocentricCRS) {
                final GeodeticDatum gd = (GeodeticDatum) datum;
                if (cs instanceof CartesianCS) {
                    modified = crsFactory.createGeocentricCRS(properties, gd, (CartesianCS) cs);
                } else {
                    modified = crsFactory.createGeocentricCRS(properties, gd, (SphericalCS) cs);
                }
            } else if (crs instanceof VerticalCRS) {
                modified =
                        crsFactory.createVerticalCRS(
                                properties, (VerticalDatum) datum, (VerticalCS) cs);
            } else if (crs instanceof TemporalCRS) {
                modified =
                        crsFactory.createTemporalCRS(
                                properties, (TemporalDatum) datum, (TimeCS) cs);
            } else if (crs instanceof ImageCRS) {
                modified = crsFactory.createImageCRS(properties, (ImageDatum) datum, (AffineCS) cs);
            } else if (crs instanceof EngineeringCRS) {
                modified =
                        crsFactory.createEngineeringCRS(properties, (EngineeringDatum) datum, cs);
            } else if (crs instanceof CompoundCRS) {
                final List<CoordinateReferenceSystem> elements =
                        ((CompoundCRS) crs).getCoordinateReferenceSystems();
                final CoordinateReferenceSystem[] m =
                        new CoordinateReferenceSystem[elements.size()];
                for (int i = 0; i < m.length; i++) {
                    m[i] = replace(elements.get(i));
                }
                modified = crsFactory.createCompoundCRS(properties, m);
            } else {
                throw new FactoryException(
                        Errors.format(ErrorKeys.UNSUPPORTED_CRS_$1, crs.getName().getCode()));
            }
        }
        modified = pool.unique(modified);
        return modified;
    }

