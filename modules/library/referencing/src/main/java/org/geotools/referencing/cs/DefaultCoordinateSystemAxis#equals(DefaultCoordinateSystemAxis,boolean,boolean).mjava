    /**
     * Compares the specified object with this axis for equality, with optional comparaison of
     * units. Units should always be compared (they are not just metadata), except in the particular
     * case of {@link AbstractCS#axisColinearWith}, which is used as a first step toward units
     * conversions through {@link AbstractCS#swapAndScaleAxis}.
     */
    final boolean equals(
            final DefaultCoordinateSystemAxis that,
            final boolean compareMetadata,
            final boolean compareUnit) {
        if (compareMetadata) {
            if (!Utilities.equals(this.abbreviation, that.abbreviation)
                    || !Utilities.equals(this.rangeMeaning, that.rangeMeaning)
                    || Double.doubleToLongBits(minimum) != Double.doubleToLongBits(that.minimum)
                    || Double.doubleToLongBits(maximum) != Double.doubleToLongBits(that.maximum)) {
                return false;
            }
        } else {
            /*
             * Checking the abbreviation is not suffisient. For example the polar angle and the
             * spherical latitude have the same abbreviation (theta).  Geotools extensions like
             * "Longitude" (in addition of ISO 19111 "Geodetic longitude") bring more potential
             * confusion. Furthermore, not all implementors will use the greek letters (even if
             * they are part of ISO 19111).    For example most CRS in WKT format use the "Lat"
             * abbreviation instead of the greek letter phi. For comparaisons without metadata,
             * we ignore the unreliable abbreviation and check the axis name instead. These
             * names are constrained by ISO 19111 specification (see class javadoc), so they
             * should be reliable enough.
             *
             * Note: there is no need to execute this block if 'compareMetadata' is true,
             *       because in this case a stricter check has already been performed by
             *       the 'equals' method in the superclass.
             */
            final String thatName = that.getName().getCode();
            if (!nameMatches(thatName)) {
                // The above test checked for special cases ("Lat" / "Lon" aliases, etc.).
                // The next line may not, but is tested anyway in case the user overrided
                // the 'that.nameMatches(...)' method.
                final String thisName = getName().getCode();
                if (!nameMatches(that, thisName)) {
                    // For the needs of AbstractCS.axisColinearWith(...), we must stop here.
                    // In addition it may be safer to not test 'nameMatchesXY' when we don't
                    // have the extra-safety of units comparaison, because "x" and "y" names
                    // are too generic.
                    if (!compareUnit) {
                        return false;
                    }
                    // Last chance: check for the special case of "x" and "y" axis names.
                    if (!nameMatchesXY(thatName, thisName) && !nameMatchesXY(thisName, thatName)) {
                        return false;
                    }
                }
            }
        }
        return Utilities.equals(this.direction, that.direction)
                && (!compareUnit || Utilities.equals(this.unit, that.unit));
    }

