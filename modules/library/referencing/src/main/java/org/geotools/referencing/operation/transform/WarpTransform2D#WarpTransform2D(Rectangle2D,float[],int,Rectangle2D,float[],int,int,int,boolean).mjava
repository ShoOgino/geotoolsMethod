    /**
     * Work around for a bug in WarpPolynomial.createWarp(...). This constructor should move in the
     * one above when the {@code cloneCoords} argument will no longer be needed (after the JAI bug
     * get fixed).
     */
    private WarpTransform2D(
            final Rectangle2D srcBounds,
            float[] srcCoords,
            int srcOffset,
            final Rectangle2D dstBounds,
            float[] dstCoords,
            int dstOffset,
            final int numCoords,
            final int degree,
            boolean cloneCoords) {
        final float preScaleX, preScaleY, postScaleX, postScaleY;
        if (srcBounds != null) {
            preScaleX = (float) srcBounds.getWidth();
            preScaleY = (float) srcBounds.getHeight();
        } else {
            preScaleX = getWidth(srcCoords, srcOffset, numCoords);
            preScaleY = getWidth(srcCoords, srcOffset + 1, numCoords);
        }
        if (dstBounds != null) {
            postScaleX = (float) dstBounds.getWidth();
            postScaleY = (float) dstBounds.getHeight();
        } else {
            postScaleX = getWidth(dstCoords, dstOffset, numCoords);
            postScaleY = getWidth(dstCoords, dstOffset + 1, numCoords);
        }
        /*
         * Workaround for a bug in WarpPolynomial.create(...): the later scale coordinates
         * according the scale values, but the 'preScale' and 'postScale' are interchanged.
         * When JAI bug will be fixed, delete all the following block until the next comment.
         */
        if (USE_HACK) {
            final double scaleX = preScaleX / postScaleX;
            final double scaleY = preScaleY / postScaleY;
            if (scaleX != 1 || scaleY != 1) {
                final int n = numCoords * 2;
                if (cloneCoords) {
                    float[] o = srcCoords;
                    srcCoords = new float[n];
                    System.arraycopy(o, srcOffset, srcCoords, 0, n);
                    srcOffset = 0;
                    o = dstCoords;
                    dstCoords = new float[n];
                    System.arraycopy(o, dstOffset, dstCoords, 0, n);
                    dstOffset = 0;
                }
                for (int i = 0; i < n; ) {
                    srcCoords[srcOffset + i] /= scaleX;
                    dstCoords[dstOffset + i++] *= scaleX;
                    srcCoords[srcOffset + i] /= scaleY;
                    dstCoords[dstOffset + i++] *= scaleY;
                }
            }
        }
        /*
         * Note: Warp semantic (transforms coordinates from destination to source) is the
         *       opposite of MathTransform semantic (transforms coordinates from source to
         *       destination). We have to interchange source and destination arrays for the
         *       direct transform.
         */
        warp =
                WarpPolynomial.createWarp(
                        dstCoords,
                        dstOffset,
                        srcCoords,
                        srcOffset,
                        numCoords,
                        1 / preScaleX,
                        1 / preScaleY,
                        postScaleX,
                        postScaleY,
                        degree);
        inverse =
                new WarpTransform2D(
                        WarpPolynomial.createWarp(
                                srcCoords,
                                srcOffset,
                                dstCoords,
                                dstOffset,
                                numCoords,
                                1 / postScaleX,
                                1 / postScaleY,
                                preScaleX,
                                preScaleY,
                                degree),
                        this);
    }

