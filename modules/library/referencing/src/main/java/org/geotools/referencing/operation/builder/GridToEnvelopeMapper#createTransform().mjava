    /**
     * Creates a math transform using the information provided by setter methods.
     *
     * @return The math transform.
     * @throws IllegalStateException if the grid range or the envelope were not set.
     */
    public MathTransform createTransform() throws IllegalStateException {
        if (transform == null) {
            final GridEnvelope gridRange = getGridRange();
            final Envelope     userRange = getEnvelope();
            final boolean      swapXY    = getSwapXY();
            final boolean[]    reverse   = getReverseAxis();
            final PixelInCell  gridType  = getPixelAnchor();
            final int          dimension = gridRange.getDimension();
            /*
             * Setup the multi-dimensional affine transform for use with OpenGIS.
             * According OpenGIS specification, transforms must map pixel center.
             * This is done by adding 0.5 to grid coordinates.
             */
            final double translate;
            if (PixelInCell.CELL_CENTER.equals(gridType)) {
                translate = 0.5;
            } else if (PixelInCell.CELL_CORNER.equals(gridType)) {
                translate = 0.0;
            } else {
                throw new IllegalStateException(Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$2,
                            "gridType", gridType));
            }
            final Matrix matrix = MatrixFactory.create(dimension + 1);
            for (int i=0; i<dimension; i++) {
                // NOTE: i is a dimension in the 'gridRange' space (source coordinates).
                //       j is a dimension in the 'userRange' space (target coordinates).
                int j = i;
                if (swapXY && j<=1) {
                    j = 1-j;
                }
                double scale = userRange.getSpan(j) / gridRange.getSpan(i);
                double offset;
                if (reverse==null || j>=reverse.length || !reverse[j]) {
                    offset = userRange.getMinimum(j);
                } else {
                    scale  = -scale;
                    offset = userRange.getMaximum(j);
                }
                offset -= scale * (gridRange.getLow(i) - translate);
                matrix.setElement(j, j,         0.0   );
                matrix.setElement(j, i,         scale );
                matrix.setElement(j, dimension, offset);
            }
            transform = ProjectiveTransform.create(matrix);
        }
        return transform;
    }

