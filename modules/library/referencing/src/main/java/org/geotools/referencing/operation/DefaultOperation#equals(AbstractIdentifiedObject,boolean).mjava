    /**
     * Compare this operation method with the specified object for equality. If {@code
     * compareMetadata} is {@code true}, then all available properties are compared including
     * {@linkplain DefaultOperationMethod#getFormula formula}.
     *
     * @param object The object to compare to {@code this}.
     * @param compareMetadata {@code true} for performing a strict comparaison, or {@code false} for
     *     comparing only properties relevant to transformations.
     * @return {@code true} if both objects are equal.
     */
    @Override
    public boolean equals(final AbstractIdentifiedObject object, final boolean compareMetadata) {
        if (super.equals(object, compareMetadata)) {
            final DefaultOperation that = (DefaultOperation) object;
            if (compareMetadata) {
                return equals(this.method, that.method, compareMetadata);
            }
            /*
             * We consider the operation method as metadata. We could argue that OperationMethod's
             * 'sourceDimensions' and 'targetDimensions' are not metadata, but their values should
             * be identical to the 'sourceCRS' and 'targetCRS' dimensions,  already checked by the
             * superclass. We could also argue that 'OperationMethod.parameters' are not metadata,
             * but their values should have been taken in account for the MathTransform creation,
             * which was compared by the superclass.
             *
             * Comparing the MathTransforms instead of parameters avoid the problem of implicit
             * parameters.  For example in a ProjectedCRS, the "semiMajor" and "semiMinor" axis
             * lengths are sometime provided as explicit parameters, and sometime inferred from
             * the geodetic datum.  The two cases would be different set of parameters from the
             * OperationMethod's point of view, but still result in the creation of identical
             * MathTransform.
             *
             * An other rational for treating OperationMethod as metadata is that Geotools
             * MathTransformProvider extends DefaultOperationMethod. Consequently there is
             * a wide range of subclasses, which make the comparaisons more difficult. For
             * example Mercator1SP.Provider and Mercator2SP.Provider are two different ways
             * to describe the same projection. The SQL-backed EPSG factory uses yet an
             * other implementation.
             *
             * As a safety, we still compare the name. But I'm not completly sure that it is
             * necessary.
             *
             * AA: this comparison was removed to allow the common case of Conformal 1SP vs
             * conformal 2SP equivalence to succeed a equalsIgnoreMetadata comparison. Extensive tests
             * revealed no regressions, as it was noted above, there is no proof this is actually
             * necessary
             */
            // return nameMatches(this.method, that.method);
            return true;
        }
        return false;
    }

