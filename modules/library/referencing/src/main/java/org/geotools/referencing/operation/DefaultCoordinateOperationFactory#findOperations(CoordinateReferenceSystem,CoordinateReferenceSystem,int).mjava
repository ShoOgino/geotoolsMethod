    /**
     * Returns all the available operations for conversion or transformation between two coordinate reference systems. If no operation exists, then an
     * empty set is returned.
     * <P>
     * The default implementation inspects the CRS and delegates the work to one or many {@code createOperationStep(...)} methods. This method fails
     * if no path between the CRSs is found.
     *
     * @param sourceCRS Input coordinate reference system.
     * @param targetCRS Output coordinate reference system.
     * @param limit The maximum number of operations to be returned. Use -1 to return all the available operations. Use 1 to return just one
     *        operations. Currently, the behavior for other values of {@code limit} is undefined.
     * @return A {@code Set} of coordinate operations from {@code sourceCRS} to {@code targetCRS}.
     * @throws FactoryException if the operation creation failed for some other reason.
     */
    protected Set<CoordinateOperation> findOperations(final CoordinateReferenceSystem sourceCRS,
            final CoordinateReferenceSystem targetCRS, int limit)
            throws FactoryException
    {
        ensureNonNull("sourceCRS", sourceCRS);
        ensureNonNull("targetCRS", targetCRS);
        if (equalsIgnoreMetadata(sourceCRS, targetCRS)) {
            final int dim  = getDimension(sourceCRS);
            assert    dim == getDimension(targetCRS) : dim;
            CoordinateOperation op = createFromAffineTransform(IDENTITY, sourceCRS, targetCRS,
                                             MatrixFactory.create(dim+1));
            return Collections.singleton(op);
        } else {
            // Query the database (if any) before to try to find the operation by ourself.
            Set<CoordinateOperation> result = findFromDatabase(sourceCRS, targetCRS, limit);
            if (!result.isEmpty()) {
                return result;
            }
        }
        
        /////////////////////////////////////////
        ////                                 ////
        ////     Generic  -->  various CS    ////
        ////     Various CS --> Generic      ////
        ////                                 ////
        /////////////////////////////////////////
        if (isWildcard(sourceCRS) || isWildcard(targetCRS))
        {
            final int dimSource = getDimension(sourceCRS);
            final int dimTarget = getDimension(targetCRS);
            if (dimTarget == dimSource) {
                final Matrix matrix = MatrixFactory.create(dimTarget+1, dimSource+1);
                CoordinateOperation op = createFromAffineTransform(IDENTITY, sourceCRS, targetCRS, matrix);
                return Collections.singleton(op);
            }
        }
        
        /*
         * Before to process, performs a special check for CompoundCRS where the target contains
         * every elements included in the source.  CompoundCRS are usually verified last, but in
         * the special case described above there is only axis switch or dimension to remove. If
         * we wait last for processing them, what would have been a simple CoordinateOperation
         * may become interleaved with more complex operation (e.g. projection followed by the
         * inverse projection, before they get simplified by DefaultConcatenatedOperation, etc.).
         */
        if (sourceCRS instanceof CompoundCRS) {
            final List<SingleCRS> sources = DefaultCompoundCRS.getSingleCRS(sourceCRS);
            final List<SingleCRS> targets = DefaultCompoundCRS.getSingleCRS(targetCRS);
            if (containsIgnoreMetadata(sources, targets)) {
                final CompoundCRS source = (CompoundCRS) sourceCRS;
                if (targetCRS instanceof CompoundCRS) {
                    final CompoundCRS target = (CompoundCRS) targetCRS;
                    return findOperationSteps(source, target, limit);
                }
                if (targetCRS instanceof SingleCRS) {
                    final SingleCRS target = (SingleCRS) targetCRS;
                    return findOperationSteps(source, target, limit);
                }
            }
        }
        /////////////////////////////////////////////////////////////////////
        ////                                                             ////
        ////     Geographic  -->  Geographic, Projected or Geocentric    ////
        ////                                                             ////
        /////////////////////////////////////////////////////////////////////
        if (sourceCRS instanceof GeographicCRS) {
            final GeographicCRS source = (GeographicCRS) sourceCRS;
            if (targetCRS instanceof GeographicCRS) {
                final GeographicCRS target = (GeographicCRS) targetCRS;
                return Collections.singleton(createOperationStep(source, target));
            }
            if (targetCRS instanceof ProjectedCRS) {
                final ProjectedCRS target = (ProjectedCRS) targetCRS;
                return findOperationSteps(source, target, limit);
            }
            if (targetCRS instanceof GeocentricCRS) {
                final GeocentricCRS target = (GeocentricCRS) targetCRS;
                return Collections.singleton(createOperationStep(source, target));
            }
            if (targetCRS instanceof VerticalCRS) {
                final VerticalCRS target = (VerticalCRS) targetCRS;
                return Collections.singleton(createOperationStep(source, target));
            }
        }
        /////////////////////////////////////////////////////////
        ////                                                 ////
        ////     Projected  -->  Projected or Geographic     ////
        ////                                                 ////
        /////////////////////////////////////////////////////////
        if (sourceCRS instanceof ProjectedCRS) {
            final ProjectedCRS source = (ProjectedCRS) sourceCRS;
            if (targetCRS instanceof ProjectedCRS) {
                final ProjectedCRS target = (ProjectedCRS) targetCRS;
                return findOperationSteps(source, target, limit);
            }
            if (targetCRS instanceof GeographicCRS) {
                final GeographicCRS target = (GeographicCRS) targetCRS;
                return findOperationSteps(source, target, limit);
            }
        }
        //////////////////////////////////////////////////////////
        ////                                                  ////
        ////     Geocentric  -->  Geocentric or Geographic    ////
        ////                                                  ////
        //////////////////////////////////////////////////////////
        if (sourceCRS instanceof GeocentricCRS) {
            final GeocentricCRS source = (GeocentricCRS) sourceCRS;
            if (targetCRS instanceof GeocentricCRS) {
                final GeocentricCRS target = (GeocentricCRS) targetCRS;
                return Collections.singleton(createOperationStep(source, target));
            }
            if (targetCRS instanceof GeographicCRS) {
                final GeographicCRS target = (GeographicCRS) targetCRS;
                return Collections.singleton(createOperationStep(source, target));
            }
        }
        /////////////////////////////////////////
        ////                                 ////
        ////     Vertical  -->  Vertical     ////
        ////                                 ////
        /////////////////////////////////////////
        if (sourceCRS instanceof VerticalCRS) {
            final VerticalCRS source = (VerticalCRS) sourceCRS;
            if (targetCRS instanceof VerticalCRS) {
                final VerticalCRS target = (VerticalCRS) targetCRS;
                return Collections.singleton(createOperationStep(source, target));
            }
        }
        /////////////////////////////////////////
        ////                                 ////
        ////     Temporal  -->  Temporal     ////
        ////                                 ////
        /////////////////////////////////////////
        if (sourceCRS instanceof TemporalCRS) {
            final TemporalCRS source = (TemporalCRS) sourceCRS;
            if (targetCRS instanceof TemporalCRS) {
                final TemporalCRS target = (TemporalCRS) targetCRS;
                return Collections.singleton(createOperationStep(source, target));
            }
        }
        //////////////////////////////////////////////////////////////////
        ////                                                          ////
        ////     Any coordinate reference system -->  Derived CRS     ////
        ////                                                          ////
        //////////////////////////////////////////////////////////////////
        if (targetCRS instanceof GeneralDerivedCRS) {
            // Note: this code is identical to 'createOperationStep(GeographicCRS, ProjectedCRS)'
            //       except that the later invokes directly the right method for 'step1' instead
            //       of invoking 'createOperation' recursively.
            final GeneralDerivedCRS  target = (GeneralDerivedCRS) targetCRS;
            final CoordinateReferenceSystem base = target.getBaseCRS();
            final Set<CoordinateOperation> step1 = findOperations(sourceCRS, base, limit);
            final CoordinateOperation step2 = target.getConversionFromBase();
            return concatenate(step1, Collections.singleton(step2));
        }
        //////////////////////////////////////////////////////////////////
        ////                                                          ////
        ////     Derived CRS -->  Any coordinate reference system     ////
        ////                                                          ////
        //////////////////////////////////////////////////////////////////
        if (sourceCRS instanceof GeneralDerivedCRS) {
            // Note: this code is identical to 'createOperationStep(ProjectedCRS, GeographicCRS)'
            //       except that the later invokes directly the right method for 'step2' instead
            //       of invoking 'createOperation' recursively.
            final GeneralDerivedCRS       source = (GeneralDerivedCRS) sourceCRS;
            final CoordinateReferenceSystem base = source.getBaseCRS();
            final Set<CoordinateOperation> step2 = findOperations(base, targetCRS, limit);
            CoordinateOperation            step1 = source.getConversionFromBase();
            MathTransform              transform = step1.getMathTransform();
            try {
                transform = transform.inverse();
            } catch (NoninvertibleTransformException exception) {
                throw new OperationNotFoundException(getErrorMessage(sourceCRS, base), exception);
            }
            step1 = createFromMathTransform(INVERSE_OPERATION, sourceCRS, base, transform);
            return concatenate(Collections.singleton(step1), step2);
        }
        ////////////////////////////////////////////
        ////                                    ////
        ////     Compound  -->  various CRS     ////
        ////                                    ////
        ////////////////////////////////////////////
        if (sourceCRS instanceof CompoundCRS) {
            final CompoundCRS source = (CompoundCRS) sourceCRS;
            if (targetCRS instanceof CompoundCRS) {
                final CompoundCRS target = (CompoundCRS) targetCRS;
                return findOperationSteps(source, target, limit);
            }
            if (targetCRS instanceof SingleCRS) {
                final SingleCRS target = (SingleCRS) targetCRS;
                return findOperationSteps(source, target, limit);
            }
        }
        if (targetCRS instanceof CompoundCRS) {
            final CompoundCRS target = (CompoundCRS) targetCRS;
            if (sourceCRS instanceof SingleCRS) {
                final SingleCRS source = (SingleCRS) sourceCRS;
                return findOperationSteps(source, target, limit);
            }
        }
        return Collections.emptySet();
    }

