    /**
     * Transforms a list of coordinate point ordinal values. The source points are first transformed
     * by {@link #transform1}, then the intermediate points are transformed by {@link #transform2}.
     * The transformations are performed without intermediate buffer if it can be avoided.
     */
    @Override
    public void transform(
            final double[] srcPts, int srcOff, final double[] dstPts, int dstOff, int numPts)
            throws TransformException {
        assert isValid();
        final int intermDim = transform1.getTargetDimensions();
        final int targetDim = getTargetDimensions();
        /*
         * If the transfert dimension is not greater than the target dimension, then we
         * don't need to use an intermediate buffer. Note that this optimization is done
         * inconditionnaly in ConcatenatedTransformDirect.
         */
        if (intermDim <= targetDim) {
            transform1.transform(srcPts, srcOff, dstPts, dstOff, numPts);
            transform2.transform(dstPts, dstOff, dstPts, dstOff, numPts);
            return;
        }
        if (numPts <= 0) {
            return;
        }
        /*
         * Creates a temporary array for the intermediate result. The array may be smaller than
         * the length necessary for containing every coordinates. In such case the concatenated
         * transform will need to be applied piecewise.
         */
        int numTmp = numPts;
        int length = numTmp * intermDim;
        if (length > TEMPORARY_ARRAY_LENGTH) {
            numTmp = Math.max(1, TEMPORARY_ARRAY_LENGTH / intermDim);
            length = numTmp * intermDim;
        }
        final double[] tmp = new double[length];
        final int sourceDim = getSourceDimensions();
        do {
            if (numTmp > numPts) {
                numTmp = numPts;
            }
            transform1.transform(srcPts, srcOff, tmp, 0, numTmp);
            transform2.transform(tmp, 0, dstPts, dstOff, numTmp);
            srcOff += numTmp * sourceDim;
            dstOff += numTmp * targetDim;
            numPts -= numTmp;
        } while (numPts != 0);
    }

