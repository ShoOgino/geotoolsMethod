    /**
     * Formats an angle and appends the resulting text to a given string buffer.
     * The string will be formatted according the pattern set in the last call
     * to {@link #applyPattern}.
     *
     * @param  angle      Angle to format, in degrees.
     * @param  toAppendTo Where the text is to be appended.
     * @param  pos        An optional {@link FieldPosition} identifying a field
     *                    in the formatted text, or {@code null} if this
     *                    information is not wanted. This field position shall
     *                    be constructed with one of the following constants:
     *                    {@link #DEGREES_FIELD},
     *                    {@link #MINUTES_FIELD},
     *                    {@link #SECONDS_FIELD} or
     *                    {@link #HEMISPHERE_FIELD}.
     *
     * @return The string buffer passed in as {@code toAppendTo}, with formatted text appended.
     */
    public synchronized StringBuffer format(final double angle, StringBuffer toAppendTo,
                                            final FieldPosition pos)
    {
        if (Double.isNaN(angle) || Double.isInfinite(angle)) {
            return numberFormat.format(angle, toAppendTo,
                    (pos != null) ? pos : new FieldPosition(DecimalFormat.INTEGER_FIELD));
        }
        double degrees = angle;
        /*
         * Calcule à l'avance les minutes et les secondes. Si les minutes et secondes
         * ne doivent pas être écrits, on mémorisera NaN. Notez que pour extraire les
         * parties entières, on utilise (int) au lieu de 'Math.floor' car (int) arrondie
         * vers 0 (ce qui est le comportement souhaité) alors que 'floor' arrondie vers
         * l'entier inférieur.
         */
        double minutes  = Double.NaN;
        double secondes = Double.NaN;
        if (width1!=0 && !Double.isNaN(angle)) {
            int tmp = (int) degrees; // Arrondie vers 0 même si négatif.
            minutes = Math.abs(degrees - tmp) * 60;
            degrees = tmp;
            if (minutes<0 || minutes>60) {
                // Erreur d'arrondissement (parce que l'angle est trop élevé)
                throw new IllegalArgumentException(Errors.format(ErrorKeys.ANGLE_OVERFLOW_$1, angle));
            }
            if (width2 != 0) {
                tmp      = (int) minutes; // Arrondie vers 0 même si négatif.
                secondes = (minutes - tmp) * 60;
                minutes  = tmp;
                if (secondes<0 || secondes>60) {
                    // Erreur d'arrondissement (parce que l'angle est trop élevé)
                    throw new IllegalArgumentException(Errors.format(ErrorKeys.ANGLE_OVERFLOW_$1, angle));
                }
                tmp = (int) (secondes/60);
                secondes -= 60*tmp;
                minutes += tmp;
            }
            tmp = (int) (minutes/60); // Arrondie vers 0 même si négatif.
            minutes -= 60*tmp;
            degrees += tmp;
        }
        /*
         * Les variables 'degrés', 'minutes' et 'secondes' contiennent
         * maintenant les valeurs des champs à écrire, en principe épurés
         * des problèmes d'arrondissements. Procède maintenant à l'écriture
         * de l'angle.
         */
        if (prefix != null) {
            toAppendTo.append(prefix);
        }
        final int field;
        if (pos != null) {
            field = pos.getField();
            pos.setBeginIndex(0);
            pos.setEndIndex(0);
        } else {
            field=PREFIX_FIELD;
        }
        toAppendTo = formatField(degrees, toAppendTo,
                                 field == DEGREES_FIELD ? pos : null,
                                 width0, width1==0, suffix0);
        if (!Double.isNaN(minutes)) {
            toAppendTo = formatField(minutes, toAppendTo,
                                   field == MINUTES_FIELD ? pos : null,
                                   width1, width2==0, suffix1);
        }
        if (!Double.isNaN(secondes)) {
            toAppendTo = formatField(secondes, toAppendTo,
                                   field == SECONDS_FIELD ? pos : null,
                                   width2, true, suffix2);
        }
        return toAppendTo;
    }

