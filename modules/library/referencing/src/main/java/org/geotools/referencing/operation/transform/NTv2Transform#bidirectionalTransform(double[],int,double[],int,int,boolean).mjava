    /**
     * Performs the actual transformation.
     *
     * @param srcPts the array containing the source point coordinates.
     * @param srcOff the offset to the first point to be transformed in the source array.
     * @param dstPts the array into which the transformed point coordinates are returned. May be the
     *     same than {@code srcPts}.
     * @param dstOff the offset to the location of the first transformed point that is stored in the
     *     destination array.
     * @param numPts the number of point objects to be transformed.
     * @param forward {@code true} for direct transform, {@code false} for inverse transform.
     * @throws TransformException if an IO error occurs reading the grid file.
     */
    private void bidirectionalTransform(
            double[] srcPts, int srcOff, double[] dstPts, int dstOff, int numPts, boolean forward)
            throws TransformException {

        boolean shifted;

        if (gridShift == null) { // Create grid when first needed.
            try {
                gridShift = FACTORY.createNTv2Grid(gridLocation);
            } catch (FactoryException e) {
                throw new TransformException(
                        "NTv2 Grid " + gridLocation + " Could not be created", e);
            }
        }

        try {
            GridShift shift = new GridShift();
            while (--numPts >= 0) {
                shift.setLonPositiveEastDegrees(srcPts[srcOff++]);
                shift.setLatDegrees(srcPts[srcOff++]);
                if (forward) {
                    shifted = gridShift.gridShiftForward(shift);
                } else {
                    shifted = gridShift.gridShiftReverse(shift);
                }
                if (shifted) {
                    dstPts[dstOff++] = shift.getShiftedLonPositiveEastDegrees();
                    dstPts[dstOff++] = shift.getShiftedLatDegrees();
                } else {
                    if (LOGGER.isLoggable(Level.FINE)) {
                        LOGGER.log(
                                Level.FINE,
                                "Point ("
                                        + srcPts[srcOff - 2]
                                        + ", "
                                        + srcPts[srcOff - 1]
                                        + ") is not covered by '"
                                        + this.grid
                                        + "' NTv2 grid,"
                                        + " it will not be shifted.");
                    }
                    dstPts[dstOff++] = srcPts[srcOff - 2];
                    dstPts[dstOff++] = srcPts[srcOff - 1];
                }
            }
        } catch (IOException e) {
            throw new TransformException(e.getLocalizedMessage(), e);
        }
    }

