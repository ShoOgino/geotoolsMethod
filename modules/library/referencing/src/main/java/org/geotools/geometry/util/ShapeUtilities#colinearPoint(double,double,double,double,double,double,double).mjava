    /**
     * Retourne le point sur le segment de droite {@code (x1,y1)-(x2,y2)} qui se trouve à la
     * distance {@code distance} spécifiée du point {@code point}. Appellons {@code result} le point
     * retourné par cette méthode. Si {@code result} est non-nul, alors il est garantit qu'il répond
     * aux conditions suivantes (aux erreurs d'arrondissements près):
     *
     * <ul>
     *   <li>{@code result} est un point du segment de droite {@code (x1,y1)-(x2,y2)}. Il ne trouve
     *       pas au delà des points extrêmes {@code (x1,y1)} et {@code (x2,y2)} de ce segment.
     *   <li>La distance entre les points {@code result} et {@code point} est exactement {@code
     *       distance} (aux erreurs d'arrondissements près). Cette distance peut être calculée par
     *       {@code point.distance(result)}.
     * </ul>
     *
     * Si aucun point ne peut répondre à ces conditions, alors cette méthode retourne {@code null}.
     * Si deux points peuvent répondre à ces conditions, alors par convention cette méthode retourne
     * le point le plus près du point {@code (x1,y1)}.
     *
     * @param x1 <var>x</var> value of the first point on the line.
     * @param y1 <var>y</var> value of the first point on the line.
     * @param x2 <var>x</var> value of the last point on the line.
     * @param y2 <var>y</var> value of the last point on the line.
     * @param x <var>x</var> value of a point close to the given line.
     * @param y <var>y</var> value of a point close to the given line.
     * @param distance The distance between the given point and the point to be returned.
     * @return A point on the given line located at the given distance from the given point.
     * @see #nearestColinearPoint(double,double , double,double , double,double)
     */
    public static Point2D colinearPoint(
            double x1, double y1, double x2, double y2, double x, double y, double distance) {
        final double ox1 = x1;
        final double oy1 = y1;
        final double ox2 = x2;
        final double oy2 = y2;
        distance *= distance;
        if (x1 == x2) {
            double dy = x1 - x;
            dy = sqrt(distance - dy * dy);
            y1 = y - dy;
            y2 = y + dy;
        } else if (y1 == y2) {
            double dx = y1 - y;
            dx = sqrt(distance - dx * dx);
            x1 = x - dx;
            x2 = x + dx;
        } else {
            final double m = (y1 - y2) / (x2 - x1);
            final double y0 = (y2 - y) + m * (x2 - x);
            final double B = m * y0;
            final double A = m * m + 1;
            final double C = sqrt(B * B + A * (distance - y0 * y0));
            x1 = (B + C) / A;
            x2 = (B - C) / A;
            y1 = y + y0 - m * x1;
            y2 = y + y0 - m * x2;
            x1 += x;
            x2 += x;
        }
        boolean in1, in2;
        if (oy1 > oy2) {
            in1 = y1 <= oy1 && y1 >= oy2;
            in2 = y2 <= oy1 && y2 >= oy2;
        } else {
            in1 = y1 >= oy1 && y1 <= oy2;
            in2 = y2 >= oy1 && y2 <= oy2;
        }
        if (ox1 > ox2) {
            in1 &= x1 <= ox1 && x1 >= ox2;
            in2 &= x2 <= ox1 && x2 >= ox2;
        } else {
            in1 &= x1 >= ox1 && x1 <= ox2;
            in2 &= x2 >= ox1 && x2 <= ox2;
        }
        if (!in1 && !in2) return null;
        if (!in1) return new Point2D.Double(x2, y2);
        if (!in2) return new Point2D.Double(x1, y1);
        x = x1 - ox1;
        y = y1 - oy1;
        final double d1 = x * x + y * y;
        x = x2 - ox1;
        y = y2 - oy1;
        final double d2 = x * x + y * y;
        if (d1 > d2) return new Point2D.Double(x2, y2);
        else return new Point2D.Double(x1, y1);
    }

