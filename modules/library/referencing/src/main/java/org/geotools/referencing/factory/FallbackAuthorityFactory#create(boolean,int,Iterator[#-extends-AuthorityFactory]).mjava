    /**
     * Wraps the specified authority factories. If the specified collection contains more than one
     * element, then a chain of {@code FallbackAuthorityFactory} instances is created.
     *
     * @param automatic {@code true} if {@code interfaceMask} should automatically be restricted to
     *     the factory types detected in the collection.
     * @param interfaceMask The value computed by {@link #interfaceMask(Class)} that describe the
     *     set of interfaces to be implemented by the returned factory.
     * @param factories The factories to chain.
     */
    private static AuthorityFactory create(
            final boolean automatic,
            int interfaceMask,
            final Iterator<? extends AuthorityFactory> factories)
            throws FactoryNotFoundException {
        AuthorityFactory primary = factories.next();
        if (factories.hasNext()) {
            AuthorityFactory fallback = create(true, interfaceMask, factories);
            while (fallback != primary) { // Paranoiac check
                if (!sameAuthorityCodes(fallback, primary)) {
                    /*
                     * (Note: argument order is significant in the above method call)
                     * Creates a "primary - fallback" chain only if the fallback is not
                     * performing the same work than the primary factory, for example:
                     *
                     *   - A BufferedAuthorityFactory wrapping the primary factory. Since
                     *     the primary factory is tested first, the second one is useless.
                     *
                     *   - A OrderedAxisAuthorityFactory wrapping the primary factory. If
                     *     the primary factory failed to create a CRS, the second factory
                     *     should fail too since it relies on the first one.
                     */
                    if (automatic) {
                        // Restricts the interface to be implemented to the
                        // same set of interfaces than the backing factories.
                        interfaceMask &= (interfaceMask(primary) | interfaceMask(fallback));
                    }
                    primary = create(interfaceMask, primary, fallback);
                } else {
                    /*
                     * If the fallback is redundant, we should be done (just return the primary
                     * factory). A special case occurs if the fallback is an other instance of
                     * FallbackAuthorityFactory. We want to discard only the redundant primary
                     * factory (this is why we don't override sameAuthorityCodes(...) for testing
                     * the fallback). The fallback may have value, so we test it recursively.
                     */
                    if (fallback instanceof FallbackAuthorityFactory) {
                        fallback = ((FallbackAuthorityFactory) fallback).fallback;
                        continue;
                    }
                }
                break;
            }
        }
        return primary;
    }

