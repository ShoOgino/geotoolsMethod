    /**
     * Returns {@code true} if either the {@linkplain #getName() primary name} or at least one
     * {@linkplain #getAlias alias} matches the specified string. This method performs all the searh
     * done by the {@linkplain AbstractIdentifiedObject#nameMatches(String) super-class}, with the
     * addition of special processing for latitudes and longitudes:
     *
     * <p>
     *
     * <ul>
     *   <li>{@code "Lat"}, {@code "Latitude"} and {@code "Geodetic latitude"} are considered
     *       equivalent.
     *   <li>{@code "Lon"}, {@code "Longitude"} and {@code "Geodetic longitude"} are considered
     *       equivalent.
     * </ul>
     *
     * <p>The above special cases are needed in order to workaround a conflict in specifications:
     * ISO 19111 explicitly state that the latitude and longitude axis names shall be "Geodetic
     * latitude" and "Geodetic longitude", will legacy OGC 01-009 (where WKT is defined) said that
     * the default values shall be "Lat" and "Lon".
     *
     * @param name The name to compare.
     * @return {@code true} if the primary name of at least one alias matches the specified {@code
     *     name}.
     */
    @Override
    public boolean nameMatches(final String name) {
        if (super.nameMatches(name)) {
            return true;
        }
        /*
         * The standard comparaisons didn't worked. Check for the aliases. Note: we don't
         * test for 'nameMatchesXY(...)' here because the "x" and "y" axis names are too
         * generic. We test them only in the 'equals' method, which has the extra-safety
         * of units comparaison (so less risk to treat incompatible axis as equivalent).
         *
         * TODO: replace Object by CoordinateSystemAxis when we will be allowed
         * to compile for J2SE 1.5.
         */
        final Object type = ALIASES.get(name.trim().toLowerCase());
        return (type != null) && (type == ALIASES.get(getName().getCode().trim().toLowerCase()));
    }

