    /**
     * If this factory is a wrapper for the specified factory that do not add any additional
     * {@linkplain #getAuthorityCodes authority codes}, returns {@code true}. This method is for
     * {@link FallbackAuthorityFactory} internal use only and should not be public. We expect only a
     * simple check, so we don't invoke the {@code getFooAuthorityFactory(...)} methods.
     */
    @Override
    boolean sameAuthorityCodes(final AuthorityFactory factory) {
        if (!isCodeMethodOverriden()) {
            /*
             * Tests wrapped factories only if the 'toBackingFactoryCode(String)' method is not
             * overwritten, otherwise we can't assume that the authority codes are the same. The
             * impact on the main subclasses are usually as below:
             *
             *     URN_AuthorityFactory           - excluded
             *     HTTP_AuthorityFactory          - excluded
             *     HTTP_URI_AuthorityFactory      - excluded
             *     OrderedAxisAuthorityFactory    - make the test below
             *     FallbackAuthorityFactory       - make the test below
             *
             * Note: in the particular case of FallbackAuthorityFactory, we test the
             *       primary factory only, not the fallback. This behavior matches the
             *       FallbackAuthorityFactory.create(boolean,int,Iterator) need, which
             *       will process this case in a special way.
             */
            if (sameAuthorityCodes(crsFactory, factory)
                    && sameAuthorityCodes(csFactory, factory)
                    && sameAuthorityCodes(datumFactory, factory)
                    && sameAuthorityCodes(operationFactory, factory)) {
                return true;
            }
        }
        return super.sameAuthorityCodes(factory);
    }

