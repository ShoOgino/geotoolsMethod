    /**
     * Dump to the standard output stream a list of available operation methods. This method can be
     * invoked from the command line. It provides a mean to verify which transforms were found in
     * the classpath. The syntax is: <br>
     *
     * <BLOCKQUOTE>
     *
     * <CODE>
     * java org.geotools.referencing.operation.DefaultMathTransformFactory
     * <VAR>&lt;options&gt;</VAR> <VAR>&lt;method&gt;</VAR>
     * </CODE>
     *
     * </BLOCKQUOTE>
     *
     * <p>where options are:
     *
     * <TABLE CELLPADDING='0' CELLSPACING='0'>
     *   <TR><TD NOWRAP><CODE>-projections</CODE></TD>
     *       <TD NOWRAP>&nbsp;List only projections</TD></TR>
     *   <TR><TD NOWRAP><CODE>-conversions</CODE></TD>
     *       <TD NOWRAP>&nbsp;List only conversions</TD></TR>
     *   <TR><TD NOWRAP><CODE>-all</CODE></TD>
     *       <TD NOWRAP>&nbsp;List the parameters for all transforms</TD></TR>
     *   <TR><TD NOWRAP><CODE>-encoding</CODE> <VAR>&lt;code&gt;</VAR></TD>
     *       <TD NOWRAP>&nbsp;Set the character encoding</TD></TR>
     *   <TR><TD NOWRAP><CODE>-locale</CODE> <VAR>&lt;language&gt;</VAR></TD>
     *       <TD NOWRAP>&nbsp;Set the language for the output (e.g. "fr" for French)</TD></TR>
     * </TABLE>
     *
     * <p>and <VAR>&lt;method&gt;</VAR> is the optional name of an operation method (e.g. <CODE>
     * "Affine"</CODE>, <CODE>"EPSG:9624"</CODE> or just <CODE>"9624"</CODE> for the affine
     * transform method).
     *
     * <p><strong>Note for Windows users:</strong> If the output contains strange symbols, try to
     * supply an "{@code -encoding}" argument. Example:
     *
     * <blockquote>
     *
     * <code>
     * java org.geotools.referencing.operation.DefaultMathTransformFactory -encoding Cp850
     * </code>
     *
     * </blockquote>
     *
     * <p>The codepage number (850 in the previous example) can be obtained from the DOS commande
     * line using the "{@code chcp}" command with no arguments.
     *
     * @param args Command line arguments.
     */
    public static void main(String[] args) {
        /*
         * Parse the command-line arguments and print the summary.
         */
        final Arguments arguments = new Arguments(args);
        final boolean printAll = arguments.getFlag("-all");
        Class<? extends Operation> type = null;
        if (arguments.getFlag("-projections")) type = Projection.class;
        if (arguments.getFlag("-conversions")) type = Conversion.class;
        args = arguments.getRemainingArguments(1);
        try (ParameterWriter writer = new ParameterWriter(arguments.out)) {
            final DefaultMathTransformFactory factory = new DefaultMathTransformFactory();

            writer.setLocale(arguments.locale);
            Set<OperationMethod> methods = Collections.emptySet();
            if (printAll || args.length == 0) {
                final Set<String> scopes = new HashSet<String>();
                //              scopes.add("OGC");  // Omitted because usually the same than
                // 'identifier'.
                scopes.add("EPSG");
                scopes.add("Geotools"); // Limit the number of columns to output.
                methods = new TreeSet<OperationMethod>(AbstractIdentifiedObject.NAME_COMPARATOR);
                methods.addAll(factory.getAvailableMethods(type));
                writer.summary(methods, scopes);
            }
            if (!printAll) {
                if (args.length == 0) {
                    methods = Collections.emptySet();
                } else {
                    methods = Collections.singleton((OperationMethod) factory.getProvider(args[0]));
                }
            }
            /*
             * Iterates through all math transform to print. It may be a singleton
             * if the user ask for a specific math transform.
             */
            final String lineSeparator = System.getProperty("line.separator", "\n");
            for (final OperationMethod method : methods) {
                arguments.out.write(lineSeparator);
                writer.format(method);
            }
            arguments.out.flush();
        } catch (NoSuchIdentifierException exception) {
            arguments.err.println(exception.getLocalizedMessage());
            return;
        } catch (Exception exception) {
            java.util.logging.Logger.getGlobal().log(java.util.logging.Level.INFO, "", exception);
            return;
        }
    }

