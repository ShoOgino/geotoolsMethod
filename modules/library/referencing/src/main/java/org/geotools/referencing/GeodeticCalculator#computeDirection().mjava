    /**
     * Computes the azimuth and orthodromic distance from the
     * {@linkplain #getStartingGeographicPoint starting point} and the
     * {@linkplain #getDestinationGeographicPoint destination point}.
     *
     * @throws IllegalStateException if the destination point has not been set.
     *
     * @see #getAzimuth
     * @see #getOrthodromicDistance
     */
    private void computeDirection() throws IllegalStateException {
        if (!destinationValid) {
            throw new IllegalStateException(Errors.format(ErrorKeys.DESTINATION_NOT_SET));
        }
        // Protect internal variables from change.
        final double long1 = this.long1;
        final double lat1  = this.lat1;
        final double long2 = this.long2;
        final double lat2  = this.lat2;
        /*
         * Solution of the geodetic inverse problem after T.Vincenty.
         * Modified Rainsford's method with Helmert's elliptical terms.
         * Effective in any azimuth and at any distance short of antipodal.
         *
         * Latitudes and longitudes in radians positive North and East.
         * Forward azimuths at both points returned in radians from North.
         *
         * Programmed for CDC-6600 by LCDR L.Pfeifer NGS ROCKVILLE MD 18FEB75
         * Modified for IBM SYSTEM 360 by John G.Gergen NGS ROCKVILLE MD 7507
         * Ported from Fortran to Java by Daniele Franzoni.
         *
         * Source: ftp://ftp.ngs.noaa.gov/pub/pcsoft/for_inv.3d/source/inverse.for
         *         subroutine GPNHRI
         *         version    200208.09
         *         written by robert (sid) safford
         */
        final double dlon = castToAngleRange(long2 - long1);
        final double ss = abs(dlon);
        if (ss < TOLERANCE_1) {
            distance = getMeridianArcLengthRadians(lat1, lat2);
            azimuth = (lat2 > lat1) ? 0.0 : PI;
            directionValid = true;
            antipodal = false;
            return;
        }
        antipodal = (PI - ss < 2*TOLERANCE_3) && (abs(lat1 + lat2) < 2*TOLERANCE_3);
        /*
         * Computes the limit in longitude (alimit), it is equal
         * to twice  the distance from the equator to the pole,
         * as measured along the equator.
         */
        // tests for antinodal difference
        final double ESQP = eccentricitySquared / (1.0-eccentricitySquared);
        final double alimit = PI * fo;
        if (ss >= alimit &&
            lat1 < TOLERANCE_3 && lat1 > -TOLERANCE_3 &&
            lat2 < TOLERANCE_3 && lat2 > -TOLERANCE_3)
        {
            // Computes an approximate AZ
            final double CONS = (PI - ss) / (PI * f);
            double AZ = asin(CONS);
            double AZ_TEMP, S, AO;
            int iter = 0;
            do {
                if (++iter > 8) {
                    throw new ArithmeticException(getNoConvergenceErrorMessage());
                }
                S = cos(AZ);
                final double C2 = S*S;
                // Compute new AO
                AO = T1 + T2*C2 + T4*C2*C2 + T6*C2*C2*C2;
                final double CS = CONS/AO;
                S = asin(CS);
                AZ_TEMP = AZ;
                AZ = S;
            } while (abs(S - AZ_TEMP) >= TOLERANCE_2);

            final double AZ1 = (dlon < 0.0) ? 2.0*PI - S : S;
            azimuth = castToAngleRange(AZ1);
            S = cos(AZ1);

            // Equatorial - geodesic(S-s) SMS
            final double U2 = ESQP*S*S;
            final double U4 = U2*U2;
            final double U6 = U4*U2;
            final double U8 = U6*U2;
            final double BO =  1.0                 +
                               0.25            *U2 +
                               0.046875        *U4 +
                               0.01953125      *U6 +
                              -0.01068115234375*U8;
            S = sin(AZ1);
            final double SMS = semiMajorAxis*PI*(1.0 - f*abs(S)*AO - BO*fo);
            distance = semiMajorAxis*ss - SMS;
            directionValid = true;
            return;
        }

        // the reduced latitudes
        final double  u1 = atan(fo*sin(lat1) / cos(lat1));
        final double  u2 = atan(fo*sin(lat2) / cos(lat2));
        final double su1 = sin(u1);
        final double cu1 = cos(u1);
        final double su2 = sin(u2);
        final double cu2 = cos(u2);
        double xy, w, q2, q4, q6, r2, r3, sig, ssig, slon, clon, sinalf, ab=dlon;
        int kcount = 0;
        do {
            if (++kcount > 12) {
                throw new ArithmeticException(getNoConvergenceErrorMessage());
            }
            clon = cos(ab);
            slon = sin(ab);
            final double csig = su1*su2 + cu1*cu2*clon;
            ssig = hypot(slon*cu2, su2*cu1 - su1*cu2*clon);
            sig  = atan2(ssig, csig);
            sinalf = cu1*cu2*slon/ssig;
            w = (1.0 - sinalf*sinalf);
            final double t4 = w*w;
            final double t6 = w*t4;

            // the coefficents of type a
            final double ao = f+a01*w+a02*t4+a03*t6;
            final double a2 =   a21*w+a22*t4+a23*t6;
            final double a4 =         a42*t4+a43*t6;
            final double a6 =                a63*t6;

            // the multiple angle functions
            double qo  = 0.0;
            if (w > TOLERANCE_0) {
                qo = -2.0*su1*su2/w;
            }
            q2 = csig + qo;
            q4 = 2.0*q2*q2 - 1.0;
            q6 = q2*(4.0*q2*q2 - 3.0);
            r2 = 2.0*ssig*csig;
            r3 = ssig*(3.0 - 4.0*ssig*ssig);

            // the longitude difference
            final double s = sinalf*(ao*sig + a2*ssig*q2 + a4*r2*q4 + a6*r3*q6);
            double xz = dlon+s;
            xy = abs(xz - ab);
            ab = dlon+s;
        } while (xy >= TOLERANCE_1);

        final double z  = ESQP*w;
        final double bo = 1.0 + z*( 1.0/4.0 + z*(-3.0/  64.0 + z*(  5.0/256.0 - z*(175.0/16384.0))));
        final double b2 =       z*(-1.0/4.0 + z*( 1.0/  16.0 + z*(-15.0/512.0 + z*( 35.0/ 2048.0))));
        final double b4 =                   z*z*(-1.0/ 128.0 + z*(  3.0/512.0 - z*( 35.0/ 8192.0)));
        final double b6 =                                  z*z*z*(-1.0/1536.0 + z*(  5.0/ 6144.0));

        // The distance in ellispoid axis units.
        distance = semiMinorAxis * (bo*sig + b2*ssig*q2 + b4*r2*q4 + b6*r3*q6);
        double az1 = (dlon < 0) ? PI*(3.0/2.0) : PI/2;

        // now compute the az1 & az2 for latitudes not on the equator
        if ((abs(su1) >= TOLERANCE_0) || (abs(su2) >= TOLERANCE_0)) {
            final double tana1 = slon*cu2 / (su2*cu1 - clon*su1*cu2);
            final double sina1 = sinalf/cu1;

            // azimuths from north,longitudes positive east
            az1 = atan2(sina1, sina1/tana1);
        }
        azimuth = castToAngleRange(az1);
        directionValid = true;
        return;
    }

