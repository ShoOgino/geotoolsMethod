    /**
     * Creates a pass through transform from a matrix. This method is invoked when the sub-transform
     * can be express as a matrix. It is also invoked for computing the matrix returned by {@link
     * #derivative}.
     *
     * @param subMatrix The sub-transform as a matrix.
     * @param firstAffectedOrdinate Index of the first affected ordinate.
     * @param numTrailingOrdinates Number of trailing ordinates to pass through.
     * @param affine 0 if the matrix do not contains translation terms, or 1 if the matrix is an
     *     affine transform with translation terms.
     */
    private static GeneralMatrix expand(
            final GeneralMatrix subMatrix,
            final int firstAffectedOrdinate,
            final int numTrailingOrdinates,
            final int affine) {
        final int nSkipped = firstAffectedOrdinate + numTrailingOrdinates;
        final int numRow = subMatrix.getNumRow() - affine;
        final int numCol = subMatrix.getNumCol() - affine;
        final GeneralMatrix matrix =
                new GeneralMatrix(numRow + nSkipped + affine, numCol + nSkipped + affine);
        matrix.setZero();

        //  Set UL part to 1:   [ 1  0             ]
        //                      [ 0  1             ]
        //                      [                  ]
        //                      [                  ]
        //                      [                  ]
        for (int j = 0; j < firstAffectedOrdinate; j++) {
            matrix.setElement(j, j, 1);
        }
        //  Set central part:   [ 1  0  0  0  0  0 ]
        //                      [ 0  1  0  0  0  0 ]
        //                      [ 0  0  ?  ?  ?  0 ]
        //                      [ 0  0  ?  ?  ?  0 ]
        //                      [                  ]
        subMatrix.copySubMatrix(
                0, 0, numRow, numCol, firstAffectedOrdinate, firstAffectedOrdinate, matrix);

        //  Set LR part to 1:   [ 1  0  0  0  0  0 ]
        //                      [ 0  1  0  0  0  0 ]
        //                      [ 0  0  ?  ?  ?  0 ]
        //                      [ 0  0  ?  ?  ?  0 ]
        //                      [ 0  0  0  0  0  1 ]
        final int offset = numCol - numRow;
        final int numRowOut = numRow + nSkipped;
        for (int j = numRowOut - numTrailingOrdinates; j < numRowOut; j++) {
            matrix.setElement(j, j + offset, 1);
        }
        if (affine != 0) {
            // Copy the translation terms in the last column.
            subMatrix.copySubMatrix(
                    0, numCol, numRow, affine, firstAffectedOrdinate, numCol + nSkipped, matrix);
            // Copy the last row as a safety, but it should contains only 0.
            subMatrix.copySubMatrix(
                    numRow, 0, affine, numCol, numRow + nSkipped, firstAffectedOrdinate, matrix);
            // Copy the lower right corner, which should contains only 1.
            subMatrix.copySubMatrix(
                    numRow, numCol, affine, affine, numRow + nSkipped, numCol + nSkipped, matrix);
        }
        return matrix;
    }

