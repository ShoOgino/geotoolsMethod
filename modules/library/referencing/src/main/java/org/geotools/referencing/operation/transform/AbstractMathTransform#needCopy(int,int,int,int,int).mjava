    /**
     * Checks if source coordinates need to be copied before to apply the transformation. This
     * convenience method is provided for {@code transform(...)} method implementation. This method
     * make the following assumptions:
     *
     * <p>
     *
     * <UL>
     *   <LI>Coordinates will be iterated from lower index to upper index.
     *   <LI>Coordinates are read and writen in shrunk. For example (longitude,latitude,height)
     *       values for one coordinate are read together, and the transformed (x,y,z) values are
     *       written together only after.
     * </UL>
     *
     * <p>However, this method does not assumes that source and target dimension are the same (in
     * the special case where source and target dimension are always the same, a simplier and more
     * efficient check is possible). The following example prepares a transformation from 2
     * dimensional points to three dimensional points:
     *
     * <p>
     *
     * <blockquote>
     *
     * <pre>
     * public void transform(double[] srcPts, int srcOff,
     *                       double[] dstPts, int dstOff, int numPts)
     * {
     *     if (srcPts==dstPts && <strong>needCopy</strong>(srcOff, 2, dstOff, 3, numPts) {
     *         final double[] old = srcPts;
     *         srcPts = new double[numPts*2];
     *         System.arraycopy(old, srcOff, srcPts, 0, srcPts.length);
     *         srcOff = 0;
     *     }
     * }</pre>
     *
     * <blockquote>
     *
     * <strong>This method is for internal usage by the referencing module only. Do not use! It will
     * be replaced by a different mechanism in a future GeoTools version.</strong>
     *
     * @param srcOff The offset in the source coordinate array.
     * @param dimSource The dimension of input points.
     * @param dstOff The offset in the destination coordinate array.
     * @param dimTarget The dimension of output points.
     * @param numPts The number of points to transform.
     * @return {@code true} if the source coordinates should be copied before to apply the
     *     transformation in order to avoid an overlap with the destination array.
     */
    protected static boolean needCopy(
            final int srcOff,
            final int dimSource,
            final int dstOff,
            final int dimTarget,
            final int numPts) {
        if (numPts <= 1 || (srcOff >= dstOff && dimSource >= dimTarget)) {
            /*
             * Source coordinates are stored after target coordinates. If implementation
             * read coordinates from lower index to upper index, then the destination will
             * not overwrite the source coordinates, even if there is an overlaps.
             */
            return false;
        }
        return srcOff < dstOff + numPts * dimTarget && dstOff < srcOff + numPts * dimSource;
    }

