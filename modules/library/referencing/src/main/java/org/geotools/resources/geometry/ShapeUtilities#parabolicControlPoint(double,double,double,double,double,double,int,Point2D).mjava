    /**
     * Retourne le point de contrôle d'une courbe quadratique passant par les trois points
     * spécifiés. Il peut exister une infinité de courbes quadratiques passant par trois points. On
     * peut voir les choses en disant qu'une courbe quadratique correspond à une parabole produite
     * par une équation de la forme <code>y=ax²+bx+c</code>, mais que l'axe des <var>x</var> de
     * cette équation n'est pas nécessairement horizontal. La direction de cet axe des <var>x</var>
     * dépend du paramètre {@code orientation} spécifié à cette méthode. La valeur {@link
     * #HORIZONTAL} signifie que l'axe des <var>x</var> de la parabole sera toujours horizontal. La
     * courbe quadratique produite ressemblera alors à une parabole classique telle qu'on en voit
     * dans les ouvrages de mathématiques élémentaires. La valeur {@link #PARALLEL} indique plutôt
     * que l'axe des <var>x</var> de la parabole doit être parallèle à la droite joignant les points
     * {@code (x0,y0)} et {@code (x2,y2)}. Ce dernier type produira le même résultat que {@link
     * #HORIZONTAL} si {@code y0==y2}.
     *
     * @param x0 <var>x</var> value of the first point.
     * @param y0 <var>y</var> value of the first point.
     * @param x1 <var>x</var> value of the second point.
     * @param y1 <var>y</var> value of the second point.
     * @param x2 <var>x</var> value of the third point.
     * @param y2 <var>y</var> value of the third point.
     * @param orientation Orientation de l'axe des <var>x</var> de la parabole: {@link #PARALLEL} ou
     *     {@link #HORIZONTAL}.
     * @param dest Where to store the control point.
     * @return Le point de contrôle d'une courbe quadratique passant par les trois points spécifiés.
     *     La courbe commencera au point {@code (x0,y0)} et se terminera au point {@code (x2,y2)}.
     *     Si deux points ont des coordonnées presque identiques, ou si les trois points sont
     *     colinéaires, alors cette méthode retourne {@code null}.
     * @throws IllegalArgumentException si l'argument {@code orientation} n'est pas une des
     *     constantes valides.
     */
    public static Point2D parabolicControlPoint(
            final double x0,
            final double y0,
            double x1,
            double y1,
            double x2,
            double y2,
            final int orientation,
            final Point2D dest)
            throws IllegalArgumentException {
        /*
         * Applique une translation de façon à ce que (x0,y0)
         * devienne l'origine du système d'axes. Il ne faudra
         * plus utiliser (x0,y0) avant la fin de ce code.
         */
        x1 -= x0;
        y1 -= y0;
        x2 -= x0;
        y2 -= y0;
        switch (orientation) {
            case PARALLEL:
                {
                    /*
                     * Applique une rotation de façon à ce que (x2,y2)
                     * tombe sur l'axe des x, c'est-à-dire que y2=0.
                     */
                    final double rx2 = x2;
                    final double ry2 = y2;
                    x2 = hypot(x2, y2);
                    y2 = (x1 * rx2 + y1 * ry2) / x2; // use 'y2' as a temporary variable for 'x1'
                    y1 = (y1 * rx2 - x1 * ry2) / x2;
                    x1 = y2;
                    y2 = 0;
                    /*
                     * Calcule maintenant les coordonnées du point
                     * de contrôle selon le nouveau système d'axes.
                     */
                    final double x = 0.5; // Really "x/x2"
                    final double y = (y1 * x * x2) / (x1 * (x2 - x1)); // Really "y/y2"
                    final double check = abs(y);
                    if (!(check <= 1 / EPS)) return null; // Deux points ont les mêmes coordonnées.
                    if (!(check >= EPS)) return null; // Les trois points sont colinéaires.
                    /*
                     * Applique une rotation inverse puis une translation pour
                     * ramener le système d'axe dans sa position d'origine.
                     */
                    x1 = (x * rx2 - y * ry2) + x0;
                    y1 = (y * rx2 + x * ry2) + y0;
                    break;
                }
            case HORIZONTAL:
                {
                    final double a = (y2 - y1 * x2 / x1) / (x2 - x1); // Really "a*x2"
                    final double check = abs(a);
                    if (!(check <= 1 / EPS)) return null; // Deux points ont les mêmes coordonnées.
                    if (!(check >= EPS)) return null; // Les trois points sont colinéaires.
                    final double b = y2 / x2 - a;
                    x1 = (1 + b / (2 * a)) * x2 - y2 / (2 * a);
                    y1 = y0 + b * x1;
                    x1 += x0;
                    break;
                }
            default:
                throw new IllegalArgumentException();
        }
        if (dest != null) {
            dest.setLocation(x1, y1);
            return dest;
        } else {
            return new Point2D.Double(x1, y1);
        }
    }

