    /**
     * Grab a transform between two Coordinate Reference Systems. This method is similar to <code>
     * {@linkplain #findMathTransform(CoordinateReferenceSystem, CoordinateReferenceSystem)
     * findMathTransform}(sourceCRS, targetCRS)</code>, except that it can optionally tolerate
     * <cite>lenient datum shift</cite>. If the {@code lenient} argument is {@code true}, then this
     * method will not throw a "<cite>Bursa-Wolf parameters required</cite>" exception during datum
     * shifts if the Bursa-Wolf paramaters are not specified. Instead it will assume a no datum
     * shift.
     *
     * @param sourceCRS The source CRS.
     * @param targetCRS The target CRS.
     * @param lenient {@code true} if the math transform should be created even when there is no
     *     information available for a datum shift. The default value is {@code false}.
     * @return The math transform from {@code sourceCRS} to {@code targetCRS}.
     * @throws FactoryException If no math transform can be created for the specified source and
     *     target CRS.
     * @see Hints#LENIENT_DATUM_SHIFT
     */
    public static MathTransform findMathTransform(
            final CoordinateReferenceSystem sourceCRS,
            final CoordinateReferenceSystem targetCRS,
            boolean lenient)
            throws FactoryException {
        if (equalsIgnoreMetadata(sourceCRS, targetCRS)) {
            // Slight optimization in order to avoid the overhead of loading the full referencing
            // engine.
            return IdentityTransform.create(sourceCRS.getCoordinateSystem().getDimension());
        }
        CoordinateOperationFactory operationFactory = getCoordinateOperationFactory(lenient);
        return operationFactory.createOperation(sourceCRS, targetCRS).getMathTransform();
    }

