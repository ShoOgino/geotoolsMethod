    /**
     * Performs recursive slicing of the area to find the optimal number of subdivisions along the x
     * and y axis.
     *
     * @param mt
     * @param minx
     * @param maxx
     * @param miny
     * @param maxy
     */
    int[] computeOptimalDepths(
            MathTransform2D mt,
            double minx,
            double maxx,
            double miny,
            double maxy,
            int rowDepth,
            int colDepth)
            throws TransformException {
        if (maxx - minx < 4 || maxy - miny < 4) {
            throw new ExcessiveDepthException("Warp grid getting as dense as the original data");
        } else if (rowDepth + colDepth > 20) {
            // this would take 2^(20) points, way too much already
            throw new ExcessiveDepthException(
                    "Warp grid getting too large to fit in memory, bailing out");
        }

        // center of this rectangle
        final double midx = (minx + maxx) / 2;
        final double midy = (miny + maxy) / 2;

        // test tolerance along the y axis
        boolean withinTolVertical =
                isWithinTolerance(mt, minx, miny, minx, midy, minx, maxy)
                        && isWithinTolerance(mt, maxx, miny, maxx, midy, maxx, maxy);
        // test tolerance along the x axis
        boolean withinTolHorizontal =
                isWithinTolerance(mt, minx, miny, midx, miny, maxx, miny)
                        && isWithinTolerance(mt, minx, maxy, midx, maxy, maxx, maxy);
        // if needed, check tolerance along the diagonal as well
        if (withinTolVertical && withinTolHorizontal) {
            if (!isWithinTolerance(mt, minx, miny, midx, midy, maxx, maxy)
                    || !isWithinTolerance(mt, minx, maxy, midx, midy, maxx, miny)) {
                withinTolVertical = false;
                withinTolHorizontal = false;
            }
        }

        // check what kind of split are we going to make
        // (and try not to get fooled by symmetrical projections)
        if ((!withinTolHorizontal && !withinTolVertical)) {
            // quad split
            rowDepth++;
            colDepth++;
            int[] d1 = computeOptimalDepths(mt, minx, midx, miny, midy, rowDepth, colDepth);
            int[] d2 = computeOptimalDepths(mt, minx, midx, midy, maxy, rowDepth, colDepth);
            int[] d3 = computeOptimalDepths(mt, midx, maxx, miny, midy, rowDepth, colDepth);
            int[] d4 = computeOptimalDepths(mt, midx, maxx, midy, maxy, rowDepth, colDepth);
            return new int[] {
                max(max(d1[0], d2[0]), max(d3[0], d4[0])), max(max(d1[1], d2[1]), max(d3[1], d4[1]))
            };
        } else if (!withinTolHorizontal) {
            // slice in two at midx (creating two more colums)
            colDepth++;
            int[] d1 = computeOptimalDepths(mt, minx, midx, miny, maxy, rowDepth, colDepth);
            int[] d2 = computeOptimalDepths(mt, midx, maxx, miny, maxy, rowDepth, colDepth);
            return new int[] {max(d1[0], d2[0]), max(d1[1], d2[1])};
        } else if (!withinTolVertical) {
            // slice in two at midy (creating two rows)
            rowDepth++;
            int[] d1 = computeOptimalDepths(mt, minx, maxx, miny, midy, rowDepth, colDepth);
            int[] d2 = computeOptimalDepths(mt, minx, maxx, midy, maxy, rowDepth, colDepth);
            return new int[] {max(d1[0], d2[0]), max(d1[1], d2[1])};
        }

        return new int[] {rowDepth, colDepth};
    }

