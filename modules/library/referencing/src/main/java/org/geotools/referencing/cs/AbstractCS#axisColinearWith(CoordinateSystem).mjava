    /**
     * Returns {@code true} if every axis in the specified {@code userCS} are colinear with axis in
     * this coordinate system. The comparaison is insensitive to axis order and units. What matter
     * is axis names (because they are fixed by ISO 19111 specification) and directions.
     *
     * <p>If this method returns {@code true}, then there is good chances that this CS can be used
     * together with {@code userCS} as arguments to {@link #swapAndScaleAxis swapAndScaleAxis}.
     *
     * <p>This method should not be public because current implementation is not fully consistent
     * for every pair of CS. It tries to check the opposite direction in addition of the usual one,
     * but only a few pre-defined axis declare their opposite. This method should be okay when
     * invoked on pre-defined CS declared in this package. {@link PredefinedCS} uses this method
     * only that way.
     */
    final boolean axisColinearWith(final CoordinateSystem userCS) {
        if (userCS.getDimension() != getDimension()) {
            return false;
        }
        final DefaultCoordinateSystemAxis[] axis0 = getDefaultAxis(this);
        final DefaultCoordinateSystemAxis[] axis1 = getDefaultAxis(userCS);
        next:
        for (int i = 0; i < axis0.length; i++) {
            final DefaultCoordinateSystemAxis direct = axis0[i];
            final DefaultCoordinateSystemAxis opposite = direct.getOpposite();
            for (int j = 0; j < axis1.length; j++) {
                final DefaultCoordinateSystemAxis candidate = axis1[j];
                if (candidate != null) {
                    if (candidate.equals(direct, false, false)
                            || (opposite != null && candidate.equals(opposite, false, false))) {
                        axis1[j] = null; // Flags as already compared.
                        continue next;
                    }
                }
            }
            return false;
        }
        assert directionColinearWith(userCS);
        return true;
    }

