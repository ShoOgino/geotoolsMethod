    /**
     * Transforms a list of coordinate point ordinal values. This method is provided for efficiently
     * transforming many points. The supplied array of ordinal values will contain packed ordinal
     * values. For example, if the source dimension is 3, then the ordinals will be packed in this
     * order: (<var>x<sub>0</sub></var>,<var>y<sub>0</sub></var>,<var>z<sub>0</sub></var>,
     *
     * <p><var>x<sub>1</sub></var>,<var>y<sub>1</sub></var>,<var>z<sub>1</sub></var> ...). All input
     * and output values are in decimal degrees.
     *
     * @param srcPts the array containing the source point coordinates.
     * @param srcOff the offset to the first point to be transformed in the source array.
     * @param dstPts the array into which the transformed point coordinates are returned. May be the
     *     same than {@code srcPts}.
     * @param dstOff the offset to the location of the first transformed point that is stored in the
     *     destination array.
     * @param numPts the number of point objects to be transformed.
     * @throws TransformException if the input point is outside the area covered by this grid.
     */
    @Override
    public void transform(
            final double[] srcPts, int srcOff, final double[] dstPts, int dstOff, int numPts)
            throws TransformException {
        int step = 0;

        if ((srcPts == dstPts)
                && (srcOff < dstOff)
                && ((srcOff + (numPts * getSourceDimensions())) > dstOff)) {
            step = -getSourceDimensions();
            srcOff -= ((numPts - 1) * step);
            dstOff -= ((numPts - 1) * step);
        }

        while (--numPts >= 0) {
            double x = srcPts[srcOff++];
            double y = srcPts[srcOff++];

            // check bounding box
            if (((x < grid.getMinX()) || (x > grid.getMaxX()))
                    || ((y < grid.getMinY()) || (y > grid.getMaxY()))) {
                throw new TransformException(
                        "Point ("
                                + x
                                + " "
                                + y
                                + ") is not outside of (("
                                + grid.getMinX()
                                + " "
                                + grid.getMinY()
                                + ")("
                                + grid.getMaxX()
                                + " "
                                + grid.getMaxY()
                                + "))");
            }

            // find the grid the point is in (index is 0 based)
            final double xgrid = (x - grid.getMinX()) / grid.getDx();
            final double ygrid = (y - grid.getMinY()) / grid.getDy();
            double[] array = {xgrid, ygrid};

            // use the LocalizationGridTransform2D transform method (bilineal interpolation)
            // returned shift values are in seconds, longitude shift values are + west
            gridShiftTransform.transform(array, 0, array, 0, 1);

            dstPts[dstOff++] = x - (array[0] / SEC_2_DEG);
            dstPts[dstOff++] = y + (array[1] / SEC_2_DEG);
            srcOff += step;
            dstOff += step;
        }
    }

