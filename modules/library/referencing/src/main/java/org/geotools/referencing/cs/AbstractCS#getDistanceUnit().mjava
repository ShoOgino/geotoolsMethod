    /**
     * Suggests an unit for measuring distances in this coordinate system. The default
     * implementation scans all {@linkplain CoordinateSystemAxis#getUnit axis units}, ignoring
     * angular ones (this also implies ignoring {@linkplain Unit#ONE dimensionless} ones). If more
     * than one non-angular unit is found, the default implementation returns the "largest" one
     * (e.g. kilometers instead of meters).
     *
     * @return Suggested distance unit.
     * @throws IllegalArgumentException if some non-angular units are incompatible.
     */
    final Unit<?> getDistanceUnit() {
        Unit<?> unit = distanceUnit; // Avoid the need for synchronization.
        if (unit == null) {
            for (int i = 0; i < axis.length; i++) {
                final Unit<?> candidate = axis[i].getUnit();
                if (candidate != null && !candidate.isCompatible(SI.RADIAN)) {
                    // TODO: checks the unit scale type (keeps RATIO only).
                    if (unit != null) {
                        UnitConverter converter = Units.getConverterToAny(candidate, unit);
                        if (!converter.isLinear()) {
                            // TODO: use the localization provided in 'swapAxis'. We could also
                            //       do a more intelligent work by checking the unit scale type.
                            throw new IllegalArgumentException("Unit conversion is non-linear");
                        }
                        final double scale = converter.convert(1) - converter.convert(0);
                        if (Math.abs(scale) <= 1) {
                            // The candidate is a "smaller" unit than the current one
                            // (e.g. "m" instead of "km"). Keeps the "largest" unit.
                            continue;
                        }
                    }
                    unit = candidate;
                }
            }
            distanceUnit = unit;
        }
        return unit;
    }

