    /**
     * Creates an engineering CRS using the same {@linkplain CoordinateSystem coordinate system}
     * than the existing CRS, and an area of validity determined from the specified points. This
     * method is used for creating a {@linkplain #getTargetCRS target CRS} from the {@linkplain
     * #getSourceCRS source CRS}, or conversely.
     *
     * @param target {@code false} for creating the source CRS, or or {@code true} for creating the
     *     target CRS.
     * @throws FactoryException if the CRS can't be created.
     */
    private EngineeringCRS createEngineeringCRS(final boolean target) throws FactoryException {
        final Map<String, Object> properties = new HashMap<>(4);
        properties.put(
                CoordinateReferenceSystem.NAME_KEY, Vocabulary.format(VocabularyKeys.UNKNOWN));
        final GeographicExtent validArea = getValidArea(target);
        if (validArea != null) {
            final ExtentImpl extent = new ExtentImpl();
            extent.getGeographicElements().add(validArea);
            properties.put(CoordinateReferenceSystem.DOMAIN_OF_VALIDITY_KEY, extent.unmodifiable());
        }
        final CoordinateReferenceSystem oppositeCRS = target ? sourceCRS : targetCRS;
        final CoordinateSystem cs;
        if (oppositeCRS != null) {
            cs = oppositeCRS.getCoordinateSystem();
        } else {
            switch (getDimension()) {
                case 2:
                    cs = DefaultCartesianCS.GENERIC_2D;
                    break;
                case 3:
                    cs = DefaultCartesianCS.GENERIC_3D;
                    break;
                default:
                    throw new FactoryException(Errors.format(ErrorKeys.UNSPECIFIED_CRS));
            }
        }
        return crsFactory.createEngineeringCRS(
                properties, datumFactory.createEngineeringDatum(properties), cs);
    }

