        /**
         * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates
         * (units in radians) and stores the result in {@code ptDst} (linear distance
         * on a unit sphere).
         */
        @Override
        protected Point2D transformNormalized(final double lambda, final double phi, Point2D ptDst)
                throws ProjectionException
        {
            // Compute using ellipsoidal formulas, for comparaison later.
            assert (ptDst = super.transformNormalized(lambda, phi, ptDst)) != null;

            final double sinphi = sin(phi);
            final double cosphi = cos(phi);
            final double coslam = cos(lambda);
            double x,y;
            switch (mode) {
                case EQUATORIAL: {
                    y = 1.0 + cosphi * coslam;
                    if (y <= FINE_EPSILON) {
                        throw new ProjectionException(ErrorKeys.TOLERANCE_ERROR);
                    }
                    y  = sqrt(2.0 / y);
                    x  = y * cosphi * sin(lambda);
                    y *= sinphi;
                    break;
                }
                case OBLIQUE: {
                    y = 1.0 + sinb1 * sinphi + cosb1 * cosphi * coslam;
                    if (y <= FINE_EPSILON) {
                        throw new ProjectionException(ErrorKeys.TOLERANCE_ERROR);
                    }
                    y  = sqrt(2.0 / y);
                    x  = y * cosphi * sin(lambda);
                    y *= cosb1 * sinphi - sinb1 * cosphi * coslam;
                    break;
                }
                case NORTH_POLE: {
                    if (abs(phi + latitudeOfOrigin) < EPSILON_LATITUDE) {
                        throw new ProjectionException(ErrorKeys.TOLERANCE_ERROR);
                    }
                    y = (PI/4) - phi * 0.5;
                    y = 2.0 * sin(y);
                    x = y * sin(lambda);
                    y *= -coslam;
                    break;
                }
                case SOUTH_POLE: {
                    if (abs(phi + latitudeOfOrigin) < EPSILON_LATITUDE) {
                        throw new ProjectionException(ErrorKeys.TOLERANCE_ERROR);
                    }
                    y = (PI/4) - phi * 0.5;
                    y = 2.0 * cos(y);
                    x = y * sin(lambda);
                    y *= +coslam;
                    break;
                }
                default: {
                    throw new AssertionError(mode);
                }
            }
            assert checkTransform(x, y, ptDst);
            if (ptDst != null) {
                ptDst.setLocation(x,y);
                return ptDst;
            }
            return new Point2D.Double(x,y);
        }

