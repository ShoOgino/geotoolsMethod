    /**
     * Gets the derivative of this transform at a point. The default implementation ensure that
     * {@code point} has a valid dimension. Next, it try to delegate the work to an other method:
     *
     * <ul>
     *   <li>If the input dimension is 2, then this method delegates the work to {@link
     *       #derivative(Point2D)}.
     *   <li>If this object is an instance of {@link MathTransform1D}, then this method delegates
     *       the work to {@link MathTransform1D#derivative(double) derivative(double)}.
     * </ul>
     *
     * Otherwise, a {@link TransformException} is thrown.
     *
     * @param point The coordinate point where to evaluate the derivative.
     * @return The derivative at the specified point (never {@code null}).
     * @throws NullPointerException if the derivative dependents on coordinate and {@code point} is
     *     {@code null}.
     * @throws MismatchedDimensionException if {@code point} doesn't have the expected dimension.
     * @throws TransformException if the derivative can't be evaluated at the specified point.
     */
    @Override
    public Matrix derivative(final DirectPosition point) throws TransformException {
        final int dimSource = getSourceDimensions();
        if (point == null) {
            if (dimSource == 2) {
                return derivative((Point2D) null);
            }
        } else {
            final int dimPoint = point.getDimension();
            if (dimPoint != dimSource) {
                throw new MismatchedDimensionException(
                        constructMessage("point", dimPoint, dimSource));
            }
            if (dimSource == 2) {
                if (point instanceof Point2D) {
                    return derivative((Point2D) point);
                }
                return derivative(new Point2D.Double(point.getOrdinate(0), point.getOrdinate(1)));
            }
            if (this instanceof MathTransform1D) {
                return new Matrix1(((MathTransform1D) this).derivative(point.getOrdinate(0)));
            }
        }
        throw new TransformException(Errors.format(ErrorKeys.CANT_COMPUTE_DERIVATIVE));
    }

