    /**
     * Returns all available operations from a projected to a geographic coordinate reference system. The default implementation constructs the
     * following operation chain:
     *
     * <blockquote>
     * 
     * <pre>
     * sourceCRS  &rarr;  {@linkplain ProjectedCRS#getBaseCRS baseCRS}  &rarr;  targetCRS
     * </pre>
     * 
     * </blockquote>
     *
     * where the conversion from {@code sourceCRS} to {@code baseCRS} is obtained from the inverse of
     * <code>sourceCRS.{@linkplain ProjectedCRS#getConversionFromBase
     * getConversionFromBase()}</code>.
     *
     * @param sourceCRS Input coordinate reference system.
     * @param targetCRS Output coordinate reference system.
     * @param limit The maximum number of operations to be returned. Use -1 to return all the available operations. Use 1 to return just one
     *        operations. Currently, the behavior for other values of {@code limit} is undefined.
     * @return A {@code Set} of coordinate operations from {@code sourceCRS} to {@code targetCRS}.
     * @throws FactoryException If the operation can't be constructed.
     */
    protected Set<CoordinateOperation> findOperationSteps(final ProjectedCRS  sourceCRS,
            final GeographicCRS targetCRS, int limit)
            throws FactoryException
    {
        final GeographicCRS base  = sourceCRS.getBaseCRS();
        CoordinateOperation step1 = sourceCRS.getConversionFromBase();
        HashSet<CoordinateOperation> result = new HashSet<CoordinateOperation>();
        Set<CoordinateOperation> step2Candidates = tryDB(base, targetCRS, limit);
        if (step2Candidates.isEmpty()) {
            CoordinateOperation step2 = createOperationStep(base, targetCRS);
            step2Candidates = Collections.singleton(step2);
        }
        MathTransform transform = step1.getMathTransform();
        try {
            transform = transform.inverse();
        } catch (NoninvertibleTransformException exception) {
            throw new OperationNotFoundException(getErrorMessage(sourceCRS, base), exception);
        }
        for (CoordinateOperation step2: step2Candidates) {
            step1 = createFromMathTransform(INVERSE_OPERATION, sourceCRS, base, transform);
            result.add(concatenate(step1, step2));
        }
        return result;
    }

