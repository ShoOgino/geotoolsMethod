    /**
     * Transforms the specified (<var>&lambda;</var>,<var>&phi;</var>) coordinates (units in
     * radians) and stores the result in {@code ptDst} (pixel coordinates).
     *
     * @param x The longitude of the coordinate, in <strong>radians</strong>.
     * @param y The latitude of the coordinate, in <strong>radians</strong>.
     */
    @Override
    protected Point2D transformNormalized(double x, double y, Point2D ptDst)
            throws ProjectionException {

        /* x - lon, y -lat */

        double r1 = 0.0, r2 = 0.0, r3 = 0.0;
        double col_norm, row_norm;

        // For non-HRV images
        double lfac = LFAC_NONHRV;
        double cfac = CFAC_NONHRV;

        long coff = COFF_NONHRV;
        long loff = LOFF_NONHRV;

        /* calculate the geocentric latitude from the */
        /* geographic one using equations on page 24, Ref. [1] */

        double c_lat = atan((0.993243 * (sin(y) / cos(y))));

        // Pre-compute some values
        double cos_c_lat = cos(c_lat);
        double cos_x_SUB_LON = cos(x - SUB_LON);

        /* using c_lat calculate the length form the Earth */
        /* centre to the surface of the Earth ellipsoid */
        /* equations on page 23, Ref. [1] */

        double re = R_POL / sqrt((1.0 - 0.00675701 * cos_c_lat * cos_c_lat));

        /* calculate the forward projection using equations on */
        /* page 24, Ref. [1] */

        double rl = re;
        r1 = SAT_HEIGHT - rl * cos_c_lat * cos_x_SUB_LON;
        r2 = -rl * cos_c_lat * sin(x - SUB_LON);
        r3 = rl * sin(c_lat);
        double rn = sqrt(r1 * r1 + r2 * r2 + r3 * r3);

        /* check for visibility, whether the point on the Earth given by the */
        /* latitude/longitude pair is visible from the satellite or not. This */
        /* is given by the dot product between the vectors of: */
        /* 1) the point to the spacecraft, */
        /* 2) the point to the centre of the Earth. */
        /* If the dot product is positive the point is visible otherwise it */
        /* is invisible. */

        double dotprod =
                r1 * (rl * cos_c_lat * cos_x_SUB_LON)
                        - r2 * r2
                        - r3 * r3 * (pow((R_EQ / R_POL), 2));

        if (dotprod <= 0) {
            /*
             * Return some real coordinates instead of -999,-999 to avoid an error and to allow GeoServer to compute other points of an image.
             *
             * TODO: Is it really proper way to handle such points?
             *
             * throw new ProjectionException(Errors.format(ErrorKeys.OUT_OF_PROJECTION_VALID_AREA_$1, "lon=" + x + " lat=" + y ));
             */

            col_norm = 58.0 / SCALE_FACTOR;
            row_norm = 1856.0 / SCALE_FACTOR;

            if (ptDst != null) {
                ptDst.setLocation(col_norm, row_norm);
                LOGGER.log(
                        Level.INFO,
                        "MeteosatSG transform: Lon/lat outside vaild range, lon="
                                + x
                                + " lat="
                                + y
                                + " Col/row set arbitrary to 58,1856 (0N, 74.48E");
                return ptDst;
            }
            return new Point2D.Double(col_norm, row_norm);
        }

        /* the forward projection is x and y */

        double xx = atan((-r2 / r1));
        double yy = asin((-r3 / rn));

        /* convert to pixel column and row using the scaling functions on */
        /* page 28, Ref. [1]. And finding nearest integer value for them. */

        double cc = coff + xx * pow(2, -16) * cfac;
        double ll = loff + yy * pow(2, -16) * lfac;

        col_norm = cc / SCALE_FACTOR;
        row_norm = ll / SCALE_FACTOR;

        if (ptDst != null) {
            ptDst.setLocation(col_norm, row_norm);
            LOGGER.log(Level.FINE, "MeteosatSG transform: col=" + cc + " row=" + ll);
            return ptDst;
        }
        return new Point2D.Double(col_norm, row_norm);
    }

