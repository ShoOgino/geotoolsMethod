    /**
     * Sets transformation info from the specified matrix, which must be affine. In addition, the
     * matrix minus the last row and last column must be <A
     * HREF="http://mathworld.wolfram.com/AntisymmetricMatrix.html">antisymmetric</a>.
     *
     * @param matrix The matrix to fit as a Bursa-Wolf construct.
     * @param eps The tolerance error for the antisymmetric matrix test. Should be a small number
     *     like {@code 1E-4}.
     * @throws IllegalArgumentException if the specified matrix doesn't meet the conditions.
     * @since 2.2
     */
    public void setAffineTransform(final Matrix matrix, final double eps)
            throws IllegalArgumentException {
        if (matrix.getNumCol() != 4 || matrix.getNumRow() != 4) {
            // TODO: localize. Same message than Matrix4
            throw new IllegalArgumentException("Illegal matrix size.");
        }
        for (int i = 0; i < 4; i++) {
            double difference = matrix.getElement(3, i) - (i == 3 ? 1 : 0);
            if (Math.abs(difference) > eps) {
                throw new IllegalArgumentException(Errors.format(ErrorKeys.NON_AFFINE_TRANSFORM));
            }
        }
        dx = matrix.getElement(0, 3);
        dy = matrix.getElement(1, 3);
        dz = matrix.getElement(2, 3);
        final double S =
                (matrix.getElement(0, 0) + matrix.getElement(1, 1) + matrix.getElement(2, 2)) / 3;
        final double RS = (Math.PI / (180 * 3600)) * S;
        ppm = (S - 1) * 1E+6;
        for (int j = 0; j < 2; j++) {
            final double eltS = (matrix.getElement(j, j) - 1) * 1E+6;
            if (!(Math.abs(eltS - ppm) <= eps)) {
                // TODO: localize
                throw new IllegalArgumentException("Scale is not uniform.");
            }
            for (int i = j + 1; i < 3; i++) {
                final double elt1 = matrix.getElement(j, i) / RS;
                final double elt2 = matrix.getElement(i, j) / RS;
                // Note: compare with +, not -, because the two values should be opposite.
                if (!(Math.abs(elt1 + elt2) <= eps)) {
                    // TODO: localize
                    throw new IllegalArgumentException("Matrix is not antisymmetric.");
                }
                final double value = 0.5 * (elt1 - elt2);
                if (j == 0)
                    switch (i) {
                        case 1:
                            ez = -value;
                            continue;
                        case 2:
                            ey = +value;
                            continue;
                    }
                assert j == 1 && i == 2;
                ex = -value;
            }
        }
        assert getAffineTransform().equals(matrix, eps * RS);
    }

