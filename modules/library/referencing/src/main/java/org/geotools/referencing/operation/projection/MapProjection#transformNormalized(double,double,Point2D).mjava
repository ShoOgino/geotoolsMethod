    /**
     * Transforms the specified coordinate and stores the result in {@code ptDst}. This method is
     * usually (but <strong>not</strong> guaranteed) to be invoked with values of <var>x</var> in
     * the range {@code [-PI..PI]} and values of <var>y</var> in the range {@code [-PI/2..PI/2]}.
     * Values outside those ranges are accepted (sometime with a warning logged) on the assumption
     * that most implementations use those values only in trigonometric functions like
     * {@linkplain Math#sin sin} and {@linkplain Math#cos cos}.
     * <p>
     * Coordinates have the {@link #centralMeridian} removed from <var>lambda</var> before this
     * method is invoked. After this method is invoked, the results in {@code ptDst} are multiplied
     * by {@link #globalScale}, and the {@link #falseEasting} and {@link #falseNorthing} are added.
     * This means that projections that implement this method are performed on an ellipse (or sphere)
     * with a semi-major axis of 1.
     * <p>
     * In <A HREF="http://www.remotesensing.org/proj/">PROJ.4</A>, the same standardization,
     * described above, is handled by {@code pj_fwd.c}. Therefore when porting projections
     * from PROJ.4, the forward transform equations can be used directly here with minimal
     * change. In the equations of Snyder, {@link #falseEasting}, {@link #falseNorthing} and
     * {@link #scaleFactor} are usually not given. When implementing these equations here,
     * you will not need to remove the {@link #centralMeridian} from <var>lambda</var> or apply
     * the {@link #semiMajor} (<var>a</var> or <var>R</var>).
     *
     * @param lambda The longitude of the coordinate, in <strong>radians</strong>.
     * @param phi    The  latitude of the coordinate, in <strong>radians</strong>.
     * @param ptDst  the specified coordinate point that stores the result of transforming
     *               {@code ptSrc}, or {@code null}. Ordinates will be in a
     *               dimensionless unit, as a linear distance on a unit sphere or ellipse.
     * @return       the coordinate point after transforming ({@code lambda}, {@code phi})
     *               and storing the result in {@code ptDst}.
     * @throws ProjectionException if the point can't be transformed.
     */
    protected abstract Point2D transformNormalized(double lambda, double phi, final Point2D ptDst)
            throws ProjectionException;

