    /**
     * Returns an operation for conversion or transformation between two coordinate reference
     * systems. The default implementation extracts the authority code from the supplied
     * {@code sourceCRS} and {@code targetCRS}, and submit them to the
     * <code>{@linkplain CoordinateOperationAuthorityFactory#createFromCoordinateReferenceSystemCodes
     * createFromCoordinateReferenceSystemCodes}(sourceCode, targetCode)</code> methods.
     * If no operation is found for those codes, then this method returns {@code null}.
     * <p>
     * Note that this method may be invoked recursively. For example no operation may be available
     * from the {@linkplain #getAuthorityFactory underlying authority factory} between two
     * {@linkplain org.opengis.referencing.crs.CompoundCRS compound CRS}, but an operation
     * may be available between two components of those compound CRS.
     *
     * @param  sourceCRS Input coordinate reference system.
     * @param  targetCRS Output coordinate reference system.
     * @return A coordinate operation from {@code sourceCRS} to {@code targetCRS}, or {@code null}
     *         if no such operation is explicitly defined in the underlying database.
     *
     * @since 2.3
     */
    @Override
    protected CoordinateOperation createFromDatabase(final CoordinateReferenceSystem sourceCRS,
                                                     final CoordinateReferenceSystem targetCRS)
    {
        /*
         * Safety check against recursivity: returns null if the given source and target CRS
         * are already under examination by a previous call to this method. Note: there is no
         * need to synchronize since the Boolean is thread-local.
         */
        if (Boolean.TRUE.equals(processing.get())) {
            return null;
        }
        /*
         * Now performs the real work.
         */
        final CoordinateOperationAuthorityFactory authorityFactory = getAuthorityFactory();
        final Citation  authority = authorityFactory.getAuthority();
        final Identifier sourceID = AbstractIdentifiedObject.getIdentifier(sourceCRS, authority);
        if (sourceID == null) {
            return null;
        }
        final Identifier targetID = AbstractIdentifiedObject.getIdentifier(targetCRS, authority);
        if (targetID == null) {
            return null;
        }
        final String sourceCode = sourceID.getCode().trim();
        final String targetCode = targetID.getCode().trim();
        if (sourceCode.equals(targetCode)) {
            /*
             * NOTE: This check is mandatory because this method may be invoked in some situations
             *       where (sourceCode == targetCode) but (sourceCRS != targetCRS). Such situation
             *       should be illegal  (or at least the MathTransform from sourceCRS to targetCRS
             *       should be the identity transform),   but unfortunatly it still happen because
             *       EPSG defines axis order as (latitude,longitude) for geographic CRS while most
             *       softwares expect (longitude,latitude) no matter what the EPSG authority said.
             *       We will need to computes a transform from sourceCRS to targetCRS ignoring the
             *       source and target codes. The superclass can do that, providing that we prevent
             *       the authority database to (legitimately) claims that the transformation from
             *       sourceCode to targetCode is the identity transform. See GEOT-854.
             */
            return null;
        }
        final boolean inverse;
        Set<CoordinateOperation> operations;
        try {
            operations = authorityFactory.createFromCoordinateReferenceSystemCodes(sourceCode, targetCode);
            inverse = (operations == null || operations.isEmpty());
            if (inverse) {
                /*
                 * No operation from 'source' to 'target' available. But maybe there is an inverse
                 * operation. This is typically the case when the user wants to convert from a
                 * projected to a geographic CRS. The EPSG database usually contains transformation
                 * paths for geographic to projected CRS only.
                 */
                operations = authorityFactory.createFromCoordinateReferenceSystemCodes(targetCode, sourceCode);
            }
        } catch (NoSuchAuthorityCodeException exception) {
            /*
             * sourceCode or targetCode is unknow to the underlying authority factory.
             * Ignores the exception and fallback on the generic algorithm provided by
             * the super-class.
             */
            return null;
        } catch (FactoryException exception) {
            /*
             * Other kind of error. It may be more serious, but the super-class is capable
             * to provides a raisonable default behavior. Log as a warning and lets continue.
             */
            log(exception, authorityFactory,Level.FINER);
            return null;
        }
        if (operations != null) {
            for (final Iterator<CoordinateOperation> it=operations.iterator(); it.hasNext();) {
                CoordinateOperation candidate;
                try {
                    // The call to it.next() must be inside the try..catch block,
                    // which is why we don't use the Java 5 for loop syntax here.
                    candidate = it.next();
                    if (candidate == null) {
                        continue;
                    }
                    if (inverse) {
                        candidate = inverse(candidate);
                    }
                } catch (NoninvertibleTransformException e) {
                    // The transform is non invertible. Do not log any error message, since it
                    // may be a normal failure - the transform is not required to be invertible.
                    continue;
                } catch (FactoryException exception) {
                    // Other kind of error. Log a warning and try the next coordinate operation.
                    log(exception, authorityFactory);
                    continue;
                } catch (BackingStoreException exception) {
                    log(exception, authorityFactory);
                    continue;
                }
                /*
                 * It is possible that the Identifier in user's CRS is not quite right.   For
                 * example the user may have created his source and target CRS from WKT using
                 * a different axis order than the official one and still call it "EPSG:xxxx"
                 * as if it were the official CRS. Checks if the source and target CRS for the
                 * operation just created are really the same (ignoring metadata) than the one
                 * specified by the user.
                 */
                CoordinateReferenceSystem source = candidate.getSourceCRS();
                CoordinateReferenceSystem target = candidate.getTargetCRS();
                try {
                    final MathTransform prepend, append;
                    if (!equalsIgnoreMetadata(sourceCRS, source)) try {
                        processing.set(Boolean.TRUE);
                        prepend = createOperation(sourceCRS, source).getMathTransform();
                        source  = sourceCRS;
                    } finally {
                        processing.remove();
                    } else {
                        prepend = null;
                    }
                    if (!equalsIgnoreMetadata(target, targetCRS)) try {
                        processing.set(Boolean.TRUE);
                        append = createOperation(target, targetCRS).getMathTransform();
                        target = targetCRS;
                    } finally {
                        processing.remove();
                    } else {
                        append = null;
                    }
                    candidate = transform(source, prepend, candidate, append, target);
                } catch (FactoryException exception) {
                    /*
                     * We have been unable to create a transform from the user-provided CRS to the
                     * authority-provided CRS. In theory, the two CRS should have been the same and
                     * the transform would have been the identity transform. In practice, it is not
                     * always the case because of axis swapping issue (see GEOT-854). The transform
                     * that we just tried to create in the two previous calls to the createOperation
                     * method should have been merely an affine transform for swapping axis. If they
                     * failed, then we are likely to fail for all other transforms provided in the
                     * database. So stop the loop now (at the very least, do not log the same
                     * warning for every pass of this loop!)
                     */
                    log(exception, authorityFactory);
                    return null;
                }
                if (accept(candidate)) {
                    return candidate;
                }
            }
        }
        return null;
    }

