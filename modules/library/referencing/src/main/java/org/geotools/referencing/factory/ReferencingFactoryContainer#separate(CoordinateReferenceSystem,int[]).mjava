    /**
     * Returns a new coordinate reference system with only the specified dimension. This method is
     * used for example in order to get a component of a {@linkplain CompoundCRS compound CRS}.
     *
     * @param crs The original (usually compound) CRS.
     * @param dimensions The dimensions to keep.
     * @return The CRS with only the specified dimensions.
     * @throws FactoryException if the given dimensions can not be isolated in the given CRS.
     */
    public CoordinateReferenceSystem separate(
            final CoordinateReferenceSystem crs, final int[] dimensions) throws FactoryException {
        final int length = dimensions.length;
        final int crsDimension = crs.getCoordinateSystem().getDimension();
        if (length == 0
                || dimensions[0] < 0
                || dimensions[length - 1] >= crsDimension
                || !XArray.isStrictlySorted(dimensions)) {
            throw new IllegalArgumentException(
                    Errors.format(ErrorKeys.ILLEGAL_ARGUMENT_$1, "dimension"));
        }
        if (length == crsDimension) {
            return crs;
        }
        /*
         * If the CRS is a compound one, separate each components independently.
         * For each component, we search the sub-array of 'dimensions' that apply
         * to this component and invoke 'separate' recursively.
         */
        if (crs instanceof CompoundCRS) {
            int count = 0, lowerDimension = 0, lowerIndex = 0;
            final List<CoordinateReferenceSystem> sources =
                    ((CompoundCRS) crs).getCoordinateReferenceSystems();
            final CoordinateReferenceSystem[] targets =
                    new CoordinateReferenceSystem[sources.size()];
            search:
            for (final CoordinateReferenceSystem source : sources) {
                final int upperDimension =
                        lowerDimension + source.getCoordinateSystem().getDimension();
                /*
                 * 'source' CRS applies to dimension 'lowerDimension' inclusive to 'upperDimension'
                 * exclusive. Now search the smallest range in the user-specified 'dimensions' that
                 * cover the [lowerDimension .. upperDimension] range.
                 */
                if (lowerIndex == dimensions.length) {
                    break search;
                }
                while (dimensions[lowerIndex] < lowerDimension) {
                    if (++lowerIndex == dimensions.length) {
                        break search;
                    }
                }
                int upperIndex = lowerIndex;
                while (dimensions[upperIndex] < upperDimension) {
                    if (++upperIndex == dimensions.length) {
                        break;
                    }
                }
                if (lowerIndex != upperIndex) {
                    final int[] sub = new int[upperIndex - lowerIndex];
                    for (int j = 0; j < sub.length; j++) {
                        sub[j] = dimensions[j + lowerIndex] - lowerDimension;
                    }
                    targets[count++] = separate(source, sub);
                }
                lowerDimension = upperDimension;
                lowerIndex = upperIndex;
            }
            if (count == 1) {
                return targets[0];
            }
            return getCRSFactory()
                    .createCompoundCRS(getTemporaryName(crs), XArray.resize(targets, count));
        }
        /*
         * TODO: Implement other cases here (3D-GeographicCRS, etc.).
         *       It may requires the creation of new CoordinateSystem objects,
         *       which is why this method live in ReferencingFactoryContainer.
         */
        throw new FactoryException(
                Errors.format(ErrorKeys.CANT_SEPARATE_CRS_$1, crs.getName().getCode()));
    }

