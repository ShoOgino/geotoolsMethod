        /**
         * Transforms the specified (<var>x</var>,<var>y</var>) coordinates (units in radians) and
         * stores the result in {@code ptDst} (linear distance on a unit sphere).
         */
        @Override
        protected Point2D inverseTransformNormalized(double x, double y, Point2D ptDst)
                throws ProjectionException {
            // Compute using ellipsoidal formulas, for comparaison later.
            assert (ptDst = super.inverseTransformNormalized(x, y, ptDst)) != null;
            final double rho = hypot(x, y);
            if (!southPole) {
                y = -y;
            }
            // (20-17) call atan2(x,y) to properly deal with y==0
            x = (abs(x) < EPSILON && abs(y) < EPSILON) ? 0.0 : atan2(x, y);
            if (abs(rho) < EPSILON) {
                y = latitudeOfOrigin;
            } else {
                final double c = 2.0 * atan(rho / k0);
                final double cosc = cos(c);
                y = (southPole) ? asin(-cosc) : asin(cosc);
                // (20-14) with phi1=90
            }
            assert checkInverseTransform(x, y, ptDst);
            if (ptDst != null) {
                ptDst.setLocation(x, y);
                return ptDst;
            }
            return new Point2D.Double(x, y);
        }

