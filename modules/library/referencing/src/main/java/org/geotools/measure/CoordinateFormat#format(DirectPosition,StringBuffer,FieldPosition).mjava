    /**
     * Formats a direct position and appends the resulting text to a given string buffer. The
     * position's dimension must matches the {@linkplain #getCoordinateReferenceSystem coordinate
     * reference system} dimension.
     *
     * @param point The position to format.
     * @param toAppendTo Where the text is to be appended.
     * @param position A {@code FieldPosition} identifying a field in the formatted text, or {@code
     *     null} if none.
     * @return The string buffer passed in as {@code toAppendTo}, with formatted text appended.
     * @throws IllegalArgumentException if this {@code CoordinateFormat} cannot format the given
     *     object.
     */
    public StringBuffer format(
            final DirectPosition point, final StringBuffer toAppendTo, final FieldPosition position)
            throws IllegalArgumentException {
        final int dimension = point.getDimension();
        final CoordinateSystem cs;
        if (crs != null) {
            if (dimension != formats.length) {
                throw new MismatchedDimensionException(
                        Errors.format(
                                ErrorKeys.MISMATCHED_DIMENSION_$3,
                                "point",
                                dimension,
                                formats.length));
            }
            cs = crs.getCoordinateSystem();
        } else {
            cs = null;
        }
        for (int i = 0; i < dimension; i++) {
            final double value = point.getOrdinate(i);
            final int fi = Math.min(i, formats.length - 1);
            final Object object;
            final byte type = types[fi];
            switch (type) {
                default:
                    object = Double.valueOf(value);
                    break;
                case LONGITUDE:
                    object = new Longitude(value);
                    break;
                case LATITUDE:
                    object = new Latitude(value);
                    break;
                case ANGLE:
                    object = new Angle(value);
                    break;
                case DATE:
                    {
                        final CoordinateSystemAxis axis = cs.getAxis(i);
                        long offset = Math.round(toMillis[fi].convert(value));
                        if (AxisDirection.PAST.equals(axis.getDirection())) {
                            offset = -offset;
                        }
                        object = new Date(epochs[fi] + offset);
                        break;
                    }
            }
            if (i != 0) {
                toAppendTo.append(separator);
            }
            formats[fi].format(object, toAppendTo, dummy);
            /*
             * If the formatted value is a number, append the units.
             */
            if (type == 0 && cs != null) {
                final Unit<?> unit = cs.getAxis(i).getUnit();
                if (unit != null) {
                    if (unitFormat == null) {
                        unitFormat = SimpleUnitFormat.getInstance();
                    }
                    final String asText = unitFormat.format(unit);
                    if (asText.length() != 0) {
                        toAppendTo.append('\u00A0'); // No break space
                        toAppendTo.append(unit);
                    }
                }
            }
        }
        return toAppendTo;
    }

