    /**
     * Transforms the list of operations into a list of single operations. This method also check
     * against null value and make sure that all CRS dimension matches.
     *
     * @param operations The array of operations to expand.
     * @param target The destination list in which to add {@code SingleOperation}.
     * @param factory The math transform factory to use, or {@code null}
     * @param wantTransform {@code true} if the concatenated math transform should be computed. This
     *     is set to {@code false} only when this method invokes itself recursively.
     * @return The concatenated math transform.
     * @throws FactoryException if the factory can't concatenate the math transforms.
     */
    private static MathTransform expand(
            final CoordinateOperation[] operations,
            final List<SingleOperation> target,
            final MathTransformFactory factory,
            final boolean wantTransform)
            throws FactoryException {
        MathTransform transform = null;
        ensureNonNull("operations", operations);
        for (int i = 0; i < operations.length; i++) {
            ensureNonNull("operations", operations, i);
            final CoordinateOperation op = operations[i];
            if (op instanceof SingleOperation) {
                target.add((SingleOperation) op);
            } else if (op instanceof ConcatenatedOperation) {
                final ConcatenatedOperation cop = (ConcatenatedOperation) op;
                final List<SingleOperation> cops = cop.getOperations();
                expand(cops.toArray(new CoordinateOperation[cops.size()]), target, factory, false);
            } else {
                throw new IllegalArgumentException(
                        Errors.format(
                                ErrorKeys.ILLEGAL_CLASS_$2,
                                Classes.getClass(op),
                                SingleOperation.class));
            }
            /*
             * Check the CRS dimensions.
             */
            if (i != 0) {
                final CoordinateReferenceSystem previous = operations[i - 1].getTargetCRS();
                final CoordinateReferenceSystem next = op.getSourceCRS();
                if (previous != null && next != null) {
                    final int dim1 = previous.getCoordinateSystem().getDimension();
                    final int dim2 = next.getCoordinateSystem().getDimension();
                    if (dim1 != dim2) {
                        throw new IllegalArgumentException(
                                Errors.format(ErrorKeys.MISMATCHED_DIMENSION_$2, dim1, dim2));
                    }
                }
            }
            /*
             * Concatenates the math transform.
             */
            if (wantTransform) {
                final MathTransform step = op.getMathTransform();
                if (transform == null) {
                    transform = step;
                } else if (factory != null) {
                    transform = factory.createConcatenatedTransform(transform, step);
                } else {
                    transform = ConcatenatedTransform.create(transform, step);
                }
            }
        }
        if (wantTransform) {
            final int size = target.size();
            if (size <= 1) {
                throw new IllegalArgumentException(
                        Errors.format(ErrorKeys.MISSING_PARAMETER_$1, "operations[" + size + ']'));
            }
        }
        return transform;
    }

