    /**
     * Formats a summary of a collection of {@linkplain IdentifiedObject identified objects}. The
     * summary contains the identifier name and alias aligned in a table.
     *
     * @param parameters The collection of parameters to format.
     * @param scopes The set of scopes to include in the table, of {@code null} for all of them. A
     *     restricted a set will produce a table with less columns.
     * @throws IOException if an error occured will writing to the stream.
     */
    @SuppressWarnings("PMD.CloseResource")
    public void summary(
            final Collection<? extends IdentifiedObject> parameters, final Set<String> scopes)
            throws IOException {
        /*
         * Prepares the list of alias before any write to the output stream.
         * We need to prepare the list first, because not all identified objects
         * may have generic names with the same scopes in the same order.
         *
         *   titles    -  The column number for each column title.
         *   names     -  The names (including alias) for each line.
         */
        final Map<Object, Integer> titles = new LinkedHashMap<Object, Integer>();
        final List<String[]> names = new ArrayList<String[]>();
        final Locale locale = this.locale; // Protect from changes.
        String[] descriptions = null;
        titles.put(null, 0); // Special value for the identifier column.
        for (final IdentifiedObject element : parameters) {
            final Collection<GenericName> aliases = element.getAlias();
            String[] elementNames = new String[titles.size()];
            elementNames[0] = element.getName().getCode();
            if (aliases != null) {
                /*
                 * The primary name has been fetch (before this block) for one element, and we
                 * determined that some alias may be available in addition. Add local alias
                 * (i.e. names without their scope) to the 'elementNames' row.
                 */
                int count = 0;
                for (final GenericName alias : aliases) {
                    final GenericName scope = alias.scope().name();
                    final GenericName name = alias.tip();
                    final Object title;
                    if (scope != null) {
                        if (scopes != null && !scopes.contains(scope.toString())) {
                            /*
                             * The user requested only a subset of alias (the 'scopes' argument),
                             * and the current alias is not a member of this subset. Continue the
                             * search to other alias.
                             */
                            continue;
                        }
                        title = scope.toInternationalString().toString(locale);
                    } else {
                        title = count++;
                    }
                    /*
                     * The alias scope is used as the column's title. If the alias has no scope,
                     * then a sequencial number is used instead. Now check if the column already
                     * exists. If it exists, fetch its position. If it doesn't exist, inserts the
                     * new column at the end of existing columns.
                     */
                    Integer position = titles.get(title);
                    if (position == null) {
                        position = titles.size();
                        titles.put(title, position);
                    }
                    /*
                     * Now stores the alias local name at the position we just determined above.
                     * Note that more than one value may exist for the same column. For example
                     * both "WGS 84" and "4326" may appear as EPSG alias (as EPSG name and EPSG
                     * identifier respectively), depending how the parameters given by the user
                     * were constructed.
                     */
                    final int index = position.intValue();
                    if (index >= elementNames.length) {
                        elementNames = XArray.resize(elementNames, index + 1);
                    }
                    final String oldName = elementNames[index];
                    final String newName = name.toInternationalString().toString(locale);
                    if (oldName == null || oldName.length() > newName.length()) {
                        /*
                         * Keep the shortest string, since it is often a code used
                         * for identification (e.g. EPSG code). It also help to fit
                         * the table in the window's width.
                         */
                        elementNames[index] = newName;
                    }
                }
            }
            /*
             * Before to add the name and alias to the list, fetch the remarks (if any).
             * They are stored in a separated list and will appear as the very last column.
             */
            final InternationalString remarks = element.getRemarks();
            if (remarks != null) {
                if (descriptions == null) {
                    descriptions = new String[parameters.size()];
                }
                descriptions[names.size()] = remarks.toString(locale);
            }
            names.add(elementNames);
        }
        /*
         * Trim the columns that duplicates the identifier column (#0). This is
         * usually the case of the OGC column (usually #1), since we already use
         * OGC name as the main identifier in most cases.
         */
        final boolean[] hide = new boolean[titles.size()];
        trim:
        for (int column = hide.length; --column >= 1; ) {
            for (final String[] alias : names) {
                if (alias.length > column) {
                    final String name = alias[column];
                    if (name != null && !name.equals(alias[0])) {
                        // No need to looks at the next lines.
                        // Move to previous column.
                        continue trim;
                    }
                }
            }
            // A column duplicating the identifier column has been found.
            hide[column] = true;
        }
        /*
         * Writes the table. The header will contains one column for each alias's
         * scope (or authority) declared in 'titles', in the same order. It will
         * also contains a "Description" column if there is some.
         */
        int column = 0;
        synchronized (lock) {
            final TableWriter table = new TableWriter(out, TableWriter.SINGLE_VERTICAL_LINE);
            table.setMultiLinesCells(true);
            table.writeHorizontalSeparator();
            /*
             * Writes all column headers.
             */
            for (final Object element : titles.keySet()) {
                if (hide[column++]) {
                    continue;
                }
                final String title;
                if (element == null) {
                    title = "Identifier"; // TODO: localize
                } else if (element instanceof String) {
                    title = (String) element;
                } else {
                    title = "Alias " + element; // TODO: localize
                }
                table.write(title);
                table.nextColumn();
            }
            if (descriptions != null) {
                table.write("Description"); // TODO: localize
            }
            table.writeHorizontalSeparator();
            /*
             * Writes all row.
             */
            int counter = 0;
            for (final String[] aliases : names) {
                for (column = 0; column < hide.length; column++) {
                    if (hide[column]) {
                        continue;
                    }
                    if (column < aliases.length) {
                        final String alias = aliases[column];
                        if (alias != null) {
                            table.write(alias);
                        }
                    }
                    table.nextColumn();
                }
                if (descriptions != null) {
                    final String remarks = descriptions[counter++];
                    if (remarks != null) {
                        table.write(remarks);
                    }
                }
                table.nextLine();
            }
            table.writeHorizontalSeparator();
            table.flush();
        }
    }

