    /**
     * Transforms the specified coordinate and stores the result in {@code ptDst}. This method
     * returns longitude as <var>x</var> values in the range {@code [-PI..PI]} and latitude as
     * <var>y</var> values in the range {@code [-PI/2..PI/2]}. It will be checked by the caller, so
     * this method doesn't need to performs this check.
     *
     * <p>Input coordinates have the {@link #falseEasting} and {@link #falseNorthing} removed and
     * are divided by {@link #globalScale} before this method is invoked. After this method is
     * invoked, the {@link #centralMeridian} is added to the {@code x} results in {@code ptDst}.
     * This means that projections that implement this method are performed on an ellipse (or
     * sphere) with a semi-major axis of 1.
     *
     * <p>In <A HREF="http://www.remotesensing.org/proj/">PROJ.4</A>, the same standardization,
     * described above, is handled by {@code pj_inv.c}. Therefore when porting projections from
     * PROJ.4, the inverse transform equations can be used directly here with minimal change. In the
     * equations of Snyder, {@link #falseEasting}, {@link #falseNorthing} and {@link #scaleFactor}
     * are usually not given. When implementing these equations here, you will not need to add the
     * {@link #centralMeridian} to the output longitude or remove the {@link #semiMajor}
     * (<var>a</var> or <var>R</var>).
     *
     * @param x The easting of the coordinate, linear distance on a unit sphere or ellipse.
     * @param y The northing of the coordinate, linear distance on a unit sphere or ellipse.
     * @param ptDst the specified coordinate point that stores the result of transforming {@code
     *     ptSrc}, or {@code null}. Ordinates will be in <strong>radians</strong>.
     * @return the coordinate point after transforming {@code x}, {@code y} and storing the result
     *     in {@code ptDst}.
     * @throws ProjectionException if the point can't be transformed.
     */
    protected abstract Point2D inverseTransformNormalized(double x, double y, final Point2D ptDst)
            throws ProjectionException;

