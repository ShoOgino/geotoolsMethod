    /**
     * Creates and fills the {@link #values} list. Note: this method must creates elements
     * inconditionnally and most not requires synchronization for proper working of the {@link
     * #clone} method.
     *
     * @return The array which is backing {@link #values}. This array is returned only in order to
     *     allow {@link #clone} to modify the values right after the clone. In other cases, this
     *     array should be discarted.
     */
    private GeneralParameterValue[] createElements() {
        final ImagingParameterDescriptors descriptor =
                (ImagingParameterDescriptors) this.descriptor;
        final ParameterListDescriptor listDescriptor = parameters.getParameterListDescriptor();
        final String[] names = listDescriptor.getParamNames();
        final Class[] types = listDescriptor.getParamClasses();
        final String[] enumerated = listDescriptor.getEnumeratedParameterNames();
        final List<GeneralParameterDescriptor> descriptors = descriptor.descriptors();
        final GeneralParameterValue[] values = new GeneralParameterValue[descriptors.size()];
        for (int i = 0; i < values.length; i++) {
            final ParameterDescriptor d = (ParameterDescriptor) descriptors.get(i);
            final ParameterValue value;
            if (compatible(d, listDescriptor, names, types, enumerated)) {
                /*
                 * Found a parameter which is a member of the JAI ParameterList, and the
                 * type matches the expected one. Uses 'parameters' as the backing store.
                 */
                value = new ImagingParameter(d, parameters);
            } else {
                /*
                 * In theory, we should use ParameterBlock sources. However, we can't because
                 * the type is not the same: JAI operations typically expect a RenderedImage
                 * source, while coverage operations typically expect a GridCoverage source.
                 * The value will be stored separatly, and the coverage framework will need
                 * to handle it itself.
                 */
                value = d.createValue();
            }
            values[i] = value;
        }
        /*
         * Checks for name clashes.
         */
        for (int j = 0; j < values.length; j++) {
            final String name = values[j].getDescriptor().getName().getCode().trim();
            for (int i = 0; i < values.length; i++) {
                if (i != j) {
                    final ParameterDescriptor d = (ParameterDescriptor) values[i].getDescriptor();
                    if (AbstractIdentifiedObject.nameMatches(d, name)) {
                        throw new InvalidParameterNameException(
                                Errors.format(
                                        ErrorKeys.PARAMETER_NAME_CLASH_$4,
                                        d.getName().getCode(),
                                        j,
                                        name,
                                        i),
                                name);
                    }
                }
            }
        }
        this.values = UnmodifiableArrayList.wrap(values);
        return values;
    }

