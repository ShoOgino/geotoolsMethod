    /**
     * If no accuracy were specified in the given properties map, add all accuracies found in the
     * operation to concatenate. This method considers only {@link Transformation} components and
     * ignores all conversions. According ISO 19111, the accuracy attribute is allowed only for
     * transformations. However, this restriction is not enforced everywhere. The EPSG database
     * declares an accuracy of 0 meters for conversions, which is conceptually exact. Ourself we are
     * departing from the specification, since we are adding accuracy informations to a concatenated
     * operation. This departure should be considered as a convenience feature only; accuracies are
     * really relevant in transformations only.
     *
     * <p>There is also a technical reasons for ignoring conversions. If a concatenated operation
     * contains a datum shift (i.e. a transformation) with unknow accuracy, and a projection (i.e. a
     * conversion) with a declared 0 meter error, we don't want to declare this 0 meter error as the
     * concatenated operation's accuracy; it would be a false information.
     *
     * <p>Note that a concatenated operation typically contains an arbitrary amount of conversions,
     * but only one transformation. So considering transformation only usually means to pickup only
     * one operation in the given {@code operations} list.
     *
     * @todo We should use a Map and merge only one accuracy for each specification.
     */
    private static Map<String, ?> mergeAccuracy(
            final Map<String, ?> properties, final List<? extends CoordinateOperation> operations) {
        if (!properties.containsKey(COORDINATE_OPERATION_ACCURACY_KEY)) {
            Set<PositionalAccuracy> accuracy = null;
            for (final CoordinateOperation op : operations) {
                if (op instanceof Transformation) {
                    // See javadoc for a rational why we take only transformations in account.
                    Collection<PositionalAccuracy> candidates = op.getCoordinateOperationAccuracy();
                    if (candidates != null && !candidates.isEmpty()) {
                        if (accuracy == null) {
                            accuracy = new LinkedHashSet<>();
                        }
                        accuracy.addAll(candidates);
                    }
                }
            }
            if (accuracy != null) {
                final Map<String, Object> merged = new HashMap<>(properties);
                merged.put(
                        COORDINATE_OPERATION_ACCURACY_KEY,
                        accuracy.toArray(new PositionalAccuracy[accuracy.size()]));
                return merged;
            }
        }
        return properties;
    }

