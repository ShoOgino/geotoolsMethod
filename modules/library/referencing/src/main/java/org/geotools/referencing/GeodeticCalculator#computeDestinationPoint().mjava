    /**
     * Computes the destination point from the {@linkplain #getStartingGeographicPoint starting
     * point}, the {@linkplain #getAzimuth azimuth} and the {@linkplain #getOrthodromicDistance
     * orthodromic distance}.
     *
     * @throws IllegalStateException if the azimuth and the distance have not been set.
     *
     * @see #getDestinationGeographicPoint
     */
    private void computeDestinationPoint() throws IllegalStateException {
        if (!directionValid) {
            throw new IllegalStateException(Errors.format(ErrorKeys.DIRECTION_NOT_SET));
        }
        // Protect internal variables from changes
        final double lat1     = this.lat1;
        final double long1    = this.long1;
        final double azimuth  = this.azimuth;
        final double distance = this.distance;
        /*
         * Solution of the geodetic direct problem after T.Vincenty.
         * Modified Rainsford's method with Helmert's elliptical terms.
         * Effective in any azimuth and at any distance short of antipodal.
         *
         * Latitudes and longitudes in radians positive North and East.
         * Forward azimuths at both points returned in radians from North.
         *
         * Programmed for CDC-6600 by LCDR L.Pfeifer NGS ROCKVILLE MD 18FEB75
         * Modified for IBM SYSTEM 360 by John G.Gergen NGS ROCKVILLE MD 7507
         * Ported from Fortran to Java by Daniele Franzoni.
         *
         * Source: ftp://ftp.ngs.noaa.gov/pub/pcsoft/for_inv.3d/source/forward.for
         *         subroutine DIRECT1
         */
        double TU  = fo*sin(lat1) / cos(lat1);
        double SF  = sin(azimuth);
        double CF  = cos(azimuth);
        double BAZ = (CF!=0) ? atan2(TU,CF)*2.0 : 0;
        double CU  = 1 / sqrt(TU*TU + 1.0);
        double SU  = TU*CU;
        double SA  = CU*SF;
        double C2A = 1.0 - SA*SA;
        double X   = sqrt((1.0/fo/fo - 1) * C2A + 1.0) + 1.0;
        X   = (X - 2.0) / X;
        double C   = 1.0-X;
        C   = (X*X / 4.0 + 1.0) / C;
        double D   = (0.375 * X*X - 1.0) * X;
        TU   = distance / fo / semiMajorAxis / C;
        double Y   = TU;
        double SY, CY, CZ, E;
        do {
            SY = sin(Y);
            CY = cos(Y);
            CZ = cos(BAZ + Y);
            E  = CZ*CZ*2.0-1.0;
            C  = Y;
            X  = E*CY;
            Y  = E+E-1.0;
            Y  = (((SY*SY*4.0-3.0)*Y*CZ*D/6.0+X)*D/4.0-CZ)*SY*D+TU;
        } while (abs(Y-C) > TOLERANCE_1);
        BAZ  = CU*CY*CF - SU*SY;
        C    = fo * hypot(SA, BAZ);
        D    = SU*CY + CU*SY*CF;
        lat2 = atan2(D,C);
        C    = CU*CY - SU*SY*CF;
        X    = atan2(SY*SF, C);
        C    = ((-3.0 * C2A + 4.0) * f + 4.0) * C2A * f / 16.0;
        D    = ((E * CY * C + CZ) * SY * C + Y) * SA;
        long2 = long1+X - (1.0-C)*D*f;
        long2 = castToAngleRange(long2);
        destinationValid = true;
    }

