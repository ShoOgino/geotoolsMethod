        /**
         * Concatenates the supplied transform with an "ellipsoid to geocentric" or a "geocentric to
         * ellipsod" step, if needed.
         */
        @SuppressWarnings("fallthrough")
        private static MathTransform concatenate(
                final MathTransform transform,
                final ParameterValueGroup values,
                final ParameterDescriptor major,
                final ParameterDescriptor minor,
                final ParameterDescriptor dim) {
            double semiMajor = doubleValue(major, values);
            double semiMinor = doubleValue(minor, values);
            int dimension = intValue(dim, values);
            switch (dimension) {
                case 0:
                    if (Double.isNaN(semiMajor) && Double.isNaN(semiMinor)) return transform;
                case 2: // Fall through for 0 and 2 cases.
                case 3:
                    break; // The dimension is a valid value.
                default:
                    throw new IllegalArgumentException(
                            Errors.format(
                                    ErrorKeys.ILLEGAL_ARGUMENT_$2,
                                    dim.getName().getCode(),
                                    dimension));
            }
            ensureValid(major, semiMajor);
            ensureValid(minor, semiMinor);
            final GeocentricTransform step;
            step = new GeocentricTransform(semiMajor, semiMinor, SI.METRE, dimension == 3);
            // Note: dimension may be 0 if not user-provided, which is treated as 2.
            if (dim == SRC_DIM) {
                return ConcatenatedTransform.create(step, transform);
            } else {
                return ConcatenatedTransform.create(transform, step.inverse());
            }
        }

