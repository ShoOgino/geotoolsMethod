    /**
     * Implementation of geodetic to geocentric conversion. This implementation allows the caller to
     * use height in computation. This is used for assertion with {@link #checkTransform}.
     */
    private void transform(
            double[] srcPts,
            int srcOff,
            final double[] dstPts,
            int dstOff,
            int numPts,
            boolean hasHeight) {
        final int dimSource = getSourceDimensions();
        hasHeight |= (dimSource >= 3);
        if (srcPts == dstPts && needCopy(srcOff, dimSource, dstOff, 3, numPts)) {
            // Source and destination arrays overlaps: copy in a temporary buffer.
            final double[] old = srcPts;
            srcPts = new double[numPts * (hasHeight ? 3 : 2)];
            System.arraycopy(old, srcOff, srcPts, 0, srcPts.length);
            srcOff = 0;
        }
        while (--numPts >= 0) {
            final double L = Math.toRadians(srcPts[srcOff++]); // Longitude
            final double P = Math.toRadians(srcPts[srcOff++]); // Latitude
            final double h = hasHeight ? srcPts[srcOff++] : 0; // Height above the ellipsoid (m)

            final double cosLat = Math.cos(P);
            final double sinLat = Math.sin(P);
            final double rn = a / Math.sqrt(1 - e2 * (sinLat * sinLat));

            dstPts[dstOff++] = (rn + h) * cosLat * Math.cos(L); // X: Toward prime meridian
            dstPts[dstOff++] = (rn + h) * cosLat * Math.sin(L); // Y: Toward East
            dstPts[dstOff++] = (rn * (1 - e2) + h) * sinLat; // Z: Toward North
        }
    }

