    /**
     * Parses the specified text and ensure that the resulting object is of the specified type. The
     * text can be any of the following: <br>
     *
     * <UL>
     *   <LI>A name declared in some previous call to <code>
     *       {@linkplain #addDefinition addDefinition}(name, ...)</code>.
     *   <LI>A Well Know Text, which may contains itself shortcuts declared in previous call to
     *       {@code addDefinition}. This text is given to the underlying {@link #parser}.
     *   <LI>Any services provided by subclasses. For example a subclass way recognize some
     *       authority code like {@code EPSG:6326}.
     * </UL>
     *
     * @param text The text, as a name, a WKT to parse, or an authority code.
     * @param type The expected type for the object to be parsed (usually a <code>
     *     {@linkplain CoordinateReferenceSystem}.class</code> or <code>
     *     {@linkplain MathTransform}.class</code>).
     * @return The object.
     * @throws ParseException if parsing the specified WKT failed.
     * @throws FactoryException if the object is not of the expected type.
     */
    public Object parseObject(String text, final Class<?> type)
            throws ParseException, FactoryException {
        Object value;
        final Definition def = definitions.get(text);
        if (def != null) {
            value = def.asObject;
            if (type.isAssignableFrom(value.getClass())) {
                return value;
            }
        } else if (!isIdentifier(text)) {
            /*
             * The specified string was not found in the definitions map. Try to parse it as a
             * WKT, but only if it contains more than a single word. This later condition exists
             * only in order to produces a more accurate error message (WKT parsing of a single
             * word is garantee to fail). In any case, the definitions map is not updated since
             * this method is not invoked from the SET instruction.
             */
            text = substitute(text);
            value = forwardParse(text);
            final Class<?> actualType = value.getClass();
            if (type.isAssignableFrom(actualType)) {
                return value;
            }
            throw new FactoryException(Errors.format(ErrorKeys.ILLEGAL_CLASS_$2, actualType, type));
        }
        throw new NoSuchIdentifierException(
                Errors.format(ErrorKeys.NO_SUCH_AUTHORITY_CODE_$2, type, text), text);
    }

