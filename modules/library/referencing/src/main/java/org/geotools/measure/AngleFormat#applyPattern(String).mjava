    /**
     * Sets the pattern to use for parsing and formatting angle. See class description for an
     * explanation of how patterns work.
     *
     * @param pattern Pattern to use for parsing and formatting angle.
     * @throws IllegalArgumentException If the specified pattern is not legal.
     */
    @SuppressWarnings("fallthrough")
    public synchronized void applyPattern(final String pattern) throws IllegalArgumentException {
        widthDecimal = 0;
        decimalSeparator = true;
        int startPrefix = 0;
        int symbolIndex = 0;
        boolean parseFinished = false;
        final int length = pattern.length();
        for (int i = 0; i < length; i++) {
            /*
             * On examine un à un tous les caractères du patron en
             * sautant ceux qui ne sont pas réservés ("D", "M", "S"
             * et leur équivalents en minuscules). Les caractères
             * non-reservés seront mémorisés comme suffix plus tard.
             */
            final char c = pattern.charAt(i);
            final char upperCaseC = Character.toUpperCase(c);
            for (int field = DEGREES_FIELD; field < SYMBOLS.length; field++) {
                if (upperCaseC == SYMBOLS[field]) {
                    /*
                     * Un caractère réservé a été trouvé. Vérifie maintenant
                     * s'il est valide. Par exemple il serait illegal d'avoir
                     * comme patron "MM.mm" sans qu'il soit précédé des degrés.
                     * On attend les lettres "D", "M" et "S" dans l'ordre. Si
                     * le caractère est en lettres minuscules, il doit être le
                     * même que le dernier code (par exemple "DD.mm" est illegal).
                     */
                    if (c == upperCaseC) {
                        symbolIndex++;
                    }
                    if (field != symbolIndex - 1 || parseFinished) {
                        setWidth(DEGREES_FIELD, 1);
                        setSuffix(PREFIX_FIELD, null);
                        widthDecimal = 0;
                        decimalSeparator = true;
                        throw new IllegalArgumentException(
                                Errors.format(ErrorKeys.ILLEGAL_ANGLE_PATTERN_$1, pattern));
                    }
                    if (c == upperCaseC) {
                        /*
                         * Mémorise les caractères qui précédaient ce code comme suffix
                         * du champs précédent. Puis on comptera le nombre de fois que le
                         * code se répète, en mémorisant cette information comme largeur
                         * de ce champ.
                         */
                        setSuffix(
                                field - 1,
                                (i > startPrefix) ? pattern.substring(startPrefix, i) : null);
                        int w = 1;
                        while (++i < length && pattern.charAt(i) == c) w++;
                        setWidth(field, w);
                    } else {
                        /*
                         * Si le caractère est une minuscule, ce qui le précédait sera le
                         * séparateur décimal plutôt qu'un suffix. On comptera le nombre
                         * d'occurences du caractères pour obtenir la précision.
                         */
                        switch (i - startPrefix) {
                            case 0:
                                {
                                    decimalSeparator = false;
                                    break;
                                }
                            case 1:
                                {
                                    if (pattern.charAt(startPrefix) == '.') {
                                        decimalSeparator = true;
                                        break;
                                    }
                                    // fall through
                                }
                            default:
                                {
                                    throw new IllegalArgumentException(
                                            Errors.format(
                                                    ErrorKeys.ILLEGAL_ANGLE_PATTERN_$1, pattern));
                                }
                        }
                        int w = 1;
                        while (++i < length && pattern.charAt(i) == c) w++;
                        widthDecimal = w;
                        parseFinished = true;
                    }
                    startPrefix = i--;
                    break; // Break 'j' and continue 'i'.
                }
            }
        }
        setSuffix(symbolIndex - 1, (startPrefix < length) ? pattern.substring(startPrefix) : null);
    }

