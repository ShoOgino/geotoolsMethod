    /**
     * Constructs a new map projection from the supplied parameters.
     *
     * @param parameters The parameter values in standard units.
     * @param esriDefinition true if ESRI parameters are specified.
     * @throws ParameterNotFoundException if a mandatory parameter is missing.
     */
    protected Krovak(
            final ParameterValueGroup parameters,
            final ParameterDescriptorGroup descriptors,
            boolean esriDefinition)
            throws ParameterNotFoundException {
        super(parameters, descriptors.descriptors());
        this.descriptors = descriptors;
        this.esriDefinition = esriDefinition;
        final Collection<GeneralParameterDescriptor> expected =
                getParameterDescriptors().descriptors();
        // Fetch parameters from user input.
        latitudeOfOrigin = doubleValue(expected, BaseProvider.LATITUDE_OF_CENTER, parameters);
        centralMeridian = doubleValue(expected, BaseProvider.LONGITUDE_OF_CENTER, parameters);
        azimuth = doubleValue(expected, BaseProvider.AZIMUTH, parameters);
        pseudoStandardParallel =
                doubleValue(expected, BaseProvider.PSEUDO_STANDARD_PARALLEL, parameters);
        scaleFactor = doubleValue(expected, BaseProvider.SCALE_FACTOR, parameters);
        x_scale = doubleValue(expected, BaseProvider.X_SCALE, parameters);
        y_scale = doubleValue(expected, BaseProvider.Y_SCALE, parameters);
        xy_plane_rotation = doubleValue(expected, BaseProvider.XY_PLANE_ROTATION, parameters);

        /**
         * Check if there are parameters for axis swapping used by ESRI - if so then set variable so
         * the proper ParameterDescriptorGroup will be returned by getParameterDescriptors()
         */
        if (Double.isNaN(doubleValue(expected, BaseProvider.X_SCALE, parameters))
                && Double.isNaN(doubleValue(expected, BaseProvider.Y_SCALE, parameters))
                && Double.isNaN(
                        doubleValue(expected, BaseProvider.XY_PLANE_ROTATION, parameters))) {
            this.esriDefinition = false;

        } else {
            axisTransform = createAffineTransform(x_scale, y_scale, xy_plane_rotation);
        }
        ensureLatitudeInRange(BaseProvider.LATITUDE_OF_CENTER, latitudeOfOrigin, false);
        ensureLongitudeInRange(BaseProvider.LONGITUDE_OF_CENTER, centralMeridian, false);

        // Calculates useful constants.
        sinAzim = sin(azimuth);
        cosAzim = cos(azimuth);
        n = sin(pseudoStandardParallel);
        tanS2 = tan(pseudoStandardParallel / 2 + s45);

        final double sinLat = sin(latitudeOfOrigin);
        final double cosLat = cos(latitudeOfOrigin);
        final double cosL2 = cosLat * cosLat;
        alfa = sqrt(1 + ((excentricitySquared * (cosL2 * cosL2)) / (1 - excentricitySquared)));
        hae = alfa * excentricity / 2;
        final double u0 = asin(sinLat / alfa);

        final double g;
        final double esl = excentricity * sinLat;
        g = pow((1 - esl) / (1 + esl), (alfa * excentricity) / 2);
        k1 = pow(tan(latitudeOfOrigin / 2 + s45), alfa) * g / tan(u0 / 2 + s45);
        ka = pow(1 / k1, -1 / alfa);

        final double radius =
                sqrt(1 - excentricitySquared) / (1 - (excentricitySquared * (sinLat * sinLat)));

        ro0 = scaleFactor * radius / tan(pseudoStandardParallel);
        rop = ro0 * pow(tanS2, n);
    }

