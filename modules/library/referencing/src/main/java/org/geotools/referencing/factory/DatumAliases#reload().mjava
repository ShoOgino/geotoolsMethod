    /**
     * Read again the "{@code DatumAliasesTable.txt}" file into {@link #aliasMap}. This method may
     * be invoked more than once in order to reload entries that have been discarted by {@link
     * #freeUnused}. This method assumes that the file content didn't change between two calls.
     *
     * @throws IOException if the loading failed.
     */
    private void reload() throws IOException {
        assert Thread.holdsLock(this);
        final LogRecord record =
                Loggings.format(Level.FINE, LoggingKeys.LOADING_DATUM_ALIASES_$1, aliasURL);
        record.setLoggerName(LOGGER.getName());
        LOGGER.log(record);
        try (BufferedReader in = new BufferedReader(new InputStreamReader(aliasURL.openStream()))) {
            /*
             * Parses the title line. This line contains authority names as column titles.
             * The authority names will be used as the scope for each identifiers to be
             * created.
             */
            String line = readLine(in);
            if (line != null) {
                final List<Object> elements = new ArrayList<>();
                StringTokenizer st = new StringTokenizer(line, SEPARATORS);
                while (st.hasMoreTokens()) {
                    final String name = st.nextToken().trim();
                    elements.add(name.length() != 0 ? new LocalName(name) : null);
                }
                authorities = elements.toArray(new LocalName[elements.size()]);
                final Map<String, String> canonical = new HashMap<>();
                /*
                 * Parses all aliases. They are stored as arrays of strings for now, but will be
                 * converted to array of generic names by {@link #getAliases} when first needed.
                 * If the alias belong to an authority (which should be true in most cases), a
                 * scoped name will be created at this time.
                 */
                while ((line = readLine(in)) != null) {
                    elements.clear();
                    canonical.clear();
                    st = new StringTokenizer(line, SEPARATORS);
                    while (st.hasMoreTokens()) {
                        String alias = st.nextToken().trim();
                        if (alias.length() != 0) {
                            final String previous = canonical.put(alias, alias);
                            if (previous != null) {
                                canonical.put(previous, previous);
                                alias = previous;
                            }
                        } else {
                            alias = null;
                        }
                        elements.add(alias);
                    }
                    // Trim trailing null values only (we must keep other null values).
                    for (int i = elements.size(); --i >= 0; ) {
                        if (elements.get(i) != null) break;
                        elements.remove(i);
                    }
                    if (!elements.isEmpty()) {
                        /*
                         * Copies the aliases array in the aliases map for all local names. If a
                         * previous value is found as an array of GenericName objects, those generic
                         * names are conserved in the map (instead of the string values parsed above)
                         * in order to avoid constructing them again when they will be needed.
                         */
                        final String[] names = elements.toArray(new String[elements.size()]);
                        for (final String name : names) {
                            final String key = toCaseless(name);
                            final Object[] previous = aliasMap.put(key, names);
                            if (previous != null && previous != NEED_LOADING) {
                                if (previous instanceof GenericName[]) {
                                    aliasMap.put(key, previous);
                                } else if (!Arrays.equals(previous, names)) {
                                    // TODO: localize
                                    LOGGER.warning(
                                            "Inconsistent aliases for datum \"" + name + "\".");
                                }
                            }
                        }
                    }
                }
            }
        }
    }

