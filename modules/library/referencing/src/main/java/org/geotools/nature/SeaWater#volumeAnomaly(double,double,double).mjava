    /**
     * Computes volumic anomaly as a function of salinity, temperature and pressure. Volumic anomaly
     * is defined as the sea water sample's volume minus a standard sample's volume, where the
     * standard sample is a sample of salinity 35, temperature 0°C and the same pressure. In
     * pseudo-code, {@code volumeAnomaly} is equivalent to <code>
     * {@link #volume volume}(S,T,P)-{@link #volume volume}(35,0,P)</code>.
     *
     * @param S Salinity PSS-78 (0 to 42)
     * @param T Temperature ITS-68 (-2 to 40°C)
     * @param P Pressure in decibars (0 to 10<sup>5</sup> dbar), not including atmospheric pressure.
     * @return Volumic anomaly (m³/kg).
     */
    public static double volumeAnomaly(final double S, final double T, double P) {
        P /= 10.0;
        // Sea water density at atmospheric pressure
        final double SR = Math.sqrt(S);
        final double RHO =
                (EOS80_D * S + polynome(T, EOS80_C) * SR + polynome(T, EOS80_B)) * S
                        + polynome(T, EOS80_A);

        // Specific volume at atmospheric pressure
        final double V_35_0_0 = 1.0 / RHO_35_0_0;
        final double SVAN_S_T_0 = -RHO * V_35_0_0 / (RHO + RHO_35_0_0);
        if (P <= 0) {
            return SVAN_S_T_0;
        }
        // Compression terms, DK = K(S,T,P) - K(35,0,P)
        final double K0 =
                (polynome(T, EOS80_F) + polynome(T, EOS80_G) * SR) * S + polynome(T, EOS80_E);
        final double DK =
                K0
                        + (((EOS80_J * SR + polynome(T, EOS80_I)) * S + polynome(T, EOS80_H))
                                        + (polynome(T, EOS80_K) + polynome(T, EOS80_M) * S) * P)
                                * P;

        final double K_35_0_P = polynome(P, EOS80_N);
        final double V_S_T_0 = SVAN_S_T_0 + V_35_0_0;
        return (SVAN_S_T_0 * (1.0 - P / K_35_0_P)
                + V_S_T_0 * P * DK / (K_35_0_P * (K_35_0_P + DK)));
    }

