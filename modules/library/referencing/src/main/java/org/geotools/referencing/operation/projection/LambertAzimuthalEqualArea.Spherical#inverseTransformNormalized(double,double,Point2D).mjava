        /**
         * Transforms the specified (<var>x</var>,<var>y</var>) coordinate
         * and stores the result in {@code ptDst} using equations for a sphere.
         */
        @Override
        protected Point2D inverseTransformNormalized(double x, double y, Point2D ptDst)
                throws ProjectionException
        {
            // Compute using ellipsoidal formulas, for comparaison later.
            assert (ptDst = super.inverseTransformNormalized(x, y, ptDst)) != null;

            double lambda, phi;
            final double rh = hypot(x, y);
            phi = rh * 0.5;
            if (phi > 1.0) {
                throw new ProjectionException(ErrorKeys.TOLERANCE_ERROR);
            }
            phi = 2.0 * asin(phi);
            switch (mode) {
                case EQUATORIAL: {
                    final double sinz = sin(phi);
                    final double cosz = cos(phi);
                    phi = abs(rh) <= FINE_EPSILON ? 0.0 : asin(y * sinz / rh);
                    x *= sinz;
                    y = cosz * rh;
                    lambda = (y == 0) ? 0.0 : atan2(x, y);
                    break;
                }
                case OBLIQUE: {
                    final double sinz = sin(phi);
                    final double cosz = cos(phi);
                    phi = abs(rh) <= FINE_EPSILON ? latitudeOfOrigin :
                            asin(cosz * sinb1 + y * sinz * cosb1 / rh);
                    x *= sinz * cosb1;
                    y = (cosz - sin(phi) * sinb1) * rh;
                    lambda = (y == 0) ? 0.0 : atan2(x, y);
                    break;
                }
                case NORTH_POLE: {
                    phi = (PI / 2) - phi;
                    lambda = atan2(x, -y);
                    break;
                }
                case SOUTH_POLE: {
                    phi -= (PI / 2);
                    lambda = atan2(x, y);
                    break;
                }
                default: {
                    throw new AssertionError(mode);
                }
            }
            assert checkInverseTransform(lambda, phi, ptDst);
            if (ptDst != null) {
                ptDst.setLocation(lambda, phi);
                return ptDst;
            }
            return new Point2D.Double(lambda, phi);
        }

