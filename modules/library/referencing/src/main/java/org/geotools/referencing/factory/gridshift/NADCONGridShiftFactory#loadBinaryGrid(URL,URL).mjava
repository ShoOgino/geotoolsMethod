    /**
     * Reads latitude and longitude binary grid shift file data into {@link grid}. The file is
     * organized into records, with the first record containing the header information, followed by
     * the shift data. The header values are: text describing grid (64 bytes), num. columns (int),
     * num. rows (int), num. z (int), min x (float), delta x (float), min y (float), delta y (float)
     * and angle (float). Each record is num. columns 4 bytes + 4 byte separator long and the file
     * contains num. rows + 1 (for the header) records. The data records (with the grid shift
     * values) are all floats and have a 4 byte separator (0's) before the data. Row records are
     * organized from low y (latitude) to high and columns are orderd from low longitude to high.
     * Everything is written in low byte order.
     *
     * @param latGridUrl URL to the binary latitude shift file (.las extention).
     * @param longGridUrl URL to the binary longitude shift file (.los extention).
     * @throws IOException if the data files cannot be read.
     * @throws FactoryException if there is an inconsistency in the data
     */
    private NADConGridShift loadBinaryGrid(final URL latGridUrl, final URL longGridUrl)
            throws IOException, FactoryException {
        final int HEADER_BYTES = 96;
        final int SEPARATOR_BYTES = 4;
        final int DESCRIPTION_LENGTH = 64;
        ReadableByteChannel latChannel = null;
        ReadableByteChannel longChannel = null;
        NADConGridShift gridShift = null;
        ByteBuffer latBuffer;
        ByteBuffer longBuffer;

        try {
            // //////////////////////
            // setup
            // //////////////////////
            latChannel = getReadChannel(latGridUrl);
            latBuffer = fillBuffer(latChannel, HEADER_BYTES);

            longChannel = getReadChannel(longGridUrl);
            longBuffer = fillBuffer(longChannel, HEADER_BYTES);

            // //////////////////////
            // read header info
            // //////////////////////
            // skip the header description
            latBuffer.position(latBuffer.position() + DESCRIPTION_LENGTH);

            int nc = latBuffer.getInt();
            int nr = latBuffer.getInt();
            int nz = latBuffer.getInt();

            float xmin = latBuffer.getFloat();
            float dx = latBuffer.getFloat();
            float ymin = latBuffer.getFloat();
            float dy = latBuffer.getFloat();

            float angle = latBuffer.getFloat();
            float xmax = xmin + ((nc - 1) * dx);
            float ymax = ymin + ((nr - 1) * dy);

            // skip the longitude header description
            longBuffer.position(longBuffer.position() + DESCRIPTION_LENGTH);

            // check that latitude grid header is the same as for latitude grid
            if ((nc != longBuffer.getInt())
                    || (nr != longBuffer.getInt())
                    || (nz != longBuffer.getInt())
                    || (xmin != longBuffer.getFloat())
                    || (dx != longBuffer.getFloat())
                    || (ymin != longBuffer.getFloat())
                    || (dy != longBuffer.getFloat())
                    || (angle != longBuffer.getFloat())) {
                throw new FactoryException(Errors.format(ErrorKeys.GRID_LOCATIONS_UNEQUAL));
            }

            // //////////////////////
            // read grid shift data into LocalizationGrid
            // //////////////////////
            final int RECORD_LENGTH = (nc * 4) + SEPARATOR_BYTES;
            final int NUM_BYTES_LEFT = ((nr + 1) * RECORD_LENGTH) - HEADER_BYTES;
            final int START_OF_DATA = RECORD_LENGTH - HEADER_BYTES;

            latBuffer = fillBuffer(latChannel, NUM_BYTES_LEFT);
            latBuffer.position(START_OF_DATA); // start of second record (data)

            longBuffer = fillBuffer(longChannel, NUM_BYTES_LEFT);
            longBuffer.position(START_OF_DATA);

            gridShift = new NADConGridShift(xmin, ymin, xmax, ymax, dx, dy, nc, nr);

            int i = 0;
            int j = 0;
            for (i = 0; i < nr; i++) {
                latBuffer.position(latBuffer.position() + SEPARATOR_BYTES); // skip record separator
                longBuffer.position(longBuffer.position() + SEPARATOR_BYTES);

                for (j = 0; j < nc; j++) {
                    gridShift.setLocalizationPoint(
                            j, i, longBuffer.getFloat(), latBuffer.getFloat());
                }
            }

            assert i == nr : i;
            assert j == nc : j;
        } finally {
            if (latChannel != null) {
                latChannel.close();
            }
            if (longChannel != null) {
                longChannel.close();
            }
        }

        return gridShift;
    }

