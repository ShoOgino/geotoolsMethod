    /**
     * Interprète une chaîne de caractères représentant un angle. Les règles d'interprétation de
     * cette méthode sont assez souples. Par exemple cettte méthode interprétera correctement la
     * chaîne "48°12.34'" même si le patron attendu était "DDMM.mm" (c'est-à-dire que la chaîne
     * aurait du être "4812.34"). Les espaces entre les degrés, minutes et secondes sont acceptés.
     * Si l'angle est suivit d'un symbole "N" ou "S", alors l'objet retourné sera de la classe
     * {@link Latitude}. S'il est plutot suivit d'un symbole "E" ou "W", alors l'objet retourné sera
     * de la classe {@link Longitude}. Sinon, il sera de la classe {@link Angle}.
     *
     * @param source Chaîne de caractères à lire.
     * @param pos Position à partir d'où interpréter la chaîne.
     * @param spaceAsSeparator Indique si l'espace est accepté comme séparateur à l'intérieur d'un
     *     angle. La valeur {@code true} fait que l'angle "45 30" sera interprété comme "45°30".
     * @return L'angle lu.
     */
    @SuppressWarnings("fallthrough")
    private synchronized Angle parse(
            final String source, final ParsePosition pos, final boolean spaceAsSeparator) {
        double degrees = Double.NaN;
        double minutes = Double.NaN;
        double secondes = Double.NaN;
        final int length = source.length();
        ///////////////////////////////////////////////////////////////////////////////
        // BLOC A: Analyse la chaîne de caractères 'source' et affecte aux variables //
        //         'degrés', 'minutes' et 'secondes' les valeurs appropriées.        //
        //         Les premières accolades ne servent qu'à garder locales            //
        //         les variables sans intérêt une fois la lecture terminée.          //
        ///////////////////////////////////////////////////////////////////////////////
        {
            /*
             * Extrait le préfix, s'il y en avait un. Si on tombe sur un symbole des
             * degrés, minutes ou secondes alors qu'on n'a pas encore lu de nombre,
             * on considèrera que la lecture a échouée.
             */
            final int indexStart = pos.getIndex();
            int index = skipSuffix(source, pos, PREFIX_FIELD);
            if (index >= 0 && index < SYMBOLS.length) {
                pos.setErrorIndex(indexStart);
                pos.setIndex(indexStart);
                return null;
            }
            /*
             * Saute les espaces blancs qui
             * précèdent le champs des degrés.
             */
            index = pos.getIndex();
            while (index < length && Character.isSpaceChar(source.charAt(index))) index++;
            pos.setIndex(index);
            /*
             * Lit les degrés. Notez que si aucun séparateur ne séparait les degrés
             * des minutes des secondes, alors cette lecture pourra inclure plusieurs
             * champs (exemple: "DDDMMmmm"). La séparation sera faite plus tard.
             */
            Number fieldObject = numberFormat.parse(source, pos);
            if (fieldObject == null) {
                pos.setIndex(indexStart);
                if (pos.getErrorIndex() < indexStart) {
                    pos.setErrorIndex(index);
                }
                return null;
            }
            degrees = fieldObject.doubleValue();
            int indexEndField = pos.getIndex();
            boolean swapDM = true;
            BigBoss:
            switch (skipSuffix(source, pos, DEGREES_FIELD)) {
                    /* ----------------------------------------------
                     * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉS DEGRÉS
                     * ----------------------------------------------
                     * Les degrés étaient suivit du préfix d'un autre angle. Le préfix sera donc
                     * retourné dans le buffer pour un éventuel traitement par le prochain appel
                     * à la méthode 'parse' et on n'ira pas plus loin dans l'analyse de la chaîne.
                     */
                case PREFIX_FIELD:
                    {
                        pos.setIndex(indexEndField);
                        break BigBoss;
                    }
                    /* ----------------------------------------------
                     * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉS DEGRÉS
                     * ----------------------------------------------
                     * On a trouvé le symbole des secondes au lieu de celui des degrés. On fait
                     * la correction dans les variables 'degrés' et 'secondes' et on considère
                     * que la lecture est terminée.
                     */
                case SECONDS_FIELD:
                    {
                        secondes = degrees;
                        degrees = Double.NaN;
                        break BigBoss;
                    }
                    /* ----------------------------------------------
                     * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉS DEGRÉS
                     * ----------------------------------------------
                     * Aucun symbole ne suit les degrés. Des minutes sont-elles attendues?
                     * Si oui, on fera comme si le symbole des degrés avait été là. Sinon,
                     * on considèrera que la lecture est terminée.
                     */
                default:
                    {
                        if (width1 == 0) break BigBoss;
                        if (!spaceAsSeparator) break BigBoss;
                        // fall through
                    }
                    /* ----------------------------------------------
                     * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉS DEGRÉS
                     * ----------------------------------------------
                     * Un symbole des degrés a été explicitement trouvé. Les degrés sont peut-être
                     * suivit des minutes. On procèdera donc à la lecture du prochain nombre, puis
                     * à l'analyse du symbole qui le suit.
                     */
                case DEGREES_FIELD:
                    {
                        final int indexStartField = index = pos.getIndex();
                        while (index < length && Character.isSpaceChar(source.charAt(index))) {
                            index++;
                        }
                        if (!spaceAsSeparator && index != indexStartField) {
                            break BigBoss;
                        }
                        pos.setIndex(index);
                        fieldObject = numberFormat.parse(source, pos);
                        if (fieldObject == null) {
                            pos.setIndex(indexStartField);
                            break BigBoss;
                        }
                        indexEndField = pos.getIndex();
                        minutes = fieldObject.doubleValue();
                        switch (skipSuffix(
                                source, pos, (width1 != 0) ? MINUTES_FIELD : PREFIX_FIELD)) {
                                /* ------------------------------------------------
                                 * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉES MINUTES
                                 * ------------------------------------------------
                                 * Le symbole trouvé est bel et bien celui des minutes.
                                 * On continuera le bloc pour tenter de lire les secondes.
                                 */
                            case MINUTES_FIELD:
                                {
                                    break; // continue outer switch
                                }
                                /* ------------------------------------------------
                                 * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉES MINUTES
                                 * ------------------------------------------------
                                 * Un symbole des secondes a été trouvé au lieu du symbole des minutes
                                 * attendu. On fera la modification dans les variables 'secondes' et
                                 * 'minutes' et on considèrera la lecture terminée.
                                 */
                            case SECONDS_FIELD:
                                {
                                    secondes = minutes;
                                    minutes = Double.NaN;
                                    break BigBoss;
                                }
                                /* ------------------------------------------------
                                 * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉES MINUTES
                                 * ------------------------------------------------
                                 * Aucun symbole n'a été trouvé. Les minutes étaient-elles attendues?
                                 * Si oui, on les acceptera et on tentera de lire les secondes. Si non,
                                 * on retourne le texte lu dans le buffer et on termine la lecture.
                                 */
                            default:
                                {
                                    if (width1 != 0) break; // Continue outer switch
                                    // fall through
                                }
                                /* ------------------------------------------------
                                 * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉES MINUTES
                                 * ------------------------------------------------
                                 * Au lieu des minutes, le symbole lu est celui des degrés. On considère
                                 * qu'il appartient au prochain angle. On retournera donc le texte lu dans
                                 * le buffer et on terminera la lecture.
                                 */
                            case DEGREES_FIELD:
                                {
                                    pos.setIndex(indexStartField);
                                    minutes = Double.NaN;
                                    break BigBoss;
                                }
                                /* ------------------------------------------------
                                 * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉES MINUTES
                                 * ------------------------------------------------
                                 * Après les minutes (qu'on accepte), on a trouvé le préfix du prochain
                                 * angle à lire. On retourne ce préfix dans le buffer et on considère la
                                 * lecture terminée.
                                 */
                            case PREFIX_FIELD:
                                {
                                    pos.setIndex(indexEndField);
                                    break BigBoss;
                                }
                        }
                        swapDM = false;
                        // fall through
                    }
                    /* ----------------------------------------------
                     * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉS DEGRÉS
                     * ----------------------------------------------
                     * Un symbole des minutes a été trouvé au lieu du symbole des degrés attendu.
                     * On fera donc la modification dans les variables 'degrés' et 'minutes'. Ces
                     * minutes sont peut-être suivies des secondes. On tentera donc de lire le
                     * prochain nombre.
                     */
                case MINUTES_FIELD:
                    {
                        if (swapDM) {
                            minutes = degrees;
                            degrees = Double.NaN;
                        }
                        final int indexStartField = index = pos.getIndex();
                        while (index < length && Character.isSpaceChar(source.charAt(index))) {
                            index++;
                        }
                        if (!spaceAsSeparator && index != indexStartField) {
                            break BigBoss;
                        }
                        pos.setIndex(index);
                        fieldObject = numberFormat.parse(source, pos);
                        if (fieldObject == null) {
                            pos.setIndex(indexStartField);
                            break;
                        }
                        indexEndField = pos.getIndex();
                        secondes = fieldObject.doubleValue();
                        switch (skipSuffix(
                                source, pos, (width2 != 0) ? MINUTES_FIELD : PREFIX_FIELD)) {
                                /* -------------------------------------------------
                                 * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉES SECONDES
                                 * -------------------------------------------------
                                 * Un symbole des secondes explicite a été trouvée.
                                 * La lecture est donc terminée.
                                 */
                            case SECONDS_FIELD:
                                {
                                    break;
                                }
                                /* -------------------------------------------------
                                 * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉES SECONDES
                                 * -------------------------------------------------
                                 * Aucun symbole n'a été trouvée. Attendait-on des secondes? Si oui, les
                                 * secondes seront acceptées. Sinon, elles seront retournées au buffer.
                                 */
                            default:
                                {
                                    if (width2 != 0) break;
                                    // fall through
                                }
                                /* -------------------------------------------------
                                 * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉES SECONDES
                                 * -------------------------------------------------
                                 * Au lieu des degrés, on a trouvé un symbole des minutes ou des
                                 * secondes. On renvoie donc le nombre et son symbole dans le buffer.
                                 */
                            case MINUTES_FIELD:
                            case DEGREES_FIELD:
                                {
                                    pos.setIndex(indexStartField);
                                    secondes = Double.NaN;
                                    break;
                                }
                                /* -------------------------------------------------
                                 * ANALYSE DU SYMBOLE SUIVANT LES PRÉSUMÉES SECONDES
                                 * -------------------------------------------------
                                 * Après les secondes (qu'on accepte), on a trouvé le préfix du prochain
                                 * angle à lire. On retourne ce préfix dans le buffer et on considère la
                                 * lecture terminée.
                                 */
                            case PREFIX_FIELD:
                                {
                                    pos.setIndex(indexEndField);
                                    break BigBoss;
                                }
                        }
                        break;
                    }
            }
        }
        ////////////////////////////////////////////////////////////////////
        // BLOC B: Prend en compte l'éventualité ou le séparateur décimal //
        //         aurrait été absent, puis calcule l'angle en degrés.    //
        ////////////////////////////////////////////////////////////////////
        if (minutes < 0) {
            secondes = -secondes;
        }
        if (degrees < 0) {
            minutes = -minutes;
            secondes = -secondes;
        }
        if (!decimalSeparator) {
            final double facteur = XMath.pow10(widthDecimal);
            if (width2 != 0) {
                if (suffix1 == null && Double.isNaN(secondes)) {
                    if (suffix0 == null && Double.isNaN(minutes)) {
                        degrees /= facteur;
                    } else {
                        minutes /= facteur;
                    }
                } else {
                    secondes /= facteur;
                }
            } else if (Double.isNaN(secondes)) {
                if (width1 != 0) {
                    if (suffix0 == null && Double.isNaN(minutes)) {
                        degrees /= facteur;
                    } else {
                        minutes /= facteur;
                    }
                } else if (Double.isNaN(minutes)) {
                    degrees /= facteur;
                }
            }
        }
        /*
         * S'il n'y a rien qui permet de séparer les degrés des minutes (par exemple si
         * le patron est "DDDMMmmm"), alors la variable 'degrés' englobe à la fois les
         * degrés, les minutes et d'éventuelles secondes. On applique une correction ici.
         */
        if (suffix1 == null && width2 != 0 && Double.isNaN(secondes)) {
            double facteur = XMath.pow10(width2);
            if (suffix0 == null && width1 != 0 && Double.isNaN(minutes)) {
                ///////////////////
                //// DDDMMSS.s ////
                ///////////////////
                secondes = degrees;
                minutes = (int) (degrees / facteur); // Arrondie vers 0
                secondes -= minutes * facteur;
                facteur = XMath.pow10(width1);
                degrees = (int) (minutes / facteur); // Arrondie vers 0
                minutes -= degrees * facteur;
            } else {
                ////////////////////
                //// DDD°MMSS.s ////
                ////////////////////
                secondes = minutes;
                minutes = (int) (minutes / facteur); // Arrondie vers 0
                secondes -= minutes * facteur;
            }
        } else if (suffix0 == null && width1 != 0 && Double.isNaN(minutes)) {
            /////////////////
            //// DDDMM.m ////
            /////////////////
            final double facteur = XMath.pow10(width1);
            minutes = degrees;
            degrees = (int) (degrees / facteur); // Arrondie vers 0
            minutes -= degrees * facteur;
        }
        pos.setErrorIndex(-1);
        if (Double.isNaN(degrees)) degrees = 0;
        if (!Double.isNaN(minutes)) degrees += minutes / 60;
        if (!Double.isNaN(secondes)) degrees += secondes / 3600;
        /////////////////////////////////////////////////////
        // BLOC C: Vérifie maintenant si l'angle ne serait //
        //         pas suivit d'un symbole N, S, E ou W.   //
        /////////////////////////////////////////////////////
        for (int index = pos.getIndex(); index < length; index++) {
            final char c = source.charAt(index);
            switch (Character.toUpperCase(c)) {
                case NORTH:
                    pos.setIndex(index + 1);
                    return new Latitude(degrees);
                case SOUTH:
                    pos.setIndex(index + 1);
                    return new Latitude(-degrees);
                case EAST:
                    pos.setIndex(index + 1);
                    return new Longitude(degrees);
                case WEST:
                    pos.setIndex(index + 1);
                    return new Longitude(-degrees);
            }
            if (!Character.isSpaceChar(c)) {
                break;
            }
        }
        return new Angle(degrees);
    }

