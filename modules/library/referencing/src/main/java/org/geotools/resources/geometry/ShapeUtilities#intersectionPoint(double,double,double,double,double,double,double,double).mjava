    /**
     * Retourne le point d'intersection de deux segments de droites. Cette méthode ne prolonge pas
     * les segments de droites à l'infini. Si les deux segments ne s'interceptent pas (soit par ce
     * qu'ils sont parallèles, ou soit parce qu'ils ne se prolongent pas assez loin pour se
     * toucher), alors cette méthode retourne {@code null}.
     *
     * @param ax1 <var>x</var> value of the first point on the first line.
     * @param ay1 <var>y</var> value of the first point on the first line.
     * @param ax2 <var>x</var> value of the last point on the first line.
     * @param ay2 <var>y</var> value of the last point on the first line.
     * @param bx1 <var>x</var> value of the first point on the second line.
     * @param by1 <var>y</var> value of the first point on the second line.
     * @param bx2 <var>x</var> value of the last point on the second line.
     * @param by2 <var>y</var> value of the last point on the second line.
     * @return Si une intersection fut trouvée, les coordonnées de cette intersection. Si aucune
     *     intersection n'a été trouvée, alors cette méthode retourne {@code null}.
     */
    public static Point2D intersectionPoint(
            final double ax1,
            final double ay1,
            double ax2,
            double ay2,
            final double bx1,
            final double by1,
            double bx2,
            double by2) {
        ax2 -= ax1;
        ay2 -= ay1;
        bx2 -= bx1;
        by2 -= by1;
        double x = ay2 * bx2;
        double y = ax2 * by2;
        /*
         * Les x et y calculés précédemment ne sont que des valeurs temporaires. Si et
         * seulement si les deux droites sont parallèles, alors x==y. Ensuite seulement,
         * la paire (x,y) ci-dessous sera les véritables coordonnées du point d'intersection.
         */
        x = ((by1 - ay1) * (ax2 * bx2) + x * ax1 - y * bx1) / (x - y);
        y = abs(bx2) > abs(ax2) ? (by2 / bx2) * (x - bx1) + by1 : (ay2 / ax2) * (x - ax1) + ay1;
        /*
         * Les expressions '!=0' ci-dessous sont importantes afin d'éviter des problèmes
         * d'erreurs d'arrondissement lorsqu'un segment est vertical ou horizontal. Les
         * '!' qui suivent sont importants pour un fonctionnement correct avec NaN.
         */
        if (ax2 != 0 && !(ax2 < 0 ? (x <= ax1 && x >= ax1 + ax2) : (x >= ax1 && x <= ax1 + ax2)))
            return null;
        if (bx2 != 0 && !(bx2 < 0 ? (x <= bx1 && x >= bx1 + bx2) : (x >= bx1 && x <= bx1 + bx2)))
            return null;
        if (ay2 != 0 && !(ay2 < 0 ? (y <= ay1 && y >= ay1 + ay2) : (y >= ay1 && y <= ay1 + ay2)))
            return null;
        if (by2 != 0 && !(by2 < 0 ? (y <= by1 && y >= by1 + by2) : (y >= by1 && y <= by1 + by2)))
            return null;
        return new Point2D.Double(x, y);
    }

