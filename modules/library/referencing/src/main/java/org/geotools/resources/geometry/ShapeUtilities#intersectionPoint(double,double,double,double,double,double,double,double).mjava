    /**
     * Retourne le point d'intersection de deux segments de droites.
     * Cette méthode ne prolonge pas les segments de droites à l'infini.
     * Si les deux segments ne s'interceptent pas (soit par ce qu'ils sont
     * parallèles, ou soit parce qu'ils ne se prolongent pas assez loin
     * pour se toucher), alors cette méthode retourne {@code null}.
     *
     * @param  ax1 <var>x</var> value of the first point on the first  line.
     * @param  ay1 <var>y</var> value of the first point on the first  line.
     * @param  ax2 <var>x</var> value of the last  point on the first  line.
     * @param  ay2 <var>y</var> value of the last  point on the first  line.
     * @param  bx1 <var>x</var> value of the first point on the second line.
     * @param  by1 <var>y</var> value of the first point on the second line.
     * @param  bx2 <var>x</var> value of the last  point on the second line.
     * @param  by2 <var>y</var> value of the last  point on the second line.
     * @return Si une intersection fut trouvée, les coordonnées de cette
     *         intersection. Si aucune intersection n'a été trouvée, alors
     *         cette méthode retourne {@code null}.
     */
    public static Point2D intersectionPoint(final double ax1, final double ay1, double ax2, double ay2,
                                            final double bx1, final double by1, double bx2, double by2)
    {
        ax2 -= ax1;
        ay2 -= ay1;
        bx2 -= bx1;
        by2 -= by1;
        double x = ay2*bx2;
        double y = ax2*by2;
        /*
         * Les x et y calculés précédemment ne sont que des valeurs temporaires. Si et
         * seulement si les deux droites sont parallèles, alors x==y. Ensuite seulement,
         * la paire (x,y) ci-dessous sera les véritables coordonnées du point d'intersection.
         */
        x = ((by1-ay1)*(ax2*bx2)+x*ax1-y*bx1)/(x-y);
        y = abs(bx2) > abs(ax2) ?
                (by2/bx2) * (x-bx1) + by1 :
                (ay2/ax2) * (x-ax1) + ay1;
        /*
         * Les expressions '!=0' ci-dessous sont importantes afin d'éviter des problèmes
         * d'erreurs d'arrondissement lorsqu'un segment est vertical ou horizontal. Les
         * '!' qui suivent sont importants pour un fonctionnement correct avec NaN.
         */
        if (ax2!=0 && !(ax2<0 ? (x<=ax1 && x>=ax1+ax2) : (x>=ax1 && x<=ax1+ax2))) return null;
        if (bx2!=0 && !(bx2<0 ? (x<=bx1 && x>=bx1+bx2) : (x>=bx1 && x<=bx1+bx2))) return null;
        if (ay2!=0 && !(ay2<0 ? (y<=ay1 && y>=ay1+ay2) : (y>=ay1 && y<=ay1+ay2))) return null;
        if (by2!=0 && !(by2<0 ? (y<=by1 && y>=by1+by2) : (y>=by1 && y<=by1+by2))) return null;
        return new Point2D.Double(x,y);
    }

