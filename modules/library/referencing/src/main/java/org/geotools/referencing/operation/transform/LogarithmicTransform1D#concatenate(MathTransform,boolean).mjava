    /**
     * Concatenates in an optimized way a {@link MathTransform} {@code other} to this {@code
     * MathTransform}. This implementation can optimize some concatenation with {@link
     * LinearTransform1D} and {@link ExponentialTransform1D}.
     *
     * @param other The math transform to apply.
     * @param applyOtherFirst {@code true} if the transformation order is {@code other} followed by
     *     {@code this}, or {@code false} if the transformation order is {@code this} followed by
     *     {@code other}.
     * @return The combined math transform, or {@code null} if no optimized combined transform is
     *     available.
     */
    @Override
    MathTransform concatenate(final MathTransform other, final boolean applyOtherFirst) {
        if (other instanceof LinearTransform) {
            final LinearTransform1D linear = (LinearTransform1D) other;
            if (applyOtherFirst) {
                if (linear.offset == 0 && linear.scale > 0) {
                    return create(base, Math.log(linear.scale) / lnBase + offset);
                }
            } else {
                final double newBase = Math.pow(base, 1 / linear.scale);
                if (!Double.isNaN(newBase)) {
                    return create(newBase, linear.scale * offset + linear.offset);
                }
            }
        } else if (other instanceof ExponentialTransform1D) {
            return ((ExponentialTransform1D) other).concatenateLog(this, !applyOtherFirst);
        }
        return super.concatenate(other, applyOtherFirst);
    }

