    /**
     * Transforms a list of coordinate point ordinal values. The source points are first copied
     * in a temporary array of type {@code double[]}, transformed by {@link #transform1} first,
     * then by {@link #transform2} and finally the result is casted to {@code float} primitive
     * type and stored in the destination array. The use of {@code double} primitive type for
     * intermediate results is necesssary for reducing rounding errors.
     */
    @Override
    public void transform(final float[] srcPts, int srcOff,
                          final float[] dstPts, int dstOff, int numPts)
            throws TransformException
    {
        assert isValid();
        if (numPts <= 0) {
            return;
        }
        final int sourceDim = getSourceDimensions();
        final int targetDim = getTargetDimensions();
        final int intermDim = transform1.getTargetDimensions();
        final int dimension = Math.max(Math.max(sourceDim, targetDim), intermDim);
        int numTmp = numPts;
        int length = numTmp * dimension;
        if (length > TEMPORARY_ARRAY_LENGTH) {
            numTmp = Math.max(1, TEMPORARY_ARRAY_LENGTH / dimension);
            length = numTmp * dimension;
        }
        final double[] tmp = new double[length];
        do {
            if (numTmp > numPts) {
                numTmp = numPts;
            }
            length = numTmp * sourceDim;
            for (int i=0; i<length; i++) {
                tmp[i] = srcPts[srcOff++];
            }
            transform1.transform(tmp, 0, tmp, 0, numTmp);
            transform2.transform(tmp, 0, tmp, 0, numTmp);
            length = numTmp * targetDim;
            for (int i=0; i<length; i++) {
                dstPts[dstOff++] = (float) tmp[i];
            }
            numPts -= numTmp;
        } while (numPts != 0);
    }

