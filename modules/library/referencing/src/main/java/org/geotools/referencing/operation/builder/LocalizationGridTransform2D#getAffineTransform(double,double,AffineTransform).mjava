    /**
     * Retourne une approximation de la transformation affine à la position indiquée.
     *
     * @param col Coordonnee <var>x</var> du point.
     * @param row Coordonnee <var>y</var> du point.
     * @param dest Matrice dans laquelle écrire la transformation affine.
     */
    private void getAffineTransform(double x, double y, final AffineTransform dest) {
        int col = (int) x;
        int row = (int) y;
        if (col > width - 2) col = width - 2;
        if (row > height - 2) row = height - 2;
        if (col < 0) col = 0;
        if (row < 0) row = 0;
        final int sgnCol;
        final int sgnRow;
        if (x - col > 0.5) {
            sgnCol = -1;
            col++;
        } else sgnCol = +1;
        if (y - row > 0.5) {
            sgnRow = -1;
            row++;
        } else sgnRow = +1;
        /*
         * Le calcul de la transformation affine  comprend 6        P00------P10
         * inconnues. Sa solution recquiert donc 6 équations.        |        |
         * Nous les obtenons en utilisant 3 points,   chaque         |        |
         * points ayant 2 coordonnées. Voir exemple ci-contre:      P01----(ignoré)
         */
        final int offset00 = (col + row * width) * CP_LENGTH;
        final int offset01 = offset00 + sgnRow * CP_LENGTH * width;
        final int offset10 = offset00 + sgnCol * CP_LENGTH;
        x = grid[offset00 + X_OFFSET];
        y = grid[offset00 + Y_OFFSET];
        final double dxCol = (grid[offset10 + X_OFFSET] - x) * sgnCol;
        final double dyCol = (grid[offset10 + Y_OFFSET] - y) * sgnCol;
        final double dxRow = (grid[offset01 + X_OFFSET] - x) * sgnRow;
        final double dyRow = (grid[offset01 + Y_OFFSET] - y) * sgnRow;
        dest.setTransform(
                dxCol,
                dyCol,
                dxRow,
                dyRow,
                x - dxCol * col - dxRow * row,
                y - dyCol * col - dyRow * row);
        /*
         * Si l'on transforme les 3 points qui ont servit à déterminer la transformation
         * affine, on devrait obtenir un résultat identique (aux erreurs d'arrondissement
         * près) peu importe que l'on utilise la transformation affine ou la grille de
         * localisation.
         */
        assert distance(new Point(col, row), dest) < 1E-5;
        assert distance(new Point(col + sgnCol, row), dest) < 1E-5;
        assert distance(new Point(col, row + sgnRow), dest) < 1E-5;
    }

