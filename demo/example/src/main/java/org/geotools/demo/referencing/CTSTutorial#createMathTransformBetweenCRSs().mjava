    /**
     * Creates a math transform between the CRS's created in createCRSByHand2() and
     * createCRSByHand1(). The resulting transformation is a concatenation of the following
     * transforms:
     * 
     * <ul>
     * <li>Affine - to switch axis order from (latitude,longitude) to (longitude,latitude)</li>
     * <li>Molodenski - to preform a datum shift between NAD27 and WGS84, using the NAD 27 CRS
     * BursaWolfParameters parameters</li>
     * <li>Transverse Mercator - to convert from geographic to projected UTM coordinates</li>
     * </ul>
     * 
     * @throws Exception
     */
    void createMathTransformBetweenCRSs() throws Exception {
        System.out.println("------------------------------------------");
        System.out.println("Creating a math transform between two CRSs:");

        // START SNIPPET: mathTransformBetweenCRSs
        CoordinateOperationFactory coFactory = ReferencingFactoryFinder
                .getCoordinateOperationFactory(null);

        // Nad 27 geographic (lat,long)
        CoordinateReferenceSystem sourceCRS = nad27CRS;
        // UTM Zone 10N, WGS 84 (x,y)
        CoordinateReferenceSystem targetCRS = utm10NCRS;

        CoordinateOperation op = coFactory.createOperation(sourceCRS, targetCRS);
        MathTransform trans = op.getMathTransform();
        System.out.println("Math Transform: " + trans.toWKT());

        // transform some points
        DirectPosition pt = new GeneralDirectPosition(45.1, -120.0);
        System.out.println("Input point: " + pt);
        pt = trans.transform(pt, null);
        System.out.println("Output point: " + pt);
        System.out.println("Inverse of output point: " + trans.inverse().transform(pt, null));
        // END SNIPPET: mathTransformBetweenCRSs
        System.out.println("------------------------------------------");
    }

